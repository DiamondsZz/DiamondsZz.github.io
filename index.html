<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  <meta name="baidu-site-verification" content="L6Lm9d5Crl">
  
  
  
  
  <title>DiamondsZz</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="来自一只野生程序猿...">
<meta property="og:type" content="website">
<meta property="og:title" content="DiamondsZz">
<meta property="og:url" content="https://DiamondsZz.github.io/index.html">
<meta property="og:site_name" content="DiamondsZz">
<meta property="og:description" content="来自一只野生程序猿...">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="DiamondsZz">
<meta name="twitter:description" content="来自一只野生程序猿...">
  
    <link rel="alternative" href="/atom.xml" title="DiamondsZz" type="application/atom+xml">
  
  
  
  <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
    
    
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet">
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: true,
          isPost: false,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>

        <a href="/" class="profilepic">
            
            <img lazy-src="/img/iu.jpeg" class="js-avatar">
            
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">DiamondsZz</a></h1>
        </hgroup>
        
        <p class="header-subtitle">DiamondsZz</p>
        
        
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        
        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                        </ul>
                    </nav>
                </section>
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/css/" style="font-size: 13.33px;">css</a> <a href="/tags/js/" style="font-size: 16.67px;">js</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/学习/" style="font-size: 20px;">学习</a> <a href="/tags/生活，心情/" style="font-size: 10px;">生活，心情</a> <a href="/tags/网站/" style="font-size: 20px;">网站</a> <a href="/tags/资源/" style="font-size: 20px;">资源</a>
                    </div>
                </section>
                
                
                
                
                <section class="switch-part switch-part3">
                
                    <div id="js-aboutme">矮穷矬!</div>
                </section>
                
            </div>
        </div>
    </header>
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">DiamondsZz</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/img/iu.jpeg" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">DiamondsZz</a></h1>
            </hgroup>
            
            <p class="header-subtitle">DiamondsZz</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                </div>
            </nav>
        </header>
    </div>
</nav>
      <div class="body-wrap">
  
    <article id="post-interview" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2021/09/01/interview/" class="article-date">
      <time datetime="2021-08-31T16:00:00.000Z" itemprop="datePublished">2021-09-01</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/09/01/interview/">起个名字真难</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="前端基础"><a href="#前端基础" class="headerlink" title="前端基础"></a>前端基础</h2><h3 id="http-https"><a href="#http-https" class="headerlink" title="http/https"></a>http/https</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line">1.http: 超文本传输协议，是一个客户端和服务器端请求和应答的标准</span><br><span class="line">可靠传输。这个特点显而易见，因为 HTTP 协议是基于 TCP/IP 的，而 TCP 本身是一个“可靠”的传输协议，所以 HTTP 自然也就继承了这个特性，能够在请求方和应答方之间“可靠”地传输数据。</span><br><span class="line">应用层协议。HTTP 几乎可以传递一切东西，满足各种需求，称得上是一个“万能”的协议。</span><br><span class="line">我们可以再对比一下 UDP 协议，不过它是无连接也无状态的，顺序发包乱序收包，数据包发出去后就不管了，收到后也不会顺序整理。而 HTTP 是有连接无状态，顺序发包顺序收包，按照收发的顺序管理报文。</span><br><span class="line"></span><br><span class="line">2.https: 是以安全为目标的 HTTP 通道，简单讲是 HTTP 的安全版，即 HTTP 下加入 SSL层</span><br><span class="line">SSL/TLS，它是一个负责加密通信的安全协议，建立在 TCP/IP 之上，所以也是个可靠的传输协议</span><br><span class="line">SSL 的全称是“Secure Socket Layer”，由网景公司发明，当发展到 3.0 时被标准化，改名为 TLS，即“Transport Layer Security”，</span><br><span class="line">但由于历史的原因还是有很多人称之为 SSL/TLS，或者直接简称为 SSL。</span><br><span class="line"></span><br><span class="line">TLS 协议的组成</span><br><span class="line">TLS 包含几个子协议，你也可以理解为它是由几个不同职责的模块组成，比较常用的有记录协议、警报协议、握手协议、变更密码规范协议等。</span><br><span class="line">记录协议（Record Protocol）规定了 TLS 收发数据的基本单位,所有的其他子协议都需要通过记录协议发出。</span><br><span class="line">警报协议（Alert Protocol）的职责是向对方发出警报信息，有点像是 HTTP 协议里的状态码。</span><br><span class="line">握手协议（Handshake Protocol）是 TLS 里最复杂的子协议，浏览器和服务器会在握手过程中协商 TLS 版本号、随机数、密码套件等信息，然后交换证书和密钥参数，最终双方协商得到会话密钥，用于后续的混合加密系统。</span><br><span class="line">变更密码规范协议（Change Cipher Spec Protocol），它非常简单，就是一个“通知”，告诉对方，后续的数据都将使用加密保护。那么反过来，在它之前，数据都是明文的。</span><br><span class="line"></span><br><span class="line">ECDHE 握手过程</span><br><span class="line">在 TCP 建立连接之后，浏览器会首先发一个“Client Hello”消息，也就是跟服务器“打招呼”。里面有客户端的版本号、支持的密码套件，还有一个随机数（Client Random），用于后续生成会话密钥。这个的意思就是：“我这边有这些这些信息，你看看哪些是能用的，关键的随机数可得留着。”</span><br><span class="line">作为“礼尚往来”，服务器收到“Client Hello”后，会返回一个“Server Hello”消息。把版本号对一下，也给出一个随机数（Server Random），然后从客户端的列表里选一个作为本次通信使用的密码套件，在这里它选择了“TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384”。这个的意思就是：“版本号对上了，可以加密，你的密码套件挺多，我选一个最合适的吧，用椭圆曲线加 RSA、AES、SHA384。我也给你一个随机数，你也得留着。”</span><br><span class="line">然后，服务器为了证明自己的身份，就把证书也发给了客户端（Server Certificate）。</span><br><span class="line">接下来是一个关键的操作，因为服务器选择了 ECDHE 算法，所以它会在证书后发送“Server Key Exchange”消息，里面是椭圆曲线的公钥（Server Params），用来实现密钥交换算法，再加上自己的私钥签名认证。这相当于说：“刚才我选的密码套件有点复杂，所以再给你个算法的参数，和刚才的随机数一样有用，别丢了。为了防止别人冒充，我又盖了个章。”</span><br><span class="line">这样第一个消息往返就结束了（两个 TCP 包），结果是客户端和服务器通过明文共享了三个信息：Client Random、Server Random 和 Server Params。</span><br><span class="line">客户端这时也拿到了服务器的证书，那这个证书是不是真实有效的呢？开始走证书链逐级验证，确认证书的真实性，再用证书公钥验证签名，就确认了服务器的身份：“刚才跟我打招呼的不是骗子，可以接着往下走。”</span><br><span class="line">然后，客户端按照密码套件的要求，也生成一个椭圆曲线的公钥（Client Params），用“Client Key Exchange”消息发给服务器。</span><br><span class="line">现在客户端和服务器手里都拿到了密钥交换算法的两个参数（Client Params、Server Params），就用 ECDHE 算法一阵算，算出了一个新的东西，叫“Pre-Master”，其实也是一个随机数。</span><br><span class="line">现在客户端和服务器手里有了三个随机数：Client Random、Server Random 和 Pre-Master。用这三个作为原始材料，就可以生成用于加密会话的主密钥，叫“Master Secret”。而黑客因为拿不到“Pre-Master”，所以也就得不到主密钥。</span><br><span class="line">为什么非得这么麻烦，非要三个随机数呢？这就必须说 TLS 的设计者考虑得非常周到了，他们不信任客户端或服务器伪随机数的可靠性，为了保证真正的“完全随机”“不可预测”，把三个不可靠的随机数混合起来，那么“随机”的程度就非常高了，足够让黑客难以猜测。</span><br><span class="line">主密钥有 48 字节，但它也不是最终用于通信的会话密钥，还会再用 PRF 扩展出更多的密钥，比如客户端发送用的会话密钥（client_write_key）、服务器发送用的会话密钥（server_write_key）等等，避免只用一个密钥带来的安全隐患。</span><br><span class="line">有了主密钥和派生的会话密钥，握手就快结束了。客户端发一个“Change Cipher Spec”，然后再发一个“Finished”消息，把之前所有发送的数据做个摘要，再加密一下，让服务器做个验证。意思就是告诉服务器：“后面都改用对称算法加密通信了啊，用的就是打招呼时说的 AES，加密对不对还得你测一下。”</span><br><span class="line">服务器也是同样的操作，发“Change Cipher Spec”和“Finished”消息，双方都验证加密解密 OK，握手正式结束，后面就收发被加密的 HTTP 请求和响应了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RSA 握手过程</span><br><span class="line">RSA 握手过程大体的流程没有变，只是“Pre-Master”不再需要用算法生成，而是客户端直接生成随机数，然后用服务器的公钥加密，通过“Client Key Exchange”消息发给服务器。服务器再用私钥解密，这样双方也实现了共享三个随机数，就可以生成主密钥。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3.HTTP/1.0增加了 HEAD、POST 等新方法；</span><br><span class="line">增加了响应状态码，标记可能的错误原因；</span><br><span class="line">引入了协议版本号概念；</span><br><span class="line">引入了 HTTP Header（头部）的概念，让 HTTP 处理请求和响应更加灵活；</span><br><span class="line">传输的数据不再仅限于文本。</span><br><span class="line"></span><br><span class="line">4.HTTP/1.1 主要的变更点有：</span><br><span class="line">增加了 PUT、DELETE 等新的方法；</span><br><span class="line">增加了缓存管理和控制；</span><br><span class="line">明确了连接管理，允许持久连接；</span><br><span class="line">允许响应数据分块（chunked），利于传输大文件；</span><br><span class="line"></span><br><span class="line">TTP/1.1 中的连接都会默认启用长连接。不需要用什么特殊的头字段指定，只要向服务器发送了第一次请求，后续的请求都会重复利用第一次打开的 TCP 连接，也就是长连接，在这个连接上收发数据。</span><br><span class="line">请求头里明确地要求使用长连接机制，使用的字段是 Connection，值是“keep-alive”。</span><br><span class="line">TCP 连接长时间不关闭，服务器必须在内存里保存它的状态，这就占用了服务器的资源。如果有大量的空闲长连接只连不发，就会很快耗尽服务器的资源，导致服务器无法为真正有需要的用户提供服务。</span><br><span class="line">服务器端通常不会主动关闭连接，但也可以使用一些策略。拿 Nginx 来举例，它有两种方式：</span><br><span class="line">使用“keepalive_timeout”指令，设置长连接的超时时间，如果在一段时间内连接上没有任何数据收发就主动断开连接，避免空闲连接占用系统资源。</span><br><span class="line">使用“keepalive_requests”指令，设置长连接上可发送的最大请求次数。比如设置成 1000，那么当 Nginx 在这个连接上处理了 1000 个请求后，也会主动断开连接。</span><br><span class="line">另外，客户端和服务器都可以在报文里附加通用头字段“Keep-Alive: timeout=value”，限定长连接的超时时间。但这个字段的约束力并不强，通信的双方可能并不会遵守，所以不太常见。</span><br><span class="line"></span><br><span class="line">队头阻塞</span><br><span class="line">因为 HTTP 规定报文必须是“一发一收”，这就形成了一个先进先出的“串行”队列。队列里的请求没有轻重缓急的优先级，只有入队的先后顺序，排在最前面的请求被最优先处理。</span><br><span class="line">如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本。</span><br><span class="line"></span><br><span class="line">性能优化 </span><br><span class="line">“域名分片”（domain sharding）技术，还是用数量来解决质量的思路。HTTP 协议和浏览器不是限制并发连接数量吗？好，那我就多开几个域名，比如 shard1.diamonds.com、shard2.diamonds.com，而这些域名都指向同一台服务器 www.diamonds.com，这样实际长连接的数量就又上去了，真是“美滋滋”。不过实在是有点“上有政策，下有对策”的味道。</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">5.HTTP/2在高度兼容 HTTP/1.1 的同时在性能改善方面做了很大努力，主要的特点有：</span><br><span class="line">二进制协议，不再是纯文本；</span><br><span class="line">可发起多个请求，废弃了 1.1 里的管道；</span><br><span class="line">使用专用算法压缩头部，减少数据传输量；</span><br><span class="line">允许服务器主动向客户端推送数据；</span><br><span class="line">增强了安全性，“事实上”要求加密通信。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">头部压缩</span><br><span class="line">HTTP/1 里可以用头字段“Content-Encoding”指定 Body 的编码方式，比如用 gzip 压缩来节约带宽，但报文的另一个组成部分——Header 却被无视了，没有针对它的优化手段。</span><br><span class="line">由于报文 Header 一般会携带“User Agent”“Cookie”“Accept”“Server”等许多固定的头字段，多达几百字节甚至上千字节，但 Body 却经常只有几十字节（比如 GET 请求、204/301/304 响应），成了不折不扣的“大头儿子”。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">二进制格式</span><br><span class="line">它把 TCP 协议的部分特性挪到了应用层，把原来的“Header+Body”的消息“打散”为数个小片的二进制“帧”（Frame），用“HEADERS”帧存放头数据、“DATA”帧存放实体数据。</span><br><span class="line"></span><br><span class="line">虚拟的“流”</span><br><span class="line">HTTP/2 为此定义了一个“流”（Stream）的概念，它是二进制帧的双向传输序列，同一个消息往返的帧会分配一个唯一的流 ID。你可以把它想象成是一个虚拟的“数据流”，在里面流动的是一串有先后顺序的数据帧，这些数据帧按照次序组装起来就是 HTTP/1 里的请求报文和响应报文。</span><br><span class="line">因为“流”是虚拟的，实际上并不存在，所以 HTTP/2 就可以在一个 TCP 连接上用“流”同时发送多个“碎片化”的消息，这就是常说的“多路复用”（ Multiplexing）——多个往返通信都复用一个连接来处理。</span><br><span class="line">HTTP/2 还在一定程度上改变了传统的“请求 - 应答”工作模式，服务器不再是完全被动地响应请求，也可以新建“流”主动向客户端发送消息。比如，在浏览器刚请求 HTML 的时候就提前把可能会用到的 JS、CSS 文件发给客户端，减少等待的延迟，这被称为“服务器推送”（Server Push，也叫 Cache Push）。</span><br><span class="line">为了区分“加密”和“明文”这两个不同的版本，HTTP/2 协议定义了两个字符串标识符：“h2”表示加密的 HTTP/2，“h2c”表示明文的 HTTP/2，多出的那个字母“c”的意思是“clear text”。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">6.HTTP/3 HTTP over QUIC</span><br><span class="line">HTTP/2 虽然使用“帧”“流”“多路复用”，没有了“队头阻塞”，但这些手段都是在应用层里，而在下层，也就是 TCP 协议里，还是会发生“队头阻塞”。</span><br><span class="line">TCP 为了保证可靠传输，有个特别的“丢包重传”机制，丢失的包必须要等待重新传输确认，其他的包即使已经收到了，也只能放在缓冲区里，上层的应用拿不出来，只能“干着急”。</span><br><span class="line"></span><br><span class="line">客户端用 TCP 发送了三个包，但服务器所在的操作系统只收到了后两个包，第一个包丢了。那么内核里的 TCP 协议栈就只能把已经收到的包暂存起来，“停下”等着客户端重传那个丢失的包，这样就又出现了“队头阻塞”。</span><br><span class="line">由于这种“队头阻塞”是 TCP 协议固有的，所以 HTTP/2 即使设计出再多的“花样”也无法解决。</span><br><span class="line"></span><br><span class="line">HTTP/3 有一个关键的改变，那就是它把下层的 TCP“抽掉”了，换成了 UDP。因为 UDP 是无序的，包之间没有依赖关系，所以就从根本上解决了“队头阻塞”。</span><br><span class="line">UDP 是一个简单、不可靠的传输协议，只是对 IP 协议的一层很薄的包装，和 TCP 相比，它实际应用的较少。不过正是因为它简单，不需要建连和断连，通信成本低，也就非常灵活、高效，“可塑性”很强。</span><br><span class="line">所以，QUIC 就选定了 UDP，在它之上把 TCP 的那一套连接管理、拥塞窗口、流量控制等“搬”了过来，“去其糟粕，取其精华”，打造出了一个全新的可靠传输协议，可以认为是“新时代的 TCP”。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">QUIC 的特点</span><br><span class="line">QUIC 基于 UDP，而 UDP 是“无连接”的，根本就不需要“握手”和“挥手”，所以天生就要比 TCP 快。</span><br><span class="line">就像 TCP 在 IP 的基础上实现了可靠传输一样，QUIC 也基于 UDP 实现了可靠传输，保证数据一定能够抵达目的地。它还引入了类似 HTTP/2 的“流”和“多路复用”，单个“流”是有序的，可能会因为丢包而阻塞，但其他“流”不会受到影响。</span><br><span class="line">但 QUIC 并不是建立在 TLS 之上，而是内部“包含”了 TLS。它使用自己的帧“接管”了 TLS 里的“记录”，握手消息、警报消息都不使用 TLS 记录，直接封装成 QUIC 的帧发送，省掉了一次开销。</span><br><span class="line"></span><br><span class="line">HTTP/3 没有指定默认端口号，需要用 HTTP/2 的扩展帧“Alt-Svc”来发现。</span><br><span class="line">QUIC 内含了 TLS1.3，只能加密通信，支持 0-RTT 快速建连；</span><br><span class="line">QUIC 是一个新的传输层协议，建立在 UDP 之上，实现了可靠传输；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">7.正向代理：靠近客户端，代表客户端向服务器发送请求</span><br><span class="line">反向代理：靠近服务器端，代表服务器响应客户端的请求；</span><br><span class="line">CDN，实际上就是一种代理，它代替源站服务器响应客户端的请求，通常扮演着透明代理和反向代理的角色。</span><br><span class="line"></span><br><span class="line">8.1××：提示信息，表示目前是协议处理的中间状态，还需要后续的操作；</span><br><span class="line">2××：成功，报文已经收到并被正确处理；</span><br><span class="line">“204 No Content”是另一个很常见的成功状态码，它的含义与“200 OK”基本相同，但响应头后没有 body 数据。</span><br><span class="line">“206 Partial Content”是 HTTP 分块下载或断点续传的基础，在客户端发送“范围请求”、要求获取资源的部分数据时出现，它与 200 一样，也是服务器成功处理了请求，但 body 里的数据不是资源的全部，而是其中的一部分。状态码 206 通常还会伴随着头字段“Content-Range”，表示响应报文里 body 数据的具体范围，供客户端确认，</span><br><span class="line">例如“Content-Range: bytes 0-99/2000”，意思是此次获取的是总计 2000 个字节的前 100 个字节。</span><br><span class="line">3××：重定向，资源位置发生变动，需要客户端重新发送请求；</span><br><span class="line">“301 Moved Permanently”俗称“永久重定向”，含义是此次请求的资源已经不存在了，需要改用新的 URI 再次访问。</span><br><span class="line">比如，你的网站升级到了 HTTPS，原来的 HTTP 不打算用了，这就是“永久”的，所以要配置 301 跳转，把所有的 HTTP 流量都切换到 HTTPS。</span><br><span class="line">“302 Found”，曾经的描述短语是“Moved Temporarily”，俗称“临时重定向”，意思是请求的资源还在，但需要暂时用另一个 URI 来访问。301 和 302 都会在响应头里使用字段 Location 指明后续要跳转的 URI，最终的效果很相似，浏览器都会重定向到新的 URI。两者的根本区别在于语义，一个是“永久”，一个是“临时”，所以在场景、用法上差距很大。</span><br><span class="line">比如，今天夜里网站后台要系统维护，服务暂时不可用，这就属于“临时”的，可以配置成 302 跳转，把流量临时切换到一个静态通知页面，浏览器看到这个 302 就知道这只是暂时的情况，不会做缓存优化，第二天还会访问原来的地址。</span><br><span class="line">“304 Not Modified” 是一个比较有意思的状态码，它用于 If-Modified-Since 等条件请求，表示资源未修改，用于缓存控制。它不具有通常的跳转含义，但可以理解成“重定向已到缓存的文件”（即“缓存重定向”）。</span><br><span class="line">4××：客户端错误，请求报文有误，服务器无法处理；</span><br><span class="line">400 Bad Request”是一个通用的错误码，只是一个笼统的错误，客户端看到 400 只会是“一头雾水”“不知所措”。</span><br><span class="line">所以，在开发 Web 应用时应当尽量避免给客户端返回 400，而是要用其他更有明确含义的状态码。</span><br><span class="line">413 Request Entity Too Large：请求报文里的 body 太大；</span><br><span class="line">414 Request-URI Too Long：请求行里的 URI 太大；</span><br><span class="line">5××：服务器错误，服务器在处理请求时内部发生了错误</span><br><span class="line">“500 Internal Server Error”与 400 类似，也是一个通用的错误码，服务器究竟发生了什么错误我们是不知道的。不过对于服务器来说这应该算是好事，通常不应该把服务器内部的详细信息，例如出错的函数调用栈告诉外界。虽然不利于调试，但能够防止黑客的窥探或者分析。</span><br><span class="line">“502 Bad Gateway”通常是服务器作为网关或者代理时返回的错误码，表示服务器自身工作正常，访问后端服务器时发生了错误，但具体的错误原因也是不知道的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">9.MIME 是一个很大的标准规范，但 HTTP 只“顺手牵羊”取了其中的一部分，用来标记 body 的数据类型，这就是我们平常总能听到的“MIME type”。</span><br><span class="line">text：即文本格式的可读数据，我们最熟悉的应该就是 text/html 了，表示超文本文档，此外还有纯文本 text/plain、样式表 text/css 等。</span><br><span class="line">image：即图像文件，有 image/gif、image/jpeg、image/png 等。</span><br><span class="line">audio/video：音频和视频数据，例如 audio/mpeg、video/mp4 等。</span><br><span class="line">application：数据格式不固定，可能是文本也可能是二进制，必须由上层应用程序来解释。常见的有 application/json，application/javascript、application/pdf 等，另外，如果实在是不知道数据是什么类型，像刚才说的“黑盒”，就会是 application/octet-stream，即不透明的二进制数据。</span><br><span class="line"></span><br><span class="line">10.为了节约带宽，有时候还会压缩数据，Encoding type”，告诉数据是用的什么编码格式</span><br><span class="line">常用的只有下面三种：</span><br><span class="line">gzip：GNU zip 压缩格式，也是互联网上最流行的压缩格式；</span><br><span class="line">deflate：zlib（deflate）压缩格式，流行程度仅次于 gzip；</span><br><span class="line">br：一种专门为 HTTP 优化的新压缩算法（Brotli）。</span><br><span class="line"></span><br><span class="line">11.范围请求不是 Web 服务器必备的功能，可以实现也可以不实现，所以服务器必须在响应头里使用字段“Accept-Ranges: bytes”明确告知客户端：“我是支持范围请求的”。</span><br><span class="line">请求头 Range 是 HTTP 范围请求的专用字段，格式是“bytes=x-y”，其中的 x 和 y 是以字节为单位的数据范围。要注意 x、y 表示的是“偏移量”，范围必须从 0 计数，例如前 10 个字节表示为“0-9”，第二个 10 字节表示为“10-19”，而“0-10”实际上是前 11 个字节。</span><br><span class="line">服务器收到 Range 字段后，需要做四件事。</span><br><span class="line">第一，它必须检查范围是否合法，比如文件只有 100 个字节，但请求“200-300”，这就是范围越界了。服务器就会返回状态码 416，意思是“你的范围请求有误，我无法处理，请再检查一下”。</span><br><span class="line">第二，如果范围正确，服务器就可以根据 Range 头计算偏移量，读取文件的片段了，返回状态码“206 Partial Content”，和 200 的意思差不多，但表示 body 只是原数据的一部分。</span><br><span class="line">第三，服务器要添加一个响应头字段 Content-Range，告诉片段的实际偏移量和资源的总大小，格式是“bytes x-y/length”，与 Range 头区别在没有“=”，范围后多了总长度。例如，对于“0-10”的范围请求，值就是“bytes 0-10/100”。</span><br><span class="line">不仅看视频的拖拽进度需要范围请求，常用的下载工具里的多段下载、断点续传也是基于它实现的，要点是：</span><br><span class="line">先发个 HEAD，看服务器是否支持范围请求，同时获取文件的大小；</span><br><span class="line">开 N 个线程，每个线程使用 Range 字段划分出各自负责下载的片段，发请求传输数据；</span><br><span class="line">下载意外中断也不怕，不必重头再来一遍，只要根据上次的下载记录，用 Range 请求剩下的那一部分就可以了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">12.Cookie 的安全性</span><br><span class="line">属性“HttpOnly”会告诉浏览器，此 Cookie 只能通过浏览器 HTTP 协议传输，禁止其他方式访问，浏览器的 JS 引擎就会禁用 document.cookie 等一切相关的 API，脚本攻击也就无从谈起了。</span><br><span class="line">另一个属性“SameSite”可以防范“跨站请求伪造”（XSRF）攻击，设置成“SameSite=Strict”可以严格限定 Cookie 不能随着跳转链接跨站发送，而“SameSite=Lax”则略宽松一点，允许 GET/HEAD 等安全方法，但禁止 POST 跨站发送。</span><br><span class="line">还有一个属性叫“Secure”，表示这个 Cookie 仅能用 HTTPS 协议加密传输，明文的 HTTP 协议会禁止发送。但 Cookie 本身不是加密的，浏览器里还是以明文的形式存在。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">13.客户端的缓存控制</span><br><span class="line">当你点“刷新”按钮的时候，协商缓存</span><br><span class="line">Ctrl+F5 的“强制刷新”又是什么样的呢？响应头里面没有if-modified-since/if-none-match字段</span><br><span class="line"></span><br><span class="line">14.加密</span><br><span class="line">对称加密</span><br><span class="line">加密和解密时使用的密钥都是同一个，是“对称”的。只要保证了密钥的安全，那整个通信过程就可以说具有了机密性。</span><br><span class="line"></span><br><span class="line">非对称加密</span><br><span class="line">它有两个密钥，一个叫“公钥”（public key），一个叫“私钥”（private key）。两个密钥是不同的，“不对称”，公钥可以公开给任何人使用，而私钥必须严格保密。</span><br><span class="line">公钥和私钥有个特别的“单向”性，虽然都可以用来加密解密，但公钥加密后只能用私钥解密，反过来，私钥加密后也只能用公钥解密。</span><br><span class="line"></span><br><span class="line">混合加密</span><br><span class="line">在通信刚开始的时候使用非对称算法，比如 RSA、ECDHE，首先解决密钥交换的问题。</span><br><span class="line">然后用随机数产生对称算法使用的“会话密钥”（session key），再用公钥加密。</span><br></pre></td></tr></table></figure>
<h3 id="从输入URL到页面展示，这中间发生了什么？"><a href="#从输入URL到页面展示，这中间发生了什么？" class="headerlink" title="从输入URL到页面展示，这中间发生了什么？"></a>从输入URL到页面展示，这中间发生了什么？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1.URL 请求过程</span><br><span class="line">浏览器进程会通过进程间通信（IPC）把 URL 请求发送至网络进程，网络进程接收到 URL 请求后，会在这里发起真正的 URL 请求流程。</span><br><span class="line">网络进程会查找本地缓存是否缓存了该资源。如果有缓存资源，那么直接返回资源给浏览器进程；如果在缓存中没有查找到资源，那么直接进入网络请求流程。</span><br><span class="line">请求前的第一步是要进行 DNS 解析，以获取请求域名的服务器 IP 地址。如果请求协议是 HTTPS，那么还需要建立 TLS 连接。</span><br><span class="line">接下来就是利用 IP 地址和服务器建立 TCP 连接。连接建立之后，浏览器端会构建请求行、请求头等信息，并把和该域名相关的 Cookie 等数据附加到请求头中，然后向服务器发送构建的请求信息。</span><br><span class="line">服务器接收到请求信息后，会根据请求信息生成响应数据（包括响应行、响应头和响应体等信息），并发给网络进程。等网络进程接收了响应行和响应头之后，就开始解析响应头的内容了。</span><br><span class="line">在接收到服务器返回的响应头后，网络进程开始解析响应头，如果发现返回的状态码是 301 或者 302，那么说明服务器需要浏览器重定向到其他 URL。这时网络进程会从响应头的 Location 字段里面读取重定向的地址，然后再发起新的 HTTP 或者 HTTPS 请求，一切又重头开始了。</span><br><span class="line">在导航过程中，如果服务器响应行的状态码包含了 301、302 一类的跳转信息，浏览器会跳转到新的地址继续导航；如果响应行是 200，那么表示浏览器可以继续处理该请求。</span><br><span class="line">Content-Type 是 HTTP 头中一个非常重要的字段， 它告诉浏览器服务器返回的响应体数据是什么类型，然后浏览器会根据 Content-Type 的值来决定如何显示响应体的内容。</span><br><span class="line">Content-Type 的值是 application/octet-stream，显示数据是字节流类型的，通常情况下，浏览器会按照下载类型来处理该请求。</span><br><span class="line">如果 Content-Type 字段的值被浏览器判断为下载类型，那么该请求会被提交给浏览器的下载管理器，同时该 URL 请求的导航流程就此结束。但如果是 HTML，那么浏览器则会继续进行导航流程。由于 Chrome 的页面渲染是运行在渲染进程中的，所以接下来就需要准备渲染进程了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.渲染进程</span><br><span class="line">默认情况下，Chrome 会为每个页面分配一个渲染进程，也就是说，每打开一个新页面就会配套创建一个新的渲染进程。但是，也有一些例外，在某些情况下，浏览器会让多个页面直接运行在同一个渲染进程中。</span><br><span class="line">那什么情况下多个页面会同时运行在一个渲染进程中呢？</span><br><span class="line">https://time.diamonds.org</span><br><span class="line">https://www.diamonds.org</span><br><span class="line">https://www.diamonds.org:8080</span><br><span class="line">它们都是属于同一站点，因为它们的协议都是 HTTPS，而且根域名也都是 diamonds.org。</span><br><span class="line">Chrome 的默认策略是，每个标签对应一个渲染进程。但如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程。官方把这个默认策略叫 process-per-site-instance。</span><br><span class="line">总结来说，打开一个新页面采用的渲染进程策略就是：</span><br><span class="line">通常情况下，打开新的页面都会使用单独的渲染进程；如果从 A 页面打开 B 页面，且 A 和 B 都属于同一站点的话，那么 B 页面复用 A 页面的渲染进程；</span><br><span class="line">如果是其他情况，浏览器进程则会为 B 创建一个新的渲染进程。</span><br><span class="line">渲染进程准备好之后，还不能立即进入文档解析状态，因为此时的文档数据还在网络进程中，并没有提交给渲染进程，所以下一步就进入了提交文档阶段。</span><br><span class="line"></span><br><span class="line">所谓提交文档，就是指浏览器进程将网络进程接收到的 HTML 数据提交给渲染进程，具体流程是这样的：</span><br><span class="line">首先当浏览器进程接收到网络进程的响应头数据之后，便向渲染进程发起“提交文档”的消息；</span><br><span class="line">渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”；</span><br><span class="line">等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程；</span><br><span class="line">浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。</span><br><span class="line">这也就解释了为什么在浏览器的地址栏里面输入了一个地址后，之前的页面没有立马消失，而是要加载一会儿才会更新页面。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3.渲染流程</span><br><span class="line">按照渲染的时间顺序，流水线可分为如下几个子阶段：构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成。</span><br><span class="line"></span><br><span class="line">构建 DOM 树</span><br><span class="line">为什么要构建 DOM 树呢？这是因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM 树。</span><br><span class="line"></span><br><span class="line">样式计算（Recalculate Style）</span><br><span class="line">样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式，这个阶段大体可分为三步来完成。</span><br><span class="line">把 CSS 转换为浏览器能够理解的结构</span><br><span class="line">和 HTML 文件一样，浏览器也是无法直接理解这些纯文本的 CSS 样式，所以当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets。</span><br><span class="line">body &#123; font-size: 2em &#125;  =&gt; body &#123; font-size: 32px &#125;</span><br><span class="line">p &#123;color:blue;&#125;  =&gt; p &#123;rgba(0,0,255)&#125;</span><br><span class="line">span  &#123;display: none&#125;</span><br><span class="line">div &#123;font-weight: bold&#125;  =&gt; div &#123;font-weight: 700)&#125;</span><br><span class="line">div  p &#123;color:green;&#125; =&gt; div &#123;rgba(0,128,0)&#125;</span><br><span class="line">div &#123;color:red; &#125;  =&gt; div &#123;rgba(255,0,0)&#125;</span><br><span class="line">可以看到上面的 CSS 文本中有很多属性值，如 2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。</span><br><span class="line">首先是 CSS 继承。CSS 继承就是每个 DOM 节点都包含有父节点的样式。</span><br><span class="line">样式计算过程中的第二个规则是样式层叠。层叠是 CSS 的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法。它在 CSS 处于核心地位，CSS 的全称“层叠样式表”正是强调了这一点。</span><br><span class="line">总之，样式计算阶段的目的是为了计算出 DOM 节点中每个元素的具体样式，在计算过程中需要遵守 CSS 的继承和层叠两个规则。这个阶段最终输出的内容是每个 DOM 节点的样式，并被保存在 ComputedStyle 的结构内。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">布局阶段</span><br><span class="line">有 DOM 树和 DOM 树中元素的样式，但这还不足以显示页面，因为我们还不知道 DOM 元素的几何位置信息。那么接下来就需要计算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做布局。</span><br><span class="line">Chrome 在布局阶段需要完成两个任务：创建布局树和布局计算。</span><br><span class="line">创建布局树</span><br><span class="line">DOM 树还含有很多不可见的元素，比如 head 标签，还有使用了 display:none 属性的元素。所以在显示之前，我们还要额外地构建一棵只包含可见元素布局树。</span><br><span class="line">DOM 树中所有不可见的节点都没有包含到布局树中。</span><br><span class="line">布局计算</span><br><span class="line">在执行布局操作的时候，会把布局运算的结果重新写回布局树中，所以布局树既是输入内容也是输出内容，这是布局阶段一个不合理的地方，因为在布局阶段并没有清晰地将输入内容和输出内容区分开来。</span><br><span class="line">针对这个问题，Chrome 团队正在重构布局代码，下一代布局系统叫 LayoutNG，试图更清晰地分离输入和输出，从而让新设计的布局算法更加简单。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">分层</span><br><span class="line">浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。</span><br><span class="line">通常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层</span><br><span class="line">拥有层叠上下文属性的元素会被提升为单独的一层。页面是个二维平面，但是层叠上下文能够让 HTML 元素具有三维概念，这些 HTML 元素按照自身属性的优先级分布在垂直于这个二维平面的 z 轴上。</span><br><span class="line">明确定位属性的元素、定义透明属性的元素、使用 CSS 滤镜的元素等，都拥有层叠上下文属性。</span><br><span class="line">需要剪裁（clip）的地方也会被创建为图层。</span><br><span class="line"></span><br><span class="line">图层绘制</span><br><span class="line">在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制</span><br><span class="line"></span><br><span class="line">栅格化（raster）操作</span><br><span class="line">绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。</span><br><span class="line">当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程</span><br><span class="line">通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做视口（viewport）。</span><br><span class="line">在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。基于这个原因，合成线程会将图层划分为图块（tile）。</span><br><span class="line">合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的</span><br><span class="line">通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。GPU 操作是运行在 GPU 进程中，如果栅格化操作使用了 GPU，那么最终生成位图的操作是在 GPU 中完成的，这就涉及到了跨进程操作</span><br><span class="line">渲染进程把生成图块的指令发送给 GPU，然后在 GPU 中执行生成图块的位图，并保存在 GPU 的内存中</span><br><span class="line"></span><br><span class="line">合成和显示</span><br><span class="line">一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。</span><br><span class="line">浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">渲染总结</span><br><span class="line">一个完整的渲染流程大致可总结为如下：</span><br><span class="line">渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。</span><br><span class="line">渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。</span><br><span class="line">创建布局树，并计算元素的布局信息。</span><br><span class="line">对布局树进行分层，并生成分层树。</span><br><span class="line">为每个图层生成绘制列表，并将其提交到合成线程。</span><br><span class="line">合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。</span><br><span class="line">合成线程发送绘制图块命令 DrawQuad 给浏览器进程。</span><br><span class="line">浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">相关概念</span><br><span class="line">更新了元素的几何属性（重排）</span><br><span class="line">如果你通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。</span><br><span class="line">无疑，重排需要更新完整的渲染流水线，所以开销也是最大的。</span><br><span class="line">更新元素的绘制属性（重绘）</span><br><span class="line">如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。</span><br><span class="line">相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。</span><br><span class="line">直接合成阶段</span><br><span class="line">使用 CSS 的 transform 来实现动画效果，可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。</span><br><span class="line">这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，</span><br><span class="line">所以相对于重绘和重排，合成能大大提升绘制效率。</span><br></pre></td></tr></table></figure>
<h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><h2 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h2><h3 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h3><h2 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h2><h3 id="vue初始化"><a href="#vue初始化" class="headerlink" title="vue初始化"></a>vue初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Vue.prototype.$mount</span><br><span class="line"> * 对vue组件进行挂载，基于render函数，没有render函数时，会获取template，将template解析生成render函数</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * mountComponent</span><br><span class="line"> * 挂载vue组件，在运行时版本、开发环境下如果没有render函数有template，vue会输出警告（运行时版本没有模板编译）</span><br><span class="line"> * 该方法会先触发beforeMount生命周期钩子函数</span><br><span class="line"> * new Watcher(),实例化一个渲染Watcher，传入一个updateComponent方法（该方法会调用_render方法（_render方法会调用render方法生成虚拟Dom）,通过_update方法将虚拟Dom转换成真实Dom）</span><br><span class="line"> * 接着触发mounted生命周期钩子</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * vue初始化过程</span><br><span class="line"> * 声明Vue构造函数，定义状态相关的属性和方法（$date/$props/$set/$delete/$watch）,定义事件有关的方法（$on/$emit/$off/$once），生命周期有关的方法(_update/$forceUpdate/$destroy),渲染有关的方法（$nextTick/_render）</span><br><span class="line"> * initGlobalAPI()初始化一些全局属性和方法（Vue.set/Vue.delete/Vue.nextTick/Vue.observable/Vue.options/Vue.use/Vue.mixin/Vue.extend/Vue.directive/Vue.component/Vue.filter）</span><br><span class="line"> * new Vue()时会调用_init()方法，对vue实例初始化</span><br><span class="line"> * initLifecycle() 初始化生命周期相关变量（$children/$parent/$root/$refs）/initEvents()/initRender()</span><br><span class="line"> * 接着触发beforeCreate生命周期钩子函数</span><br><span class="line"> * initInjections()在data/props之前处理injections/initState()(_props/methods/_data/computed/watch)/initProvide()在data/props之前处理provide</span><br><span class="line"> * 接着会触发created生命周期钩子函数</span><br><span class="line"> * 最后挂载并渲染页面</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line"> /**</span><br><span class="line"> * Vue.use() </span><br><span class="line"> * 插件是function时直接调用,插件有install字段且install是function时调用install</span><br><span class="line"> * export function initUse (Vue: GlobalAPI) &#123;</span><br><span class="line">   //参数为函数或对象</span><br><span class="line">  Vue.use = function (plugin: Function | Object) &#123;</span><br><span class="line">   //已经安装的插件</span><br><span class="line">    const installedPlugins = (this._installedPlugins || (this._installedPlugins = []))</span><br><span class="line">	//已经安装过的插件不会再次安装</span><br><span class="line">    if (installedPlugins.indexOf(plugin) &gt; -1) &#123;</span><br><span class="line">      return this</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // additional parameters   把参数的第一个元素去除，第一个元素是插件</span><br><span class="line">    const args = toArray(arguments, 1)</span><br><span class="line">    args.unshift(this)   //args数组第一项插入this(Vue)</span><br><span class="line">	//参数为对象时，有一个install方法，调用install方法</span><br><span class="line">    if (typeof plugin.install === &apos;function&apos;) &#123;</span><br><span class="line">      plugin.install.apply(plugin, args)</span><br><span class="line">    &#125; </span><br><span class="line">	//参数为函数时,直接调用</span><br><span class="line">	else if (typeof plugin === &apos;function&apos;) &#123;</span><br><span class="line">      plugin.apply(null, args)</span><br><span class="line">    &#125;</span><br><span class="line">    installedPlugins.push(plugin)</span><br><span class="line">    return this</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<h2 id="react"><a href="#react" class="headerlink" title="react"></a>react</h2><h2 id="node"><a href="#node" class="headerlink" title="node"></a>node</h2><h2 id="各种手写"><a href="#各种手写" class="headerlink" title="各种手写"></a>各种手写</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br></pre></td><td class="code"><pre><span class="line">1.call/apply/bind</span><br><span class="line"></span><br><span class="line">Function.prototype.call = function (context, ...args) &#123;</span><br><span class="line">  var context = context || window;</span><br><span class="line"></span><br><span class="line">  //当前this指向Function.prototype上面的方法</span><br><span class="line">  context.fn = this;</span><br><span class="line">  var result = eval(&quot;context.fn(...args)&quot;);</span><br><span class="line"></span><br><span class="line">  delete context.fn;</span><br><span class="line"></span><br><span class="line">  return result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Function.prototype.apply = function (context, args) &#123;</span><br><span class="line"></span><br><span class="line">  let context = context || window;</span><br><span class="line"></span><br><span class="line">  context.fn = this;</span><br><span class="line"></span><br><span class="line">  let result = eval(&apos;context.fn(...args)&apos;);</span><br><span class="line"></span><br><span class="line">  delete context.fn</span><br><span class="line"></span><br><span class="line">  return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Function.prototype.bind = function (context, ...args) &#123;</span><br><span class="line">  if (typeof this !== &quot;function&quot;) &#123;</span><br><span class="line">    throw new Error(&quot;this must be a function&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  var self = this;</span><br><span class="line">  var fbound = function () &#123;  </span><br><span class="line">    self.apply(</span><br><span class="line">      this instanceof fbound ? this : context,</span><br><span class="line">      args.concat(Array.prototype.slice.call(arguments))</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  if (this.prototype) &#123;</span><br><span class="line">    fbound.prototype = Object.create(this.prototype);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return fbound;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">2.promise</span><br><span class="line"></span><br><span class="line">class APromise &#123;</span><br><span class="line">  //容器状态</span><br><span class="line">  status = &quot;pending&quot;;</span><br><span class="line">  //处理成功时的容器值</span><br><span class="line">  value = &quot;&quot;;</span><br><span class="line">  //处理失败时的原因</span><br><span class="line">  reason = &quot;&quot;;</span><br><span class="line">  //处理成功回调函数     then方法被多次调用时，采用数组进行存储回调函数</span><br><span class="line">  fullFilledCallbacks = [];</span><br><span class="line">  //处理失败回调函数</span><br><span class="line">  rejectedCallBacks = [];</span><br><span class="line">  //处理成功</span><br><span class="line">  resolve = (value) =&gt; &#123;</span><br><span class="line">    if (this.status === &quot;pending&quot;) &#123;</span><br><span class="line">      this.status = &quot;fullFilled&quot;;</span><br><span class="line">      this.value = value;</span><br><span class="line"></span><br><span class="line">      //处理成功回调</span><br><span class="line">      while (this.fullFilledCallbacks.length) &#123;</span><br><span class="line">        this.fullFilledCallbacks.shift()(value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  //处理成败</span><br><span class="line">  reject = (reason) =&gt; &#123;</span><br><span class="line">    if (this.status === &quot;pending&quot;) &#123;</span><br><span class="line">      this.status = &quot;rejected&quot;;</span><br><span class="line">      this.reason = reason;</span><br><span class="line"></span><br><span class="line">      //处理失败回调</span><br><span class="line">      while (this.rejectedCallBacks.length) &#123;</span><br><span class="line">        this.rejectedCallBacks.shift()(reason);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  //处理then方法回调函数返回值</span><br><span class="line">  resolvePromise = (promise, res, resolve, reject) =&gt; &#123;</span><br><span class="line">    //then方法成功回调返回值和then方法返回值一样时</span><br><span class="line">    if (promise === res) &#123;</span><br><span class="line">      //避免循环引用</span><br><span class="line">      reject(new TypeError(&quot;Chaining cycle detected for promise #&lt;Promise&gt;&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //返回值为promise（这里的promise指then方法成功回调时返回的promise）时</span><br><span class="line">    if (res instanceof APromise) &#123;</span><br><span class="line">      //对返回的promise（这里的promise指then方法成功回调时返回的promise）的处理结果进行处理</span><br><span class="line">      //通过resolve/reject对返回的promise（这里的promise指调用then方法时返回的promise）状态进行处理</span><br><span class="line">      res.then(resolve, reject);</span><br><span class="line">    &#125;</span><br><span class="line">    //普通值</span><br><span class="line">    else &#123;</span><br><span class="line">      resolve(res);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  //处理完成   (rejected/pending逻辑参考fullFilled状态)</span><br><span class="line">  then = (onFullFilled, onRejected) =&gt; &#123;</span><br><span class="line">    // 如果不传，就使用默认函数</span><br><span class="line">    onFullFilled =</span><br><span class="line">      typeof onFullFilled === &quot;function&quot; ? onFullFilled : (value) =&gt; value;</span><br><span class="line">    // 如果不传，就使用默认函数</span><br><span class="line">    onRejected =</span><br><span class="line">      typeof onRejected === &quot;function&quot;</span><br><span class="line">        ? onRejected</span><br><span class="line">        : (reason) =&gt; &#123;</span><br><span class="line">            throw reason;</span><br><span class="line">          &#125;;</span><br><span class="line"></span><br><span class="line">    //返回promise用于链式调用</span><br><span class="line">    const promise = new APromise((resolve, reject) =&gt; &#123;</span><br><span class="line">      //成功回调</span><br><span class="line">      if (this.status === &quot;fullFilled&quot;) &#123;</span><br><span class="line">        // 为了拿到上面返回的promise实例对象，需要创建一个微任务等待promise初始化</span><br><span class="line">        //否则，会报ReferenceError: Cannot access &apos;promise&apos; before initialization</span><br><span class="line">        queueMicrotask(() =&gt; &#123;</span><br><span class="line">          //异常捕获</span><br><span class="line">          try &#123;</span><br><span class="line">            const res = onFullFilled(this.value);</span><br><span class="line">            this.resolvePromise(promise, res, resolve, reject);</span><br><span class="line">          &#125; catch (error) &#123;</span><br><span class="line">            reject(error);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      //失败回调</span><br><span class="line">      if (this.status === &quot;rejected&quot;) &#123;</span><br><span class="line">        queueMicrotask(() =&gt; &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">            const res = onRejected(this.reason);</span><br><span class="line">            this.resolvePromise(promise, res, resolve, reject);</span><br><span class="line">          &#125; catch (error) &#123;</span><br><span class="line">            reject(error);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      //处理异步任务</span><br><span class="line">      if (this.status === &quot;pending&quot;) &#123;</span><br><span class="line">        //对成功、失败回调进行存储。异步任务执行成功后再进行处理</span><br><span class="line">        //对成功处理函数存储</span><br><span class="line">        this.fullFilledCallbacks.push(() =&gt; &#123;</span><br><span class="line">          //异常捕获</span><br><span class="line">          try &#123;</span><br><span class="line">            const res = onFullFilled(this.value);</span><br><span class="line">            this.resolvePromise(promise, res, resolve, reject);</span><br><span class="line">          &#125; catch (error) &#123;</span><br><span class="line">            reject(error);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        //对失败处理函数进行存储</span><br><span class="line">        this.rejectedCallBacks.push(() =&gt; &#123;</span><br><span class="line">          queueMicrotask(() =&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">              const res = onRejected(this.reason);</span><br><span class="line">              this.resolvePromise(promise, res, resolve, reject);</span><br><span class="line">            &#125; catch (error) &#123;</span><br><span class="line">              reject(error);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return promise;</span><br><span class="line">  &#125;;</span><br><span class="line">  constructor(executor) &#123;</span><br><span class="line">    //异常捕获</span><br><span class="line">    try &#123;</span><br><span class="line">      //执行器</span><br><span class="line">      executor(this.resolve, this.reject);</span><br><span class="line">    &#125; catch (error) &#123;</span><br><span class="line">      console.log(error);</span><br><span class="line">      this.reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default APromise;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------------</span><br><span class="line">/**</span><br><span class="line"> * Promise.all Promise.race Promise.allSettled Promise.any</span><br><span class="line"> *</span><br><span class="line"> * Promise.all()方法只适合所有异步操作都成功的情况，如果有一个操作失败，就无法满足要求。</span><br><span class="line"> * ES2020 引入了Promise.allSettled()方法，用来确定一组异步操作是否都结束了（不管成功或失败）。</span><br><span class="line"> * Promise.any()跟Promise.race()方法很像，只有一点不同，就是Promise.any()不会因为某个 Promise 变成rejected状态而结束，必须等到所有参数 Promise 变成rejected状态才会结束。</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">Promise.all = function (promiseArr) &#123;</span><br><span class="line">  let index = 0,</span><br><span class="line">    result = [];</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    promiseArr.forEach((p, i) =&gt; &#123;</span><br><span class="line">      Promise.resolve(p).then(</span><br><span class="line">        (val) =&gt; &#123;</span><br><span class="line">          index++;</span><br><span class="line">          result[i] = val;</span><br><span class="line">          if (index === promiseArr.length) &#123;</span><br><span class="line">            resolve(result);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        (err) =&gt; &#123;</span><br><span class="line">          reject(err);</span><br><span class="line">        &#125;</span><br><span class="line">      );</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Promise.race = function (promiseArr) &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    promiseArr.forEach((p) =&gt; &#123;</span><br><span class="line">      Promise.resolve(p).then(</span><br><span class="line">        (val) =&gt; &#123;</span><br><span class="line">          resolve(val);</span><br><span class="line">        &#125;,</span><br><span class="line">        (err) =&gt; &#123;</span><br><span class="line">          reject(err);</span><br><span class="line">        &#125;</span><br><span class="line">      );</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Promise.allSettled = function(promiseArr) &#123;</span><br><span class="line">  let result = []</span><br><span class="line"></span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      promiseArr.forEach((p, i) =&gt; &#123;</span><br><span class="line">          Promise.resolve(p).then(val =&gt; &#123;</span><br><span class="line">              result.push(&#123;</span><br><span class="line">                  status: &apos;fulfilled&apos;,</span><br><span class="line">                  value: val</span><br><span class="line">              &#125;)</span><br><span class="line">              if (result.length === promiseArr.length) &#123;</span><br><span class="line">                  resolve(result)</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;, err =&gt; &#123;</span><br><span class="line">              result.push(&#123;</span><br><span class="line">                  status: &apos;rejected&apos;,</span><br><span class="line">                  reason: err</span><br><span class="line">              &#125;)</span><br><span class="line">              if (result.length === promiseArr.length) &#123;</span><br><span class="line">                  resolve(result)</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise.any = function(promiseArr) &#123;</span><br><span class="line">  let index = 0</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      if (promiseArr.length === 0) return</span><br><span class="line">      promiseArr.forEach((p, i) =&gt; &#123;</span><br><span class="line">          Promise.resolve(p).then(val =&gt; &#123;</span><br><span class="line">              resolve(val)</span><br><span class="line"></span><br><span class="line">          &#125;, err =&gt; &#123;</span><br><span class="line">              index++</span><br><span class="line">              if (index === promiseArr.length) &#123;</span><br><span class="line">                reject(new AggregateError(&apos;All promises were rejected&apos;))</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3.JSON.stringify/JSON.parse</span><br><span class="line"></span><br><span class="line">function jsonStringify(data) &#123;</span><br><span class="line">  let type = typeof data;</span><br><span class="line"></span><br><span class="line">  if (type !== &quot;object&quot;) &#123;</span><br><span class="line">    let result = data;</span><br><span class="line"></span><br><span class="line">    //data 可能是基础数据类型的情况在这里处理</span><br><span class="line"></span><br><span class="line">    if (Number.isNaN(data) || data === Infinity) &#123;</span><br><span class="line">      //NaN 和 Infinity 序列化返回 &quot;null&quot;</span><br><span class="line"></span><br><span class="line">      result = &quot;null&quot;;</span><br><span class="line">    &#125; else if (</span><br><span class="line">      type === &quot;function&quot; ||</span><br><span class="line">      type === &quot;undefined&quot; ||</span><br><span class="line">      type === &quot;symbol&quot;</span><br><span class="line">    ) &#123;</span><br><span class="line">      // 由于 function 序列化返回 undefined，因此和 undefined、symbol 一起处理</span><br><span class="line"></span><br><span class="line">      return undefined;</span><br><span class="line">    &#125; else if (type === &quot;string&quot;) &#123;</span><br><span class="line">      result = &apos;&quot;&apos; + data + &apos;&quot;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return String(result);</span><br><span class="line">  &#125; else if (type === &quot;object&quot;) &#123;</span><br><span class="line">    //null</span><br><span class="line">    if (data === null) &#123;</span><br><span class="line">      return &quot;null&quot;; // 第01讲有讲过 typeof null 为&apos;object&apos;的特殊情况</span><br><span class="line">    &#125;</span><br><span class="line">    //date类型</span><br><span class="line">    else if (data.toJSON &amp;&amp; typeof data.toJSON === &quot;function&quot;) &#123;</span><br><span class="line">      return jsonStringify(data.toJSON());</span><br><span class="line">    &#125;</span><br><span class="line">    //数组</span><br><span class="line">    else if (data instanceof Array) &#123;</span><br><span class="line">      let result = [];</span><br><span class="line"></span><br><span class="line">      //如果是数组，那么数组里面的每一项类型又有可能是多样的</span><br><span class="line"></span><br><span class="line">      data.forEach((item, index) =&gt; &#123;</span><br><span class="line">        if (</span><br><span class="line">          typeof item === &quot;undefined&quot; ||</span><br><span class="line">          typeof item === &quot;function&quot; ||</span><br><span class="line">          typeof item === &quot;symbol&quot;</span><br><span class="line">        ) &#123;</span><br><span class="line">          result[index] = &quot;null&quot;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          result[index] = jsonStringify(item);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      result = &quot;[&quot; + result + &quot;]&quot;;</span><br><span class="line"></span><br><span class="line">      return result.replace(/&apos;/g, &apos;&quot;&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    //普通对象</span><br><span class="line">    else &#123;</span><br><span class="line">      // 处理普通对象</span><br><span class="line"></span><br><span class="line">      let result = [];</span><br><span class="line"></span><br><span class="line">      Object.keys(data).forEach((item, index) =&gt; &#123;</span><br><span class="line">        if (typeof item !== &quot;symbol&quot;) &#123;</span><br><span class="line">          //key 如果是 symbol 对象，忽略</span><br><span class="line"></span><br><span class="line">          if (</span><br><span class="line">            data[item] !== undefined &amp;&amp;</span><br><span class="line">            typeof data[item] !== &quot;function&quot; &amp;&amp;</span><br><span class="line">            typeof data[item] !== &quot;symbol&quot;</span><br><span class="line">          ) &#123;</span><br><span class="line">            //键值如果是 undefined、function、symbol 为属性值，忽略</span><br><span class="line"></span><br><span class="line">            result.push(&apos;&quot;&apos; + item + &apos;&quot;&apos; + &quot;:&quot; + jsonStringify(data[item]));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      return (&quot;&#123;&quot; + result + &quot;&#125;&quot;).replace(/&apos;/g, &apos;&quot;&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------------------------------</span><br><span class="line">eval(`($&#123;&apos;&#123;&quot;p&quot;: 5,&quot;p2&quot;: 52&#125;&apos;&#125;)`)</span><br><span class="line">new Function(`return ($&#123;&apos;&#123;&quot;p&quot;: 5,&quot;p2&quot;: 52&#125;&apos;&#125;)`)()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4.EventEmitter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function EventEmitter() &#123;</span><br><span class="line">  this.__events = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventEmitter.VERSION = &quot;1.0.0&quot;;</span><br><span class="line"></span><br><span class="line">//绑定事件</span><br><span class="line">EventEmitter.prototype.on = function (eventName, event) &#123;</span><br><span class="line">  let events = (this.__events[eventName] = this.__events[eventName] || []);</span><br><span class="line">  //是否存在该事件</span><br><span class="line">  let isExist = events.find((ev) =&gt; ev.listener === (event.listener || event));</span><br><span class="line">  if (!isExist) &#123;</span><br><span class="line">    events.push(</span><br><span class="line">      //对象或函数</span><br><span class="line">      event.listener</span><br><span class="line">        ? event</span><br><span class="line">        : &#123;</span><br><span class="line">            once: false,</span><br><span class="line">            listener: event,</span><br><span class="line">          &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return this;</span><br><span class="line">&#125;;</span><br><span class="line">//触发事件</span><br><span class="line">EventEmitter.prototype.emit = function (eventName, args) &#123;</span><br><span class="line">  let events = this.__events[eventName] || [];</span><br><span class="line"></span><br><span class="line">  //多个事件</span><br><span class="line">  for (let event of events) &#123;</span><br><span class="line">    event.listener.apply(this, args || []);</span><br><span class="line">    if (event.once) &#123;</span><br><span class="line">      this.off(eventName, event);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//执行一次</span><br><span class="line">EventEmitter.prototype.once = function (eventName, event) &#123;</span><br><span class="line">  return this.on(eventName, &#123;</span><br><span class="line">    once: true,</span><br><span class="line">    listener: event.listener || event,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">//移除事件</span><br><span class="line">EventEmitter.prototype.off = function (eventName, event) &#123;</span><br><span class="line">  let events = this.__events[eventName] || [];</span><br><span class="line">  //事件下标</span><br><span class="line">  let eventIndex = events.findIndex(</span><br><span class="line">    (ev) =&gt; ev.listener === (event.listener || event)</span><br><span class="line">  );</span><br><span class="line">  //存在该事件时</span><br><span class="line">  if (eventIndex !== -1) events.splice(eventIndex, 1);</span><br><span class="line">&#125;;</span><br><span class="line">//移除所有事件</span><br><span class="line">EventEmitter.prototype.allOff = function (eventName) &#123;</span><br><span class="line">  if (this.__events[eventName]) this.__events[eventName] = [];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5.继承</span><br><span class="line"></span><br><span class="line">//原型链继承</span><br><span class="line">function Parent1() &#123;</span><br><span class="line">  this.name = &quot;parent1&quot;;</span><br><span class="line"></span><br><span class="line">  this.play = [1, 2, 3];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child1() &#123;</span><br><span class="line">  this.type = &quot;child2&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child1.prototype = new Parent1();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//构造函数继承</span><br><span class="line">function Parent1() &#123;</span><br><span class="line">  this.name = &quot;parent1&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent1.prototype.getName = function () &#123;</span><br><span class="line">  return this.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Child1() &#123;</span><br><span class="line">  Parent1.call(this);</span><br><span class="line"></span><br><span class="line">  this.type = &quot;child1&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//组合继承</span><br><span class="line"></span><br><span class="line">function Parent3() &#123;</span><br><span class="line">  this.name = &quot;parent3&quot;;</span><br><span class="line"></span><br><span class="line">  this.play = [1, 2, 3];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent3.prototype.getName = function () &#123;</span><br><span class="line">  return this.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Child3() &#123;</span><br><span class="line"></span><br><span class="line">  Parent3.call(this);</span><br><span class="line"></span><br><span class="line">  this.type = &quot;child3&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Child3.prototype = new Parent3();</span><br><span class="line"></span><br><span class="line">// 手动挂上构造器，指向自己的构造函数</span><br><span class="line">Child3.prototype.constructor = Child3;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">6.new</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//new 关键字会进行如下的操作：</span><br><span class="line"></span><br><span class="line">//创建一个空的简单JavaScript对象（即&#123;&#125;）；</span><br><span class="line">//为步骤1新创建的对象添加属性__proto__，将该属性链接至构造函数的原型对象 ；</span><br><span class="line">//将步骤1新创建的对象作为this的上下文 ；</span><br><span class="line">//如果该函数没有返回对象，则返回this。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function _new(ctor, ...args) &#123;</span><br><span class="line">  if (typeof ctor !== &quot;function&quot;) &#123;</span><br><span class="line">    throw &quot;ctor must be a function&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let obj = new Object();</span><br><span class="line"></span><br><span class="line">  obj.__proto__ = Object.create(ctor.prototype);</span><br><span class="line"></span><br><span class="line">  //关键  this指向</span><br><span class="line">  let res = ctor.apply(obj, [...args]);</span><br><span class="line"></span><br><span class="line">  let isObject = typeof res === &quot;object&quot; &amp;&amp; res !== null;</span><br><span class="line"></span><br><span class="line">  let isFunction = typeof res === &quot;function&quot;;</span><br><span class="line"></span><br><span class="line">  return isObject || isFunction ? res : obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">7.对象拷贝</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const isComplexDataType = (obj) =&gt;</span><br><span class="line">  (typeof obj === &quot;object&quot; || typeof obj === &quot;function&quot;) &amp;&amp; obj !== null;</span><br><span class="line"></span><br><span class="line">const deepClone = function (obj, hash = new WeakMap()) &#123;</span><br><span class="line">  if (obj.constructor === Date) return new Date(obj); // 日期对象直接返回一个新的日期对象</span><br><span class="line"></span><br><span class="line">  if (obj.constructor === RegExp) return new RegExp(obj); //正则对象直接返回一个新的正则对象</span><br><span class="line"></span><br><span class="line">  //如果循环引用了就用 weakMap 来解决</span><br><span class="line"></span><br><span class="line">  if (hash.has(obj)) return hash.get(obj);</span><br><span class="line"></span><br><span class="line">  let allDesc = Object.getOwnPropertyDescriptors(obj);</span><br><span class="line"></span><br><span class="line">  //遍历传入参数所有键的特性</span><br><span class="line"></span><br><span class="line">  let cloneObj = Object.create(Object.getPrototypeOf(obj), allDesc);</span><br><span class="line"></span><br><span class="line">  //继承原型链</span><br><span class="line"></span><br><span class="line">  hash.set(obj, cloneObj);</span><br><span class="line"></span><br><span class="line">  for (let key of Reflect.ownKeys(obj)) &#123;</span><br><span class="line">    cloneObj[key] =</span><br><span class="line">      isComplexDataType(obj[key]) &amp;&amp; typeof obj[key] !== &quot;function&quot;</span><br><span class="line">        ? deepClone(obj[key], hash)</span><br><span class="line">        : obj[key];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return cloneObj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">8.字符串模板</span><br><span class="line"></span><br><span class="line">function render(template, data) &#123;</span><br><span class="line">  const reg = /\&#123;\&#123;(\w+)\&#125;\&#125;/; // 模板字符串正则</span><br><span class="line">  if (reg.test(template)) &#123; // 判断模板里是否有模板字符串</span><br><span class="line">      const name = reg.exec(template)[1]; // 查找当前模板里第一个模板字符串的字段</span><br><span class="line">      template = template.replace(reg, data[name]); // 将第一个模板字符串渲染</span><br><span class="line">      return render(template, data); // 递归的渲染并返回渲染后的结构</span><br><span class="line">  &#125;</span><br><span class="line">  return template; // 如果模板没有模板字符串直接返回</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">9.防抖/节流</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//节流</span><br><span class="line">//leading 是否第一次执行</span><br><span class="line">//trailing 是否最后一次执行</span><br><span class="line">function throttle(fn, wait, options) &#123;</span><br><span class="line">  var timeout, result;</span><br><span class="line">  var previous = 0;</span><br><span class="line">  if (!options) options = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  var later = function () &#123;</span><br><span class="line">    previous = options.leading === false ? 0 : Date.now();</span><br><span class="line">    timeout = null;</span><br><span class="line">    result = fn.apply(null);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  var throttled = function () &#123;</span><br><span class="line">    var now = Date.now();</span><br><span class="line"></span><br><span class="line">    if (!previous &amp;&amp; options.leading === false) previous = now;</span><br><span class="line"></span><br><span class="line">    //计算剩余时间</span><br><span class="line">    var remaining = wait - (now - previous);</span><br><span class="line">    //立即执行</span><br><span class="line">    if (remaining &lt;= 0 || remaining &gt; wait) &#123;</span><br><span class="line">      //设置options中leading为false时 remaining=wait  不执行函数</span><br><span class="line">      if (timeout) &#123;</span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        timeout = null;</span><br><span class="line">      &#125;</span><br><span class="line">      previous = now;</span><br><span class="line">      result = fn.apply(null);</span><br><span class="line">    &#125;</span><br><span class="line">    //延迟执行</span><br><span class="line">    else if (!timeout &amp;&amp; options.trailing !== false) &#123;</span><br><span class="line">      timeout = setTimeout(later, remaining);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;;</span><br><span class="line">  return throttled;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//防抖</span><br><span class="line"></span><br><span class="line">function debounce(func, wait, immediate) &#123;</span><br><span class="line">  var timeout, result;</span><br><span class="line"></span><br><span class="line">  var later = function () &#123;</span><br><span class="line">    timeout = null;</span><br><span class="line">    result = func.apply(null);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  var debounced = function () &#123;</span><br><span class="line">    if (timeout) clearTimeout(timeout);</span><br><span class="line">    //立即执行</span><br><span class="line">    if (immediate) &#123;</span><br><span class="line">      //存在定时器时无法立即执行（通俗讲就是wait秒内该事件又触发了，需要再等wait秒才能触发）</span><br><span class="line">      var callNow = !timeout;</span><br><span class="line">      timeout = setTimeout(later, wait);</span><br><span class="line">      //不存在定时器，立即执行该事件</span><br><span class="line">      if (callNow) result = func.apply(null);</span><br><span class="line">    &#125;</span><br><span class="line">    //指定时间后执行</span><br><span class="line">    else &#123;</span><br><span class="line">      timeout = setTimeout(later, wait);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return debounced;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">10.柯里化</span><br><span class="line">//什么叫函数柯里化？其实就是将使用多个参数的函数转换成一系列使用一个参数的函数的技术。</span><br><span class="line">function curry(fn) &#123;</span><br><span class="line">  let func;</span><br><span class="line"></span><br><span class="line">  func = (...args) =&gt; &#123;</span><br><span class="line">    if (args.length === fn.length) return fn(...args);</span><br><span class="line">    else return (...arg) =&gt; func(...arg, ...args);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return func;</span><br><span class="line">&#125;</span><br><span class="line">11.偏函数</span><br><span class="line">//什么是偏函数？偏函数就是将一个 n 参的函数转换成固定 x 参的函数，剩余参数（n - x）将在下次调用全部传入。</span><br><span class="line"> function partial(fn, ...args) &#123;</span><br><span class="line">  return (...arg) =&gt; &#123;</span><br><span class="line">      return fn(...args, ...arg)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">12.instance</span><br><span class="line"></span><br><span class="line">function instanceOf(left, right) &#123;</span><br><span class="line">  let proto = left.__proto__;</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    if (proto === null) return false;</span><br><span class="line">    if (proto === right.prototype) &#123;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">    proto = proto.__proto__;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">13.sleep</span><br><span class="line">function sleep(time) &#123;</span><br><span class="line">  return new Promise((resolve) =&gt; setTimeout(resolve, time));</span><br><span class="line">&#125;</span><br><span class="line">async function testSleep() &#123;</span><br><span class="line">  console.log(1);</span><br><span class="line">  await sleep(2000);</span><br><span class="line">  console.log(2);</span><br><span class="line">&#125;</span><br><span class="line">testSleep();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">14.Object.create</span><br><span class="line">Object.create2 = function (proto, propertyObject = undefined) &#123;</span><br><span class="line">  if (typeof proto !== &quot;object&quot; &amp;&amp; typeof proto !== &quot;function&quot;) &#123;</span><br><span class="line">    throw new TypeError(&quot;Object prototype may only be an Object or null.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  if (propertyObject == null) &#123;</span><br><span class="line">    new TypeError(&quot;Cannot convert undefined or null to object&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  function F() &#123;&#125;</span><br><span class="line">  F.prototype = proto;</span><br><span class="line">  const obj = new F();</span><br><span class="line">  if (propertyObject != undefined) &#123;</span><br><span class="line">    Object.defineProperties(obj, propertyObject);</span><br><span class="line">  &#125;</span><br><span class="line">  if (proto === null) &#123;</span><br><span class="line">    // 创建一个没有原型对象的对象，Object.create(null)</span><br><span class="line">    obj.__proto__ = null;</span><br><span class="line">  &#125;</span><br><span class="line">  return obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/学习/">学习</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/学习/">学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网站/">网站</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/资源/">资源</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-optimize" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2021/08/01/optimize/" class="article-date">
      <time datetime="2021-07-31T16:00:00.000Z" itemprop="datePublished">2021-08-01</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/08/01/optimize/">前端性能优化</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="首屏"><a href="#首屏" class="headerlink" title="首屏"></a>首屏</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">懒加载</span><br><span class="line">以百度图片列表页为例，可视区域范围内的图片先请求加载，一般会根据不同手机机型估算一个最大数据，比如 ihone12 Pro 屏幕比较大， 4 行 8 条数据，我们就先请求 8 条数据，用来在可视区域展示，其他位置采用占位符填充，在滑动到目标区域位置后，才使用真实的图片填充。</span><br><span class="line">这样，通过使用懒加载，可以最大限度降低了数据接口传输阶段的时间。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">接口缓存</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">静态资源缓存</span><br><span class="line">资源长期不变的话，比如 1 年都不怎么变化，我们可以使用强缓存，如 Cache-Control 来实现。</span><br><span class="line">具体来说可以通过设置 Cache-Control:max-age=31536000，来让浏览器在一年内直接使用本地缓存文件，而不是向服务端发出请求。</span><br><span class="line">**如果资源本身随时会发生改动的，可以通过设置 Etag 实现协商缓存。</span><br><span class="line">**具体来说，在初次请求资源时，设置 Etag（比如使用资源的 md5 作为 Etag），并且返回 200 的状态码，之后请求时带上 If-none-match 字段，来询问服务器当前版本是否可用。</span><br><span class="line">如果服务端数据没有变化，会返回一个 304 的状态码给客户端，告诉客户端不需要请求数据，直接使用之前缓存的数据即可。</span><br><span class="line"></span><br><span class="line">离线化</span><br><span class="line">可以通过 Webpack 的 prerender-spa-plugin 来实现预渲染，进而实现离线化。</span><br><span class="line">// webpack.conf.js</span><br><span class="line"></span><br><span class="line">var path = require(&apos;path&apos;)</span><br><span class="line"></span><br><span class="line">var PrerenderSpaPlugin = require(&apos;prerender-spa-plugin&apos;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line"></span><br><span class="line">  // ...</span><br><span class="line"></span><br><span class="line">  plugins: [</span><br><span class="line"></span><br><span class="line">    new PrerenderSpaPlugin(</span><br><span class="line"></span><br><span class="line">      // 编译后的html需要存放的路径</span><br><span class="line"></span><br><span class="line">      path.join(__dirname, &apos;../dist&apos;),</span><br><span class="line"></span><br><span class="line">      // 列出哪些路由需要预渲染</span><br><span class="line"></span><br><span class="line">      [ &apos;/&apos;, &apos;/about&apos;, &apos;/contact&apos; ]</span><br><span class="line"></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">并行化</span><br><span class="line">并行化则是在请求通道上功夫，解决请求阻塞问题，进而减少首屏时间。借助于HTTP 2.0 的多路复用方案来解决。</span><br></pre></td></tr></table></figure>
<h2 id="白屏"><a href="#白屏" class="headerlink" title="白屏"></a>白屏</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">基于影响白屏时间长短的两个主要因素来解决——DNS 查询和首字符展示。</span><br><span class="line"></span><br><span class="line">DNS 查询优化</span><br><span class="line">前端侧，可以通过在页面中加入 dns-prefetch，在静态资源请求之前对域名进行解析，从而减少用户进入页面的等待时间。如下所示：</span><br><span class="line">&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot; /&gt;</span><br><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;https://s.google.com/&quot; &gt;</span><br><span class="line">其中第一行中的 x-dns-prefetch-control 表示开启 DNS 预解析功能，第二行 dns-prefetch 表示强制对 s.google.com 的域名做预解析。这样在 s.google.com 的资源请求开始前，DNS 解析完成，后续请求就不需要重复做解析了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">客户端侧呢？可以在启动 App 时，同步创建一个肉眼不可见的 WebView（例如 1*1 像素的 webview），将常用的静态资源路径写入这个 WebView 中，然后对它做域名解析并放入缓存中。</span><br><span class="line">这样后面需要使用 WebView 打开真正所需的页面时，由于已经做过域名解析了，客户端直接从缓存中获取即可。</span><br><span class="line"></span><br><span class="line">如果是端外页面，因为没在 App 里面，就没法使用 1*1 WebView 的策略了，我们可以使用 iframe ，也能达到类似效果。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">首字符展示优化</span><br><span class="line">使用骨架屏。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">卡顿治理</span><br><span class="line">如果问题出在前端，一般和以下两种情形有关：浏览器的主线程与合成线程调度不合理，以及计算耗时操作。</span><br><span class="line">一般来说，主线程主要负责运行 JavaScript，计算 CSS 样式，元素布局，然后交给合成线程，合成线程主要负责绘制。</span><br><span class="line">比如红包元素从 margin-left:-10px 渲染到 margin-left:0，主线程需要计算样式 margin-left:-9px，margin-left:-8px，一直到 margin-left:0，每一次主线程计算样式后，合成线程都需要绘制到 GPU 再渲染到屏幕上，来来回回需要进行 10 次主线程渲染，10 次合成线程渲染，这给浏览器造成很大压力，从而出现卡顿。</span><br><span class="line">如何解决呢？我们可以利用 transform 来做，比如 tranform:translate(-10px,0) 到 transform:translate(0,0)，主线程只需要进行一次tranform:translate(-10px,0) 到 transform:translate(0,0)，然后合成线程去一次将 -10px 转换到 0px。这样的话，总计 11 次计算，可以减少 9 步操作，假设一次 10ms，将减少 90ms。</span><br><span class="line">计算耗时操作</span><br><span class="line">空间换时间方面，比如你需要频繁增加删除很多 DOM 元素，这时候一定会很卡，在对 DOM 元素增删的过程中最好先在 DocumentFragment （DOM文档碎片）上操作，而不是直接在 DOM上操作。只在最后一步操作完成后，将所有 DocumentFragment 的变动更新到 DOM上，从而解决频繁更新 DOM 带来的卡顿问题。</span><br></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/学习/">学习</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/学习/">学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网站/">网站</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/资源/">资源</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-test" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2021/08/01/test/" class="article-date">
      <time datetime="2021-07-31T16:00:00.000Z" itemprop="datePublished">2021-08-01</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/08/01/test/">前端测试</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/学习/">学习</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/学习/">学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网站/">网站</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/资源/">资源</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-node" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2021/07/18/node/" class="article-date">
      <time datetime="2021-07-17T16:00:00.000Z" itemprop="datePublished">2021-07-18</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/07/18/node/">node学习</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="process"><a href="#process" class="headerlink" title="process"></a>process</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">process.argv  //运行参数</span><br><span class="line">process.uptime() 脚本运行时间</span><br><span class="line">process.memoryUsage //内存</span><br><span class="line">process.cpuUsage  //cpu</span><br></pre></td></tr></table></figure>
<h2 id="命令行配置"><a href="#命令行配置" class="headerlink" title="命令行配置"></a>命令行配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#! /usr/bin/env node</span><br></pre></td></tr></table></figure>
<h2 id="fs"><a href="#fs" class="headerlink" title="fs"></a>fs</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">fs.writeFile(&apos;data.txt&apos;,&apos;123&apos;,&#123;</span><br><span class="line">    mode:438,//可读可写不可执行</span><br><span class="line">    flag:&apos;r+&apos;,  //  r+:不会清除原文件内容   w+:会先清除原文件内容再写入</span><br><span class="line">    encoding:&apos;utf-8&apos;</span><br><span class="line">&#125;,(err)=&gt;&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">fs.appendFile 追加文件</span><br><span class="line"></span><br><span class="line">fs.copyFile 拷贝文件</span><br><span class="line"></span><br><span class="line">fs.watchFile 监听文件修改</span><br><span class="line"></span><br><span class="line">fs.watchFile(&apos;data.txt&apos;,&#123;</span><br><span class="line">interval:20 //每20ms监听一次</span><br><span class="line">&#125;,(curr,prev)=&gt;&#123;</span><br><span class="line">//curr.mtime 当前文件修改时间</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fs.unwatchFile 取消文件修改监听</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">大文件读写</span><br><span class="line"></span><br><span class="line">//read:将数据从磁盘文件写入到buffer中</span><br><span class="line">let buf=Buffer.alloc(10)</span><br><span class="line"></span><br><span class="line">fs.open(&apos;data.txt&apos;,&apos;r&apos;,(err,rfd)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">//rfd:文件标识</span><br><span class="line">//buf 当前缓冲区</span><br><span class="line">//offset 从buf的哪个位置开始执行写入</span><br><span class="line">//length 写入长度</span><br><span class="line">//position 从文件哪个位置开始读取</span><br><span class="line">fs.read(rfd,buf,1,4,0,(err,readBytes)=&gt;&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//write:将缓冲区内容写入到磁盘中</span><br><span class="line"> buf=Buffer.from(&apos;aaaaaaaddfgdsg&apos;)</span><br><span class="line"></span><br><span class="line">fs.open(&apos;b.txt&apos;,&apos;w&apos;,(err,wfd)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">fs.write(wfd,buf,1,4,0,(err,written,buffer)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">//written 写入字节数</span><br><span class="line">//buffer：数据源 buf=Buffer.from(&apos;aaaaaaaddfgdsg&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  fs.close(wrd)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------------------------------------------</span><br><span class="line"></span><br><span class="line">文件拷贝</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let buf=Buffer.alloc(10)</span><br><span class="line">const BUFFER_SIZE=buf.length</span><br><span class="line">let readOffset=0</span><br><span class="line"></span><br><span class="line">fs.open(&apos;a.txt&apos;,&apos;r&apos;,(err,rfd)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">fs.open(&apos;b.txt&apos;,&apos;w&apos;,(err,wfd)=&gt;&#123;</span><br><span class="line"> function next()&#123;</span><br><span class="line"> </span><br><span class="line"> fs.read(rfd,buf,0,BUFFER_SIZE,readOffset,(err,readBytes)=&gt;&#123;</span><br><span class="line">     if(!readBytes)&#123;</span><br><span class="line">	 </span><br><span class="line">	   fs.close(rfd,()=&gt;&#123;&#125;)</span><br><span class="line">	   fs.close(wfd,()=&gt;&#123;&#125;)</span><br><span class="line">	   </span><br><span class="line">	   return</span><br><span class="line">	 &#125;</span><br><span class="line">	 readOffset+= readBytes</span><br><span class="line">	 fs.write(wfd,buf,0,readBytes,(err,written)=&gt;&#123;</span><br><span class="line">	 </span><br><span class="line">	   next()</span><br><span class="line">	 &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  next()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">目录操作</span><br><span class="line"></span><br><span class="line">access:判断文件或目录是否具有操作权限</span><br><span class="line">stat:获取目录及文件信息</span><br><span class="line">mkdir:创建目录   &#123;recursive:true //递归创建&#125;</span><br><span class="line">rmdir:删除目录   &#123;recursive:true //递归删除&#125;</span><br><span class="line">readdir:读取目录内容</span><br><span class="line">unlink:删除指定文件</span><br></pre></td></tr></table></figure>
<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">CommonJS</span><br><span class="line">语言层面的规范，主要用于Node.js</span><br><span class="line">规定模块化分为引入、定义、标识符三部分</span><br><span class="line">Module在任意模块中可直接使用包含模块信息</span><br><span class="line">Require接受标识符，加载目标模块</span><br><span class="line">Exports与module.exports都能导出模块数据</span><br><span class="line">CommonJS定义模块加载时同步的，不适用于浏览器</span><br><span class="line"></span><br><span class="line">--------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">module属性</span><br><span class="line">任意js文件就是一个模块，可以直接使用module属性</span><br><span class="line">id:返回模块标识符，一般是一个绝对路径</span><br><span class="line">filename:返回文件模块的绝对路径</span><br><span class="line">loaded:返回布尔值，标识模块是否完成加载</span><br><span class="line">parent:返回对象存放调用当前模块的模块</span><br><span class="line">children:返回数组，存放当前模块调用的其他模块</span><br><span class="line">exports:返回当前模块需要暴露的内容</span><br><span class="line">paths:返回数组，存放不同目录下的node_modules位置(路径查找策略,逐层向上查找)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">模块加载流程</span><br><span class="line">路径分析：依据标识符确定模块位置(核心模块根据package.json文件查找入口)</span><br><span class="line">文件定位：确定目标模块中具体的文件及文件类型</span><br><span class="line">编译执行：采用对应的方式完成文件的编译执行</span><br><span class="line"></span><br><span class="line">js文件的编译执行</span><br><span class="line">使用fs模块同步读入目标文件内容</span><br><span class="line">对内容进行语法包装，生成可执行js函数</span><br><span class="line">调用函数时传入exports/module/require等属性值</span><br><span class="line"></span><br><span class="line">json文件编译执行</span><br><span class="line">将读取到的内容通过JSON.parse()进行解析</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">缓存优先原则</span><br><span class="line">使用路径作为索引进行模块缓存</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vm模块</span><br><span class="line"></span><br><span class="line">const fs=require(&apos;fs&apos;)</span><br><span class="line">const vm=require(&apos;vm&apos;)</span><br><span class="line">let content=fs.readFileSync(&apos;test.txt&apos;,&apos;utf-8&apos;)</span><br><span class="line"></span><br><span class="line">eval(content) //处于同一上下文,不是独立作用域</span><br><span class="line">new Function() //操作麻烦</span><br><span class="line"></span><br><span class="line">vm.runInThisContext(content)</span><br></pre></td></tr></table></figure>
<h2 id="事件环"><a href="#事件环" class="headerlink" title="事件环"></a>事件环</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">常见宏任务：setTimeout()/setInterval()/setImmediate()/点击和键盘事件/...</span><br><span class="line">常见微任务：promise.then()/promise.catch()/new MutationObserver()/process.nextTick()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------------</span><br><span class="line">node环境</span><br><span class="line">timers:执行setTimeout与setInterval回调</span><br><span class="line">pending callbacks:执行系统操作的回调，例如tcp、udp</span><br><span class="line">idle,prepare:只在系统内部调用</span><br><span class="line">poll:执行与I/O相关的回调,轮询等待新的链接和请求等事件。V8 引擎将 JS 代码解析并传入 Libuv 引擎后首先进入此阶段。如果此阶段任务队列已经执行完了，则进入 check 阶段执行 setImmediate 回调（如果有 setImmediate），或等待新的任务进来（如果没有 setImmediate）。在等待新的任务时，如果有 timers 计时到期，则会直接进入 timers 阶段。此阶段可能会阻塞等待。</span><br><span class="line">check:执行setImmediate中的回调</span><br><span class="line">close callbacks:执行close事件的回调</span><br><span class="line">----------------------------------</span><br><span class="line"></span><br><span class="line">Nodejs完整事件环</span><br><span class="line">执行同步代码，将不同任务添加至相应的队列</span><br><span class="line">所有同步代码执行完成后会去执行满足条件的微任务</span><br><span class="line">所有微任务代码执行完会执行timer队列中满足得宏任务</span><br><span class="line">timers中所有宏任务执行完成后就会依次切换队列（在完成队列切换之前会先清空微任务代码）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------------------------------------</span><br><span class="line"></span><br><span class="line">浏览器、node环境</span><br><span class="line">任务队列数不同</span><br><span class="line">微任务执行时机不同：二者都会在同步代码执行完毕后执行微任务、浏览器平台下每当一个宏任务执行完毕后就会清空微任务、node环境下在事件队列切换时会去清空微任务队列(新版node（NodeJS 11 ）与浏览器保持一致)</span><br><span class="line">微任务优先级：浏览器环境微任务存放于事件队列，先进先出、node环境中process.nextTick先于promise.then执行</span><br><span class="line"></span><br><span class="line">-------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">setTimeout(()=&gt;&#123;&#125;,0)  不稳定，会产生延时     // timers</span><br><span class="line">setImmediate(()=&gt;&#123;&#125;)                         // check</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fs.readFile(&apos;./test.js&apos;,()=&gt;&#123;     // poll</span><br><span class="line">setTimeout(()=&gt;&#123;&#125;,0)  </span><br><span class="line">setImmediate(()=&gt;&#123;&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">-------------------------------</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    console.log(&apos;timeout&apos;);</span><br><span class="line"></span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">Promise.resolve().then(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    console.error(&apos;promise&apos;)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">process.nextTick(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    console.error(&apos;nextTick&apos;)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 输出：nextTick、promise、timeout</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------------------</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  console.log(&apos;timeout&apos;);</span><br><span class="line"></span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">setImmediate(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  console.log(&apos;setImmediate&apos;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 输出：timeout、 setImmediate</span><br><span class="line"></span><br><span class="line">分析上面代码，第一轮循环后，分别将 setTimeout  和 setImmediate 加入了各自阶段的任务队列。</span><br><span class="line">第二轮循环首先进入timers 阶段，执行定时器队列回调，然后 pending callbacks和poll 阶段没有任务，</span><br><span class="line">因此进入check 阶段执行 setImmediate 回调。所以最后输出为“timeout”、“setImmediate”。</span><br><span class="line">当然这里还有种理论上的极端情况，就是第一轮循环结束后耗时很短，导致 setTimeout 的计时还没结束，此时第二轮循环则会先执行 setImmediate 回调。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------------------------------</span><br><span class="line">const fs = require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">fs.readFile(__filename, (data) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    console.log(&apos;readFile&apos;);</span><br><span class="line"></span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">        console.log(&apos;timeout&apos;);</span><br><span class="line"></span><br><span class="line">    &#125;, 0);</span><br><span class="line"></span><br><span class="line">    setImmediate(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">        console.log(&apos;setImmediate&apos;);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 输出：readFile、setImmediate、timeout</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如上面代码所示：</span><br><span class="line"></span><br><span class="line">第一轮循环没有需要执行的异步任务队列；</span><br><span class="line"></span><br><span class="line">第二轮循环 timers 等阶段都没有任务，只有 poll 阶段有 I/O 回调任务，即输出“readFile”；</span><br><span class="line"></span><br><span class="line">参考前面事件阶段的说明，接下来，poll 阶段会检测如果有 setImmediate 的任务队列则进入 check 阶段，否则再进行判断，如果有定时器任务回调，则回到 timers 阶段，所以应该进入 check 阶段执行 setImmediate，输出“setImmediate”；</span><br><span class="line"></span><br><span class="line">然后进入最后的 close callbacks 阶段，本次循环结束；</span><br><span class="line"></span><br><span class="line">最后进行第三轮循环，进入 timers 阶段，输出“timeout”。</span><br><span class="line"></span><br><span class="line">所以最终输出“setImmediate”在“timeout”之前。可见这两者的执行顺序与当前执行的阶段有关系。</span><br></pre></td></tr></table></figure>
<h2 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line">readable  可读流</span><br><span class="line">writeable 可写流</span><br><span class="line">duplex 双工流，可读可写</span><br><span class="line">transform 转换流，可读可写可转换</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------------------------------</span><br><span class="line"></span><br><span class="line">readable事件：当流中存在可读取数据时触发</span><br><span class="line">data事件：当流中数据传给消费者后触发</span><br><span class="line"></span><br><span class="line">const &#123;Readable&#125; = require(&apos;stream&apos;)</span><br><span class="line"></span><br><span class="line">// 模拟底层数据</span><br><span class="line">let source = [&apos;aa&apos;, &apos;bbb&apos;, &apos;ccc&apos;]</span><br><span class="line"></span><br><span class="line">// 自定义类继承 Readable</span><br><span class="line">class MyReadable extends Readable&#123;</span><br><span class="line">  constructor(source) &#123;</span><br><span class="line">    super()</span><br><span class="line">    this.source = source</span><br><span class="line">  &#125;</span><br><span class="line">  _read() &#123;</span><br><span class="line">    let data = this.source.shift() || null </span><br><span class="line">    this.push(data)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实例化</span><br><span class="line">let myReadable = new MyReadable(source)</span><br><span class="line"></span><br><span class="line">/* myReadable.on(&apos;readable&apos;, () =&gt; &#123;</span><br><span class="line">  let data = null </span><br><span class="line">  while((data = myReadable.read(2)) != null) &#123;</span><br><span class="line">    console.log(data.toString())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;) */</span><br><span class="line"></span><br><span class="line">myReadable.on(&apos;data&apos;, (chunk) =&gt; &#123;</span><br><span class="line">  console.log(chunk.toString())</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----------------------------------------------------</span><br><span class="line"></span><br><span class="line">const &#123;Writable&#125; = require(&apos;stream&apos;)</span><br><span class="line"></span><br><span class="line">class MyWriteable extends Writable&#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super()</span><br><span class="line">  &#125;</span><br><span class="line">  _write(chunk, en, done) &#123;</span><br><span class="line">    process.stdout.write(chunk.toString() + &apos;&lt;----&apos;)</span><br><span class="line">    process.nextTick(done)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myWriteable = new MyWriteable()</span><br><span class="line"></span><br><span class="line">myWriteable.write(&apos;aaa&apos;, &apos;utf-8&apos;, () =&gt; &#123;</span><br><span class="line">  console.log(&apos;end&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--------------------------------------------</span><br><span class="line"></span><br><span class="line">const fs = require(&apos;fs&apos;)</span><br><span class="line"></span><br><span class="line">let ws = fs.createWriteStream(&apos;test.txt&apos;, &#123;</span><br><span class="line">  highWaterMark: 3</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">let flag = ws.write(&apos;1&apos;)</span><br><span class="line">console.log(flag)</span><br><span class="line"></span><br><span class="line">flag = ws.write(&apos;2&apos;)</span><br><span class="line">console.log(flag)</span><br><span class="line"></span><br><span class="line">// 如果 flag 为 false 并不是说明当前数据不能被执行写入</span><br><span class="line">// </span><br><span class="line"></span><br><span class="line">ws.on(&apos;drain&apos;, () =&gt; &#123;</span><br><span class="line">  console.log(&apos;11&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第一次调用write方法时是将数据直接写入文件中</span><br><span class="line">第二次开始write方法将数据写入缓存当中</span><br><span class="line">生产速度和消费速度是不一样的，一般情况下生产速度要比消费速度快很多</span><br><span class="line">当flag为false之后并不意味着当前的数据不能被写入，我们应该告知生产者当前数据消费速度已经跟不上生产速度了，这个时候，一般我们会将可读流修改为暂停模式</span><br><span class="line">当数据生产者暂停之后，消费者会慢慢消化缓存中的数据直到可以再次被执行写入操作</span><br><span class="line">当缓冲区可以继续写入数据时，通过drain事件让生产者知道</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 需求：“呜呜呜呜” 写入指定的文件</span><br><span class="line"> * 01 一次性写入</span><br><span class="line"> * 02 分批写入</span><br><span class="line"> * 对比：</span><br><span class="line"> */</span><br><span class="line">let fs = require(&apos;fs&apos;)</span><br><span class="line"></span><br><span class="line">let ws = fs.createWriteStream(&apos;test.txt&apos;, &#123;</span><br><span class="line">  highWaterMark: 3</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// ws.write(&apos;呜呜呜呜&apos;)</span><br><span class="line">let source = &quot;呜呜呜呜&quot;.split(&apos;&apos;)</span><br><span class="line">let num = 0</span><br><span class="line">let flag = true</span><br><span class="line"></span><br><span class="line">function executeWrite () &#123;</span><br><span class="line">  flag = true</span><br><span class="line">  while(num !== 4 &amp;&amp; flag) &#123;</span><br><span class="line">    flag = ws.write(source[num])</span><br><span class="line">    num++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">executeWrite()</span><br><span class="line"></span><br><span class="line">ws.on(&apos;drain&apos;, () =&gt; &#123;</span><br><span class="line">  console.log(&apos;drain 执行了&apos;)</span><br><span class="line">  executeWrite()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------------------------------------------------------</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/学习/">学习</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/学习/">学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网站/">网站</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/资源/">资源</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-performance" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2021/05/01/performance/" class="article-date">
      <time datetime="2021-04-30T16:00:00.000Z" itemprop="datePublished">2021-05-01</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/05/01/performance/">performance</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="window-performance"><a href="#window-performance" class="headerlink" title="window.performance"></a>window.performance</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line">connectEnd	HTTP（TCP） 返回浏览器与服务器之间的连接建立时的时间戳。如果建立的是持久连接，则返回值等同于fetchStart属性的值。连接建立指的是所有握手和认证过程全部结束。</span><br><span class="line">connectStart	HTTP（TCP） 域名查询结束的时间戳。如果使用了持续连接(persistent connection)，或者这个信息存储到了缓存或者本地资源上，这个值将和 fetchStart一致。</span><br><span class="line">domComplete	当前文档解析完成，即Document.readyState 变为 &apos;complete&apos;且相对应的readystatechange 被触发时的时间戳</span><br><span class="line">domContentLoadedEventEnd	当所有需要立即执行的脚本已经被执行（不论执行顺序）时的时间戳。</span><br><span class="line">domContentLoadedEventStart	当解析器发送DOMContentLoaded 事件，即所有需要被执行的脚本已经被解析时的时间戳。</span><br><span class="line">domInteractive	当前网页DOM结构结束解析、开始加载内嵌资源时（即Document.readyState属性变为“interactive”、相应的readystatechange事件触发时）的时间戳。</span><br><span class="line">domLoading	当前网页DOM结构开始解析时（即Document.readyState属性变为“loading”、相应的 readystatechange事件触发时）的时间戳。</span><br><span class="line">domainLookupEnd	DNS 域名查询完成的时间。如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等</span><br><span class="line">domainLookupStart	DNS 域名查询开始的UNIX时间戳。如果使用了持续连接(persistent connection)，或者这个信息存储到了缓存或者本地资源上，这个值将和fetchStart一致。</span><br><span class="line">fetchStart	浏览器准备好使用HTTP请求来获取(fetch)文档的时间戳。这个时间点会在检查任何应用缓存之前。</span><br><span class="line">loadEventEnd	当load事件结束，即加载事件完成时的时间戳。如果这个事件还未被发送，或者尚未完成，它的值将会是0.</span><br><span class="line">loadEventStart	load事件被发送时的时间戳。如果这个事件还未被发送，它的值将会是0。</span><br><span class="line">navigationStart	同一个浏览器上一个页面卸载(unload)结束时的时间戳。如果没有上一个页面，这个值会和fetchStart相同。</span><br><span class="line">redirectEnd	最后一个HTTP重定向完成时（也就是说是HTTP响应的最后一个比特直接被收到的时间）的时间戳。如果没有重定向，或者重定向中的一个不同源，这个值会返回0.</span><br><span class="line">redirectStart	第一个HTTP重定向开始时的时间戳。如果没有重定向，或者重定向中的一个不同源，这个值会返回0。</span><br><span class="line">requestStart	返回浏览器向服务器发出HTTP请求时（或开始读取本地缓存时）的时间戳。</span><br><span class="line">responseEnd	返回浏览器从服务器收到（或从本地缓存读取，或从本地资源读取）最后一个字节时（如果在此之前HTTP连接已经关闭，则返回关闭时）的时间戳。</span><br><span class="line">responseStart	返回浏览器从服务器收到（或从本地缓存读取）第一个字节时的时间戳。如果传输层在开始请求之后失败并且连接被重开，该属性将会被数制成新的请求的相对应的发起时间</span><br><span class="line">secureConnectionStart	HTTPS 返回浏览器与服务器开始安全链接的握手时的时间戳。如果当前网页不要求安全连接，则返回0。</span><br><span class="line">unloadEventEnd	和 unloadEventStart 相对应，unload事件处理完成时的时间戳。如果没有上一个页面,这个值会返回0。</span><br><span class="line">unloadEventStart	上一个页面unload事件抛出时的时间戳。如果没有上一个页面，这个值会返回0。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 获取 performance 数据</span><br><span class="line">var performance = &#123;  </span><br><span class="line">    // memory 是非标准属性，只在 Chrome 有</span><br><span class="line">    //内存</span><br><span class="line">    memory: &#123;</span><br><span class="line">        usedJSHeapSize:  16100000, // JS 对象（包括V8引擎内部对象）占用的内存，一定小于 totalJSHeapSize</span><br><span class="line">        totalJSHeapSize: 35100000, // 可使用的内存</span><br><span class="line">        jsHeapSizeLimit: 793000000 // 内存大小限制</span><br><span class="line">    &#125;,</span><br><span class="line"> </span><br><span class="line">    navigation: &#123;</span><br><span class="line">        redirectCount: 0, // 如果有重定向的话，页面通过几次重定向跳转而来</span><br><span class="line">        type: 0           // 0   即 TYPE_NAVIGATENEXT 正常进入的页面（非刷新、非重定向等）</span><br><span class="line">                          // 1   即 TYPE_RELOAD       通过 window.location.reload() 刷新的页面</span><br><span class="line">                          // 2   即 TYPE_BACK_FORWARD 通过浏览器的前进后退按钮进入的页面（历史记录）</span><br><span class="line">                          // 255 即 TYPE_UNDEFINED    非以上方式进入的页面</span><br><span class="line">    &#125;,</span><br><span class="line"> </span><br><span class="line">    timing: &#123;</span><br><span class="line">        // 在同一个浏览器上下文中，前一个网页（与当前页面不一定同域）unload 的时间戳，如果无前一个网页 unload ，则与 fetchStart 值相等</span><br><span class="line">        navigationStart: 1441112691935,</span><br><span class="line"> </span><br><span class="line">        // 前一个网页（与当前页面同域）unload 的时间戳，如果无前一个网页 unload 或者前一个网页与当前页面不同域，则值为 0</span><br><span class="line">        unloadEventStart: 0,</span><br><span class="line"> </span><br><span class="line">        // 和 unloadEventStart 相对应，返回前一个网页 unload 事件绑定的回调函数执行完毕的时间戳</span><br><span class="line">        unloadEventEnd: 0,</span><br><span class="line"> </span><br><span class="line">        // 第一个 HTTP 重定向发生时的时间。有跳转且是同域名内的重定向才算，否则值为 0 </span><br><span class="line">        redirectStart: 0,</span><br><span class="line"> </span><br><span class="line">        // 最后一个 HTTP 重定向完成时的时间。有跳转且是同域名内部的重定向才算，否则值为 0 </span><br><span class="line">        redirectEnd: 0,</span><br><span class="line"> </span><br><span class="line">        // 浏览器准备好使用 HTTP 请求抓取文档的时间，这发生在检查本地缓存之前</span><br><span class="line">        fetchStart: 1441112692155,</span><br><span class="line"> </span><br><span class="line">        // DNS 域名查询开始的时间，如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等</span><br><span class="line">        domainLookupStart: 1441112692155,</span><br><span class="line"> </span><br><span class="line">        // DNS 域名查询完成的时间，如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等</span><br><span class="line">        domainLookupEnd: 1441112692155,</span><br><span class="line"> </span><br><span class="line">        // HTTP（TCP） 开始建立连接的时间，如果是持久连接，则与 fetchStart 值相等</span><br><span class="line">        // 注意如果在传输层发生了错误且重新建立连接，则这里显示的是新建立的连接开始的时间</span><br><span class="line">        connectStart: 1441112692155,</span><br><span class="line"> </span><br><span class="line">        // HTTP（TCP） 完成建立连接的时间（完成握手），如果是持久连接，则与 fetchStart 值相等</span><br><span class="line">        // 注意如果在传输层发生了错误且重新建立连接，则这里显示的是新建立的连接完成的时间</span><br><span class="line">        // 注意这里握手结束，包括安全连接建立完成、SOCKS 授权通过</span><br><span class="line">        connectEnd: 1441112692155,</span><br><span class="line"> </span><br><span class="line">        // HTTPS 连接开始的时间，如果不是安全连接，则值为 0</span><br><span class="line">        secureConnectionStart: 0,</span><br><span class="line"> </span><br><span class="line">        // HTTP 请求读取真实文档开始的时间（完成建立连接），包括从本地读取缓存</span><br><span class="line">        // 连接错误重连时，这里显示的也是新建立连接的时间</span><br><span class="line">        requestStart: 1441112692158,</span><br><span class="line"> </span><br><span class="line">        // HTTP 开始接收响应的时间（获取到第一个字节），包括从本地读取缓存</span><br><span class="line">        responseStart: 1441112692686,</span><br><span class="line"> </span><br><span class="line">        // HTTP 响应全部接收完成的时间（获取到最后一个字节），包括从本地读取缓存</span><br><span class="line">        responseEnd: 1441112692687,</span><br><span class="line"> </span><br><span class="line">        // 开始解析渲染 DOM 树的时间，此时 Document.readyState 变为 loading，并将抛出 readystatechange 相关事件</span><br><span class="line">        domLoading: 1441112692690,</span><br><span class="line"> </span><br><span class="line">        // 完成解析 DOM 树的时间，Document.readyState 变为 interactive，并将抛出 readystatechange 相关事件</span><br><span class="line">        // 注意只是 DOM 树解析完成，这时候并没有开始加载网页内的资源</span><br><span class="line">        domInteractive: 1441112693093,</span><br><span class="line"> </span><br><span class="line">        // DOM 解析完成后，网页内资源加载开始的时间</span><br><span class="line">        // 在 DOMContentLoaded 事件抛出前发生</span><br><span class="line">        domContentLoadedEventStart: 1441112693093,</span><br><span class="line"> </span><br><span class="line">        // DOM 解析完成后，网页内资源加载完成的时间（如 JS 脚本加载执行完毕）</span><br><span class="line">        domContentLoadedEventEnd: 1441112693101,</span><br><span class="line"> </span><br><span class="line">        // DOM 树解析完成，且资源也准备就绪的时间，Document.readyState 变为 complete，并将抛出 readystatechange 相关事件</span><br><span class="line">        domComplete: 1441112693214,</span><br><span class="line"> </span><br><span class="line">        // load 事件发送给文档，也即 load 回调函数开始执行的时间</span><br><span class="line">        // 注意如果没有绑定 load 事件，值为 0</span><br><span class="line">        loadEventStart: 1441112693214,</span><br><span class="line"> </span><br><span class="line">        // load 事件的回调函数执行完毕的时间</span><br><span class="line">        loadEventEnd: 1441112693215</span><br><span class="line"> </span><br><span class="line">        // 字母顺序</span><br><span class="line">        // connectEnd: 1441112692155,</span><br><span class="line">        // connectStart: 1441112692155,</span><br><span class="line">        // domComplete: 1441112693214,</span><br><span class="line">        // domContentLoadedEventEnd: 1441112693101,</span><br><span class="line">        // domContentLoadedEventStart: 1441112693093,</span><br><span class="line">        // domInteractive: 1441112693093,</span><br><span class="line">        // domLoading: 1441112692690,</span><br><span class="line">        // domainLookupEnd: 1441112692155,</span><br><span class="line">        // domainLookupStart: 1441112692155,</span><br><span class="line">        // fetchStart: 1441112692155,</span><br><span class="line">        // loadEventEnd: 1441112693215,</span><br><span class="line">        // loadEventStart: 1441112693214,</span><br><span class="line">        // navigationStart: 1441112691935,</span><br><span class="line">        // redirectEnd: 0,</span><br><span class="line">        // redirectStart: 0,</span><br><span class="line">        // requestStart: 1441112692158,</span><br><span class="line">        // responseEnd: 1441112692687,</span><br><span class="line">        // responseStart: 1441112692686,</span><br><span class="line">        // secureConnectionStart: 0,</span><br><span class="line">        // unloadEventEnd: 0,</span><br><span class="line">        // unloadEventStart: 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 计算加载时间</span><br><span class="line">function getPerformanceTiming() &#123;</span><br><span class="line">    var performance = window.performance;</span><br><span class="line">    if (!performance) &#123;</span><br><span class="line">        // 当前浏览器不支持</span><br><span class="line">        console.log(&apos;你的浏览器不支持 performance 接口&apos;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    var t = performance.timing;</span><br><span class="line">    var times = &#123;&#125;;</span><br><span class="line">    //【重要】页面加载完成的时间</span><br><span class="line">    //【原因】这几乎代表了用户等待页面可用的时间</span><br><span class="line">    times.loadPage = t.loadEventEnd - t.navigationStart;</span><br><span class="line">    //【重要】解析 DOM 树结构的时间</span><br><span class="line">    //【原因】反省下你的 DOM 树嵌套是不是太多了！</span><br><span class="line">    times.domReady = t.domComplete - t.responseEnd;</span><br><span class="line">    //【重要】重定向的时间</span><br><span class="line">    //【原因】拒绝重定向！比如，http://example.com/ 就不该写成 http://example.com</span><br><span class="line">    times.redirect = t.redirectEnd - t.redirectStart;</span><br><span class="line">    //【重要】DNS 查询时间</span><br><span class="line">    //【原因】DNS 预加载做了么？页面内是不是使用了太多不同的域名导致域名查询的时间太长？</span><br><span class="line">    // 可使用 HTML5 Prefetch 预查询 DNS ，见：[HTML5 prefetch](http://segmentfault.com/a/1190000000633364)            </span><br><span class="line">    times.lookupDomain = t.domainLookupEnd - t.domainLookupStart;</span><br><span class="line">    //【重要】读取页面第一个字节的时间</span><br><span class="line">    //【原因】这可以理解为用户拿到你的资源占用的时间，加异地机房了么，加CDN 处理了么？加带宽了么？加 CPU 运算速度了么？</span><br><span class="line">    // TTFB 即 Time To First Byte 的意思</span><br><span class="line">    // 维基百科：https://en.wikipedia.org/wiki/Time_To_First_Byte</span><br><span class="line">    times.ttfb = t.responseStart - t.navigationStart;</span><br><span class="line">    //【重要】内容加载完成的时间</span><br><span class="line">    //【原因】页面内容经过 gzip 压缩了么，静态资源 css/js 等压缩了么？</span><br><span class="line">    times.request = t.responseEnd - t.requestStart;</span><br><span class="line">    //【重要】执行 onload 回调函数的时间</span><br><span class="line">    //【原因】是否太多不必要的操作都放到 onload 回调函数里执行了，考虑过延迟加载、按需加载的策略么？</span><br><span class="line">    times.loadEvent = t.loadEventEnd - t.loadEventStart;</span><br><span class="line">    // DNS 缓存时间</span><br><span class="line">    times.appcache = t.domainLookupStart - t.fetchStart;</span><br><span class="line">    // 卸载页面的时间</span><br><span class="line">    times.unloadEvent = t.unloadEventEnd - t.unloadEventStart;</span><br><span class="line">    // TCP 建立连接完成握手的时间</span><br><span class="line">    times.connect = t.connectEnd - t.connectStart;</span><br><span class="line">    return times;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常见性能指标"><a href="#常见性能指标" class="headerlink" title="常见性能指标"></a>常见性能指标</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FP	页面首次绘制时间</span><br><span class="line">FCP	页面首次有内容绘制的时间</span><br><span class="line">FMP	页面首次有效绘制时间，FMP &gt;= FCP</span><br><span class="line">TTI	页面完全可交互时间</span><br><span class="line">FID	页面加载阶段，用户首次交互操作的延时时间</span><br><span class="line">MPFID	页面加载阶段，用户交互操作可能遇到的最大延时时间</span><br><span class="line">LOAD	页面完全加载的时间（load 事件发生的时间）</span><br></pre></td></tr></table></figure>
<h3 id="FP"><a href="#FP" class="headerlink" title="FP"></a>FP</h3><p>FP (First Paint)指标通常会反映页面的白屏时间，而白屏时间会反映当前 Web 页面的网络加载性能情况，当加载性能非常良好的情况下，白屏的时间就会越短，用户等待内容的时间就会越短，流失的概率就会降低。<br>该指标可以通过 performance.getEntriesByType(‘paint’) 方法获取 PerformancePaintTiming API 提供的打点信息，找到 name 为 first-paint 的对象，描述的即为 FP 的指标数据</p>
<h3 id="FCP"><a href="#FCP" class="headerlink" title="FCP"></a>FCP</h3><p>FCP (First Contentful Paint) 为首次有内容渲染的时间点，在性能统计指标中，从用户开始访问 Web 页面的时间点到 FCP 的时间点这段时间可以被视为无内容时间，一般 FCP &gt;= FP。<br>该指标可以通过 performance.getEntriesByType(‘paint’) 方法获取 PerformancePaintTiming API 提供的打点信息，找到 name 为 first-contentful-paint 的对象，描述的即为 FCP 的指标数据</p>
<h3 id="TTI"><a href="#TTI" class="headerlink" title="TTI"></a>TTI</h3><p>TTI（Time To Interactive），即从页面加载开始到页面处于完全可交互状态所花费的时间。页面处于完全可交互状态时，满足以下 3 个条件：</p>
<ol>
<li>页面已经显示有用内容。</li>
<li>页面上的可见元素关联的事件响应函数已经完成注册。</li>
<li>事件响应函数可以在事件发生后的 50ms 内开始执行。<br>window.performance.getEntriesByType(‘resource’)会返回当前页面加载的所有资源（js、css、img…）的各类性能指标，可用于静态资源性能数据采集。<br>主要类型有：script、link、img、css、xmlhttprequest、beacon、fetch、other。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">connectEnd	一个 DOMHighResTimeStamp，表示浏览器完成建立与服务器的连接以检索资源之后的时间。</span><br><span class="line">connectStart	一个 DOMHighResTimeStamp，表示浏览器开始建立与服务器的连接以检索资源之前的时间。</span><br><span class="line">decodedBodySize	一个 number，表示在删除任何应用的内容编码之后，从消息主体的请求（HTTP 或缓存）中接收到的大小（以八位字节为单位）。</span><br><span class="line">domainLookupEnd	一个 DOMHighResTimeStamp，表示浏览器完成资源的域名查找之后的时间。</span><br><span class="line">domainLookupStart	一个 DOMHighResTimeStamp，表示在浏览器立即开始资源的域名查找之前的时间</span><br><span class="line">duration	返回一个 timestamp，即 responseEnd 和 startTime 属性的差值。</span><br><span class="line">encodedBodySize	一个 number，表示在删除任何应用的内容编码之前，从有效内容主体的请求（HTTP 或缓存）中接收到的大小（以八位字节为单位）。</span><br><span class="line">entryType	返回 &quot;resource&quot;。</span><br><span class="line">fetchStart	一个 DOMHighResTimeStamp，表示浏览器即将开始获取资源之前的时间。</span><br><span class="line">initiatorType	一个 string，代表启动性能条目的资源的类型</span><br><span class="line">name	返回资源 URL。</span><br><span class="line">nextHopProtocol	一个 string，代表用于获取资源的网络协议，由 ALPN 协议 ID（RFC7301） 定义。</span><br><span class="line">redirectEnd	一个 DOMHighResTimeStamp，表示收到上一次重定向响应的发送最后一个字节时的时间。</span><br><span class="line">redirectStart	一个 DOMHighResTimeStamp 代表启动重定向的请求开始之前的时间。</span><br><span class="line">requestStart	一个 DOMHighResTimeStamp，表示浏览器开始向服务器请求资源之前的时间。</span><br><span class="line">responseEnd	一个 DOMHighResTimeStamp，表示在浏览器接收到资源的最后一个字节之后或在传输连接关闭之前（以先到者为准）的时间。</span><br><span class="line">responseStart	一个 DOMHighResTimeStamp，表示浏览器从服务器接收到响应的第一个字节后的时间。</span><br><span class="line">secureConnectionStart	一个 DOMHighResTimeStamp，表示浏览器即将开始握手过程以保护当前连接之前的时间。</span><br><span class="line">serverTiming	一个 PerformanceServerTiming 数组，包含服务器计时指标的 PerformanceServerTiming 条目。</span><br><span class="line">startTime	返回一个 timestamp，表示资源获取开始的时间。该值等效于 fetchStart。</span><br><span class="line">transferSize	一个 number 代表所获取资源的大小（以八位字节为单位）。该大小包括响应标头字段以及响应有效内容主体。</span><br><span class="line">workerStart	一个 DOMHighResTimeStamp， 如果服务 Worker 线程已经在运行，则返回在分派 FetchEvent 之前的时间戳，如果尚未运行，则返回在启动 Service Worker 线程之前的时间戳。如果服务 Worker 未拦截该资源，则该属性将始终返回 0。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="其他指标计算方式"><a href="#其他指标计算方式" class="headerlink" title="其他指标计算方式"></a>其他指标计算方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DNS查询	DNS 阶段耗时	domainLookupEnd - domainLookupStart</span><br><span class="line">TCP连接	TCP 阶段耗时	connectEnd - connectStart</span><br><span class="line">SSL建连	SSL 连接时间	connectEnd - secureConnectionStart</span><br><span class="line">首字节网络请求	首字节响应时间（ttfb）	responseStart - requestStart</span><br><span class="line">内容传输	内容传输，Response阶段耗时	responseEnd - responseStart</span><br><span class="line">DOM解析	Dom解析时间	domInteractive - responseEnd</span><br><span class="line">资源加载	资源加载	loadEventStart - domContentLoadedEventEnd</span><br><span class="line">首字节	首字节	responseStart - fetchStart</span><br><span class="line">DOM Ready	dom ready	domContentLoadedEventEnd - fetchStart</span><br><span class="line">redirect时间	重定向时间	redirectEnd - redirectStart</span><br><span class="line">DOM render	dom渲染耗时	domComplete - domLoading</span><br><span class="line">load	页面加载耗时	loadEventEnd - navigationStart</span><br><span class="line">unload	页面卸载耗时	unloadEventEnd - unloadEventStart</span><br><span class="line">请求耗时	请求耗时	responseEnd - requestStart</span><br><span class="line">白屏时间	白屏时间	domLoading - navigationStart</span><br></pre></td></tr></table></figure>
<h2 id="错误数据采集方案"><a href="#错误数据采集方案" class="headerlink" title="错误数据采集方案"></a>错误数据采集方案</h2><p>目前所能捕捉的错误有三种:</p>
<ol>
<li>资源加载错误，通过 addEventListener(‘error’, callback, true)在捕获阶段捕捉资源加载失败错误。</li>
<li>js 执行错误，通过 window.onerror捕捉 js 错误。<br>跨域的脚本会给出 “Script Error.” 提示，拿不到具体的错误信息和堆栈信息。此时需要在script标签增加crossorigin=”anonymous”属性，同时资源服务器需要增加CORS相关配置，比如Access-Control-Allow-Origin: *</li>
<li>promise 错误，通过 addEventListener(‘unhandledrejection’, callback)捕捉 promise 错误，但是没有发生错误的行数，列数等信息，只能手动抛出相关错误信息。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 在捕获阶段，捕获资源加载失败错误</span><br><span class="line">addEventListener(&apos;error&apos;, e =&gt; &#123;</span><br><span class="line">    const target = e.target</span><br><span class="line">    if (target != window) &#123;</span><br><span class="line">        monitor.errors.push(&#123;</span><br><span class="line">            type: target.localName,</span><br><span class="line">            url: target.src || target.href,</span><br><span class="line">            msg: (target.src || target.href) + &apos; is load error&apos;,</span><br><span class="line">            time: Date.now()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, true)</span><br><span class="line"></span><br><span class="line">// 监听 js 错误</span><br><span class="line">window.onerror = function(msg, url, row, col, error) &#123;</span><br><span class="line">    monitor.errors.push(&#123;</span><br><span class="line">        type: &apos;javascript&apos;,</span><br><span class="line">        row: row,</span><br><span class="line">        col: col,</span><br><span class="line">        msg: error &amp;&amp; error.stack? error.stack : msg,</span><br><span class="line">        url: url,</span><br><span class="line">        time: Date.now()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 监听 promise 错误 缺点是获取不到行数数据</span><br><span class="line">addEventListener(&apos;unhandledrejection&apos;, e =&gt; &#123;</span><br><span class="line">    monitor.errors.push(&#123;</span><br><span class="line">        type: &apos;promise&apos;,</span><br><span class="line">        msg: (e.reason &amp;&amp; e.reason.msg) || e.reason || &apos;&apos;,</span><br><span class="line">        time: Date.now()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="数据上报方案"><a href="#数据上报方案" class="headerlink" title="数据上报方案"></a>数据上报方案</h2><p>在这个场景中，需要考虑两个问题：</p>
<ol>
<li>如果数据上报接口与业务系统使用同一域名，浏览器对请求并发量有限制，所以存在网络资源竞争的可能性。</li>
<li>浏览器通常在页面卸载时会忽略异步ajax请求，如果需要必须进行数据请求，一般在unload或者beforeunload事件中创建同步ajax请求，以此延迟页面卸载。从用户侧角度，就是页面跳转变慢。</li>
</ol>
<ul>
<li>Beacon 接口用来调度向 Web 服务器发送的异步非阻塞请求。</li>
</ul>
<ol>
<li>Beacon 请求使用 HTTP POST方法，并且不需要有响应。</li>
<li>Beacon 请求能确保在页面触发 unload 之前完成初始化。 通俗的讲就是，Beacon可将数据异步发送至服务端，且能够保证在页面卸载完成前发送请求（解决ajax页面卸载会终止请求的问题）。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">navigator.sendBeacon(url, data);</span><br><span class="line">其中 data 参数是可选的，它的类型可以为 ArrayBufferView, Blob, DOMString 或者 FormData。如果浏览器成功地将 beacon 请求加入到待发送的队列里，这个方法将会返回 true ，否则将会返回 false</span><br><span class="line"></span><br><span class="line">使用Beacon时需要后台需要使用post方法接收参数，考虑到跨域问题，后台还需要改造接口配置CORS。同时请求头必须满足CORS-safelisted request-header，其中content-type的类型必须为application/x-www-form-urlencoded, multipart/form-data, 或者text/plain。</span><br><span class="line"></span><br><span class="line">type ContentType = &apos;application/x-www-form-urlencoded&apos; | &apos;multipart/form-data&apos; | &apos;text/plain&apos;;</span><br><span class="line"></span><br><span class="line">const serilizeParams = (params: object) =&gt; &#123;</span><br><span class="line">    return window.btoa(JSON.stringify(params))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function sendBeacon(url: string, params: object) &#123;</span><br><span class="line">  const formData = new FormData()</span><br><span class="line">  formData.append(&apos;params&apos;, serilizeParams(params))</span><br><span class="line">  navigator.sendBeacon(url, formData)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sendBeacon的兼容性问题是不可避免的，不过可以充分利用大部分浏览器会在页面卸载前完成图片的加载的特性，通过在页面添加img的方式上报数据。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function sendImage(url: string, params: object) &#123;</span><br><span class="line">  const img = new Image()</span><br><span class="line"></span><br><span class="line">  img.style.display = &apos;none&apos;</span><br><span class="line"></span><br><span class="line">  const removeImage = function() &#123;</span><br><span class="line">    img.parentNode.removeChild(img)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  img.onload = removeImage</span><br><span class="line">  img.onerror = removeImage</span><br><span class="line"></span><br><span class="line">  img.src = `$&#123;url&#125;?params=$&#123;serilizeParams(params)&#125;`</span><br><span class="line"></span><br><span class="line">  document.body.appendChild(img)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">由于img图片为get请求方式，不同服务器针对uri的长度有限制，长度超过限制时会出现HTTP 414错误，所以还要注意上报频率，减少一次性上传的属性过多。</span><br></pre></td></tr></table></figure>
</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/前端/">前端</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/">js</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-http" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2021/04/25/http/" class="article-date">
      <time datetime="2021-04-24T16:00:00.000Z" itemprop="datePublished">2021-04-25</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/04/25/http/">http协议</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="时势与英雄：HTTP的前世今生"><a href="#时势与英雄：HTTP的前世今生" class="headerlink" title="时势与英雄：HTTP的前世今生"></a>时势与英雄：HTTP的前世今生</h2><h3 id="创世纪"><a href="#创世纪" class="headerlink" title="创世纪"></a>创世纪</h3><ul>
<li>URI：即统一资源标识符，作为互联网上资源的唯一身份；</li>
<li>HTML：即超文本标记语言，描述超文本文档；</li>
<li>HTTP：即超文本传输协议，用来传输超文本。</li>
<li>这三项技术在如今的我们看来已经是稀松平常，但在当时却是了不得的大发明。基于它们，就可以把超文本系统完美地运行在互联网上，让各地的人们能够自由地共享信息，蒂姆把这个系统称为“万维网”（World Wide Web），也就是我们现在所熟知的 Web。所以在这一年，我们的英雄“HTTP”诞生了，从此开始了它伟大的征途。<h3 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP/0.9"></a>HTTP/0.9</h3></li>
<li>20 世纪 90 年代初期的互联网世界非常简陋，计算机处理能力低，存储容量小，网速很慢，还是一片“信息荒漠”。网络上绝大多数的资源都是纯文本，很多通信协议也都使用纯文本，所以 HTTP 的设计也不可避免地受到了时代的限制。</li>
<li>最初设想的系统里的文档都是只读的，所以只允许用“GET”动作从服务器上获取 HTML 文档，并且在响应请求之后立即关闭连接，功能非常有限。<h3 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP/1.0"></a>HTTP/1.0</h3></li>
<li>HTTP/1.0 版本在 1996 年正式发布。它在多方面增强了 0.9 版，形式上已经和我们现在的 HTTP 差别不大了，例如：</li>
</ul>
<ol>
<li>增加了 HEAD、POST 等新方法；</li>
<li>增加了响应状态码，标记可能的错误原因；</li>
<li>引入了协议版本号概念；</li>
<li>引入了 HTTP Header（头部）的概念，让 HTTP 处理请求和响应更加灵活；</li>
<li>传输的数据不再仅限于文本。</li>
</ol>
<ul>
<li>TTP/1.0 的发布对于当时正在蓬勃发展的互联网来说并没有太大的实际意义，各方势力仍然按照自己的意图继续在市场上奋力拼杀。<h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h3></li>
<li>1995 年，网景的 Netscape Navigator 和微软的 Internet Explorer 开始了著名的“浏览器大战”，都希望在互联网上占据主导地位。这场战争的结果你一定早就知道了，最终微软的 IE 取得了决定性的胜利，而网景则“败走麦城”（但后来却凭借 Mozilla Firefox 又扳回一局）。</li>
<li>1999 年，HTTP/1.1 发布了 RFC 文档，编号为 2616，正式确立了延续十余年的传奇。从版本号我们就可以看到，HTTP/1.1 是对 HTTP/1.0 的小幅度修正。但一个重要的区别是：它是一个“正式的标准”，而不是一份可有可无的“参考文档”。这意味着今后互联网上所有的浏览器、服务器、网关、代理等等，只要用到 HTTP 协议，就必须严格遵守这个标准，相当于是互联网世界的一个“立法”。</li>
<li>HTTP/1.1 主要的变更点有：</li>
</ul>
<ol>
<li>增加了 PUT、DELETE 等新的方法；</li>
<li>增加了缓存管理和控制；</li>
<li>明确了连接管理，允许持久连接；</li>
<li>允许响应数据分块（chunked），利于传输大文件；</li>
<li>强制要求 Host 头，让互联网主机托管成为可能。<h3 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h3></li>
</ol>
<ul>
<li>互联网标准化组织以 SPDY 为基础开始制定新版本的 HTTP 协议，最终在 2015 年发布了 HTTP/2，RFC 编号 7540。</li>
<li>HTTP/2 的制定充分考虑了现今互联网的现状：宽带、移动、不安全，在高度兼容 HTTP/1.1 的同时在性能改善方面做了很大努力，主要的特点有：</li>
</ul>
<ol>
<li>二进制协议，不再是纯文本；</li>
<li>可发起多个请求，废弃了 1.1 里的管道；</li>
<li>使用专用算法压缩头部，减少数据传输量；</li>
<li>允许服务器主动向客户端推送数据；</li>
<li>增强了安全性，“事实上”要求加密通信。<h3 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP/3"></a>HTTP/3</h3></li>
</ol>
<ul>
<li>2018 年，互联网标准化组织 IETF 提议将“HTTP over QUIC”更名为“HTTP/3”并获得批准，HTTP/3 正式进入了标准化制订阶段，也许两三年后就会正式发布，到时候我们很可能会跳过 HTTP/2 直接进入 HTTP/3。</li>
</ul>
<h2 id="HTTP是什么？HTTP又不是什么？"><a href="#HTTP是什么？HTTP又不是什么？" class="headerlink" title="HTTP是什么？HTTP又不是什么？"></a>HTTP是什么？HTTP又不是什么？</h2><ul>
<li>HTTP 是一个用在计算机世界里的协议，它确立了一种计算机之间交流通信的规范，以及相关的各种控制和错误处理方式。</li>
<li>HTTP 专门用来在两点之间传输数据，不能用于广播、寻址或路由</li>
<li>HTTP 传输的是文字、图片、音频、视频等超文本数据。</li>
<li>HTTP 是构建互联网的重要基础技术，它没有实体，依赖许多其他的技术来实现，但同时许多技术也都依赖于它。</li>
</ul>
<h2 id="HTTP世界全览（上）：与HTTP相关的各种概念"><a href="#HTTP世界全览（上）：与HTTP相关的各种概念" class="headerlink" title="HTTP世界全览（上）：与HTTP相关的各种概念"></a>HTTP世界全览（上）：与HTTP相关的各种概念</h2><h3 id="网络世界"><a href="#网络世界" class="headerlink" title="网络世界"></a>网络世界</h3><ul>
<li>互联网的正式名称是 Internet，里面存储着无穷无尽的信息资源，我们通常所说的“上网”实际上访问的只是互联网的一个子集“万维网”（World Wide Web），它基于 HTTP 协议，传输 HTML 等超文本资源，能力也就被限制在 HTTP 协议之内。</li>
<li>互联网上还有许多万维网之外的资源，例如常用的电子邮件、BT 和 Magnet 点对点下载、FTP 文件下载、SSH 安全登录、各种即时通信服务等等，它们需要用各自的专有协议来访问。</li>
<li>不过由于 HTTP 协议非常灵活、易于扩展，而且“超文本”的表述能力很强，所以很多其他原本不属于 HTTP 的资源也可以“包装”成 HTTP 来访问，这就是我们为什么能够总看到各种“网页应用”——例如“微信网页版”“邮箱网页版”——的原因。<h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3></li>
<li>常见的浏览器有 Google 的 Chrome、Mozilla 的 Firefox、Apple 的 Safari、Microsoft 的 IE 和 Edge，还有小众的 Opera 以及国内的各种“换壳”的“极速”“安全”浏览器。</li>
<li>浏览器本质上是一个 HTTP 协议中的请求方，使用 HTTP 协议获取网络上的各种资源。当然，为了让我们更好地检索查看网页，它还集成了很多额外的功能。</li>
<li>在 HTTP 协议里，浏览器的角色被称为“User Agent”即“用户代理”，意思是作为访问者的“代理”来发起 HTTP 请求。不过在不引起混淆的情况下，我们通常都简单地称之为“客户端”。<h3 id="Web-服务器"><a href="#Web-服务器" class="headerlink" title="Web 服务器"></a>Web 服务器</h3></li>
<li>比起层出不穷的各种 Web 浏览器，Web 服务器就要少很多了，一只手的手指头就可以数得过来。</li>
</ul>
<ol>
<li>Apache 是老牌的服务器，到今天已经快 25 年了，功能相当完善，相关的资料很多，学习门槛低，是许多创业者建站的入门产品。</li>
<li>Nginx 是 Web 服务器里的后起之秀，特点是高性能、高稳定，且易于扩展。自 2004 年推出后就不断蚕食 Apache 的市场份额，在高流量的网站里更是不二之选。</li>
<li>此外，还有 Windows 上的 IIS、Java 的 Jetty/Tomcat 等，因为性能不是很高，所以在互联网上应用得较少。</li>
</ol>
<ul>
<li>当我们谈到“Web 服务器”时有两个层面的含义：硬件和软件。</li>
</ul>
<ol>
<li>硬件含义就是物理形式或“云”形式的机器，在大多数情况下它可能不是一台服务器，而是利用反向代理、负载均衡等技术组成的庞大集群。但从外界看来，它仍然表现为一台机器，但这个形象是“虚拟的”。</li>
<li>软件含义的 Web 服务器可能我们更为关心，它就是提供 Web 服务的应用程序，通常会运行在硬件含义的服务器上。它利用强大的硬件能力响应海量的客户端 HTTP 请求，处理磁盘上的网页、图片等静态文件，或者把请求转发给后面的 Tomcat、Node.js 等业务应用，返回动态的信息。<h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3></li>
</ol>
<ul>
<li>浏览器通常不会直接连到服务器，中间会经过“重重关卡”，其中的一个重要角色就叫做 CDN。</li>
<li>CDN，全称是“Content Delivery Network”，翻译过来就是“内容分发网络”。它应用了 HTTP 协议里的缓存和代理技术，代替源站响应客户端的请求。</li>
<li>简单来说，它可以缓存源站的数据，让浏览器的请求不用“千里迢迢”地到达源站服务器，直接在“半路”就可以获取响应。如果 CDN 的调度算法很优秀，更可以找到离用户最近的节点，大幅度缩短响应时间。</li>
<li>CDN 也是现在互联网中的一项重要基础设施，除了基本的网络加速外，还提供负载均衡、安全防护、边缘计算、跨运营商网络等功能，能够成倍地“放大”源站服务器的服务能力，很多云服务商都把 CDN 作为产品的一部分<h3 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h3></li>
<li>HTTP 协议并没有规定用户代理后面必须是“真正的人类”，它也完全可以是“机器人”，这些“机器人”的正式名称就叫做“爬虫”（Crawler），实际上是一种可以自动访问 Web 资源的应用程序。</li>
<li>爬虫绝大多数是由各大搜索引擎“放”出来的，抓取网页存入庞大的数据库，再建立关键字索引，这样我们才能够在搜索引擎中快速地搜索到互联网角落里的页面。</li>
<li>爬虫也有不好的一面，它会过度消耗网络资源，占用服务器和带宽，影响网站对真实数据的分析，甚至导致敏感信息泄漏。所以，又出现了“反爬虫”技术，通过各种手段来限制爬虫。其中一项就是“君子协定”robots.txt，约定哪些该爬，哪些不该爬。</li>
</ul>
<h3 id="HTML-WebService-WAF"><a href="#HTML-WebService-WAF" class="headerlink" title="HTML/WebService/WAF"></a>HTML/WebService/WAF</h3><ul>
<li>HTML 是 HTTP 协议传输的主要内容之一，它描述了超文本页面，用各种“标签”定义文字、图片等资源和排版布局，最终由浏览器“渲染”出可视化页面。</li>
<li>Web  Service 是一种由 W3C 定义的应用服务开发规范，使用 client-server 主从架构，通常使用 WSDL 定义服务接口，使用 HTTP 协议传输 XML 或 SOAP 消息，也就是说，它是一个基于 Web（HTTP）的服务架构技术，既可以运行在内网，也可以在适当保护后运行在外网。因为采用了 HTTP 协议传输数据，所以在 Web  Service 架构里服务器和客户端可以采用不同的操作系统或编程语言开发。例如服务器端用 Linux+Java，客户端用 Windows+C#，具有跨平台跨语言的优点。</li>
<li>WAF 是近几年比较“火”的一个词，意思是“网络应用防火墙”。与硬件“防火墙”类似，它是应用层面的“防火墙”，专门检测 HTTP 流量，是防护 Web 应用的安全技术。WAF 通常位于 Web 服务器之前，可以阻止如 SQL 注入、跨站脚本等攻击，目前应用较多的一个开源项目是 ModSecurity，它能够完全集成进 Apache 或 Nginx。</li>
</ul>
<h2 id="HTTP世界全览（下）：与HTTP相关的各种协议"><a href="#HTTP世界全览（下）：与HTTP相关的各种协议" class="headerlink" title="HTTP世界全览（下）：与HTTP相关的各种协议"></a>HTTP世界全览（下）：与HTTP相关的各种协议</h2><h3 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h3><ul>
<li>TCP/IP 协议实际上是一系列网络通信协议的统称，其中最核心的两个协议是 TCP 和 IP，其他的还有 UDP、ICMP、ARP 等等，共同构成了一个复杂但有层次的协议栈。</li>
<li>这个协议栈有四层，最上层是“应用层”，最下层是“链接层”，TCP 和 IP 则在中间：TCP 属于“传输层”，IP 属于“网际层”。</li>
<li>IP 协议是“Internet Protocol”的缩写，主要目的是解决寻址和路由问题，以及如何在两点间传送数据包。IP 协议使用“IP 地址”的概念来定位互联网上的每一台计算机。</li>
<li>现在我们使用的 IP 协议大多数是 v4 版，地址是四个用“.”分隔的数字，例如“192.168.0.1”，总共有 2^32，大约 42 亿个可以分配的地址。看上去好像很多，但互联网的快速发展让地址的分配管理很快就“捉襟见肘”。所以，就又出现了 v6 版，使用 8 组“:”分隔的数字作为地址，容量扩大了很多，有 2^128 个，在未来的几十年里应该是足够用了。</li>
<li>TCP 协议是“Transmission Control Protocol”的缩写，意思是“传输控制协议”，它位于 IP 协议之上，基于 IP 协议提供可靠的、字节流形式的通信，是 HTTP 协议得以实现的基础。</li>
<li>“可靠”是指保证数据不丢失，“字节流”是指保证数据完整，所以在 TCP 协议的两端可以如同操作文件一样访问传输的数据，就像是读写在一个密闭的管道里“流动”的字节。</li>
<li>HTTP 是一个”传输协议”，但它不关心寻址、路由、数据完整性等传输细节，而要求这些工作都由下层来处理。因为互联网上最流行的是 TCP/IP 协议，而它刚好满足 HTTP 的要求，所以互联网上的 HTTP 协议就运行在了 TCP/IP 上，HTTP 也就可以更准确地称为“HTTP over TCP/IP”。<h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3></li>
<li>在 DNS 中，“域名”（Domain Name）又称为“主机名”（Host），为了更好地标记不同国家或组织的主机，让名字更好记，所以被设计成了一个有层次的结构。</li>
<li>域名用“.”分隔成多个单词，级别从左到右逐级升高，最右边的被称为“顶级域名”。对于顶级域名，可能你随口就能说出几个，例如表示商业公司的“com”、表示教育机构的“edu”，表示国家的“cn”“uk”等，买火车票时的域名还记得吗？是“<a href="http://www.12306.cn”。" target="_blank" rel="noopener">www.12306.cn”。</a></li>
<li>想要使用 TCP/IP 协议来通信仍然要使用 IP 地址，所以需要把域名做一个转换，“映射”到它的真实 IP，这就是所谓的“域名解析”。</li>
<li>目前全世界有 13 组根 DNS 服务器，下面再有许多的顶级 DNS、权威 DNS 和更小的本地 DNS，逐层递归地实现域名查询。<h3 id="URI-URL"><a href="#URI-URL" class="headerlink" title="URI/URL"></a>URI/URL</h3></li>
<li>URI（Uniform Resource Identifier），中文名称是 统一资源标识符，使用它就能够唯一地标记互联网上资源。</li>
<li>URI 另一个更常用的表现形式是 URL（Uniform Resource Locator）， 统一资源定位符，也就是我们俗称的“网址”，它实际上是 URI 的一个子集，不过因为这两者几乎是相同的，差异不大，所以通常不会做严格的区分。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">http://nginx.org/en/download.html</span><br><span class="line">URI 主要有三个基本的部分构成：</span><br><span class="line">1.协议名：即访问该资源应当使用的协议，在这里是“http”；</span><br><span class="line">2.主机名：即互联网上主机的标记，可以是域名或 IP 地址，在这里是“nginx.org”；</span><br><span class="line">3.路径：即资源在主机上的位置，使用“/”分隔多级目录，在这里是“/en/download.html”。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><ul>
<li>SSL/TLS，它是一个负责加密通信的安全协议，建立在 TCP/IP 之上，所以也是个可靠的传输协议，可以被用作 HTTP 的下层。</li>
<li>SSL 的全称是“Secure Socket Layer”，由网景公司发明，当发展到 3.0 时被标准化，改名为 TLS，即“Transport Layer Security”，但由于历史的原因还是有很多人称之为 SSL/TLS，或者直接简称为 SSL。</li>
<li>SSL 使用了许多密码学最先进的研究成果，综合了对称加密、非对称加密、摘要算法、数字签名、数字证书等技术，能够在不安全的环境中为通信的双方创建出一个秘密的、安全的传输通道，为 HTTP 套上一副坚固的盔甲。<h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3></li>
<li>代理（Proxy）是 HTTP 协议中请求方和应答方中间的一个环节，作为“中转站”，既可以转发客户端的请求，也可以转发服务器的应答。</li>
<li>代理有很多的种类，常见的有：</li>
</ul>
<ol>
<li>匿名代理：完全“隐匿”了被代理的机器，外界看到的只是代理服务器；</li>
<li>透明代理：顾名思义，它在传输过程中是“透明开放”的，外界既知道代理，也知道客户端；</li>
<li>正向代理：靠近客户端，代表客户端向服务器发送请求</li>
<li>反向代理：靠近服务器端，代表服务器响应客户端的请求；</li>
</ol>
<ul>
<li>CDN，实际上就是一种代理，它代替源站服务器响应客户端的请求，通常扮演着透明代理和反向代理的角色。</li>
<li>由于代理在传输过程中插入了一个“中间层”，所以可以在这个环节做很多有意思的事情，比如：</li>
</ul>
<ol>
<li>负载均衡：把访问请求均匀分散到多台机器，实现访问集群化；</li>
<li>内容缓存：暂存上下行的数据，减轻后端的压力；</li>
<li>安全防护：隐匿 IP, 使用 WAF 等工具抵御网络攻击，保护被代理的机器；</li>
<li>数据处理：提供压缩、加密等额外的功能。</li>
</ol>
<h2 id="常说的“四层”和“七层”到底是什么？“五层”“六层”哪去了？"><a href="#常说的“四层”和“七层”到底是什么？“五层”“六层”哪去了？" class="headerlink" title="常说的“四层”和“七层”到底是什么？“五层”“六层”哪去了？"></a>常说的“四层”和“七层”到底是什么？“五层”“六层”哪去了？</h2><h3 id="TCP-IP-网络分层模型"><a href="#TCP-IP-网络分层模型" class="headerlink" title="TCP/IP 网络分层模型"></a>TCP/IP 网络分层模型</h3><ul>
<li>TCP/IP 协议总共有四层：“从下往上”</li>
</ul>
<ol>
<li>第一层叫“链接层”（link layer），负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标记网络上的设备，所以有时候也叫 MAC 层。</li>
<li>第二层叫“网际层”或者“网络互连层”（internet layer），IP 协议就处在这一层。因为 IP 协议定义了“IP 地址”的概念，所以就可以在“链接层”的基础上，用 IP 地址取代 MAC 地址，把许许多多的局域网、广域网连接成一个虚拟的巨大网络，在这个网络里找设备时只要把 IP 地址再“翻译”成 MAC 地址就可以了。</li>
<li>第三层叫“传输层”（transport layer），这个层次协议的职责是保证数据在 IP 地址标记的两点之间“可靠”地传输，是 TCP 协议工作的层次，另外还有它的一个“小伙伴”UDP。<br>TCP 是一个有状态的协议，需要先与对方建立连接然后才能发送数据，而且保证数据不丢失不重复。<br>而 UDP 则比较简单，它无状态，不用事先建立连接就可以任意发送数据，但不保证数据一定会发到对方。<br>两个协议的另一个重要区别在于数据的形式。TCP 的数据是连续的“字节流”，有先后顺序，而 UDP 则是分散的小数据包，是顺序发，乱序收。</li>
<li>协议栈的第四层叫“应用层”（application layer），由于下面的三层把基础打得非常好，所以在这一层就“百花齐放”了，有各种面向具体应用的协议。例如 Telnet、SSH、FTP、SMTP 等等，当然还有我们的 HTTP。</li>
</ol>
<ul>
<li>MAC地址（英语：Media Access Control Address），直译为媒体存取控制位址，也称为局域网地址（LAN Address），MAC位址，以太网地址（Ethernet Address）或物理地址（Physical Address），它是一个用来确认网络设备位置的位址。在OSI模型中，第三层网络层负责IP地址，第二层数据链路层则负责MAC位址 。MAC地址用于在网络中唯一标示一个网卡，一台设备若有一或多个网卡，则每个网卡都需要并会有一个唯一的MAC地址 。</li>
</ul>
<h3 id="OSI-网络分层模型"><a href="#OSI-网络分层模型" class="headerlink" title="OSI 网络分层模型"></a>OSI 网络分层模型</h3><ul>
<li>OSI，全称是“开放式系统互联通信参考模型”（Open System Interconnection Reference Model）。</li>
<li>OSI 模型分成了七层，部分层次与 TCP/IP 很像，从下到上分别是：</li>
</ul>
<ol>
<li>第一层：物理层，网络的物理形式，例如电缆、光纤、网卡、集线器等等；</li>
<li>第二层：数据链路层，它基本相当于 TCP/IP 的链接层；</li>
<li>第三层：网络层，相当于 TCP/IP 里的网际层；</li>
<li>第四层：传输层，相当于 TCP/IP 里的传输层；</li>
<li>第五层：会话层，维护网络中的连接状态，即保持会话和同步；</li>
<li>第六层：表示层，把数据转换为合适、可理解的语法和语义；</li>
<li>第七层：应用层，面向具体的应用传输数据。<h3 id="两个分层模型的映射关系"><a href="#两个分层模型的映射关系" class="headerlink" title="两个分层模型的映射关系"></a>两个分层模型的映射关系</h3></li>
</ol>
<ul>
<li>OSI 在设计之初就参考了 TCP/IP 等多个协议，可以比较容易但不是很精确地实现对应关系。</li>
</ul>
<ol>
<li>第一层：物理层，TCP/IP 里无对应；</li>
<li>第二层：数据链路层，对应 TCP/IP 的链接层；</li>
<li>第三层：网络层，对应 TCP/IP 的网际层；</li>
<li>第四层：传输层，对应 TCP/IP 的传输层；</li>
<li>第五、六、七层：统一对应到 TCP/IP 的应用层。</li>
</ol>
<ul>
<li>OSI 的分层模型在四层以上分的太细，而 TCP/IP 实际应用时的会话管理、编码转换、压缩等和具体应用经常联系的很紧密，很难分开。例如，HTTP 协议就同时包含了连接管理和数据格式定义。</li>
<li>所谓的“四层负载均衡”就是指工作在传输层上，基于 TCP/IP 协议的特性，例如 IP 地址、端口号等实现对后端服务器的负载均衡。</li>
<li>所谓的“七层负载均衡”就是指工作在应用层上，看到的是 HTTP 协议，解析 HTTP 报文里的 URI、主机名、资源类型等数据，再用适当的策略转发给后端服务器。</li>
</ul>
<h3 id="TCP-IP-协议栈的工作方式"><a href="#TCP-IP-协议栈的工作方式" class="headerlink" title="TCP/IP 协议栈的工作方式"></a>TCP/IP 协议栈的工作方式</h3><ul>
<li>HTTP 协议的传输过程就是这样通过协议栈逐层向下，每一层都添加本层的专有数据，层层打包，然后通过下层发送出去。</li>
<li>接收数据则是相反的操作，从下往上穿过协议栈，逐层拆包，每层去掉本层的专有头，上层就会拿到自己的数据。</li>
<li>但下层的传输过程对于上层是完全“透明”的，上层也不需要关心下层的具体实现细节，所以就 HTTP 层次来看，它不管下层是不是 TCP/IP 协议，看到的只是一个可靠的传输链路，只要把数据加上自己的头，对方就能原样收到。</li>
</ul>
<h2 id="域名里有哪些门道？"><a href="#域名里有哪些门道？" class="headerlink" title="域名里有哪些门道？"></a>域名里有哪些门道？</h2><h3 id="域名的形式"><a href="#域名的形式" class="headerlink" title="域名的形式"></a>域名的形式</h3><ul>
<li>域名是一个有层次的结构，是一串用“.”分隔的多个单词，最右边的被称为“顶级域名”，然后是“二级域名”，层级关系向左依次降低。</li>
<li>域名不仅能够代替 IP 地址，还有许多其他的用途。在 Apache、Nginx 这样的 Web 服务器里，域名可以用来标识虚拟主机，决定由哪个虚拟主机来对外提供服务，比如在 Nginx 里就会使用“server_name”指令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;                       #监听80端口</span><br><span class="line">    server_name  time.diamonds.org;  #主机名是time.diamonds.org</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="域名的解析"><a href="#域名的解析" class="headerlink" title="域名的解析"></a>域名的解析</h3><ul>
<li>就像 IP 地址必须转换成 MAC 地址才能访问主机一样，域名也必须要转换成 IP 地址，这个过程就是“域名解析”。</li>
<li>DNS 的核心系统是一个三层的树状、分布式服务，基本对应域名的结构：</li>
</ul>
<ol>
<li>根域名服务器（Root DNS Server）：管理顶级域名服务器，返回“com”“net”“cn”等顶级域名服务器的 IP 地址；</li>
<li>顶级域名服务器（Top-level DNS Server）：管理各自域名下的权威域名服务器，比如 com 顶级域名服务器可以返回 apple.com 域名服务器的 IP 地址；</li>
<li>权威域名服务器（Authoritative DNS Server）：管理自己域名下主机的 IP 地址，比如 apple.com 权威域名服务器可以返回 <a href="http://www.apple.com" target="_blank" rel="noopener">www.apple.com</a> 的 IP 地址。</li>
</ol>
<ul>
<li>在这里根域名服务器是关键，它必须是众所周知的，否则下面的各级服务器就无从谈起了。目前全世界共有 13 组根域名服务器，又有数百台的镜像，保证一定能够被访问到。</li>
<li><p>有了这个系统以后，任何一个域名都可以在这个树形结构里从顶至下进行查询，就好像是把域名从右到左顺序走了一遍，最终就获得了域名对应的 IP 地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例如，你要访问“www.apple.com”，就要进行下面的三次查询：</span><br><span class="line">1. 访问根域名服务器，它会告诉你“com”顶级域名服务器的地址；</span><br><span class="line">2. 访问“com”顶级域名服务器，它再告诉你“apple.com”域名服务器的地址；</span><br><span class="line">3. 最后访问“apple.com”域名服务器，就得到了“www.apple.com”的地址。</span><br></pre></td></tr></table></figure>
</li>
<li><p>在核心 DNS 系统之外，还有两种手段用来减轻域名解析的压力，并且能够更快地获取结果，基本思路就是“缓存”。</p>
</li>
<li>首先，许多大公司、网络运行商都会建立自己的 DNS 服务器，作为用户 DNS 查询的代理，代替用户访问核心 DNS 系统。这些“野生”服务器被称为“非权威域名服务器”，可以缓存之前的查询结果，如果已经有了记录，就无需再向根服务器发起查询，直接返回对应的 IP 地址。</li>
<li>这些 DNS 服务器的数量要比核心系统的服务器多很多，而且大多部署在离用户很近的地方。比较知名的 DNS 有 Google 的“8.8.8.8”，Microsoft 的“4.2.2.1”，还有 CloudFlare 的“1.1.1.1”等等。</li>
<li>其次，操作系统里也会对 DNS 解析结果做缓存，如果你之前访问过“<a href="http://www.apple.com”，那么下一次在浏览器里再输入这个网址的时候就不会再跑到" target="_blank" rel="noopener">www.apple.com”，那么下一次在浏览器里再输入这个网址的时候就不会再跑到</a> DNS 那里去问了，直接在操作系统里就可以拿到 IP 地址。</li>
<li>另外，操作系统里还有一个特殊的“主机映射”文件，通常是一个可编辑的文本，在 Linux 里是“/etc/hosts”，在 Windows 里是“C:\WINDOWS\system32\drivers\etc\hosts”，如果操作系统在缓存里找不到 DNS 记录，就会找这个文件。</li>
<li>有了上面的“野生”DNS 服务器、操作系统缓存和 hosts 文件后，很多域名解析的工作就都不用“跋山涉水”了，直接在本地或本机就能解决，不仅方便了用户，也减轻了各级 DNS 服务器的压力，效率就大大提升了。</li>
</ul>
<h3 id="域名的“新玩法”"><a href="#域名的“新玩法”" class="headerlink" title="域名的“新玩法”"></a>域名的“新玩法”</h3><ul>
<li>第一种，也是最简单的，“重定向”。因为域名代替了 IP 地址，所以可以让对外服务的域名不变，而主机的 IP 地址任意变动。当主机有情况需要下线、迁移时，可以更改 DNS 记录，让域名指向其他的机器。</li>
<li>第二种，因为域名是一个名字空间，所以可以使用 bind9 等开源软件搭建一个在内部使用的 DNS，作为名字服务器。这样我们开发的各种内部服务就都用域名来标记，比如数据库服务都用域名“mysql.inner.app”，商品服务都用“goods.inner.app”，发起网络通信时也就不必再使用写死的 IP 地址了，可以直接用域名，而且这种方式也兼具了第一种“玩法”的优势。</li>
<li>第三种“玩法”包含了前两种，也就是基于域名实现的负载均衡。这种“玩法”也有两种方式，两种方式可以混用。</li>
</ul>
<ol>
<li>第一种方式，因为域名解析可以返回多个 IP 地址，所以一个域名可以对应多台主机，客户端收到多个 IP 地址后，就可以自己使用轮询算法依次向服务器发起请求，实现负载均衡。</li>
<li>第二种方式，域名解析可以配置内部的策略，返回离客户端最近的主机，或者返回当前服务质量最好的主机，这样在 DNS 端把请求分发到不同的服务器，实现负载均衡。</li>
</ol>
<ul>
<li>不怀好意的 DNS</li>
</ul>
<ol>
<li>“域名屏蔽”，对域名直接不解析，返回错误，让你无法拿到 IP 地址，也就无法访问网站；</li>
<li>“域名劫持”，也叫“域名污染”，你要访问 A 网站，但 DNS 给了你 B 网站。</li>
</ol>
<h2 id="键入网址再按下回车，后面究竟发生了什么？"><a href="#键入网址再按下回车，后面究竟发生了什么？" class="headerlink" title="键入网址再按下回车，后面究竟发生了什么？"></a>键入网址再按下回车，后面究竟发生了什么？</h2><p>###使用 IP 地址访问 Web 服务器</p>
<ul>
<li>在 Chrome 浏览器的地址栏里输入“<a href="http://127.0.0.1/”，再按下回车键" target="_blank" rel="noopener">http://127.0.0.1/”，再按下回车键</a></li>
</ul>
<ol>
<li>因为我们在地址栏里直接输入了 IP 地址“127.0.0.1”，而 Web 服务器的默认端口是 80，所以浏览器就要依照 TCP 协议的规范，使用“三次握手”建立与 Web 服务器的连接。</li>
<li>经过 SYN、SYN/ACK、ACK 的三个包之后，浏览器与服务器的 TCP 连接就建立起来了。</li>
<li>有了可靠的 TCP 连接通道后，HTTP 协议就可以开始工作了。于是，浏览器按照 HTTP 协议规定的格式，通过 TCP 发送了一个“GET / HTTP/1.1”请求报文</li>
<li>随后，Web 服务器回复了第五个包，在 TCP 协议层面确认：“刚才的报文我已经收到了”，不过这个 TCP 包 HTTP 协议是看不见的。</li>
<li>Web 服务器收到报文后在内部就要处理这个请求。同样也是依据 HTTP 协议的规定，解析报文，看看浏览器发送这个请求想要干什么。</li>
<li>它一看，原来是要求获取根目录下的默认文件，好吧，那我就从磁盘上把那个文件全读出来，再拼成符合 HTTP 格式的报文，发回去吧。</li>
<li>同样的，浏览器也要给服务器回复一个 TCP 的 ACK 确认，“你的响应报文收到了，多谢”，即第七个包。</li>
<li>这时浏览器就收到了响应数据，但里面是什么呢？所以也要解析报文。一看，服务器给我的是个 HTML 文件，好，那我就调用排版引擎、JavaScript 引擎等等处理一下，然后在浏览器窗口里展现出了欢迎页面。</li>
<li>这之后还有两个来回，共四个包，重复了相同的步骤。这是浏览器自动请求了作为网站图标的“favicon.ico”文件，与我们输入的网址无关。</li>
<li>至此，“键入网址再按下回车”的全过程就结束了。</li>
</ol>
<ul>
<li>简要叙述一下这次最简单的浏览器 HTTP 请求过程：</li>
</ul>
<ol>
<li>浏览器从地址栏的输入中获得服务器的 IP 地址和端口号；</li>
<li>浏览器用 TCP 的三次握手与服务器建立连接；</li>
<li>浏览器向服务器发送拼好的报文；</li>
<li>服务器收到报文后处理请求，同样拼好报文再发给浏览器；</li>
<li>浏览器解析报文，渲染输出页面。</li>
</ol>
<h3 id="使用域名访问-Web-服务器"><a href="#使用域名访问-Web-服务器" class="headerlink" title="使用域名访问 Web 服务器"></a>使用域名访问 Web 服务器</h3><ul>
<li>在域名解析的过程中会有多级的缓存，浏览器首先看一下自己的缓存里有没有，如果没有就向操作系统的缓存要，还没有就检查本机域名解析文件 hosts，</li>
<li>DNS 解析可能会给出 CDN 服务器的 IP 地址，这样你拿到的就会是 CDN 服务器而不是目标网站的实际地址。</li>
<li>因为 CDN 会缓存网站的大部分资源，比如图片、CSS 样式表，所以有的 HTTP 请求就不需要再发到 Apple，CDN 就可以直接响应你的请求，把数据发给你。</li>
<li>目标网站的服务器对外表现的是一个 IP 地址，但为了能够扛住高并发，在内部也是一套复杂的架构。通常在入口是负载均衡设备，例如四层的 LVS 或者七层的 Nginx，在后面是许多的服务器，构成一个更强更稳定的集群。</li>
<li>负载均衡设备会先访问系统里的缓存服务器，通常有 memory 级缓存 Redis 和 disk 级缓存 Varnish，它们的作用与 CDN 类似，不过是工作在内部网络里，把最频繁访问的数据缓存几秒钟或几分钟，减轻后端应用服务器的压力。</li>
<li>如果缓存服务器里也没有，那么负载均衡设备就要把请求转发给应用服务器了。这里就是各种开发框架大显神通的地方了，例如 Java 的 Tomcat/Netty/Jetty，Python 的 Django，还有 PHP、Node.js、Golang 等等。它们又会再访问后面的 MySQL、PostgreSQL、MongoDB 等数据库服务，实现用户登录、商品查询、购物下单、扣款支付等业务操作，然后把执行的结果返回给负载均衡设备，同时也可能给缓存服务器里也放一份。</li>
<li>应用服务器的输出到了负载均衡设备这里，请求的处理就算是完成了，就要按照原路再走回去，还是要经过许多的路由器、网关、代理。如果这个资源允许缓存，那么经过 CDN 的时候它也会做缓存，这样下次同样的请求就不会到达源站了。</li>
<li>最后网站的响应数据回到了你的设备，它可能是 HTML、JSON、图片或者其他格式的数据，需要由浏览器解析处理才能显示出来，如果数据里面还有超链接，指向别的资源，那么就又要重走一遍整个流程，直到所有的资源都下载完。</li>
</ul>
<h2 id="HTTP报文是什么样子的？"><a href="#HTTP报文是什么样子的？" class="headerlink" title="HTTP报文是什么样子的？"></a>HTTP报文是什么样子的？</h2><ul>
<li>HTTP 的工作模式是非常简单的，由于 TCP/IP 协议负责底层的具体传输工作，HTTP 协议基本上不用在这方面操心太多。单从这一点上来看，所谓的“超文本传输协议”其实并不怎么管“传输”的事情，有点“名不副实”。</li>
<li>HTTP 协议的核心部分是什么呢？答案就是它传输的报文内容。</li>
<li>HTTP 协议在规范文档里详细定义了报文的格式，规定了组成部分，解析规则，还有处理策略，所以可以在 TCP/IP 层之上实现更灵活丰富的功能，例如连接控制，缓存管理、数据编码、内容协商等等。</li>
</ul>
<h3 id="报文结构"><a href="#报文结构" class="headerlink" title="报文结构"></a>报文结构</h3><ul>
<li>拿 TCP 报文来举例，它在实际要传输的数据之前附加了一个 20 字节的头部数据，存储 TCP 协议必须的额外信息，例如发送方的端口号、接收方的端口号、包序号、标志位等等。</li>
<li>有了这个附加的 TCP 头，数据包才能够正确传输，到了目的地后把头部去掉，就可以拿到真正的数据。</li>
<li>HTTP 协议也是与 TCP/UDP 类似，同样也需要在实际传输的数据前附加一些头数据，不过与 TCP/UDP 不同的是，它是一个“纯文本”的协议，所以头数据都是 ASCII 码的文本，可以很容易地用肉眼阅读，不用借助程序解析也能够看懂。</li>
<li>HTTP 协议的请求报文和响应报文的结构基本相同，由三大部分组成：</li>
</ul>
<ol>
<li>起始行（start line）：描述请求或响应的基本信息；</li>
<li>头部字段集合（header）：使用 key-value 形式更详细地说明报文；</li>
<li>消息正文（entity）：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据。</li>
</ol>
<ul>
<li>HTTP 协议规定报文必须有 header，但可以没有 body，而且在 header 之后必须要有一个“空行”，也就是“CRLF”，十六进制的“0D0A”。</li>
<li>虽然 HTTP 协议对 header 的大小没有做限制，但各个 Web 服务器都不允许过大的请求头，因为头部太大可能会占用大量的服务器资源，影响运行效率。<h3 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h3></li>
<li>它简要地描述了客户端想要如何操作服务器端的资源。</li>
<li>请求行由三部分构成：</li>
</ul>
<ol>
<li>请求方法：是一个动词，如 GET/POST，表示对资源的操作；</li>
<li>请求目标：通常是一个 URI，标记了请求方法要操作的资源；</li>
<li>版本号：表示报文使用的 HTTP 协议版本。</li>
</ol>
<ul>
<li>这三个部分通常使用空格（space）来分隔，最后要用 CRLF 换行表示结束。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line"></span><br><span class="line">在这个请求行里，“GET”是请求方法，“/”是请求目标，“HTTP/1.1”是版本号，</span><br><span class="line">把这三部分连起来，意思就是“服务器你好，我想获取网站根目录下的默认文件，</span><br><span class="line">我用的协议版本号是 1.1，请不要用 1.0 或者 2.0 回复我。”</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h3><ul>
<li>响应报文里的起始行，在这里它不叫“响应行”，而是叫“状态行”（status line），意思是服务器响应的状态。</li>
<li>比起请求行来说，状态行要简单一些，同样也是由三部分构成：</li>
</ul>
<ol>
<li>版本号：表示报文使用的 HTTP 协议版本；</li>
<li>状态码：一个三位数，用代码的形式表示处理的结果，比如 200 是成功，500 是服务器错误；</li>
<li>原因：作为数字状态码补充，是更详细的解释文字，帮助人理解原因。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">意思就是：“浏览器你好，我已经处理完了你的请求，这个报文使用的协议版本号是 1.1，状态码是 200，一切 OK。”</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HTTP/1.1 404 Not Found</span><br><span class="line">翻译成人话就是：“抱歉啊浏览器，刚才你的请求收到了，但我没找到你要的资源，错误代码是 404，接下来的事情你就看着办吧。”</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="头部字段"><a href="#头部字段" class="headerlink" title="头部字段"></a>头部字段</h3><ul>
<li>头部字段是 key-value 的形式，key 和 value 之间用“:”分隔，最后用 CRLF 换行表示字段结束。比如在“Host: 127.0.0.1”这一行里 key 就是“Host”，value 就是“127.0.0.1”。</li>
<li>HTTP 头字段非常灵活，不仅可以使用标准里的 Host、Connection 等已有头，也可以任意添加自定义头，这就给 HTTP 协议带来了无限的扩展可能。</li>
<li>不过使用头字段需要注意下面几点：</li>
</ul>
<ol>
<li>字段名不区分大小写，例如“Host”也可以写成“host”，但首字母大写的可读性更好；</li>
<li>字段名里不允许出现空格，可以使用连字符“-”，但不能使用下划线“_”。例如，“test-name”是合法的字段名，而“test name”“test_name”是不正确的字段名；</li>
<li>字段名后面必须紧接着“:”，不能有空格，而“:”后的字段值前可以有多个空格；</li>
<li>字段的顺序是没有意义的，可以任意排列不影响语义；</li>
<li>字段原则上不能重复，除非这个字段本身的语义允许，例如 Set-Cookie。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">GET /09-1 HTTP/1.1</span><br><span class="line">Host:   www.diamonds.com</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GET /09-1 HTTP/1.1</span><br><span class="line">Host : www.diamonds.com</span><br><span class="line"></span><br><span class="line">第一个可以正确获取服务器的响应报文，而第二个得到的会是一个“400 Bad Request”，表示请求报文格式有误，服务器无法正确处理：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HTTP/1.1 400 Bad Request</span><br><span class="line">Server: openresty/1.15.8.1</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="常用头字段"><a href="#常用头字段" class="headerlink" title="常用头字段"></a>常用头字段</h3><ul>
<li>HTTP 协议规定了非常多的头部字段，实现各种各样的功能，但基本上可以分为四大类：</li>
</ul>
<ol>
<li>通用字段：在请求头和响应头里都可以出现；</li>
<li>请求字段：仅能出现在请求头里，进一步说明请求信息或者额外的附加条件；</li>
<li>响应字段：仅能出现在响应头里，补充说明响应报文的信息；</li>
<li>实体字段：它实际上属于通用字段，但专门描述 body 的额外信息。</li>
</ol>
<ul>
<li>对 HTTP 报文的解析和处理实际上主要就是对头字段的处理，理解了头字段也就理解了 HTTP 报文。</li>
<li>Host 字段，它属于请求字段，只能出现在请求头里，它同时也是唯一一个 HTTP/1.1 规范里要求必须出现的字段，也就是说，如果请求头里没有 Host，那这就是一个错误的报文。Host 字段告诉服务器这个请求应该由哪个主机来处理，当一台计算机上托管了多个虚拟主机的时候，服务器端就需要用 Host 字段来选择，有点像是一个简单的“路由重定向”。例如我们的试验环境，在 127.0.0.1 上有三个虚拟主机：“<a href="http://www.diamonds.com”“www.metroid.net”和“origin.io”。那么当使用域名的方式访问时，就必须要用" target="_blank" rel="noopener">www.diamonds.com”“www.metroid.net”和“origin.io”。那么当使用域名的方式访问时，就必须要用</a> Host 字段来区分这三个 IP 相同但域名不同的网站，否则服务器就会找不到合适的虚拟主机，无法处理。</li>
<li>User-Agent 是请求字段，只出现在请求头里。它使用一个字符串来描述发起 HTTP 请求的客户端，服务器可以依据它来返回最合适此浏览器显示的页面。但由于历史的原因，User-Agent 非常混乱，每个浏览器都自称是“Mozilla”“Chrome”“Safari”，企图使用这个字段来互相“伪装”，导致 User-Agent 变得越来越长，最终变得毫无意义。不过有的比较“诚实”的爬虫会在 User-Agent 里用“spider”标明自己是爬虫，所以可以利用这个字段实现简单的反爬虫策略。</li>
<li>Date 字段是一个通用字段，但通常出现在响应头里，表示 HTTP 报文创建的时间，客户端可以使用这个时间再搭配其他字段决定缓存策略。</li>
<li>Server 字段是响应字段，只能出现在响应头里。它告诉客户端当前正在提供 Web 服务的软件名称和版本号，例如在我们的实验环境里它就是“Server: openresty/1.15.8.1”，即使用的是 OpenResty 1.15.8.1。Server 字段也不是必须要出现的，因为这会把服务器的一部分信息暴露给外界，如果这个版本恰好存在 bug，那么黑客就有可能利用 bug 攻陷服务器。所以，有的网站响应头里要么没有这个字段，要么就给出一个完全无关的描述信息。</li>
<li>实体字段里要说的一个是 Content-Length，它表示报文里 body 的长度，也就是请求头或响应头空行后面数据的长度。服务器看到这个字段，就知道了后续有多少数据，可以直接接收。如果没有这个字段，那么 body 就是不定长的，需要使用 chunked 方式分段传输。</li>
</ul>
<h2 id="应该如何理解请求方法？"><a href="#应该如何理解请求方法？" class="headerlink" title="应该如何理解请求方法？"></a>应该如何理解请求方法？</h2><h3 id="标准请求方法"><a href="#标准请求方法" class="headerlink" title="标准请求方法"></a>标准请求方法</h3><ul>
<li>它的实际含义就是客户端发出了一个“动作指令”，要求服务器端对 URI 定位的资源执行这个动作。</li>
<li>目前 HTTP/1.1 规定了八种方法，单词都必须是大写的形式，</li>
</ul>
<ol>
<li>GET：获取资源，可以理解为读取或者下载数据；</li>
<li>HEAD：获取资源的元信息；</li>
<li>POST：向资源提交数据，相当于写入或上传数据；</li>
<li>PUT：类似 POST；</li>
<li>DELETE：删除资源；</li>
<li>CONNECT：建立特殊的连接隧道；</li>
<li>OPTIONS：列出可对资源实行的方法；</li>
<li>TRACE：追踪请求 - 响应的传输路径。</li>
</ol>
<ul>
<li>服务器掌控着所有资源，也就有绝对的决策权力。它收到 HTTP 请求报文后，看到里面的请求方法，可以执行也可以拒绝，或者改变动作的含义，毕竟 HTTP 是一个“协议”，两边都要“商量着来”。</li>
<li>比如，你发起了一个 GET 请求，想获取“/orders”这个文件，但这个文件保密级别比较高，不是谁都能看的，服务器就可以有如下的几种响应方式：</li>
</ul>
<ol>
<li>假装这个文件不存在，直接返回一个 404 Not found 报文；</li>
<li>稍微友好一点，明确告诉你有这个文件，但不允许访问，返回一个 403 Forbidden；</li>
<li>再宽松一些，返回 405 Method Not Allowed，然后用 Allow 头告诉你可以用 HEAD 方法获取文件的元信息。<h3 id="GET-HEAD"><a href="#GET-HEAD" class="headerlink" title="GET/HEAD"></a>GET/HEAD</h3></li>
</ol>
<ul>
<li>GET 方法应该是 HTTP 协议里最知名的请求方法了，它的含义是请求从服务器获取资源，这个资源既可以是静态的文本、页面、图片、视频，也可以是由 PHP、Java 动态生成的页面或者其他格式的数据。GET 方法虽然基本动作比较简单，但搭配 URI 和其他头字段就能实现对资源更精细的操作。例如，在 URI 后使用“#”，就可以在获取页面后直接定位到某个标签所在的位置；使用 If-Modified-Since 字段就变成了“有条件的请求”，仅当资源被修改时才会执行获取动作；使用 Range 字段就是“范围请求”，只获取资源的一部分数据。</li>
<li>HEAD 方法与 GET 方法类似，也是请求从服务器获取资源，服务器的处理机制也是一样的，但服务器不会返回请求的实体数据，只会传回响应头，也就是资源的“元信息”。HEAD 方法可以看做是 GET 方法的一个“简化版”或者“轻量版”。因为它的响应头与 GET 完全相同，所以可以用在很多并不真正需要资源的场合，避免传输 body 数据的浪费。比如，想要检查一个文件是否存在，只要发个 HEAD 请求就可以了，没有必要用 GET 把整个文件都取下来。再比如，要检查文件是否有最新版本，同样也应该用 HEAD，服务器会在响应头里把文件的修改时间传回来。</li>
</ul>
<h3 id="POST-PUT"><a href="#POST-PUT" class="headerlink" title="POST/PUT"></a>POST/PUT</h3><ul>
<li>POST 也是一个经常用到的请求方法，PUT 的作用与 POST 类似，也可以向服务器提交数据，但与 POST 存在微妙的不同，通常 POST 表示的是“新建”“create”的含义，而 PUT 则是“修改”“update”的含义。<h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3></li>
<li>DELETE 方法指示服务器删除资源，因为这个动作危险性太大，所以通常服务器不会执行真正的删除操作，而是对资源做一个删除标记。当然，更多的时候服务器就直接不处理 DELETE 请求。</li>
<li>CONNECT 是一个比较特殊的方法，要求服务器为客户端和另一台远程服务器建立一条特殊的连接隧道，这时 Web 服务器在中间充当了代理的角色。</li>
<li>OPTIONS 方法要求服务器列出可对资源实行的操作方法，在响应头的 Allow 字段里返回。它的功能很有限，用处也不大，有的服务器（例如 Nginx）干脆就没有实现对它的支持。</li>
<li>TRACE 方法多用于对 HTTP 链路的测试或诊断，可以显示出请求 - 响应的传输路径。它的本意是好的，但存在漏洞，会泄漏网站的信息，所以 Web 服务器通常也是禁止使用。<h3 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h3></li>
<li>虽然 HTTP/1.1 里规定了八种请求方法，但它并没有限制我们只能用这八种方法，这也体现了 HTTP 协议良好的扩展性，我们可以任意添加请求动作，只要请求方和响应方都能理解就行。</li>
<li>例如著名的愚人节玩笑 RFC2324，它定义了协议 HTCPCP，即“超文本咖啡壶控制协议”，为 HTTP 协议增加了用来煮咖啡的 BREW 方法，要求添牛奶的 WHEN 方法。</li>
<li>此外，还有一些得到了实际应用的请求方法（WebDAV），例如 MKCOL、COPY、MOVE、LOCK、UNLOCK、PATCH 等。如果有合适的场景，你也可以把它们应用到自己的系统里，比如用 LOCK 方法锁定资源暂时不允许修改，或者使用 PATCH 方法给资源打个小补丁，部分更新数据。但因为这些方法是非标准的，所以需要为客户端和服务器编写额外的代码才能添加支持。<h3 id="安全与幂等"><a href="#安全与幂等" class="headerlink" title="安全与幂等"></a>安全与幂等</h3></li>
<li>在 HTTP 协议里，所谓的“安全”是指请求方法不会“破坏”服务器上的资源，即不会对服务器上的资源造成实质的修改。</li>
<li>按照这个定义，只有 GET 和 HEAD 方法是“安全”的，因为它们是“只读”操作，只要服务器不故意曲解请求方法的处理方式，无论 GET 和 HEAD 操作多少次，服务器上的数据都是“安全的”。而 POST/PUT/DELETE 操作会修改服务器上的资源，增加或删除数据，所以是“不安全”的。</li>
<li>所谓的“幂等”实际上是一个数学用语，被借用到了 HTTP 协议里，意思是多次执行相同的操作，结果也都是相同的，即多次“幂”后结果“相等”。</li>
<li>很显然，GET 和 HEAD 既是安全的也是幂等的，DELETE 可以多次删除同一个资源，效果都是“资源不存在”，所以也是幂等的。POST 和 PUT 的幂等性质就略费解一点。</li>
<li>按照 RFC 里的语义，POST 是“新增或提交数据”，多次提交数据会创建多个资源，所以不是幂等的；而 PUT 是“替换或更新数据”，多次更新一个资源，资源还是会第一次更新的状态，所以是幂等的。可以对比一下 SQL 来加深理解：把 POST 理解成 INSERT，把 PUT 理解成 UPDATE，这样就很清楚了。多次 INSERT 会添加多条记录，而多次 UPDATE 只操作一条记录，而且效果相同。</li>
</ul>
<h2 id="你能写出正确的网址吗？"><a href="#你能写出正确的网址吗？" class="headerlink" title="你能写出正确的网址吗？"></a>你能写出正确的网址吗？</h2><ul>
<li>严格地说，URI统一资源标识符（Uniform Resource Identifier） 不完全等同于网址，它包含有 URL 和 URN 两个部分，在 HTTP 世界里用的网址实际上是 URL——统一资源定位符（Uniform Resource Locator）。但因为 URL 实在是太普及了，所以常常把这两者简单地视为相等。<h3 id="URI-的格式"><a href="#URI-的格式" class="headerlink" title="URI 的格式"></a>URI 的格式</h3></li>
<li>URI 本质上是一个字符串，这个字符串的作用是唯一地标记资源的位置或者名字。它不仅能够标记万维网的资源，也可以标记其他的，如邮件系统、本地文件系统等任意资源。而“资源”既可以是存在磁盘上的静态文本、页面数据，也可以是由 Java、PHP 提供的动态服务。<h3 id="URI-的基本组成"><a href="#URI-的基本组成" class="headerlink" title="URI 的基本组成"></a>URI 的基本组成</h3></li>
<li>URI 第一个组成部分叫 scheme，翻译成中文叫“方案名”或者“协议名”，表示资源应该使用哪种协议来访问。最常见的当然就是“http”了，表示使用 HTTP 协议。另外还有“https”，表示使用经过加密、安全的 HTTPS 协议。此外还有其他不是很常见的 scheme，例如 ftp、ldap、file、news 等。</li>
<li>在 scheme 之后，必须是三个特定的字符“://”，它把 scheme 和后面的部分分离开。URI 的创造者蒂姆·伯纳斯 - 李也曾经私下承认“://”并非必要，当初有些“过于草率”了。</li>
<li>在“://”之后，是被称为“authority”的部分，表示资源所在的主机名，通常的形式是“host:port”，即主机名加端口号。主机名可以是 IP 地址或者域名的形式，必须要有，否则浏览器就会找不到服务器。但端口号有时可以省略，浏览器等客户端会依据 scheme 使用默认的端口号，例如 HTTP 的默认端口号是 80，HTTPS 的默认端口号是 443。</li>
<li>有了协议名和主机地址、端口号，再加上后面标记资源所在位置的 path，浏览器就可以连接服务器访问资源了。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">http://nginx.org</span><br><span class="line">https://tools.ietf.org/html/rfc7230</span><br><span class="line">file:///D:/http_study/www/</span><br><span class="line"></span><br><span class="line">最后一个 URI 要注意了，它的协议名不是“http”，而是“file”，表示这是本地文件，而后面居然有三个斜杠，这是怎么回事？</span><br><span class="line">这三个斜杠里的前两个属于 URI 特殊分隔符“://”，然后后面的“/D:/http_study/www/”是路径，而中间的主机名被“省略”了。</span><br><span class="line">这实际上是 file 类型 URI 的“特例”，它允许省略主机名，默认是本机 localhost。</span><br><span class="line"></span><br><span class="line">但对于 HTTP 或 HTTPS 这样的网络通信协议，主机名是绝对不能省略的。原因之前也说了，会导致浏览器无法找到服务器。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="URI-的查询参数"><a href="#URI-的查询参数" class="headerlink" title="URI 的查询参数"></a>URI 的查询参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">http://www.diamonds.com:8080/11-1?uid=1234&amp;name=mario&amp;referer=xxx</span><br></pre></td></tr></table></figure>
<h3 id="URI-的完整格式"><a href="#URI-的完整格式" class="headerlink" title="URI 的完整格式"></a>URI 的完整格式</h3><ul>
<li>第一个多出的部分是协议名之后、主机名之前的身份信息“user:passwd@”，表示登录主机时的用户名和密码，但现在已经不推荐使用这种形式了（RFC7230），因为它把敏感信息以明文形式暴露出来，存在严重的安全隐患。</li>
<li>第二个多出的部分是查询参数后的片段标识符“#fragment”，它是 URI 所定位的资源内部的一个“锚点”或者说是“标签”，浏览器可以在获取资源后直接跳转到它指示的位置。但片段标识符仅能由浏览器这样的客户端使用，服务器是看不到的。也就是说，浏览器永远不会把带“#fragment”的 URI 发送给服务器，服务器也永远不会用这种方式去处理资源的片段。</li>
</ul>
<h3 id="URI-的编码"><a href="#URI-的编码" class="headerlink" title="URI 的编码"></a>URI 的编码</h3><ul>
<li>URI 引入了编码机制，对于 ASCII 码以外的字符集和特殊字符做一个特殊的操作，把它们转换成与 URI 语义不冲突的形式。这在 RFC 规范里称为“escape”和“unescape”，俗称“转义”。</li>
<li>URI 转义的规则有点“简单粗暴”，直接把非 ASCII 码或特殊字符转换成十六进制字节值，然后前面再加上一个“%”。例如，空格被转义成“%20”，“?”被转义成“%3F”。而中文、日文等则通常使用 UTF-8 编码后再转义，例如“银河”会被转义成“%E9%93%B6%E6%B2%B3”。</li>
<li>不过我们在浏览器的地址栏里通常是不会看到这些转义后的“乱码”的，这实际上是浏览器一种“友好”表现，隐藏了 URI 编码后的“丑陋一面”，</li>
</ul>
<h2 id="响应状态码该怎么用？"><a href="#响应状态码该怎么用？" class="headerlink" title="响应状态码该怎么用？"></a>响应状态码该怎么用？</h2><ul>
<li>RFC 标准把状态码分成了五类，用数字的第一位表示分类，而 0~99 不用，这样状态码的实际可用范围就大大缩小了，由 000~999 变成了 100~599。</li>
</ul>
<ol>
<li>1××：提示信息，表示目前是协议处理的中间状态，还需要后续的操作；</li>
<li>2××：成功，报文已经收到并被正确处理；</li>
<li>3××：重定向，资源位置发生变动，需要客户端重新发送请求；</li>
<li>4××：客户端错误，请求报文有误，服务器无法处理；</li>
<li>5××：服务器错误，服务器在处理请求时内部发生了错误。<h3 id="1××"><a href="#1××" class="headerlink" title="1××"></a>1××</h3></li>
</ol>
<ul>
<li>1××类状态码属于提示信息，是协议处理的中间状态，实际能够用到的时候很少。</li>
<li>“101 Switching Protocols”。它的意思是客户端使用 Upgrade 头字段，要求在 HTTP 协议的基础上改成其他的协议继续通信，比如 WebSocket。而如果服务器也同意变更协议，就会发送状态码 101，但这之后的数据传输就不会再使用 HTTP 了。<h3 id="2××"><a href="#2××" class="headerlink" title="2××"></a>2××</h3></li>
<li>“204 No Content”是另一个很常见的成功状态码，它的含义与“200 OK”基本相同，但响应头后没有 body 数据。所以对于 Web 服务器来说，正确地区分 200 和 204 是很必要的。</li>
<li>“206 Partial Content”是 HTTP 分块下载或断点续传的基础，在客户端发送“范围请求”、要求获取资源的部分数据时出现，它与 200 一样，也是服务器成功处理了请求，但 body 里的数据不是资源的全部，而是其中的一部分。状态码 206 通常还会伴随着头字段“Content-Range”，表示响应报文里 body 数据的具体范围，供客户端确认，例如“Content-Range: bytes 0-99/2000”，意思是此次获取的是总计 2000 个字节的前 100 个字节。<h3 id="3××"><a href="#3××" class="headerlink" title="3××"></a>3××</h3></li>
<li>“301 Moved Permanently”俗称“永久重定向”，含义是此次请求的资源已经不存在了，需要改用新的 URI 再次访问。比如，你的网站升级到了 HTTPS，原来的 HTTP 不打算用了，这就是“永久”的，所以要配置 301 跳转，把所有的 HTTP 流量都切换到 HTTPS。</li>
<li>“302 Found”，曾经的描述短语是“Moved Temporarily”，俗称“临时重定向”，意思是请求的资源还在，但需要暂时用另一个 URI 来访问。301 和 302 都会在响应头里使用字段 Location 指明后续要跳转的 URI，最终的效果很相似，浏览器都会重定向到新的 URI。两者的根本区别在于语义，一个是“永久”，一个是“临时”，所以在场景、用法上差距很大。比如，今天夜里网站后台要系统维护，服务暂时不可用，这就属于“临时”的，可以配置成 302 跳转，把流量临时切换到一个静态通知页面，浏览器看到这个 302 就知道这只是暂时的情况，不会做缓存优化，第二天还会访问原来的地址。</li>
<li>“304 Not Modified” 是一个比较有意思的状态码，它用于 If-Modified-Since 等条件请求，表示资源未修改，用于缓存控制。它不具有通常的跳转含义，但可以理解成“重定向已到缓存的文件”（即“缓存重定向”）。<h3 id="4××"><a href="#4××" class="headerlink" title="4××"></a>4××</h3></li>
<li>“400 Bad Request”是一个通用的错误码，表示请求报文有错误，但具体是数据格式错误、缺少请求头还是 URI 超长它没有明确说，只是一个笼统的错误，客户端看到 400 只会是“一头雾水”“不知所措”。所以，在开发 Web 应用时应当尽量避免给客户端返回 400，而是要用其他更有明确含义的状态码。</li>
<li>“403 Forbidden”实际上不是客户端的请求出错，而是表示服务器禁止访问资源。原因可能多种多样，例如信息敏感、法律禁止等，如果服务器友好一点，可以在 body 里详细说明拒绝请求的原因，不过现实中通常都是直接给一个“闭门羹”。</li>
<li>“404 Not Found”可能是我们最常看见也是最不愿意看到的一个状态码，它的原意是资源在本服务器上未找到，所以无法提供给客户端。但现在已经被“用滥了”，只要服务器“不高兴”就可以给出个 404，而我们也无从得知后面到底是真的未找到，还是有什么别的原因，某种程度上它比 403 还要令人讨厌。</li>
<li>405 Method Not Allowed：不允许使用某些方法操作资源，例如不允许 POST 只能 GET；</li>
<li>406 Not Acceptable：资源无法满足客户端请求的条件，例如请求中文但只有英文；</li>
<li>408 Request Timeout：请求超时，服务器等待了过长的时间；</li>
<li>409 Conflict：多个请求发生了冲突，可以理解为多线程并发时的竞态；</li>
<li>413 Request Entity Too Large：请求报文里的 body 太大；</li>
<li>414 Request-URI Too Long：请求行里的 URI 太大；</li>
<li>429 Too Many Requests：客户端发送了太多的请求，通常是由于服务器的限连策略；</li>
<li>431 Request Header Fields Too Large：请求头某个字段或总体太大；<h3 id="5××"><a href="#5××" class="headerlink" title="5××"></a>5××</h3></li>
<li>“500 Internal Server Error”与 400 类似，也是一个通用的错误码，服务器究竟发生了什么错误我们是不知道的。不过对于服务器来说这应该算是好事，通常不应该把服务器内部的详细信息，例如出错的函数调用栈告诉外界。虽然不利于调试，但能够防止黑客的窥探或者分析。</li>
<li>“501 Not Implemented”表示客户端请求的功能还不支持，这个错误码比 500 要“温和”一些，和“即将开业，敬请期待”的意思差不多，不过具体什么时候“开业”就不好说了。</li>
<li>“502 Bad Gateway”通常是服务器作为网关或者代理时返回的错误码，表示服务器自身工作正常，访问后端服务器时发生了错误，但具体的错误原因也是不知道的。<br>*　“503 Service Unavailable”表示服务器当前很忙，暂时无法响应服务，我们上网时有时候遇到的“网络服务正忙，请稍后重试”的提示信息就是状态码 503。503 是一个“临时”的状态，很可能过几秒钟后服务器就不那么忙了，可以继续提供服务，所以 503 响应报文里通常还会有一个“Retry-After”字段，指示客户端可以在多久以后再次尝试发送请求。</li>
</ul>
<h2 id="HTTP有哪些特点？"><a href="#HTTP有哪些特点？" class="headerlink" title="HTTP有哪些特点？"></a>HTTP有哪些特点？</h2><ul>
<li>灵活可扩展。HTTP 是灵活可扩展的，可以任意添加头字段实现任意功能；</li>
<li>可靠传输。这个特点显而易见，因为 HTTP 协议是基于 TCP/IP 的，而 TCP 本身是一个“可靠”的传输协议，所以 HTTP 自然也就继承了这个特性，能够在请求方和应答方之间“可靠”地传输数据。</li>
<li>应用层协议。虽然出现了许多的应用层协议，但它们都仅关注很小的应用领域，局限在很少的应用场景。例如 FTP 只能传输文件、SMTP 只能发送邮件、SSH 只能远程登录等，在通用的数据传输方面“完全不能打”。所以 HTTP 凭借着可携带任意头字段和实体数据的报文结构，以及连接控制、缓存代理等方便易用的特性，一出现就“技压群雄”，迅速成为了应用层里的“明星”协议。只要不太苛求性能，HTTP 几乎可以传递一切东西，满足各种需求，称得上是一个“万能”的协议。HTTP 完全可以用开玩笑的口吻说：“不要误会，我不是针对 FTP，我是说在座的应用层各位，都是垃圾。”</li>
<li>请求 - 应答。</li>
<li>无状态。“无状态”形象地来说就是“没有记忆能力”。比如，浏览器发了一个请求，说“我是小明，请给我 A 文件。”，服务器收到报文后就会检查一下权限，看小明确实可以访问 A 文件，于是把文件发回给浏览器。接着浏览器还想要 B 文件，但服务器不会记录刚才的请求状态，不知道第二个请求和第一个请求是同一个浏览器发来的，所以浏览器必须还得重复一次自己的身份才行：“我是刚才的小明，请再给我 B 文件。”我们可以再对比一下 UDP 协议，不过它是无连接也无状态的，顺序发包乱序收包，数据包发出去后就不管了，收到后也不会顺序整理。而 HTTP 是有连接无状态，顺序发包顺序收包，按照收发的顺序管理报文。</li>
</ul>
<h2 id="HTTP有哪些优点？又有哪些缺点？"><a href="#HTTP有哪些优点？又有哪些缺点？" class="headerlink" title="HTTP有哪些优点？又有哪些缺点？"></a>HTTP有哪些优点？又有哪些缺点？</h2><ul>
<li>HTTP 最大的优点是简单、灵活和易于扩展；</li>
<li>HTTP 拥有成熟的软硬件环境，应用的非常广泛，是互联网的基础设施；</li>
<li>HTTP 是无状态的，可以轻松实现集群化，扩展性能，但有时也需要用 Cookie 技术来实现“有状态”；</li>
<li>HTTP 是明文传输，数据完全肉眼可见，能够方便地研究分析，但也容易被窃听；</li>
<li>HTTP 是不安全的，无法验证通信双方的身份，也不能判断报文是否被窜改；</li>
<li>HTTP 的性能不算差，但不完全适应现在的互联网，还有很大的提升空间。</li>
</ul>
<h2 id="HTTP的实体数据"><a href="#HTTP的实体数据" class="headerlink" title="HTTP的实体数据"></a>HTTP的实体数据</h2><h3 id="数据类型与编码"><a href="#数据类型与编码" class="headerlink" title="数据类型与编码"></a>数据类型与编码</h3><ul>
<li>在 TCP/IP 协议栈里，传输数据基本上都是“header+body”的格式。但 TCP、UDP 因为是传输层的协议，它们不会关心 body 数据是什么，只要把数据发送到对方就算是完成了任务。</li>
<li>而 HTTP 协议则不同，它是应用层的协议，数据到达之后工作只能说是完成了一半，还必须要告诉上层应用这是什么数据才行，否则上层应用就会“不知所措”。早在 HTTP 协议诞生之前就已经有了针对这种问题的解决方案，不过它是用在电子邮件系统里的，让电子邮件可以发送 ASCII 码以外的任意数据，方案的名字叫做“多用途互联网邮件扩展”（Multipurpose Internet Mail Extensions），简称为 MIME。</li>
<li>MIME 是一个很大的标准规范，但 HTTP 只“顺手牵羊”取了其中的一部分，用来标记 body 的数据类型，这就是我们平常总能听到的“MIME type”。MIME 把数据分成了八大类，每个大类下再细分出多个子类，形式是“type/subtype”的字符串，巧得很，刚好也符合了 HTTP 明文的特点，所以能够很容易地纳入 HTTP 头字段里。</li>
</ul>
<ol>
<li>text：即文本格式的可读数据，我们最熟悉的应该就是 text/html 了，表示超文本文档，此外还有纯文本 text/plain、样式表 text/css 等。</li>
<li>image：即图像文件，有 image/gif、image/jpeg、image/png 等。</li>
<li>audio/video：音频和视频数据，例如 audio/mpeg、video/mp4 等。</li>
<li>application：数据格式不固定，可能是文本也可能是二进制，必须由上层应用程序来解释。常见的有 application/json，application/javascript、application/pdf 等，另外，如果实在是不知道数据是什么类型，像刚才说的“黑盒”，就会是 application/octet-stream，即不透明的二进制数据。</li>
</ol>
<ul>
<li>但仅有 MIME type 还不够，因为 HTTP 在传输时为了节约带宽，有时候还会压缩数据，为了不要让浏览器继续“猜”，还需要有一个“Encoding type”，告诉数据是用的什么编码格式，这样对方才能正确解压缩，还原出原始的数据。</li>
<li>比起 MIME type 来说，Encoding type 就少了很多，常用的只有下面三种：</li>
</ul>
<ol>
<li>gzip：GNU zip 压缩格式，也是互联网上最流行的压缩格式；</li>
<li>deflate：zlib（deflate）压缩格式，流行程度仅次于 gzip；</li>
<li>br：一种专门为 HTTP 优化的新压缩算法（Brotli）。<h3 id="数据类型使用的头字段"><a href="#数据类型使用的头字段" class="headerlink" title="数据类型使用的头字段"></a>数据类型使用的头字段</h3></li>
</ol>
<ul>
<li>客户端用 Accept 头告诉服务器希望接收什么样的数据，而服务器用 Content 头告诉客户端实际发送了什么样的数据。</li>
<li><p>Accept 字段标记的是客户端可理解的 MIME type，可以用“,”做分隔符列出多个类型，让服务器有更多的选择余地，例如下面的这个头：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Accept: text/html,application/xml,image/webp,image/png</span><br><span class="line">这就是告诉服务器：“我能够看懂 HTML、XML 的文本，还有 webp 和 png 的图片，请给我这四类格式的数据”。</span><br></pre></td></tr></table></figure>
</li>
<li><p>相应的，服务器会在响应报文里用头字段 Content-Type 告诉实体数据的真实类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Type: image/png</span><br></pre></td></tr></table></figure>
</li>
<li><p>Accept-Encoding 字段标记的是客户端支持的压缩格式，例如上面说的 gzip、deflate 等，同样也可以用“,”列出多个，服务器可以选择其中一种来压缩数据，实际使用的压缩格式放在响应头字段 Content-Encoding 里。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Content-Encoding: gzip</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果请求报文里没有 Accept-Encoding 字段，就表示客户端不支持压缩数据；如果响应报文里没有 Content-Encoding 字段，就表示响应数据没有被压缩。</p>
</li>
</ul>
<h3 id="语言类型与编码"><a href="#语言类型与编码" class="headerlink" title="语言类型与编码"></a>语言类型与编码</h3><ul>
<li><p>Accept-Language 字段标记了客户端可理解的自然语言，也允许用“,”做分隔符列出多个类型，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Accept-Language: zh-CN, zh, en</span><br><span class="line">这个请求头会告诉服务器：“最好给我 zh-CN 的汉语文字，如果没有就用其他的汉语方言，如果还没有就给英文”。</span><br></pre></td></tr></table></figure>
</li>
<li><p>相应的，服务器应该在响应报文里用头字段 Content-Language 告诉客户端实体数据使用的实际语言类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Content-Language: zh-CN</span><br></pre></td></tr></table></figure>
</li>
<li><p>字符集在 HTTP 里使用的请求头字段是 Accept-Charset，但响应头里却没有对应的 Content-Charset，而是在 Content-Type 字段的数据类型后面用“charset=xxx”来表示，这点需要特别注意。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Accept-Charset: gbk, utf-8</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="内容协商的质量值"><a href="#内容协商的质量值" class="headerlink" title="内容协商的质量值"></a>内容协商的质量值</h3><ul>
<li>在 HTTP 协议里用 Accept、Accept-Encoding、Accept-Language 等请求头字段进行内容协商的时候，还可以用一种特殊的“q”参数表示权重来设定优先级，这里的“q”是“quality factor”的意思。</li>
<li>权重的最大值是 1，最小值是 0.01，默认值是 1，如果值是 0 就表示拒绝。具体的形式是在数据类型或语言代码后面加一个“;”，然后是“q=value”。这里要提醒的是“;”的用法，在大多数编程语言里“;”的断句语气要强于“,”，而在 HTTP 的内容协商里却恰好反了过来，“;”的意义是小于“,”的。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Accept: text/html,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line"></span><br><span class="line">它表示浏览器最希望使用的是 HTML 文件，权重是 1，其次是 XML 文件，权重是 0.9，最后是任意数据类型，权重是 0.8。服务器收到请求头后，就会计算权重，再根据自己的实际情况优先输出 HTML 或者 XML。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="内容协商的结果"><a href="#内容协商的结果" class="headerlink" title="内容协商的结果"></a>内容协商的结果</h3><ul>
<li>内容协商的过程是不透明的，每个 Web 服务器使用的算法都不一样。但有的时候，服务器会在响应头里多加一个 Vary 字段，记录服务器在内容协商时参考的请求头字段，给出一点信息，例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Vary: Accept-Encoding,User-Agent,Accept</span><br><span class="line">这个 Vary 字段表示服务器依据了 Accept-Encoding、User-Agent 和 Accept 这三个头字段，然后决定了发回的响应报文。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="HTTP传输大文件的方法"><a href="#HTTP传输大文件的方法" class="headerlink" title="HTTP传输大文件的方法"></a>HTTP传输大文件的方法</h2><h3 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a>数据压缩</h3><ul>
<li>通常浏览器在发送请求时都会带着“Accept-Encoding”头字段，里面是浏览器支持的压缩格式列表，例如 gzip、deflate、br 等，这样服务器就可以从中选择一种压缩算法，放进“Content-Encoding”响应头里，再把原数据压缩后发给浏览器。</li>
<li>gzip 等压缩算法通常只对文本文件有较好的压缩率，而图片、音频视频等多媒体数据本身就已经是高度压缩的，再用 gzip 处理也不会变小（甚至还有可能会增大一点），所以它就失效了。</li>
<li>不过数据压缩在处理文本的时候效果还是很好的，所以各大网站的服务器都会使用这个手段作为“保底”。例如，在 Nginx 里就会使用“gzip on”指令，启用对“text/html”的压缩。<h3 id="分块传输"><a href="#分块传输" class="headerlink" title="分块传输"></a>分块传输</h3></li>
<li>压缩是把大文件整体变小，我们可以反过来思考，如果大文件整体不能变小，那就把它“拆开”，分解成多个小块，把这些小块分批发给浏览器，浏览器收到后再组装复原。</li>
<li>这种“化整为零”的思路在 HTTP 协议里就是“chunked”分块传输编码，在响应报文里用头字段“Transfer-Encoding: chunked”来表示，意思是报文里的 body 部分不是一次性发过来的，而是分成了许多的块（chunk）逐个发送。</li>
<li>分块传输也可以用于“流式数据”，例如由数据库动态生成的表单页面，这种情况下 body 数据的长度是未知的，无法在头字段“Content-Length”里给出确切的长度，所以也只能用 chunked 方式分块发送。</li>
<li>“Transfer-Encoding: chunked”和“Content-Length”这两个字段是互斥的，也就是说响应报文里这两个字段不能同时出现，一个响应报文的传输要么是长度已知，要么是长度未知（chunked），这一点你一定要记住。</li>
<li>下面我们来看一下分块传输的编码规则，其实也很简单，同样采用了明文的方式，很类似响应头。</li>
</ul>
<ol>
<li>每个分块包含两个部分，长度头和数据块；</li>
<li>长度头是以 CRLF（回车换行，即\r\n）结尾的一行明文，用 16 进制数字表示长度；</li>
<li>数据块紧跟在长度头后，最后也用 CRLF 结尾，但数据不包含 CRLF；</li>
<li>最后用一个长度为 0 的块表示结束，即“0\r\n\r\n”。<h3 id="范围请求"><a href="#范围请求" class="headerlink" title="范围请求"></a>范围请求</h3></li>
</ol>
<ul>
<li>比如，你在看当下正热播的某穿越剧，想跳过片头，直接看正片，或者有段剧情很无聊，想拖动进度条快进几分钟，这实际上是想获取一个大文件其中的片段数据，而分块传输并没有这个能力。</li>
<li>HTTP 协议为了满足这样的需求，提出了“范围请求”（range requests）的概念，允许客户端在请求头里使用专用字段来表示只获取文件的一部分，相当于是客户端的“化整为零”。</li>
<li>范围请求不是 Web 服务器必备的功能，可以实现也可以不实现，所以服务器必须在响应头里使用字段“Accept-Ranges: bytes”明确告知客户端：“我是支持范围请求的”。</li>
<li>请求头 Range 是 HTTP 范围请求的专用字段，格式是“bytes=x-y”，其中的 x 和 y 是以字节为单位的数据范围。要注意 x、y 表示的是“偏移量”，范围必须从 0 计数，例如前 10 个字节表示为“0-9”，第二个 10 字节表示为“10-19”，而“0-10”实际上是前 11 个字节。</li>
<li>服务器收到 Range 字段后，需要做四件事。</li>
</ul>
<ol>
<li>第一，它必须检查范围是否合法，比如文件只有 100 个字节，但请求“200-300”，这就是范围越界了。服务器就会返回状态码 416，意思是“你的范围请求有误，我无法处理，请再检查一下”。</li>
<li>第二，如果范围正确，服务器就可以根据 Range 头计算偏移量，读取文件的片段了，返回状态码“206 Partial Content”，和 200 的意思差不多，但表示 body 只是原数据的一部分。</li>
<li>第三，服务器要添加一个响应头字段 Content-Range，告诉片段的实际偏移量和资源的总大小，格式是“bytes x-y/length”，与 Range 头区别在没有“=”，范围后多了总长度。例如，对于“0-10”的范围请求，值就是“bytes 0-10/100”。</li>
<li>最后剩下的就是发送数据了，直接把片段用 TCP 发给客户端，一个范围请求就算是处理完了。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">GET /16-2 HTTP/1.1</span><br><span class="line">Host: www.diamonds.com</span><br><span class="line">Range: bytes=0-31</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HTTP/1.1 206 Partial Content</span><br><span class="line">Content-Length: 32</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Content-Range: bytes 0-31/96</span><br><span class="line"></span><br><span class="line">// this is a plain text json doc</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>有了范围请求之后，HTTP 处理大文件就更加轻松了，看视频时可以根据时间点计算出文件的 Range，不用下载整个文件，直接精确获取片段所在的数据内容。</li>
<li>不仅看视频的拖拽进度需要范围请求，常用的下载工具里的多段下载、断点续传也是基于它实现的，要点是：</li>
</ul>
<ol>
<li>先发个 HEAD，看服务器是否支持范围请求，同时获取文件的大小；</li>
<li>开 N 个线程，每个线程使用 Range 字段划分出各自负责下载的片段，发请求传输数据；</li>
<li>下载意外中断也不怕，不必重头再来一遍，只要根据上次的下载记录，用 Range 请求剩下的那一部分就可以了。</li>
</ol>
<h3 id="多段数据"><a href="#多段数据" class="headerlink" title="多段数据"></a>多段数据</h3><ul>
<li>范围请求一次只获取一个片段，其实它还支持在 Range 头里使用多个“x-y”，一次性获取多个片段数据。</li>
<li>这种情况需要使用一种特殊的 MIME 类型：“multipart/byteranges”，表示报文的 body 是由多段字节序列组成的，并且还要用一个参数“boundary=xxx”给出段之间的分隔标记。</li>
<li>每一个分段必须以“- -boundary”开始（前面加两个“-”），之后要用“Content-Type”和“Content-Range”标记这段数据的类型和所在范围，然后就像普通的响应头一样以回车换行结束，再加上分段数据，最后用一个“- -boundary- -”（前后各有两个“-”）表示所有的分段结束。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">GET /16-2 HTTP/1.1</span><br><span class="line">Host: www.diamonds.com</span><br><span class="line">Range: bytes=0-9, 20-29</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HTTP/1.1 206 Partial Content</span><br><span class="line">Content-Type: multipart/byteranges; boundary=00000000001</span><br><span class="line">Content-Length: 189</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--00000000001</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Range: bytes 0-9/96</span><br><span class="line"></span><br><span class="line">// this is</span><br><span class="line">--00000000001</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Range: bytes 20-29/96</span><br><span class="line"></span><br><span class="line">ext json d</span><br><span class="line">--00000000001--</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="HTTP的连接管理"><a href="#HTTP的连接管理" class="headerlink" title="HTTP的连接管理"></a>HTTP的连接管理</h2><h3 id="短连接"><a href="#短连接" class="headerlink" title="短连接"></a>短连接</h3><ul>
<li>短连接的缺点相当严重，因为在 TCP 协议里，建立连接和关闭连接都是非常“昂贵”的操作。TCP 建立连接要有“三次握手”，发送 3 个数据包，需要 1 个 RTT；关闭连接是“四次挥手”，4 个数据包需要 2 个 RTT。</li>
<li>而 HTTP 的一次简单“请求 - 响应”通常只需要 4 个包，如果不算服务器内部的处理时间，最多是 2 个 RTT。这么算下来，浪费的时间就是“3÷5=60%”，有三分之二的时间被浪费掉了，传输效率低得惊人。<h3 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h3></li>
<li>针对短连接暴露出的缺点，HTTP 协议就提出了“长连接”的通信方式，也叫“持久连接”（persistent connections）、“连接保活”（keep alive）、“连接复用”（connection reuse）。</li>
<li>其实解决办法也很简单，用的就是“成本均摊”的思路，既然 TCP 的连接和关闭非常耗时间，那么就把这个时间成本由原来的一个“请求 - 应答”均摊到多个“请求 - 应答”上</li>
<li>这样虽然不能改善 TCP 的连接效率，但基于“分母效应”，每个“请求 - 应答”的无效时间就会降低不少，整体传输效率也就提高了。</li>
<li>在短连接里发送了三次 HTTP“请求 - 应答”，每次都会浪费 60% 的 RTT 时间。而在长连接的情况下，同样发送三次请求，因为只在第一次时建立连接，在最后一次时关闭连接，所以浪费率就是“3÷9≈33%”，降低了差不多一半的时间损耗。显然，如果在这个长连接上发送的请求越多，分母就越大，利用率也就越高。<h3 id="连接相关的头字段"><a href="#连接相关的头字段" class="headerlink" title="连接相关的头字段"></a>连接相关的头字段</h3></li>
<li>由于长连接对性能的改善效果非常显著，所以在 HTTP/1.1 中的连接都会默认启用长连接。不需要用什么特殊的头字段指定，只要向服务器发送了第一次请求，后续的请求都会重复利用第一次打开的 TCP 连接，也就是长连接，在这个连接上收发数据。</li>
<li>当然，我们也可以在请求头里明确地要求使用长连接机制，使用的字段是 Connection，值是“keep-alive”。</li>
<li>因为 TCP 连接长时间不关闭，服务器必须在内存里保存它的状态，这就占用了服务器的资源。如果有大量的空闲长连接只连不发，就会很快耗尽服务器的资源，导致服务器无法为真正有需要的用户提供服务。</li>
<li>在客户端，可以在请求头里加上“Connection: close”字段，告诉服务器：“这次通信后就关闭连接”。服务器看到这个字段，就知道客户端要主动关闭连接，于是在响应报文里也加上这个字段，发送之后就调用 Socket API 关闭 TCP 连接。</li>
<li>服务器端通常不会主动关闭连接，但也可以使用一些策略。拿 Nginx 来举例，它有两种方式：</li>
</ul>
<ol>
<li>使用“keepalive_timeout”指令，设置长连接的超时时间，如果在一段时间内连接上没有任何数据收发就主动断开连接，避免空闲连接占用系统资源。</li>
<li>使用“keepalive_requests”指令，设置长连接上可发送的最大请求次数。比如设置成 1000，那么当 Nginx 在这个连接上处理了 1000 个请求后，也会主动断开连接。</li>
</ol>
<ul>
<li>另外，客户端和服务器都可以在报文里附加通用头字段“Keep-Alive: timeout=value”，限定长连接的超时时间。但这个字段的约束力并不强，通信的双方可能并不会遵守，所以不太常见。<h3 id="队头阻塞"><a href="#队头阻塞" class="headerlink" title="队头阻塞"></a>队头阻塞</h3></li>
<li>因为 HTTP 规定报文必须是“一发一收”，这就形成了一个先进先出的“串行”队列。队列里的请求没有轻重缓急的优先级，只有入队的先后顺序，排在最前面的请求被最优先处理。</li>
<li>如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本。<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3></li>
<li>在 HTTP 里就是“并发连接”（concurrent connections），也就是同时对一个域名发起多个长连接，用数量来解决质量的问题。但这种方式也存在缺陷。如果每个客户端都想自己快，建立很多个连接，用户数×并发数就会是个天文数字。服务器的资源根本就扛不住，或者被服务器认为是恶意攻击，反而会造成“拒绝服务”。</li>
<li>所以，HTTP 协议建议客户端使用并发，但不能“滥用”并发。RFC2616 里明确限制每个客户端最多并发 2 个连接。不过实践证明这个数字实在是太小了，众多浏览器都“无视”标准，把这个上限提高到了 6~8。后来修订的 RFC7230 也就“顺水推舟”，取消了这个“2”的限制。</li>
<li>“域名分片”（domain sharding）技术，还是用数量来解决质量的思路。HTTP 协议和浏览器不是限制并发连接数量吗？好，那我就多开几个域名，比如 shard1.diamonds.com、shard2.diamonds.com，而这些域名都指向同一台服务器 <a href="http://www.diamonds.com，这样实际长连接的数量就又上去了，真是“美滋滋”。不过实在是有点“上有政策，下有对策”的味道。" target="_blank" rel="noopener">www.diamonds.com，这样实际长连接的数量就又上去了，真是“美滋滋”。不过实在是有点“上有政策，下有对策”的味道。</a><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3></li>
<li>早期的 HTTP 协议使用短连接，收到响应后就立即关闭连接，效率很低；</li>
<li>HTTP/1.1 默认启用长连接，在一个连接上收发多个请求响应，提高了传输效率；</li>
<li>服务器会发送“Connection: keep-alive”字段表示启用了长连接；</li>
<li>报文头里如果有“Connection: close”就意味着长连接即将关闭；</li>
<li>过多的长连接会占用服务器资源，所以服务器会用一些策略有选择地关闭长连接；</li>
<li>“队头阻塞”问题会导致性能下降，可以用“并发连接”和“域名分片”技术缓解。</li>
</ul>
<h2 id="HTTP的重定向和跳转"><a href="#HTTP的重定向和跳转" class="headerlink" title="HTTP的重定向和跳转"></a>HTTP的重定向和跳转</h2><ul>
<li>在 Nginx 的主页上点了一下“download”链接，会发生什么呢？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">http://nginx.org/en/download.html</span><br><span class="line"></span><br><span class="line">浏览器首先要解析链接文字里的 URI。</span><br><span class="line">再用这个 URI 发起一个新的 HTTP 请求，获取响应报文后就会切换显示内容，渲染出新 URI 指向的页面。</span><br><span class="line">这样的跳转动作是由浏览器的使用者主动发起的，可以称为“主动跳转”</span><br><span class="line"></span><br><span class="line">但还有一类跳转是由服务器来发起的，浏览器使用者无法控制，相对地就可以称为“被动跳转”，这在 HTTP 协议里有个专门的名词，叫做“重定向”（Redirection）。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="重定向的过程"><a href="#重定向的过程" class="headerlink" title="重定向的过程"></a>重定向的过程</h3><ul>
<li>301 是“永久重定向”，302 是“临时重定向”，浏览器收到这两个状态码就会跳转到新的 URI。</li>
<li>“Location”字段属于响应字段，必须出现在响应报文里。但只有配合 301/302 状态码才有意义，它标记了服务器要求重定向的 URI，这里就是要求浏览器跳转到“index.html”。</li>
<li>浏览器收到 301/302 报文，会检查响应头里有没有“Location”。如果有，就从字段值里提取出 URI，发出新的 HTTP 请求，相当于自动替我们点击了这个链接。</li>
<li>在“Location”里的 URI 既可以使用绝对 URI，也可以使用相对 URI。所谓“绝对 URI”，就是完整形式的 URI，包括 scheme、host:port、path 等。所谓“相对 URI”，就是省略了 scheme 和 host:port，只有 path 和 query 部分，是不完整的，但可以从请求上下文里计算得到。<h3 id="重定向状态码"><a href="#重定向状态码" class="headerlink" title="重定向状态码"></a>重定向状态码</h3></li>
<li>301 俗称“永久重定向”（Moved Permanently），意思是原 URI 已经“永久”性地不存在了，今后的所有请求都必须改用新的 URI。</li>
<li>浏览器看到 301，就知道原来的 URI“过时”了，就会做适当的优化。比如历史记录、更新书签，下次可能就会直接用新的 URI 访问，省去了再次跳转的成本。搜索引擎的爬虫看到 301，也会更新索引库，不再使用老的 URI。</li>
<li>302 俗称“临时重定向”（“Moved Temporarily”），意思是原 URI 处于“临时维护”状态，新的 URI 是起“顶包”作用的“临时工”。</li>
<li>浏览器或者爬虫看到 302，会认为原来的 URI 仍然有效，但暂时不可用，所以只会执行简单的跳转页面，不记录新的 URI，也不会有其他的多余动作，下次访问还是用原 URI。</li>
<li>303 See Other：类似 302，但要求重定向后的请求改为 GET 方法，访问一个结果页面，避免 POST/PUT 重复操作；</li>
<li>307 Temporary Redirect：类似 302，但重定向后请求里的方法和实体不允许变动，含义比 302 更明确；</li>
<li>308 Permanent Redirect：类似 307，不允许重定向后的请求变动，但它是 301“永久重定向”的含义。</li>
<li>不过这303/307/308三个状态码的接受程度较低，有的浏览器和服务器可能不支持，开发时应当慎重，测试确认浏览器的实际效果后才能使用。</li>
</ul>
<h3 id="重定向的相关问题"><a href="#重定向的相关问题" class="headerlink" title="重定向的相关问题"></a>重定向的相关问题</h3><ul>
<li>第一个问题是“性能损耗”。很明显，重定向的机制决定了一个跳转会有两次请求 - 应答，比正常的访问多了一次。虽然 301/302 报文很小，但大量的跳转对服务器的影响也是不可忽视的。站内重定向还好说，可以长连接复用，站外重定向就要开两个连接，如果网络连接质量差，那成本可就高多了，会严重影响用户的体验。</li>
<li>第二个问题是“循环跳转”。如果重定向的策略设置欠考虑，可能会出现“A=&gt;B=&gt;C=&gt;A”的无限循环，不停地在这个链路里转圈圈，后果可想而知。</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>重定向是服务器发起的跳转，要求客户端改用新的 URI 重新发送请求，通常会自动进行，用户是无感知的；</li>
<li>301/302 是最常用的重定向状态码，分别是“永久重定向”和“临时重定向”；</li>
<li>响应头字段 Location 指示了要跳转的 URI，可以用绝对或相对的形式；</li>
<li>重定向可以把一个 URI 指向另一个 URI，也可以把多个 URI 指向同一个 URI，用途很多；</li>
<li>使用重定向时需要当心性能损耗，还要避免出现循环跳转。</li>
</ul>
<h2 id="HTTP的Cookie机制"><a href="#HTTP的Cookie机制" class="headerlink" title="HTTP的Cookie机制"></a>HTTP的Cookie机制</h2><ul>
<li>HTTP 是“无状态”的，这既是优点也是缺点。优点是服务器没有状态差异，可以很容易地组成集群，而缺点就是无法支持需要记录状态的事务操作。</li>
<li>HTTP 协议是可扩展的，后来发明的 Cookie 技术，给 HTTP 增加了“记忆能力”。<h3 id="什么是-Cookie？"><a href="#什么是-Cookie？" class="headerlink" title="什么是 Cookie？"></a>什么是 Cookie？</h3></li>
<li>相当于是服务器给每个客户端都贴上一张小纸条，上面写了一些只有服务器才能理解的数据，需要的时候客户端把这些信息发给服务器，服务器看到 Cookie，就能够认出对方是谁了。<h3 id="Cookie-的工作过程"><a href="#Cookie-的工作过程" class="headerlink" title="Cookie 的工作过程"></a>Cookie 的工作过程</h3></li>
<li>这要用到两个字段：响应头字段 Set-Cookie 和请求头字段 Cookie。</li>
<li>当用户通过浏览器第一次访问服务器的时候，服务器肯定是不知道他的身份的。所以，就要创建一个独特的身份标识数据，格式是“key=value”，然后放进 Set-Cookie 字段里，随着响应报文一同发给浏览器。</li>
<li>浏览器收到响应报文，看到里面有 Set-Cookie，知道这是服务器给的身份标识，于是就保存起来，下次再请求的时候就自动把这个值放进 Cookie 字段里发给服务器。</li>
<li>服务器有时会在响应头里添加多个 Set-Cookie，存储多个“key=value”。但浏览器这边发送时不需要用多个 Cookie 字段，只要在一行里用“;”隔开就行。</li>
<li>Cookie 是由浏览器负责存储的，而不是操作系统。所以，它是“浏览器绑定”的，只能在本浏览器内生效。<h3 id="Cookie-的属性"><a href="#Cookie-的属性" class="headerlink" title="Cookie 的属性"></a>Cookie 的属性</h3></li>
<li>Cookie 就是服务器委托浏览器存储在客户端里的一些数据，而这些数据通常都会记录用户的关键识别信息。所以，就需要在“key=value”外再用一些手段来保护，防止外泄或窃取，这些手段就是 Cookie 的属性。</li>
<li>首先，我们应该设置 Cookie 的生存周期，也就是它的有效期，让它只能在一段时间内可用，就像是食品的“保鲜期”，一旦超过这个期限浏览器就认为是 Cookie 失效，在存储里删除，也不会发送给服务器。</li>
<li>Cookie 的有效期可以使用 Expires 和 Max-Age 两个属性来设置。</li>
<li>“Expires”俗称“过期时间”，用的是绝对时间点，可以理解为“截止日期”（deadline）。“Max-Age”用的是相对时间，单位是秒，浏览器用收到报文的时间点再加上 Max-Age，就可以得到失效的绝对时间。</li>
<li>Expires 和 Max-Age 可以同时出现，两者的失效时间可以一致，也可以不一致，但浏览器会优先采用 Max-Age 计算失效期。</li>
<li>设置 Cookie 的作用域，让浏览器仅发送给特定的服务器和 URI，避免被其他网站盗用。作用域的设置比较简单，“Domain”和“Path”指定了 Cookie 所属的域名和路径，浏览器在发送 Cookie 前会从 URI 中提取出 host 和 path 部分，对比 Cookie 的属性。如果不满足条件，就不会在请求头里发送 Cookie。</li>
<li>使用这两个属性可以为不同的域名和路径分别设置各自的 Cookie，比如“/19-1”用一个 Cookie，“/19-2”再用另外一个 Cookie，两者互不干扰。不过现实中为了省事，通常 Path 就用一个“/”或者直接省略，表示域名下的任意路径都允许使用 Cookie，让服务器自己去挑。<h3 id="Cookie-的安全性"><a href="#Cookie-的安全性" class="headerlink" title="Cookie 的安全性"></a>Cookie 的安全性</h3></li>
<li>属性“HttpOnly”会告诉浏览器，此 Cookie 只能通过浏览器 HTTP 协议传输，禁止其他方式访问，浏览器的 JS 引擎就会禁用 document.cookie 等一切相关的 API，脚本攻击也就无从谈起了。</li>
<li>另一个属性“SameSite”可以防范“跨站请求伪造”（XSRF）攻击，设置成“SameSite=Strict”可以严格限定 Cookie 不能随着跳转链接跨站发送，而“SameSite=Lax”则略宽松一点，允许 GET/HEAD 等安全方法，但禁止 POST 跨站发送。</li>
<li>还有一个属性叫“Secure”，表示这个 Cookie 仅能用 HTTPS 协议加密传输，明文的 HTTP 协议会禁止发送。但 Cookie 本身不是加密的，浏览器里还是以明文的形式存在。</li>
</ul>
<h2 id="HTTP的缓存控制"><a href="#HTTP的缓存控制" class="headerlink" title="HTTP的缓存控制"></a>HTTP的缓存控制</h2><ul>
<li>缓存（Cache）是计算机领域里的一个重要概念，是优化系统性能的利器。</li>
<li>由于链路漫长，网络时延不可控，浏览器使用 HTTP 获取资源的成本较高。所以，非常有必要把“来之不易”的数据缓存起来，下次再请求的时候尽可能地复用。这样，就可以避免多次请求 - 应答的通信成本，节约网络带宽，也可以加快响应速度。<h3 id="服务器的缓存控制"><a href="#服务器的缓存控制" class="headerlink" title="服务器的缓存控制"></a>服务器的缓存控制</h3></li>
<li>服务器标记资源有效期使用的头字段是“Cache-Control”，里面的值“max-age=30”就是资源的有效时间，相当于告诉浏览器，“这个页面只能缓存 30 秒，之后就算是过期，不能用。”</li>
<li>这里的 max-age 是“生存时间”（又叫“新鲜度”“缓存寿命”，类似 TTL，Time-To-Live），时间的计算起点是响应报文的创建时刻（即 Date 字段，也就是离开服务器的时刻），而不是客户端收到报文的时刻，也就是说包含了在链路传输过程中所有节点所停留的时间。比如，服务器设定“max-age=5”，但因为网络质量很糟糕，等浏览器收到响应报文已经过去了 4 秒，那么这个资源在客户端就最多能够再存 1 秒钟，之后就会失效。</li>
<li>no-store：不允许缓存，用于某些变化非常频繁的数据，例如秒杀页面；</li>
<li>no-cache：它的字面含义容易与 no-store 搞混，实际的意思并不是不允许缓存，而是可以缓存，但在使用之前必须要去服务器验证是否过期，是否有最新的版本；<h3 id="客户端的缓存控制"><a href="#客户端的缓存控制" class="headerlink" title="客户端的缓存控制"></a>客户端的缓存控制</h3></li>
<li>当你点“刷新”按钮的时候，浏览器会在请求头里加一个“Cache-Control: max-age=0”。因为 max-age 是“生存时间”，max-age=0 的意思就是“我要一个最最新鲜的西瓜”，而本地缓存里的数据至少保存了几秒钟，所以浏览器就不会使用缓存，而是向服务器发请求。服务器看到 max-age=0，也就会用一个最新生成的报文回应浏览器。</li>
<li>Ctrl+F5 的“强制刷新”又是什么样的呢？它其实是发了一个“Cache-Control: no-cache”，含义和“max-age=0”基本一样，就看后台的服务器怎么理解，通常两者的效果是相同的。</li>
</ul>
<h3 id="条件请求"><a href="#条件请求" class="headerlink" title="条件请求"></a>条件请求</h3><ul>
<li>HTTP 协议定义了一系列“If”开头的“条件请求”字段，专门用来检查验证资源是否过期，把两个请求才能完成的工作合并在一个请求里做。而且，验证的责任也交给服务器，浏览器只需“坐享其成”。</li>
<li>条件请求一共有 5 个头字段，我们最常用的是“if-Modified-Since”和“If-None-Match”这两个。需要第一次的响应报文预先提供“Last-modified”和“ETag”，然后第二次请求时就可以带上缓存里的原值，验证资源是否是最新的。</li>
<li>ETag 是“实体标签”（Entity Tag）的缩写，是资源的一个唯一标识，主要是用来解决修改时间无法准确区分文件变化的问题。比如，一个文件在一秒内修改了多次，但因为修改时间是秒级，所以这一秒内的新版本无法区分。再比如，一个文件定期更新，但有时会是同样的内容，实际上没有变化，用修改时间就会误以为发生了变化，传送给浏览器就会浪费带宽。</li>
<li>使用 ETag 就可以精确地识别资源的变动情况，让浏览器能够更有效地利用缓存。ETag 还有“强”“弱”之分。强 ETag 要求资源在字节级别必须完全相符，弱 ETag 在值前有个“W/”标记，只要求资源在语义上没有变化，但内部可能会有部分发生了改变（例如 HTML 里的标签顺序调整，或者多了几个空格）。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">还是拿生鲜速递做比喻最容易理解：</span><br><span class="line">你打电话给超市，“我这个西瓜是 3 天前买的，还有最新的吗？”。超市看了一下库存，说：“没有啊，我这里都是 3 天前的。”于是你就知道了，再让超市送货也没用，还是吃冰箱里的西瓜吧。这就是“if-Modified-Since”和“Last-modified”。</span><br><span class="line">但你还是想要最新的，就又打电话：“有不是沙瓤的西瓜吗？”，超市告诉你都是沙瓤的（Match），于是你还是只能吃冰箱里的沙瓤西瓜。这就是“If-None-Match”和“弱 ETag”。</span><br><span class="line">第三次打电话，你说“有不是 8 斤的沙瓤西瓜吗？”，这回超市给了你满意的答复：“有个 10 斤的沙瓤西瓜”。于是，你就扔掉了冰箱里的存货，让超市重新送了一个新的大西瓜。这就是“If-None-Match”和“强 ETag”。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="HTTP的代理服务"><a href="#HTTP的代理服务" class="headerlink" title="HTTP的代理服务"></a>HTTP的代理服务</h2><ul>
<li>引入 HTTP 代理后，原来简单的双方通信就变复杂了一些，加入了一个或者多个中间人，但整体上来看，还是一个有顺序关系的链条，而且链条里相邻的两个角色仍然是简单的一对一通信，不会出现越级的情况。<h3 id="代理服务"><a href="#代理服务" class="headerlink" title="代理服务"></a>代理服务</h3></li>
<li>所谓的“代理服务”就是指服务本身不生产内容，而是处于中间位置转发上下游的请求和响应，具有双重身份：面向下游的用户时，表现为服务器，代表源服务器响应客户端的请求；而面向上游的源服务器时，又表现为客户端，代表客户端发送请求。<h3 id="代理的作用"><a href="#代理的作用" class="headerlink" title="代理的作用"></a>代理的作用</h3></li>
<li>你也许听过这样一句至理名言：“计算机科学领域里的任何问题，都可以通过引入一个中间层来解决”（在这句话后面还可以再加上一句“如果一个中间层解决不了问题，那就再加一个中间层”）。TCP/IP 协议栈是这样，而代理也是这样。</li>
<li>由于代理处在 HTTP 通信过程的中间位置，相应地就对上屏蔽了真实客户端，对下屏蔽了真实服务器，简单的说就是“欺上瞒下”。在这个中间层的“小天地”里就可以做很多的事情，为 HTTP 协议增加更多的灵活性，实现客户端和服务器的“双赢”。</li>
<li>代理最基本的一个功能是负载均衡。因为在面向客户端时屏蔽了源服务器，客户端看到的只是代理服务器，源服务器究竟有多少台、是哪些 IP 地址都不知道。于是代理服务器就可以掌握请求分发的“大权”，决定由后面的哪台服务器来响应请求。</li>
<li>代理中常用的负载均衡算法你应该也有所耳闻吧，比如轮询、一致性哈希等等，这些算法的目标都是尽量把外部的流量合理地分散到多台源服务器，提高系统的整体资源利用率和性能。</li>
<li>在负载均衡的同时，代理服务还可以执行更多的功能，比如：</li>
</ul>
<ol>
<li>健康检查：使用“心跳”等机制监控后端服务器，发现有故障就及时“踢出”集群，保证服务高可用；</li>
<li>安全防护：保护被代理的后端服务器，限制 IP 地址或流量，抵御网络攻击和过载；</li>
<li>加密卸载：对外网使用 SSL/TLS 加密通信认证，而在安全的内网不加密，消除加解密成本；</li>
<li>数据过滤：拦截上下行的数据，任意指定策略修改请求或者响应；</li>
<li>内容缓存：暂存、复用服务器响应<h3 id="代理相关头字段"><a href="#代理相关头字段" class="headerlink" title="代理相关头字段"></a>代理相关头字段</h3></li>
</ol>
<ul>
<li>首先，代理服务器需要用字段“Via”标明代理的身份。</li>
<li>Via 是一个通用字段，请求头或响应头里都可以出现。每当报文经过一个代理节点，代理服务器就会把自身的信息追加到字段的末尾，就像是经手人盖了一个章。</li>
<li>如果通信链路中有很多中间代理，就会在 Via 里形成一个链表，这样就可以知道报文究竟走过了多少个环节才到达了目的地。</li>
<li>服务器的 IP 地址应该是保密的，关系到企业的内网安全，所以一般不会让客户端知道。不过反过来，通常服务器需要知道客户端的真实 IP 地址，方便做访问控制、用户画像、统计分析。</li>
<li>“X-Forwarded-For”的字面意思是“为谁而转发”，形式上和“Via”差不多，也是每经过一个代理节点就会在字段里追加一个信息。但“Via”追加的是代理主机名（或者域名），而“X-Forwarded-For”追加的是请求方的 IP 地址。所以，在字段里最左边的 IP 地址就是客户端的地址。</li>
<li>“X-Real-IP”是另一种获取客户端真实 IP 的手段，它的作用很简单，就是记录客户端 IP 地址，没有中间的代理信息，相当于是“X-Forwarded-For”的简化版。如果客户端和源服务器之间只有一个代理，那么这两个字段的值就是相同的。<h3 id="代理协议"><a href="#代理协议" class="headerlink" title="代理协议"></a>代理协议</h3></li>
<li>通过“X-Forwarded-For”操作代理信息必须要解析 HTTP 报文头，这对于代理来说成本比较高，原本只需要简单地转发消息就好，而现在却必须要费力解析数据再修改数据，会降低代理的转发性能。</li>
<li>“X-Forwarded-For”等头必须要修改原始报文，而有些情况下是不允许甚至不可能的（比如使用 HTTPS 通信被加密）。</li>
<li>所以就出现了一个专门的“代理协议”（The PROXY protocol），它由知名的代理软件 HAProxy 所定义，也是一个“事实标准”，被广泛采用（注意并不是 RFC）。</li>
<li>“代理协议”有 v1 和 v2 两个版本，v1 和 HTTP 差不多，也是明文，而 v2 是二进制格式。</li>
<li>v1版本在 HTTP 报文前增加了一行 ASCII 码文本，相当于又多了一个头。这一行文本其实非常简单，开头必须是“PROXY”五个大写字母，然后是“TCP4”或者“TCP6”，表示客户端的 IP 地址类型，再后面是请求方地址、应答方地址、请求方端口号、应答方端口号，最后用一个回车换行（\r\n）结束。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">PROXY TCP4 1.1.1.1 2.2.2.2 55555 80\r\n</span><br><span class="line">GET / HTTP/1.1\r\n</span><br><span class="line">Host: www.xxx.com\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="HTTP的缓存代理"><a href="#HTTP的缓存代理" class="headerlink" title="HTTP的缓存代理"></a>HTTP的缓存代理</h2><ul>
<li>HTTP 传输链路上，不只是客户端有缓存，服务器上的缓存也是非常有价值的，可以让请求不必走完整个后续处理流程，“就近”获得响应结果。</li>
<li>特别是对于那些“读多写少”的数据，例如突发热点新闻、爆款商品的详情页，一秒钟内可能有成千上万次的请求。即使仅仅缓存数秒钟，也能够把巨大的访问流量挡在外面，让 RPS（request per second）降低好几个数量级，减轻应用服务器的并发压力，对性能的改善是非常显著的。</li>
<li>HTTP 的服务器缓存功能主要由代理服务器来实现（即缓存代理），而源服务器系统内部虽然也经常有各种缓存（如 Memcache、Redis、Varnish 等），但与 HTTP 没有太多关系<h3 id="缓存代理服务"><a href="#缓存代理服务" class="headerlink" title="缓存代理服务"></a>缓存代理服务</h3></li>
<li>在 HTTP 的缓存体系中，缓存代理的身份十分特殊，它“既是客户端，又是服务器”，同时也“既不是客户端，又不是服务器”。</li>
<li>说它“即是客户端又是服务器”，是因为它面向源服务器时是客户端，在面向客户端时又是服务器，所以它即可以用客户端的缓存控制策略也可以用服务器端的缓存控制策略</li>
<li>但缓存代理也“即不是客户端又不是服务器”，因为它只是一个数据的“中转站”，并不是真正的数据消费者和生产者，所以还需要有一些新的“Cache-Control”属性来对它做特别的约束。<h3 id="源服务器的缓存控制"><a href="#源服务器的缓存控制" class="headerlink" title="源服务器的缓存控制"></a>源服务器的缓存控制</h3></li>
<li>4 种服务器端的“Cache-Control”属性：max-age、no-store、no-cache 和 must-revalidate,这 4 种缓存属性可以约束客户端，也可以约束代理。</li>
<li>但客户端和代理是不一样的，客户端的缓存只是用户自己使用，而代理的缓存可能会为非常多的客户端提供服务。所以，需要对它的缓存再多一些限制条件。</li>
<li><p>首先，我们要区分客户端上的缓存和代理上的缓存，可以使用两个新属性“private”和“public”。“private”表示缓存只能在客户端保存，是用户“私有”的，不能放在代理上与别人共享。而“public”的意思就是缓存完全开放，谁都可以存，谁都可以用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比如你登录论坛，返回的响应报文里用“Set-Cookie”添加了论坛 ID，这就属于私人数据，不能存在代理上。不然，别人访问代理获取了被缓存的响应就麻烦了。</span><br></pre></td></tr></table></figure>
</li>
<li><p>其次，缓存失效后的重新验证也要区分开（即使用条件请求“Last-modified”和“ETag”），“must-revalidate”是只要过期就必须回源服务器验证，而新的“proxy-revalidate”只要求代理的缓存过期后必须验证，客户端不必回源，只验证到代理这个环节就行了。</p>
</li>
<li>再次，缓存的生存时间可以使用新的“s-maxage”（s 是 share 的意思，注意 maxage 中间没有“-”），只限定在代理上能够存多久，而客户端仍然使用“max-age”</li>
<li><p>还有一个代理专用的属性“no-transform”。代理有时候会对缓存下来的数据做一些优化，比如把图片生成 png、webp 等几种格式，方便今后的请求处理，而“no-transform”就会禁止这样做，不许“偷偷摸摸搞小动作”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这些新的缓存控制属性比较复杂，还是用“便利店冷柜”来举例好理解一些。</span><br><span class="line">水果上贴着标签“private, max-age=5”。这就是说水果不能放进冷柜，必须直接给顾客，保鲜期 5 天，过期了还得去超市重新进货。</span><br><span class="line">冻鱼上贴着标签“public, max-age=5, s-maxage=10”。这个的意思就是可以在冰柜里存 10 天，但顾客那里只能存 5 天，过期了可以来便利店取，只要在 10 天之内就不必再找超市。</span><br><span class="line">排骨上贴着标签“max-age=30, proxy-revalidate, no-transform”。因为缓存默认是 public 的，那么它在便利店和顾客的冰箱里就都可以存 30 天，过期后便利店必须去超市进新货，而且不能擅自把“大排”改成“小排”。</span><br></pre></td></tr></table></figure>
</li>
<li><p>源服务器在设置完“Cache-Control”后必须要为报文加上“Last-modified”或“ETag”字段。否则，客户端和代理后面就无法使用条件请求来验证缓存是否有效，也就不会有 304 缓存重定向。</p>
</li>
</ul>
<h3 id="客户端的缓存控制-1"><a href="#客户端的缓存控制-1" class="headerlink" title="客户端的缓存控制"></a>客户端的缓存控制</h3><ul>
<li>max-age、no-store、no-cache 这三个属性它们也是同样作用于代理和源服务器。</li>
<li>关于缓存的生存时间，多了两个新属性“max-stale”和“min-fresh”。</li>
<li><p>“max-stale”的意思是如果代理上的缓存过期了也可以接受，但不能过期太多，超过 x 秒也会不要。“min-fresh”的意思是缓存必须有效，而且必须在 x 秒后依然有效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">比如，草莓上贴着标签“max-age=5”，现在已经在冰柜里存了 7 天。如果有请求“max-stale=2”，意思是过期两天也能接受，所以刚好能卖出去。</span><br><span class="line">但要是“min-fresh=1”，这是绝对不允许过期的，就不会买走。这时如果有另外一个菠萝是“max-age=10”，那么“7+1&lt;10”，在一天之后还是新鲜的，所以就能卖出去。</span><br></pre></td></tr></table></figure>
</li>
<li><p>有的时候客户端还会发出一个特别的“only-if-cached”属性，表示只接受代理缓存的数据，不接受源服务器的响应。如果代理上没有缓存或者缓存过期，就应该给客户端返回一个 504（Gateway Timeout）。</p>
</li>
</ul>
<h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><ul>
<li>第一个是“Vary”字段，它是内容协商的结果，相当于报文的一个版本标记。同一个请求，经过内容协商后可能会有不同的字符集、编码、浏览器等版本。比如，“Vary: Accept-Encoding”“Vary: User-Agent”，缓存代理必须要存储这些不同的版本。当再收到相同的请求时，代理就读取缓存里的“Vary”，对比请求头里相应的“ Accept-Encoding”“User-Agent”等字段，如果和上一个请求的完全匹配，比如都是“gzip”“Chrome”，就表示版本一致，可以返回缓存的数据。</li>
<li>另一个问题是“Purge”，也就是“缓存清理”，它对于代理也是非常重要的功能，例如：</li>
</ul>
<ol>
<li>过期的数据应该及时淘汰，避免占用空间；</li>
<li>源站的资源有更新，需要删除旧版本，主动换成最新版（即刷新）；</li>
<li>有时候会缓存了一些本不该存储的信息，例如网络谣言或者危险链接，必须尽快把它们删除。<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3></li>
</ol>
<ul>
<li>计算机领域里最常用的性能优化手段是“时空转换”，也就是“时间换空间”或者“空间换时间”，HTTP 缓存属于后者；</li>
<li>缓存代理是增加了缓存功能的代理服务，缓存源服务器的数据，分发给下游的客户端；</li>
<li>“Cache-Control”字段也可以控制缓存代理，常用的有“private”“s-maxage”“no-transform”等，同样必须配合“Last-modified”“ETag”等字段才能使用；</li>
<li>缓存代理有时候也会带来负面影响，缓存不良数据，需要及时刷新或删除。</li>
</ul>
<h2 id="HTTPS是什么？SSL-TLS又是什么？"><a href="#HTTPS是什么？SSL-TLS又是什么？" class="headerlink" title="HTTPS是什么？SSL/TLS又是什么？"></a>HTTPS是什么？SSL/TLS又是什么？</h2><ul>
<li>为什么要有 HTTPS？简单的回答是“因为 HTTP 不安全”。由于 HTTP 天生“明文”的特点，整个传输过程完全透明，任何人都能够在链路中截获、修改或者伪造请求 / 响应报文，数据不具有可信性。</li>
<li>“代理服务”。它作为 HTTP 通信的中间人，在数据上下行的时候可以添加或删除部分头字段，也可以使用黑白名单过滤 body 里的关键字，甚至直接发送虚假的请求、响应，而浏览器和源服务器都没有办法判断报文的真伪。<h3 id="什么是安全？"><a href="#什么是安全？" class="headerlink" title="什么是安全？"></a>什么是安全？</h3></li>
<li>通常认为，如果通信过程具备了四个特性，就可以认为是“安全”的，这四个特性是：机密性、完整性，身份认证和不可否认。</li>
</ul>
<ol>
<li>机密性（Secrecy/Confidentiality）是指对数据的“保密”，只能由可信的人访问，对其他人是不可见的“秘密”，简单来说就是不能让不相关的人看到不该看的东西。</li>
<li>完整性（Integrity，也叫一致性）是指数据在传输过程中没有被篡改，不多也不少，“完完整整”地保持着原状。</li>
<li>身份认证（Authentication）是指确认对方的真实身份，也就是“证明你真的是你”，保证消息只能发送给可信的人。</li>
<li>不可否认（Non-repudiation/Undeniable），也叫不可抵赖，意思是不能否认已经发生过的行为，不能“说话不算数”“耍赖皮”。<h3 id="什么是-HTTPS？"><a href="#什么是-HTTPS？" class="headerlink" title="什么是 HTTPS？"></a>什么是 HTTPS？</h3></li>
</ol>
<ul>
<li>默认端口号 443，HTTPS 与 HTTP 最大的区别，它能够鉴别危险的网站，并且尽最大可能保证你的上网安全，防御黑客对信息的窃听、篡改或者“钓鱼”、伪造。</li>
<li>它把 HTTP 下层的传输协议由 TCP/IP 换成了 SSL/TLS，由“HTTP over TCP/IP”变成了“HTTP over SSL/TLS”，让 HTTP 运行在了安全的 SSL/TLS 协议上，收发报文不再使用 Socket API，而是调用专门的安全接口。<h3 id="SSL-TLS"><a href="#SSL-TLS" class="headerlink" title="SSL/TLS"></a>SSL/TLS</h3></li>
<li>SSL 即安全套接层（Secure Sockets Layer），在 OSI 模型中处于第 5 层（会话层），由网景公司于 1994 年发明，有 v2 和 v3 两个版本，而 v1 因为有严重的缺陷从未公开过。</li>
<li>SSL 发展到 v3 时已经证明了它自身是一个非常好的安全通信协议，于是互联网工程组 IETF 在 1999 年把它改名为 TLS（传输层安全，Transport Layer Security），正式标准化，版本号从 1.0 重新算起，所以 TLS1.0 实际上就是 SSLv3.1。到今天 TLS 已经发展出了三个版本，分别是 2006 年的 1.1、2008 年的 1.2 和去年（2018）的 1.3，每个新版本都紧跟密码学的发展和互联网的现状，持续强化安全和性能，已经成为了信息安全领域中的权威标准。目前应用的最广泛的 TLS 是 1.2，而之前的协议（TLS1.1/1.0、SSLv3/v2）都已经被认为是不安全的，各大浏览器即将在 2020 年左右停止支持，所以接下来的讲解都针对的是 TLS1.2。</li>
<li>TLS 由记录协议、握手协议、警告协议、变更密码规范协议、扩展协议等几个子协议组成，综合使用了对称加密、非对称加密、身份认证等许多密码学前沿技术。</li>
<li>浏览器和服务器在使用 TLS 建立连接时需要选择一组恰当的加密算法来实现安全通信，这些算法的组合被称为“密码套件”（cipher suite，也叫加密套件）。</li>
<li>TLS 的密码套件命名非常规范，格式很固定。基本的形式是“密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法”<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">“ECDHE-RSA-AES256-GCM-SHA384”</span><br><span class="line"></span><br><span class="line">“握手时使用 ECDHE 算法进行密钥交换，用 RSA 签名和身份认证，握手后的通信使用 AES 对称算法，密钥长度 256 位，分组模式是 GCM，摘要算法 SHA384 用于消息认证和产生随机数。”</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="OpenSSL"><a href="#OpenSSL" class="headerlink" title="OpenSSL"></a>OpenSSL</h3><ul>
<li>它是一个著名的开源密码学程序库和工具包，几乎支持所有公开的加密算法和协议，已经成为了事实上的标准，许多应用软件都会使用它作为底层库来实现 TLS 功能，包括常用的 Web 服务器 Apache、Nginx 等。</li>
</ul>
<h2 id="对称加密与非对称加密"><a href="#对称加密与非对称加密" class="headerlink" title="对称加密与非对称加密"></a>对称加密与非对称加密</h2><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><ul>
<li><p>加密和解密时使用的密钥都是同一个，是“对称”的。只要保证了密钥的安全，那整个通信过程就可以说具有了机密性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">举个例子，你想要登录某网站，只要事先和它约定好使用一个对称密钥，通信过程中传输的全是用密钥加密后的密文，只有你和网站才能解密。黑客即使能够窃听，看到的也只是乱码，因为没有密钥无法解出明文，所以就实现了机密性。</span><br></pre></td></tr></table></figure>
</li>
<li><p>TLS 里有非常多的对称加密算法可供选择，比如 RC4、DES、3DES、AES、ChaCha20 等，但前三种算法都被认为是不安全的，通常都禁止使用，目前常用的只有 AES 和 ChaCha20。</p>
<h3 id="加密分组模式"><a href="#加密分组模式" class="headerlink" title="加密分组模式"></a>加密分组模式</h3></li>
<li>对称算法还有一个“分组模式”的概念，它可以让算法用固定长度的密钥加密任意长度的明文，把小秘密（即密钥）转化为大秘密（即密文）。</li>
<li>最新的分组模式被称为 AEAD（Authenticated Encryption with Associated Data），在加密的同时增加了认证的功能，常用的是 GCM、CCM 和 Poly1305。把上面这些组合起来，就可以得到 TLS 密码套件中定义的对称加密算法。<h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3></li>
<li>它有两个密钥，一个叫“公钥”（public key），一个叫“私钥”（private key）。两个密钥是不同的，“不对称”，公钥可以公开给任何人使用，而私钥必须严格保密。</li>
<li>因为在对称加密算法中只要持有密钥就可以解密。如果你和网站约定的密钥在传递途中被黑客窃取，那他就可以在之后随意解密收发的数据，通信过程也就没有机密性可言了。</li>
<li>公钥和私钥有个特别的“单向”性，虽然都可以用来加密解密，但公钥加密后只能用私钥解密，反过来，私钥加密后也只能用公钥解密。<h3 id="混合加密"><a href="#混合加密" class="headerlink" title="混合加密"></a>混合加密</h3></li>
<li>很遗憾，虽然非对称加密没有“密钥交换”的问题，但因为它们都是基于复杂的数学难题，运算速度很慢，即使是 ECC 也要比 AES 差上好几个数量级。如果仅用非对称加密，虽然保证了安全，但通信速度有如乌龟、蜗牛，实用性就变成了零。</li>
<li>在通信刚开始的时候使用非对称算法，比如 RSA、ECDHE，首先解决密钥交换的问题。</li>
<li>然后用随机数产生对称算法使用的“会话密钥”（session key），再用公钥加密。因为会话密钥很短，通常只有 16 字节或 32 字节，所以慢一点也无所谓。</li>
</ul>
<h2 id="数字签名与证书"><a href="#数字签名与证书" class="headerlink" title="数字签名与证书"></a>数字签名与证书</h2><ul>
<li>黑客虽然拿不到会话密钥，无法破解密文，但可以通过窃听收集到足够多的密文，再尝试着修改、重组后发给网站。因为没有完整性保证，服务器只能“照单全收”，然后他就可以通过服务器的响应获取进一步的线索，最终就会破解出明文。</li>
<li>黑客也可以伪造身份发布公钥。如果你拿到了假的公钥，混合加密就完全失效了。你以为自己是在和“某宝”通信，实际上网线的另一端却是黑客，银行卡号、密码等敏感信息就在“安全”的通信过程中被窃取了。</li>
<li>所以，在机密性的基础上还必须加上完整性、身份认证等特性，才能实现真正的安全。<h3 id="摘要算法"><a href="#摘要算法" class="headerlink" title="摘要算法"></a>摘要算法</h3></li>
<li>实现完整性的手段主要是摘要算法（Digest Algorithm），也就是常说的散列函数、哈希函数（Hash Function）。</li>
<li>你可以把摘要算法近似地理解成一种特殊的压缩算法，它能够把任意长度的数据“压缩”成固定长度、而且独一无二的“摘要”字符串，就好像是给这段数据生成了一个数字“指纹”。</li>
<li>换一个角度，也可以把摘要算法理解成特殊的“单向”加密算法，它只有算法，没有密钥，加密后的数据无法解密，不能从摘要逆推出原文。</li>
<li>摘要算法实际上是把数据从一个“大空间”映射到了“小空间”，所以就存在“冲突”（collision，也叫碰撞）的可能性，就如同现实中的指纹一样，可能会有两份不同的原文对应相同的摘要。好的摘要算法必须能够“抵抗冲突”，让这种可能性尽量地小。</li>
<li>你一定在日常工作中听过、或者用过 MD5（Message-Digest 5）、SHA-1（Secure Hash Algorithm 1），它们就是最常用的两个摘要算法，能够生成 16 字节和 20 字节长度的数字摘要。但这两个算法的安全强度比较低，不够安全，在 TLS 里已经被禁止使用了。<h3 id="完整性"><a href="#完整性" class="headerlink" title="完整性"></a>完整性</h3></li>
<li>摘要算法保证了“数字摘要”和原文是完全等价的。所以，我们只要在原文后附上它的摘要，就能够保证数据的完整性。</li>
<li>不过摘要算法不具有机密性，如果明文传输，那么黑客可以修改消息后把摘要也一起改了，网站还是鉴别不出完整性。</li>
<li>所以，真正的完整性必须要建立在机密性之上，在混合加密系统里用会话密钥加密消息和摘要，这样黑客无法得知明文，也就没有办法动手脚了。<h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3></li>
<li>加密算法结合摘要算法，我们的通信过程可以说是比较安全了。但这里还有漏洞，就是通信的两个端点（endpoint）。</li>
<li>就像一开始所说的，黑客可以伪装成网站来窃取信息。而反过来，他也可以伪装成你，向网站发送支付、转账等消息，网站没有办法确认你的身份，钱可能就这么被偷走了。</li>
<li>现实生活中，解决身份认证的手段是签名和印章，只要在纸上写下签名或者盖个章，就能够证明这份文件确实是由本人而不是其他人发出的。</li>
<li>使用私钥再加上摘要算法，就能够实现“数字签名”，同时实现“身份认证”和“不可否认”。<h3 id="数字证书和-CA"><a href="#数字证书和-CA" class="headerlink" title="数字证书和 CA"></a>数字证书和 CA</h3></li>
<li>CA（Certificate Authority，证书认证机构）。它就像网络世界里的公安局、教育部、公证中心，具有极高的可信度，由它来给各个公钥签名，用自身的信誉来保证公钥无法伪造，是可信的。</li>
<li>CA 对公钥的签名认证也是有格式的，不是简单地把公钥绑定在持有者身份上就完事了，还要包含序列号、用途、颁发者、有效时间等等，把这些打成一个包再签名，完整地证明公钥关联的各种信息，形成“数字证书”（Certificate）。</li>
<li>有了这个证书体系，操作系统和浏览器都内置了各大 CA 的根证书，上网的时候只要服务器发过来它的证书，就可以验证证书里的签名，顺着证书链（Certificate Chain）一层层地验证，直到找到根证书，就能够确定证书是可信的，从而里面的公钥也是可信的。</li>
</ul>
<h3 id="证书体系的弱点"><a href="#证书体系的弱点" class="headerlink" title="证书体系的弱点"></a>证书体系的弱点</h3><ul>
<li>如果 CA 失误或者被欺骗，签发了错误的证书，虽然证书是真的，可它代表的网站却是假的。</li>
<li>还有一种更危险的情况，CA 被黑客攻陷，或者 CA 有恶意，因为它（即根证书）是信任的源头，整个信任链里的所有证书也就都不可信了。</li>
<li>针对第一种，开发出了 CRL（证书吊销列表，Certificate revocation list）和 OCSP（在线证书状态协议，Online Certificate Status Protocol），及时废止有问题的证书。</li>
<li>对于第二种，因为涉及的证书太多，就只能操作系统或者浏览器从根上“下狠手”了，撤销对 CA 的信任，列入“黑名单”，这样它颁发的所有证书就都会被认为是不安全的。</li>
</ul>
<h2 id="TLS1-2连接过程解析"><a href="#TLS1-2连接过程解析" class="headerlink" title="TLS1.2连接过程解析"></a>TLS1.2连接过程解析</h2><h3 id="HTTPS-建立连接"><a href="#HTTPS-建立连接" class="headerlink" title="HTTPS 建立连接"></a>HTTPS 建立连接</h3><ul>
<li>当你在浏览器地址栏里键入“https”开头的 URI，再按下回车，会发生什么呢？</li>
</ul>
<ol>
<li>浏览器首先要从 URI 里提取出协议名和域名。因为协议名是“https”，所以浏览器就知道了端口号是默认的 443，它再用 DNS 解析域名，得到目标的 IP 地址，然后就可以使用三次握手与网站建立 TCP 连接了。</li>
<li>在 HTTP 协议里，建立连接后，浏览器会立即发送请求报文。但现在是 HTTPS 协议，它需要再用另外一个“握手”过程，在 TCP 上建立安全连接，之后才是收发 HTTP 报文。这个“握手”过程与 TCP 有些类似，是 HTTPS 和 TLS 协议里最重要、最核心的部分。<h3 id="TLS-协议的组成"><a href="#TLS-协议的组成" class="headerlink" title="TLS 协议的组成"></a>TLS 协议的组成</h3></li>
</ol>
<ul>
<li>TLS 包含几个子协议，你也可以理解为它是由几个不同职责的模块组成，比较常用的有记录协议、警报协议、握手协议、变更密码规范协议等。</li>
</ul>
<ol>
<li>记录协议（Record Protocol）规定了 TLS 收发数据的基本单位：记录（record）。它有点像是 TCP 里的 segment，所有的其他子协议都需要通过记录协议发出。但多个记录数据可以在一个 TCP 包里一次性发出，也并不需要像 TCP 那样返回 ACK。</li>
<li>警报协议（Alert Protocol）的职责是向对方发出警报信息，有点像是 HTTP 协议里的状态码。比如，protocol_version 就是不支持旧版本，bad_certificate 就是证书有问题，收到警报后另一方可以选择继续，也可以立即终止连接。</li>
<li>握手协议（Handshake Protocol）是 TLS 里最复杂的子协议，要比 TCP 的 SYN/ACK 复杂的多，浏览器和服务器会在握手过程中协商 TLS 版本号、随机数、密码套件等信息，然后交换证书和密钥参数，最终双方协商得到会话密钥，用于后续的混合加密系统。</li>
<li>变更密码规范协议（Change Cipher Spec Protocol），它非常简单，就是一个“通知”，告诉对方，后续的数据都将使用加密保护。那么反过来，在它之前，数据都是明文的。<h3 id="ECDHE-握手过程"><a href="#ECDHE-握手过程" class="headerlink" title="ECDHE 握手过程"></a>ECDHE 握手过程</h3></li>
</ol>
<ul>
<li>在 TCP 建立连接之后，浏览器会首先发一个“Client Hello”消息，也就是跟服务器“打招呼”。里面有客户端的版本号、支持的密码套件，还有一个随机数（Client Random），用于后续生成会话密钥。这个的意思就是：“我这边有这些这些信息，你看看哪些是能用的，关键的随机数可得留着。”</li>
<li>作为“礼尚往来”，服务器收到“Client Hello”后，会返回一个“Server Hello”消息。把版本号对一下，也给出一个随机数（Server Random），然后从客户端的列表里选一个作为本次通信使用的密码套件，在这里它选择了“TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384”。这个的意思就是：“版本号对上了，可以加密，你的密码套件挺多，我选一个最合适的吧，用椭圆曲线加 RSA、AES、SHA384。我也给你一个随机数，你也得留着。”</li>
<li>然后，服务器为了证明自己的身份，就把证书也发给了客户端（Server Certificate）。</li>
<li>接下来是一个关键的操作，因为服务器选择了 ECDHE 算法，所以它会在证书后发送“Server Key Exchange”消息，里面是椭圆曲线的公钥（Server Params），用来实现密钥交换算法，再加上自己的私钥签名认证。这相当于说：“刚才我选的密码套件有点复杂，所以再给你个算法的参数，和刚才的随机数一样有用，别丢了。为了防止别人冒充，我又盖了个章。”</li>
<li>之后是“Server Hello Done”消息，服务器说：“我的信息就是这些，打招呼完毕。”</li>
<li>这样第一个消息往返就结束了（两个 TCP 包），结果是客户端和服务器通过明文共享了三个信息：Client Random、Server Random 和 Server Params。</li>
<li>客户端这时也拿到了服务器的证书，那这个证书是不是真实有效的呢？开始走证书链逐级验证，确认证书的真实性，再用证书公钥验证签名，就确认了服务器的身份：“刚才跟我打招呼的不是骗子，可以接着往下走。”</li>
<li>然后，客户端按照密码套件的要求，也生成一个椭圆曲线的公钥（Client Params），用“Client Key Exchange”消息发给服务器。</li>
<li>现在客户端和服务器手里都拿到了密钥交换算法的两个参数（Client Params、Server Params），就用 ECDHE 算法一阵算，算出了一个新的东西，叫“Pre-Master”，其实也是一个随机数。</li>
<li>现在客户端和服务器手里有了三个随机数：Client Random、Server Random 和 Pre-Master。用这三个作为原始材料，就可以生成用于加密会话的主密钥，叫“Master Secret”。而黑客因为拿不到“Pre-Master”，所以也就得不到主密钥。</li>
<li>为什么非得这么麻烦，非要三个随机数呢？这就必须说 TLS 的设计者考虑得非常周到了，他们不信任客户端或服务器伪随机数的可靠性，为了保证真正的“完全随机”“不可预测”，把三个不可靠的随机数混合起来，那么“随机”的程度就非常高了，足够让黑客难以猜测。</li>
<li>主密钥有 48 字节，但它也不是最终用于通信的会话密钥，还会再用 PRF （这里的“PRF”就是伪随机数函数，它基于密码套件里的最后一个参数，比如这次的 SHA384，通过摘要算法来再一次强化“Master Secret”的随机性）扩展出更多的密钥，比如客户端发送用的会话密钥（client_write_key）、服务器发送用的会话密钥（server_write_key）等等，避免只用一个密钥带来的安全隐患。</li>
<li>有了主密钥和派生的会话密钥，握手就快结束了。客户端发一个“Change Cipher Spec”，然后再发一个“Finished”消息，把之前所有发送的数据做个摘要，再加密一下，让服务器做个验证。意思就是告诉服务器：“后面都改用对称算法加密通信了啊，用的就是打招呼时说的 AES，加密对不对还得你测一下。”</li>
<li>服务器也是同样的操作，发“Change Cipher Spec”和“Finished”消息，双方都验证加密解密 OK，握手正式结束，后面就收发被加密的 HTTP 请求和响应了。<h3 id="RSA-握手过程"><a href="#RSA-握手过程" class="headerlink" title="RSA 握手过程"></a>RSA 握手过程</h3></li>
<li>第一个，使用 ECDHE 实现密钥交换，而不是 RSA，所以会在服务器端发出“Server Key Exchange”消息。</li>
<li>第二个，因为使用了 ECDHE，客户端可以不用等到服务器发回“Finished”确认握手完毕，立即就发出 HTTP 报文，省去了一个消息往返的时间浪费。这个叫“TLS False Start”，意思就是“抢跑”，和“TCP Fast Open”有点像，都是不等连接完全建立就提前发应用数据，提高传输的效率。</li>
<li>RSA 握手过程大体的流程没有变，只是“Pre-Master”不再需要用算法生成，而是客户端直接生成随机数，然后用服务器的公钥加密，通过“Client Key Exchange”消息发给服务器。服务器再用私钥解密，这样双方也实现了共享三个随机数，就可以生成主密钥。<h3 id="双向认证"><a href="#双向认证" class="headerlink" title="双向认证"></a>双向认证</h3></li>
<li>但为了防止账号、密码被盗，有的时候（比如网上银行）还会使用 U 盾给用户颁发客户端证书，实现“双向认证”，这样会更加安全。</li>
<li>双向认证的流程也没有太多变化，只是在“Server Hello Done”之后，“Client Key Exchange”之前，客户端要发送“Client Certificate”消息，服务器收到后也把证书链走一遍，验证客户端的身份。</li>
</ul>
<h2 id="TLS1-3特性解析"><a href="#TLS1-3特性解析" class="headerlink" title="TLS1.3特性解析"></a>TLS1.3特性解析</h2><h3 id="强化安全"><a href="#强化安全" class="headerlink" title="强化安全"></a>强化安全</h3><ul>
<li>TLS1.2 在十来年的应用中获得了许多宝贵的经验，陆续发现了很多的漏洞和加密算法的弱点，所以 TLS1.3 就在协议里修补了这些不安全因素。</li>
</ul>
<ol>
<li>伪随机数函数由 PRF 升级为 HKDF（HMAC-based Extract-and-Expand Key Derivation Function）；</li>
<li>明确禁止在记录协议里使用压缩；</li>
<li>废除了 RC4、DES 对称加密算法；</li>
<li>废除了 ECB、CBC 等传统分组模式；</li>
<li>废除了 MD5、SHA1、SHA-224 摘要算法；</li>
<li>废除了 RSA、DH 密钥交换算法和许多命名曲线。</li>
</ol>
<ul>
<li>经过这一番“减肥瘦身”之后，TLS1.3 里只保留了 AES、ChaCha20 对称加密算法，分组模式只能用 AEAD 的 GCM、CCM 和 Poly1305，摘要算法只能用 SHA256、SHA384，密钥交换算法只有 ECDHE 和 DHE，椭圆曲线也被“砍”到只剩 P-256 和 x25519 等 5 种。现在的 TLS1.3 里只有 5 个套件，无论是客户端还是服务器都不会再犯“选择困难症”了。</li>
<li>浏览器默认会使用 ECDHE 而不是 RSA 做密钥交换，这是因为它不具有“前向安全”（Forward Secrecy）。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">假设有这么一个很有耐心的黑客，一直在长期收集混合加密系统收发的所有报文。</span><br><span class="line">如果加密系统使用服务器证书里的 RSA 做密钥交换，一旦私钥泄露或被破解（使用社会工程学或者巨型计算机），那么黑客就能够使用私钥解密出之前所有报文的“Pre-Master”，再算出会话密钥，破解所有密文。</span><br><span class="line">这就是所谓的“今日截获，明日破解”。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">而 ECDHE 算法在每次握手时都会生成一对临时的公钥和私钥，每次通信的密钥对都是不同的，也就是“一次一密”，即使黑客花大力气破解了这一次的会话密钥，也只是这次通信被攻击，之前的历史消息不会受到影响，仍然是安全的。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="提升性能"><a href="#提升性能" class="headerlink" title="提升性能"></a>提升性能</h3><ul>
<li>HTTPS 建立连接时除了要做 TCP 握手，还要做 TLS 握手，在 1.2 中会多花两个消息往返（2-RTT），可能导致几十毫秒甚至上百毫秒的延迟，在移动网络中延迟还会更严重</li>
<li>TLS1.3 压缩了以前的“Hello”协商过程，删除了“Key Exchange”消息，把握手时间减少到了“1-RTT”，效率提高了一倍。<h3 id="握手分析"><a href="#握手分析" class="headerlink" title="握手分析"></a>握手分析</h3></li>
<li>在 TCP 建立连接之后，浏览器首先还是发一个“Client Hello”。注意“Client Hello”里的扩展，“supported_versions”表示这是 TLS1.3，“supported_groups”是支持的曲线，“key_share”是曲线对应的参数。这就好像是说：“还是照老规矩打招呼，这边有这些这些信息。但我猜你可能会升级，所以再多给你一些东西，也许后面用的上，咱们有话尽量一口气说完。”</li>
<li>服务器收到“Client Hello”同样返回“Server Hello”消息，还是要给出一个随机数（Server Random）和选定密码套件。“supported_versions”里确认使用的是 TLS1.3，然后在“key_share”扩展带上曲线和对应的公钥参数。</li>
<li>这时只交换了两条消息，客户端和服务器就拿到了四个共享信息：Client Random 和 Server Random、Client Params 和 Server Params，两边就可以各自用 ECDHE 算出“Pre-Master”，再用 HKDF 生成主密钥“Master Secret”，效率比 TLS1.2 提高了一大截。</li>
<li>在算出主密钥后，服务器立刻发出“Change Cipher Spec”消息，比 TLS1.2 提早进入加密通信，后面的证书等就都是加密的了，减少了握手时的明文信息泄露。</li>
<li>这里 TLS1.3 还有一个安全强化措施，多了个“Certificate Verify”消息，用服务器的私钥把前面的曲线、套件、参数等握手数据加了签名，作用和“Finished”消息差不多。但由于是私钥签名，所以强化了身份认证和和防窜改。</li>
<li>这两个“Hello”消息之后，客户端验证服务器证书，再发“Finished”消息，就正式完成了握手，开始收发 HTTP 报文。</li>
</ul>
<h2 id="HTTPS的优化"><a href="#HTTPS的优化" class="headerlink" title="HTTPS的优化"></a>HTTPS的优化</h2><ul>
<li>HTTPS 连接大致上可以划分为两个部分，第一个是建立连接时的非对称加密握手，第二个是握手后的对称加密报文传输。</li>
<li>由于目前流行的 AES、ChaCha20 性能都很好，还有硬件优化，报文传输的性能损耗可以说是非常地小，小到几乎可以忽略不计了。所以，通常所说的“HTTPS 连接慢”指的就是刚开始建立连接的那段时间。</li>
<li>在 TCP 建连之后，正式数据传输之前，HTTPS 比 HTTP 增加了一个 TLS 握手的步骤，这个步骤最长可以花费两个消息往返，也就是 2-RTT。而且在握手消息的网络耗时之外，还会有其他的一些“隐形”消耗，比如：</li>
</ul>
<ol>
<li>产生用于密钥交换的临时公私钥对（ECDHE）</li>
<li>验证证书时访问 CA 获取 CRL 或者 OCSP；</li>
<li>非对称加密解密处理“Pre-Master”。</li>
</ol>
<ul>
<li>在最差的情况下，也就是不做任何的优化措施，HTTPS 建立连接可能会比 HTTP 慢上几百毫秒甚至几秒，这其中既有网络耗时，也有计算耗时，就会让人产生“打开一个 HTTPS 网站好慢啊”的感觉。不过刚才说的情况早就是“过去时”了，现在已经有了很多行之有效的 HTTPS 优化手段，运用得好可以把连接的额外耗时降低到几十毫秒甚至是“零”。<h3 id="硬件优化"><a href="#硬件优化" class="headerlink" title="硬件优化"></a>硬件优化</h3></li>
<li>HTTPS 连接是计算密集型，而不是 I/O 密集型。所以，如果你花大价钱去买网卡、带宽、SSD 存储就是“南辕北辙”了，起不到优化的效果。</li>
<li>首先，你可以选择更快的 CPU，最好还内建 AES 优化，这样即可以加速握手，也可以加速传输。</li>
<li>其次，你可以选择“SSL 加速卡”，加解密时调用它的 API，让专门的硬件来做非对称加解密，分担 CPU 的计算压力。不过“SSL 加速卡”也有一些缺点，比如升级慢、支持算法有限，不能灵活定制解决方案等。</li>
<li>所以，就出现了第三种硬件加速方式：“SSL 加速服务器”，用专门的服务器集群来彻底“卸载”TLS 握手时的加密解密计算，性能自然要比单纯的“加速卡”要强大的多。<h3 id="软件优化"><a href="#软件优化" class="headerlink" title="软件优化"></a>软件优化</h3></li>
<li>软件方面的优化还可以再分成两部分：一个是软件升级，一个是协议优化。</li>
<li>软件升级实施起来比较简单，就是把现在正在使用的软件尽量升级到最新版本，比如把 Linux 内核由 2.x 升级到 4.x，把 Nginx 由 1.6 升级到 1.16，把 OpenSSL 由 1.0.1 升级到 1.1.0/1.1.1。</li>
<li>但对于很多大中型公司来说，硬件升级或软件升级都是个棘手的问题，有成千上万台各种型号的机器遍布各个机房，逐一升级不仅需要大量人手，而且有较高的风险，可能会影响正常的线上服务。<h3 id="协议优化"><a href="#协议优化" class="headerlink" title="协议优化"></a>协议优化</h3></li>
<li>如果有可能，应当尽量采用 TLS1.3，它大幅度简化了握手的过程，完全握手只要 1-RTT，而且更加安全。</li>
<li>如果暂时不能升级到 1.3，只能用 1.2，那么握手时使用的密钥交换协议应当尽量选用椭圆曲线的 ECDHE 算法。它不仅运算速度快，安全性高，还支持“False Start”，能够把握手的消息往返由 2-RTT 减少到 1-RTT，达到与 TLS1.3 类似的效果。</li>
<li>另外，椭圆曲线也要选择高性能的曲线，最好是 x25519，次优选择是 P-256。对称加密算法方面，也可以选用“AES_128_GCM”，它能比“AES_256_GCM”略快一点点。</li>
<li>在 Nginx 里可以用“ssl_ciphers”“ssl_ecdh_curve”等指令配置服务器使用的密码套件和椭圆曲线，把优先使用的放在前面，例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ssl_ciphers   TLS13-AES-256-GCM-SHA384:TLS13-CHACHA20-POLY1305-SHA256:EECDH+CHACHA20；</span><br><span class="line">ssl_ecdh_curve              X25519:P-256;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="证书优化"><a href="#证书优化" class="headerlink" title="证书优化"></a>证书优化</h3><ul>
<li>这里就有两个优化点，一个是证书传输，一个是证书验证。</li>
<li>服务器的证书可以选择椭圆曲线（ECDSA）证书而不是 RSA 证书，因为 224 位的 ECC 相当于 2048 位的 RSA，所以椭圆曲线证书的“个头”要比 RSA 小很多，即能够节约带宽也能减少客户端的运算量，可谓“一举两得”。</li>
<li>客户端的证书验证其实是个很复杂的操作，除了要公钥解密验证多个证书签名外，因为证书还有可能会被撤销失效，客户端有时还会再去访问 CA，下载 CRL 或者 OCSP 数据，这又会产生 DNS 查询、建立连接、收发数据等一系列网络通信，增加好几个 RTT。</li>
<li>CRL（Certificate revocation list，证书吊销列表）由 CA 定期发布，里面是所有被撤销信任的证书序号，查询这个列表就可以知道证书是否有效。但 CRL 因为是“定期”发布，就有“时间窗口”的安全隐患，而且随着吊销证书的增多，列表会越来越大，一个 CRL 经常会上 MB。想象一下，每次需要预先下载几 M 的“无用数据”才能连接网站，实用性实在是太低了。</li>
<li>所以，现在 CRL 基本上不用了，取而代之的是 OCSP（在线证书状态协议，Online Certificate Status Protocol），向 CA 发送查询请求，让 CA 返回证书的有效状态。</li>
<li>但 OCSP 也要多出一次网络请求的消耗，而且还依赖于 CA 服务器，如果 CA 服务器很忙，那响应延迟也是等不起的。于是又出来了一个“补丁”，叫“OCSP Stapling”（OCSP 装订），它可以让服务器预先访问 CA 获取 OCSP 响应，然后在握手时随着证书一起发给客户端，免去了客户端连接 CA 服务器查询的时间。<h3 id="会话复用"><a href="#会话复用" class="headerlink" title="会话复用"></a>会话复用</h3></li>
<li>HTTPS 建立连接的过程：先是 TCP 三次握手，然后是 TLS 一次握手。这后一次握手的重点是算出主密钥“Master Secret”，而主密钥每次连接都要重新计算，未免有点太浪费了，如果能够把“辛辛苦苦”算出来的主密钥缓存一下“重用”，不就可以免去了握手和计算的成本了吗？这种做法就叫“会话复用”（TLS session resumption），和 HTTP Cache 一样，也是提高 HTTPS 性能的“大杀器”，被浏览器和服务器广泛应用。</li>
<li>会话复用分两种，第一种叫“Session ID”，就是客户端和服务器首次连接后各自保存一个会话的 ID 号，内存里存储主密钥和其他相关的信息。当客户端再次连接时发一个 ID 过来，服务器就在内存里找，找到就直接用主密钥恢复会话状态，跳过证书验证和密钥交换，只用一个消息往返就可以建立安全通信。<h3 id="会话票证"><a href="#会话票证" class="headerlink" title="会话票证"></a>会话票证</h3></li>
<li>“Session ID”是最早出现的会话复用技术，也是应用最广的，但它也有缺点，服务器必须保存每一个客户端的会话数据，对于拥有百万、千万级别用户的网站来说存储量就成了大问题，加重了服务器的负担。</li>
<li>于是，又出现了第二种“Session Ticket”方案。它有点类似 HTTP 的 Cookie，存储的责任由服务器转移到了客户端，服务器加密会话信息，用“New Session Ticket”消息发给客户端，让客户端保存。重连的时候，客户端使用扩展“session_ticket”发送“Ticket”而不是“Session ID”，服务器解密后验证有效期，就可以恢复会话，开始加密通信。不过“Session Ticket”方案需要使用一个固定的密钥文件（ticket_key）来加密 Ticket，为了防止密钥被破解，保证“前向安全”，密钥文件需要定期轮换，比如设置为一小时或者一天。<h3 id="预共享密钥"><a href="#预共享密钥" class="headerlink" title="预共享密钥"></a>预共享密钥</h3></li>
<li>“False Start”“Session ID”“Session Ticket”等方式只能实现 1-RTT，而 TLS1.3 更进一步实现了“0-RTT”，原理和“Session Ticket”差不多，但在发送 Ticket 的同时会带上应用数据（Early Data），免去了 1.2 里的服务器确认步骤，这种方式叫“Pre-shared Key”，简称为“PSK”。</li>
<li>但“PSK”也不是完美的，它为了追求效率而牺牲了一点安全性，容易受到“重放攻击”（Replay attack）的威胁。黑客可以截获“PSK”的数据，像复读机那样反复向服务器发送。</li>
<li>解决的办法是只允许安全的 GET/HEAD 方法，在消息里加入时间戳、“nonce”验证，或者“一次性票证”限制重放。</li>
</ul>
<h2 id="我应该迁移到HTTPS吗？"><a href="#我应该迁移到HTTPS吗？" class="headerlink" title="我应该迁移到HTTPS吗？"></a>我应该迁移到HTTPS吗？</h2><ul>
<li>从 HTTP 迁移到 HTTPS 是“大势所趋”，能做就应该尽早做；<h3 id="重定向跳转"><a href="#重定向跳转" class="headerlink" title="重定向跳转"></a>重定向跳转</h3></li>
<li><p>把不安全的 HTTP 网址用 301 或 302“重定向”到新的 HTTPS 网站，这在 Nginx 里也很容易做到，使用“return”或“rewrite”都可以。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">return 301 https://$host$request_uri;             #永久重定向</span><br><span class="line">rewrite ^  https://$host$request_uri permanent;   #永久重定向</span><br><span class="line">但这种方式有两个问题。一个是重定向增加了网络成本，多出了一次请求；</span><br><span class="line">另一个是存在安全隐患，重定向的响应可能会被“中间人”窜改，实现“会话劫持”，跳转到恶意网站</span><br></pre></td></tr></table></figure>
</li>
<li><p>不过有一种叫“HSTS”（HTTP 严格传输安全，HTTP Strict Transport Security）的技术可以消除这种安全隐患。HTTPS 服务器需要在发出的响应头里添加一个“Strict-Transport-Security”的字段，再设定一个有效期，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Strict-Transport-Security: max-age=15768000; includeSubDomains</span><br><span class="line">这相当于告诉浏览器：我这个网站必须严格使用 HTTPS 协议，在半年之内（182.5 天）都不允许用 HTTP，你以后就自己做转换吧，不要再来麻烦我了。</span><br><span class="line">有了“HSTS”的指示，以后浏览器再访问同样的域名的时候就会自动把 URI 里的“http”改成“https”，直接访问安全的 HTTPS 网站。这样“中间人”就失去了攻击的机会，而且对于客户端来说也免去了一次跳转，加快了连接速度。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="HTTP-2特性概览"><a href="#HTTP-2特性概览" class="headerlink" title="HTTP/2特性概览"></a>HTTP/2特性概览</h2><ul>
<li>HTTPS，通过引入 SSL/TLS 在安全上达到了“极致”，但在性能提升方面却是乏善可陈，只优化了握手加密的环节，对于整体的数据传输没有提出更好的改进方案，还只能依赖于“长连接”这种“落后”的技术</li>
<li>“秦失其鹿，天下共逐之”，Google 率先发明了 SPDY 协议，并应用于自家的浏览器 Chrome，打响了 HTTP 性能优化的“第一枪”。随后互联网标准化组织 IETF 以 SPDY 为基础，综合其他多方的意见，终于推出了 HTTP/1 的继任者，也就是今天的主角“HTTP/2”，在性能方面有了一个大的飞跃。</li>
</ul>
<h3 id="为什么不是-HTTP-2-0"><a href="#为什么不是-HTTP-2-0" class="headerlink" title="为什么不是 HTTP/2.0"></a>为什么不是 HTTP/2.0</h3><ul>
<li>以前的“1.0”“1.1”造成了很多的混乱和误解，让人在实际的使用中难以区分差异，所以就决定 HTTP 协议不再使用小版本号（minor version），只使用大版本号（major version），从今往后 HTTP 协议不会出现 HTTP/2.0、2.1，只会有“HTTP/2”“HTTP/3”……<h3 id="兼容-HTTP-1"><a href="#兼容-HTTP-1" class="headerlink" title="兼容 HTTP/1"></a>兼容 HTTP/1</h3></li>
<li>由于 HTTPS 已经在安全方面做的非常好了，所以 HTTP/2 的唯一目标就是改进性能。</li>
<li>但它不仅背负着众多的期待，同时还背负着 HTTP/1 庞大的历史包袱，所以协议的修改必须小心谨慎，兼容性是首要考虑的目标，否则就会破坏互联网上无数现有的资产，这方面 TLS 已经有了先例（为了兼容 TLS1.2 不得不进行“伪装”）。</li>
<li>因为必须要保持功能上的兼容，所以 HTTP/2 把 HTTP 分解成了“语义”和“语法”两个部分，“语义”层不做改动，与 HTTP/1 完全一致（即 RFC7231）。比如请求方法、URI、状态码、头字段等概念都保留不变，这样就消除了再学习的成本，基于 HTTP 的上层应用也不需要做任何修改，可以无缝转换到 HTTP/2。</li>
<li>与 HTTPS 不同，HTTP/2 没有在 URI 里引入新的协议名，仍然用“http”表示明文协议，用“https”表示加密协议。</li>
<li>在“语义”保持稳定之后，HTTP/2 在“语法”层做了“天翻地覆”的改造，完全变更了 HTTP 报文的传输格式。</li>
</ul>
<h3 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h3><ul>
<li>首先，HTTP/2 对报文的头部做了一个“大手术”。</li>
<li>HTTP/1 里可以用头字段“Content-Encoding”指定 Body 的编码方式，比如用 gzip 压缩来节约带宽，但报文的另一个组成部分——Header 却被无视了，没有针对它的优化手段。</li>
<li>由于报文 Header 一般会携带“User Agent”“Cookie”“Accept”“Server”等许多固定的头字段，多达几百字节甚至上千字节，但 Body 却经常只有几十字节（比如 GET 请求、204/301/304 响应），成了不折不扣的“大头儿子”。</li>
<li>更要命的是，成千上万的请求响应报文里有很多字段值都是重复的，非常浪费，“长尾效应”导致大量带宽消耗在了这些冗余度极高的数据上。</li>
<li>HTTP/2 并没有使用传统的压缩算法，而是开发了专门的“HPACK”算法，在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，还釆用哈夫曼编码来压缩整数和字符串，可以达到 50%~90% 的高压缩率。<h3 id="二进制格式"><a href="#二进制格式" class="headerlink" title="二进制格式"></a>二进制格式</h3></li>
<li>HTTP/2不再使用肉眼可见的 ASCII 码，而是向下层的 TCP/IP 协议“靠拢”，全面采用二进制格式。虽然对人不友好，但却大大方便了计算机的解析。原来使用纯文本的时候容易出现多义性，比如大小写、空白字符、回车换行、多字少字等等，程序在处理时必须用复杂的状态机，效率低，还麻烦。</li>
<li>二进制里只有“0”和“1”，可以严格规定字段大小、顺序、标志位等格式，“对就是对，错就是错”，解析起来没有歧义，实现简单，而且体积小、速度快，做到“内部提效”。</li>
<li>它把 TCP 协议的部分特性挪到了应用层，把原来的“Header+Body”的消息“打散”为数个小片的二进制“帧”（Frame），用“HEADERS”帧存放头数据、“DATA”帧存放实体数据。</li>
<li>这种做法有点像是“Chunked”分块编码的方式，也是“化整为零”的思路，但 HTTP/2 数据分帧后“Header+Body”的报文结构就完全消失了，协议看到的只是一个个的“碎片”。<h3 id="虚拟的“流”"><a href="#虚拟的“流”" class="headerlink" title="虚拟的“流”"></a>虚拟的“流”</h3></li>
<li>HTTP/2 为此定义了一个“流”（Stream）的概念，它是二进制帧的双向传输序列，同一个消息往返的帧会分配一个唯一的流 ID。你可以把它想象成是一个虚拟的“数据流”，在里面流动的是一串有先后顺序的数据帧，这些数据帧按照次序组装起来就是 HTTP/1 里的请求报文和响应报文。</li>
<li>因为“流”是虚拟的，实际上并不存在，所以 HTTP/2 就可以在一个 TCP 连接上用“流”同时发送多个“碎片化”的消息，这就是常说的“多路复用”（ Multiplexing）——多个往返通信都复用一个连接来处理。</li>
<li>在“流”的层面上看，消息是一些有序的“帧”序列，而在“连接”的层面上看，消息却是乱序收发的“帧”。多个请求 / 响应之间没有了顺序关系，不需要排队等待，也就不会再出现“队头阻塞”问题，降低了延迟，大幅度提高了连接的利用率。</li>
<li>为了更好地利用连接，加大吞吐量，HTTP/2 还添加了一些控制帧来管理虚拟的“流”，实现了优先级和流量控制，这些特性也和 TCP 协议非常相似。</li>
<li>HTTP/2 还在一定程度上改变了传统的“请求 - 应答”工作模式，服务器不再是完全被动地响应请求，也可以新建“流”主动向客户端发送消息。比如，在浏览器刚请求 HTML 的时候就提前把可能会用到的 JS、CSS 文件发给客户端，减少等待的延迟，这被称为“服务器推送”（Server Push，也叫 Cache Push）。</li>
</ul>
<h3 id="强化安全-1"><a href="#强化安全-1" class="headerlink" title="强化安全"></a>强化安全</h3><ul>
<li>出于兼容的考虑，HTTP/2 延续了 HTTP/1 的“明文”特点，可以像以前一样使用明文传输数据，不强制使用加密通信，不过格式还是二进制，只是不需要解密。</li>
<li>但由于 HTTPS 已经是大势所趋，而且主流的浏览器 Chrome、Firefox 等都公开宣布只支持加密的 HTTP/2，所以“事实上”的 HTTP/2 是加密的。也就是说，互联网上通常所能见到的 HTTP/2 都是使用“https”协议名，跑在 TLS 上面。</li>
<li>为了区分“加密”和“明文”这两个不同的版本，HTTP/2 协议定义了两个字符串标识符：“h2”表示加密的 HTTP/2，“h2c”表示明文的 HTTP/2，多出的那个字母“c”的意思是“clear text”。</li>
</ul>
<h3 id="协议栈"><a href="#协议栈" class="headerlink" title="协议栈"></a>协议栈</h3><ul>
<li>http/1: http/tcp/ip/mac</li>
<li>https: http/tls/tcp/ip/mac</li>
<li>http/2: http/hpack+stream/tls 1.2+/tcp/ip/mac</li>
</ul>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li>HTTP 协议取消了小版本号，所以 HTTP/2 的正式名字不是 2.0；</li>
<li>HTTP/2 在“语义”上兼容 HTTP/1，保留了请求方法、URI 等传统概念；</li>
<li>HTTP/2 使用“HPACK”算法压缩头部信息，消除冗余数据节约带宽；</li>
<li>HTTP/2 的消息不再是“Header+Body”的形式，而是分散为多个二进制“帧”；</li>
<li>HTTP/2 使用虚拟的“流”传输消息，解决了困扰多年的“队头阻塞”问题，同时实现了“多路复用”，提高连接的利用率；</li>
<li>HTTP/2 也增强了安全性，要求至少是 TLS1.2，而且禁用了很多不安全的密码套件。</li>
</ul>
<h2 id="HTTP-2内核剖析"><a href="#HTTP-2内核剖析" class="headerlink" title="HTTP/2内核剖析"></a>HTTP/2内核剖析</h2><h3 id="连接前言"><a href="#连接前言" class="headerlink" title="连接前言"></a>连接前言</h3><ul>
<li>由于 HTTP/2“事实上”是基于 TLS，所以在正式收发数据之前，会有 TCP 握手和 TLS 握手，</li>
<li>TLS 握手成功之后，客户端必须要发送一个“连接前言”（connection preface），用来确认建立 HTTP/2 连接。这个“连接前言”是标准的 HTTP/1 请求报文，使用纯文本的 ASCII 码格式，请求方法是特别注册的一个关键字“PRI”，全文只有 24 个字节：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n</span><br><span class="line">只要服务器收到这个“有魔力的字符串”，就知道客户端在 TLS 上想要的是 HTTP/2 协议，而不是其他别的协议，后面就会都使用 HTTP/2 的数据格式。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="头部压缩-1"><a href="#头部压缩-1" class="headerlink" title="头部压缩"></a>头部压缩</h3><ul>
<li>因为语义上它与 HTTP/1 兼容，所以报文还是由“Header+Body”构成的，但在请求发送前，必须要用“HPACK”算法来压缩头部数据。</li>
<li>“HPACK”算法是专门为压缩 HTTP 头部定制的算法，与 gzip、zlib 等压缩算法不同，它是一个“有状态”的算法，需要客户端和服务器各自维护一份“索引表”，也可以说是“字典”（这有点类似 brotli），压缩和解压缩就是查表和更新表的操作。</li>
<li>为了方便管理和压缩，HTTP/2 废除了原有的起始行概念，把起始行里面的请求方法、URI、状态码等统一转换成了头字段的形式，并且给这些“不是头字段的头字段”起了个特别的名字——“伪头字段”（pseudo-header fields）。而起始行里的版本号和错误原因短语因为没什么大用，顺便也给废除了。为了与“真头字段”区分开来，这些“伪头字段”会在名字前加一个“:”，比如“:authority” “:method” “:status”，分别表示的是域名、请求方法和状态码。</li>
<li><p>现在 HTTP 报文头就简单了，全都是“Key-Value”形式的字段，于是 HTTP/2 就为一些最常用的头字段定义了一个只读的“静态表”（Static Table）。动态表”（Dynamic Table）添加在静态表后面，结构相同，但会在编码解码的时候随时更新。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">比如说，第一次发送请求时的“user-agent”字段长是一百多个字节，用哈夫曼压缩编码发送之后，客户端和服务器都更新自己的动态表，添加一个新的索引号“65”。</span><br><span class="line">那么下一次发送的时候就不用再重复发那么多字节了，只要用一个字节发送编号就好。</span><br></pre></td></tr></table></figure>
</li>
<li><p>随着在 HTTP/2 连接上发送的报文越来越多，两边的“字典”也会越来越丰富，最终每次的头部字段都会变成一两个字节的代码，原来上千字节的头用几十个字节就可以表示了，压缩效果比 gzip 要好得多。</p>
<h3 id="二进制帧"><a href="#二进制帧" class="headerlink" title="二进制帧"></a>二进制帧</h3></li>
<li>头部数据压缩之后，HTTP/2 就要把报文拆成二进制的帧准备发送。</li>
<li>HTTP/2 的帧结构有点类似 TCP 的段或者 TLS 里的记录，但报头很小，只有 9 字节，非常地节省（可以对比一下 TCP 头，它最少是 20 个字节）。</li>
<li>帧开头是 3 个字节的长度（但不包括头的 9 个字节），默认上限是 2^14，最大是 2^24，也就是说 HTTP/2 的帧通常不超过 16K，最大是 16M。</li>
<li>长度后面的一个字节是帧类型，大致可以分成数据帧和控制帧两类，HEADERS 帧和 DATA 帧属于数据帧，存放的是 HTTP 报文，而 SETTINGS、PING、PRIORITY 等则是用来管理流的控制帧。</li>
<li>报文头里最后 4 个字节是流标识符，也就是帧所属的“流”，接收方使用它就可以从乱序的帧里识别出具有相同流 ID 的帧序列，按顺序组装起来就实现了虚拟的“流”。<h3 id="流与多路复用"><a href="#流与多路复用" class="headerlink" title="流与多路复用"></a>流与多路复用</h3></li>
<li>流是二进制帧的双向传输序列。要搞明白流，关键是要理解帧头里的流 ID。</li>
<li>在 HTTP/2 连接上，虽然帧是乱序收发的，但只要它们都拥有相同的流 ID，就都属于一个流，而且在这个流里帧不是无序的，而是有着严格的先后顺序。</li>
<li>HTTP/2 的流有哪些特点呢？</li>
</ul>
<ol>
<li>流是可并发的，一个 HTTP/2 连接上可以同时发出多个流传输数据，也就是并发多请求，实现“多路复用”；</li>
<li>客户端和服务器都可以创建流，双方互不干扰；</li>
<li>流是双向的，一个流里面客户端和服务器都可以发送或接收数据帧，也就是一个“请求 - 应答”来回；</li>
<li>流之间没有固定关系，彼此独立，但流内部的帧是有严格顺序的；</li>
<li>流可以设置优先级，让服务器优先处理，比如先传 HTML/CSS，后传图片，优化用户体验；</li>
<li>流 ID 不能重用，只能顺序递增，客户端发起的 ID 是奇数，服务器端发起的 ID 是偶数；</li>
<li>在流上发送“RST_STREAM”帧可以随时终止流，取消接收或发送；</li>
<li>第 0 号流比较特殊，不能关闭，也不能发送数据帧，只能发送控制帧，用于流量控制。</li>
</ol>
<ul>
<li>HTTP/2 在一个连接上使用多个流收发数据，那么它本身默认就会是长连接，所以永远不需要“Connection”头字段（keepalive 或 close）。</li>
<li>下载大文件的时候想取消接收，在 HTTP/1 里只能断开 TCP 连接重新“三次握手”，成本很高，而在 HTTP/2 里就可以简单地发送一个“RST_STREAM”中断流，而长连接会继续保持。</li>
<li>因为客户端和服务器两端都可以创建流，而流 ID 有奇数偶数和上限的区分，所以大多数的流 ID 都会是奇数，而且客户端在一个连接里最多只能发出 2^30，也就是 10 亿个请求。ID 用完了该怎么办呢？这个时候可以再发一个控制帧“GOAWAY”，真正关闭 TCP 连接。<h3 id="流状态转换"><a href="#流状态转换" class="headerlink" title="流状态转换"></a>流状态转换</h3></li>
<li>HTTP/2 借鉴了 TCP，根据帧的标志位实现流状态转换。当然，这些状态也是虚拟的，只是为了辅助理解。</li>
<li>最开始的时候流都是“空闲”（idle）状态，也就是“不存在”，可以理解成是待分配的“号段资源”。</li>
<li>当客户端发送 HEADERS 帧后，有了流 ID，流就进入了“打开”状态，两端都可以收发数据，然后客户端发送一个带“END_STREAM”标志位的帧，流就进入了“半关闭”状态。这个“半关闭”状态很重要，意味着客户端的请求数据已经发送完了，需要接受响应数据，而服务器端也知道请求数据接收完毕，之后就要内部处理，再发送响应数据。</li>
<li>响应数据发完了之后，也要带上“END_STREAM”标志位，表示数据发送完毕，这样流两端就都进入了“关闭”状态，流就结束了。</li>
<li>流 ID 不能重用，所以流的生命周期就是 HTTP/1 里的一次完整的“请求 - 应答”，流关闭就是一次通信结束。下一次再发请求就要开一个新流（而不是新连接），流 ID 不断增加，直到到达上限，发送“GOAWAY”帧开一个新的 TCP 连接，流 ID 就又可以重头计数。</li>
<li>因为流可以并发，所以 HTTP/2 就可以实现无阻塞的多路复用。</li>
</ul>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><ul>
<li>HTTP/2 必须先发送一个“连接前言”字符串，然后才能建立正式连接；</li>
<li>HTTP/2 废除了起始行，统一使用头字段，在两端维护字段“Key-Value”的索引表，使用“HPACK”算法压缩头部；</li>
<li>HTTP/2 把报文切分为多种类型的二进制帧，报头里最重要的字段是流标识符，标记帧属于哪个流；</li>
<li>流是 HTTP/2 虚拟的概念，是帧的双向传输序列，相当于 HTTP/1 里的一次“请求 - 应答”；</li>
<li>在一个 HTTP/2 连接上可以并发多个流，也就是多个“请求 - 响应”报文，这就是“多路复用”。</li>
</ul>
<h2 id="HTTP-3展望"><a href="#HTTP-3展望" class="headerlink" title="HTTP/3展望"></a>HTTP/3展望</h2><ul>
<li>HTTP/2 做出的许多努力，比如头部压缩、二进制分帧、虚拟的“流”与多路复用，性能方面比 HTTP/1 有了很大的提升，“基本上”解决了“队头阻塞”这个“老大难”问题。<h3 id="HTTP-2-的“队头阻塞”"><a href="#HTTP-2-的“队头阻塞”" class="headerlink" title="HTTP/2 的“队头阻塞”"></a>HTTP/2 的“队头阻塞”</h3></li>
<li>HTTP/2 虽然使用“帧”“流”“多路复用”，没有了“队头阻塞”，但这些手段都是在应用层里，而在下层，也就是 TCP 协议里，还是会发生“队头阻塞”。</li>
<li>在 HTTP/2 把多个“请求 - 响应”分解成流，交给 TCP 后，TCP 会再拆成更小的包依次发送（其实在 TCP 里应该叫 segment，也就是“段”）。</li>
<li><p>在网络良好的情况下，包可以很快送达目的地。但如果网络质量比较差，像手机上网的时候，就有可能会丢包。而 TCP 为了保证可靠传输，有个特别的“丢包重传”机制，丢失的包必须要等待重新传输确认，其他的包即使已经收到了，也只能放在缓冲区里，上层的应用拿不出来，只能“干着急”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">客户端用 TCP 发送了三个包，但服务器所在的操作系统只收到了后两个包，第一个包丢了。那么内核里的 TCP 协议栈就只能把已经收到的包暂存起来，“停下”等着客户端重传那个丢失的包，这样就又出现了“队头阻塞”。</span><br><span class="line">由于这种“队头阻塞”是 TCP 协议固有的，所以 HTTP/2 即使设计出再多的“花样”也无法解决。</span><br></pre></td></tr></table></figure>
</li>
<li><p>Google 在推 SPDY 的时候就已经意识到了这个问题，于是就又发明了一个新的“QUIC”协议，让 HTTP 跑在 QUIC 上而不是 TCP 上。而这个“HTTP over QUIC”就是 HTTP 协议的下一个大版本，HTTP/3。它在 HTTP/2 的基础上又实现了质的飞跃，真正“完美”地解决了“队头阻塞”问题。</p>
</li>
</ul>
<h3 id="QUIC-协议"><a href="#QUIC-协议" class="headerlink" title="QUIC 协议"></a>QUIC 协议</h3><ul>
<li>http/2:http/qpack+stream/quic+tls 1.3+/udp/ip/mac</li>
<li>HTTP/3 有一个关键的改变，那就是它把下层的 TCP“抽掉”了，换成了 UDP。因为 UDP 是无序的，包之间没有依赖关系，所以就从根本上解决了“队头阻塞”。</li>
<li>UDP 是一个简单、不可靠的传输协议，只是对 IP 协议的一层很薄的包装，和 TCP 相比，它实际应用的较少。不过正是因为它简单，不需要建连和断连，通信成本低，也就非常灵活、高效，“可塑性”很强。</li>
<li>所以，QUIC 就选定了 UDP，在它之上把 TCP 的那一套连接管理、拥塞窗口、流量控制等“搬”了过来，“去其糟粕，取其精华”，打造出了一个全新的可靠传输协议，可以认为是“新时代的 TCP”。<h3 id="QUIC-的特点"><a href="#QUIC-的特点" class="headerlink" title="QUIC 的特点"></a>QUIC 的特点</h3></li>
<li>QUIC 基于 UDP，而 UDP 是“无连接”的，根本就不需要“握手”和“挥手”，所以天生就要比 TCP 快。</li>
<li>就像 TCP 在 IP 的基础上实现了可靠传输一样，QUIC 也基于 UDP 实现了可靠传输，保证数据一定能够抵达目的地。它还引入了类似 HTTP/2 的“流”和“多路复用”，单个“流”是有序的，可能会因为丢包而阻塞，但其他“流”不会受到影响。</li>
<li>但 QUIC 并不是建立在 TLS 之上，而是内部“包含”了 TLS。它使用自己的帧“接管”了 TLS 里的“记录”，握手消息、警报消息都不使用 TLS 记录，直接封装成 QUIC 的帧发送，省掉了一次开销。<h3 id="QUIC-内部细节"><a href="#QUIC-内部细节" class="headerlink" title="QUIC 内部细节"></a>QUIC 内部细节</h3></li>
<li>QUIC 的基本数据传输单位是包（packet）和帧（frame），一个包由多个帧组成，包面向的是“连接”，帧面向的是“流”。</li>
<li><p>QUIC 使用不透明的“连接 ID”来标记通信的两个端点，客户端和服务器可以自行选择一组 ID 来标记自己，这样就解除了 TCP 里连接对“IP 地址 + 端口”（即常说的四元组）的强绑定，支持“连接迁移”（Connection Migration）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比如你下班回家，手机会自动由 4G 切换到 WiFi。这时 IP 地址会发生变化，TCP 就必须重新建立连接。而 QUIC 连接里的两端连接 ID 不会变，所以连接在“逻辑上”没有中断，它就可以在新的 IP 地址上继续使用之前的连接，消除重连的成本，实现连接的无缝迁移。</span><br></pre></td></tr></table></figure>
</li>
<li><p>HTTP/2 里的流都是双向的，而 QUIC 则分为双向流和单向流。</p>
</li>
</ul>
<h3 id="HTTP-3-协议"><a href="#HTTP-3-协议" class="headerlink" title="HTTP/3 协议"></a>HTTP/3 协议</h3><ul>
<li>因为 QUIC 本身就已经支持了加密、流和多路复用，所以 HTTP/3 的工作减轻了很多，把流控制都交给 QUIC 去做。调用的不再是 TLS 的安全接口，也不是 Socket API，而是专门的 QUIC 函数。不过这个“QUIC 函数”还没有形成标准，必须要绑定到某一个具体的实现库。</li>
<li>HTTP/3 里仍然使用流来发送“请求 - 响应”，但它自身不需要像 HTTP/2 那样再去定义流，而是直接使用 QUIC 的流，相当于做了一个“概念映射”。</li>
<li>HTTP/3 里的“双向流”可以完全对应到 HTTP/2 的流，而“单向流”在 HTTP/3 里用来实现控制和推送，近似地对应 HTTP/2 的 0 号流。</li>
<li>头部压缩算法在 HTTP/3 里升级成了“QPACK”，使用方式上也做了改变。虽然也分成静态表和动态表，但在流上发送 HEADERS 帧时不能更新字段，只能引用，索引表的更新需要在专门的单向流上发送指令来管理，解决了 HPACK 的“队头阻塞”问题。</li>
<li>另外，QPACK 的字典也做了优化，静态表由之前的 61 个增加到了 98 个，而且序号从 0 开始，也就是说“:authority”的编号是 0。</li>
</ul>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><ul>
<li>HTTP/3 基于 QUIC 协议，完全解决了“队头阻塞”问题，弱网环境下的表现会优于 HTTP/2；</li>
<li>QUIC 是一个新的传输层协议，建立在 UDP 之上，实现了可靠传输；</li>
<li>QUIC 内含了 TLS1.3，只能加密通信，支持 0-RTT 快速建连；</li>
<li>QUIC 的连接使用“不透明”的连接 ID，不绑定在“IP 地址 + 端口”上，支持“连接迁移”；</li>
<li>QUIC 的流与 HTTP/2 的流很相似，但分为双向流和单向流；</li>
<li>HTTP/3 没有指定默认端口号，需要用 HTTP/2 的扩展帧“Alt-Svc”来发现。</li>
</ul>
<h2 id="我应该迁移到HTTP-2吗？"><a href="#我应该迁移到HTTP-2吗？" class="headerlink" title="我应该迁移到HTTP/2吗？"></a>我应该迁移到HTTP/2吗？</h2><ul>
<li>HTTP/2 完全兼容 HTTP/1，是“更安全的 HTTP、更快的 HTTPS”，头部压缩、多路复用等技术可以充分利用带宽，降低延迟，从而大幅度提高上网体验；</li>
<li>TCP 协议存在“队头阻塞”，所以 HTTP/2 在弱网或者移动网络下的性能表现会不如 HTTP/1；</li>
<li>迁移到 HTTP/2 肯定会有性能提升，但高流量网站效果会更显著；</li>
<li>如果已经升级到了 HTTPS，那么再升级到 HTTP/2 会很简单；</li>
<li>TLS 协议提供“ALPN”扩展，让客户端和服务器协商使用的应用层协议，“发现”HTTP/2 服务。</li>
</ul>
<h2 id="Nginx：高性能的Web服务器"><a href="#Nginx：高性能的Web服务器" class="headerlink" title="Nginx：高性能的Web服务器"></a>Nginx：高性能的Web服务器</h2><ul>
<li>作为一个 Web 服务器，Nginx 的功能非常完善，完美支持 HTTP/1、HTTPS 和 HTTP/2，而且还在不断进步。当前的主线版本已经发展到了 1.17，正在进行 HTTP/3 的研发，或许一年之后就能在 Nginx 上跑 HTTP/3 了。<h3 id="进程池"><a href="#进程池" class="headerlink" title="进程池"></a>进程池</h3></li>
<li>Nginx 作为“轻量级”的服务器，它的 CPU、内存占用都非常少，同样的资源配置下就能够为更多的用户提供服务，其奥秘在于它独特的工作模式。</li>
<li>在 Nginx 之前，Web 服务器对每一个请求使用单独的进程或者线程处理。这就存在创建进程或线程的成本，还会有进程、线程“上下文切换”的额外开销。如果请求数量很多，CPU 就会在多个进程、线程之间切换时“疲于奔命”，平白地浪费了计算时间。</li>
<li>Nginx 则完全不同，“一反惯例”地没有使用多线程，而是使用了“进程池 + 单线程”的工作模式。</li>
<li>Nginx 在启动的时候会预先创建好固定数量的 worker 进程，在之后的运行过程中不会再 fork 出新进程，这就是进程池，而且可以自动把进程“绑定”到独立的 CPU 上，这样就完全消除了进程创建和切换的成本，能够充分利用多核 CPU 的计算能力。</li>
<li>在进程池之上，还有一个“master”进程，专门用来管理进程池。它的作用有点像是 supervisor（一个用 Python 编写的进程管理工具），用来监控进程，自动恢复发生异常的 worker，保持进程池的稳定和服务能力。<h3 id="I-O-多路复用"><a href="#I-O-多路复用" class="headerlink" title="I/O 多路复用"></a>I/O 多路复用</h3></li>
<li>使用多线程能够很容易实现并发处理,但多线程也有一些缺点，除了刚才说到的“上下文切换”成本，还有编程模型复杂、数据竞争、同步等问题，写出正确、快速的多线程程序并不是一件容易的事情。</li>
<li>所以 Nginx 就选择了单线程的方式，带来的好处就是开发简单，没有互斥锁的成本，减少系统消耗。</li>
<li>Web 服务器从根本上来说是“I/O 密集型”而不是“CPU 密集型”，处理能力的关键在于网络收发而不是 CPU 计算（这里暂时不考虑 HTTPS 的加解密），而网络 I/O 会因为各式各样的原因不得不等待，比如数据还没到达、对端没有响应、缓冲区满发不出去等等。</li>
<li>对于一般的单线程来说 CPU 就会“停下来”，造成浪费。而多线程的解决思路有点类似“并发连接”，虽然有的线程可能阻塞，但由于多个线程并行，总体上看阻塞的情况就不会太严重了。Nginx 里使用的 epoll，就好像是 HTTP/2 里的“多路复用”技术，它把多个 HTTP 请求处理打散成碎片，都“复用”到一个单线程里，不按照先来后到的顺序处理，而是只当连接上真正可读、可写的时候才处理，如果可能发生阻塞就立刻切换出去，处理其他的请求。通过这种方式，Nginx 就完全消除了 I/O 阻塞，把 CPU 利用得“满满当当”，又因为网络收发并不会消耗太多 CPU 计算能力，也不需要切换进程、线程，所以整体的 CPU 负载是相当低的。</li>
<li>epoll 还有一个特点，大量的连接管理工作都是在操作系统内核里做的，这就减轻了应用程序的负担，所以 Nginx 可以为每个连接只分配很小的内存维护状态，即使有几万、几十万的并发连接也只会消耗几百 M 内存，而其他的 Web 服务器这个时候早就“Memory not enough”了。<h3 id="多阶段处理"><a href="#多阶段处理" class="headerlink" title="多阶段处理"></a>多阶段处理</h3></li>
<li>Nginx 的 HTTP 处理有四大类模块：</li>
</ul>
<ol>
<li>handler 模块：直接处理 HTTP 请求；</li>
<li>filter 模块：不直接处理请求，而是加工过滤响应报文；</li>
<li>upstream 模块：实现反向代理功能，转发请求到其他服务器；</li>
<li>balance 模块：实现反向代理时的负载均衡算法。</li>
</ol>
<ul>
<li>charset 模块实现了字符集编码转换;chunked 模块实现了响应数据的分块传输；range 模块实现了范围请求，只返回数据的一部分；rewrite 模块实现了重定向和跳转，还可以使用内置变量自定义跳转的 URI；not_modified 模块检查头字段“if-Modified-Since”和“If-None-Match”，处理条件请求；ssl 模块实现了 SSL/TLS 协议支持，读取磁盘上的证书和私钥，实现 TLS 握手和 SNI、ALPN 等扩展功能；http_v2 模块实现了完整的 HTTP/2 协议。</li>
</ul>
<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><ul>
<li>Nginx 是一个高性能的 Web 服务器，它非常的轻量级，消耗的 CPU、内存很少；</li>
<li>Nginx 采用“master/workers”进程池架构，不使用多线程，消除了进程、线程切换的成本</li>
<li>Nginx 基于 epoll 实现了“I/O 多路复用”，不会阻塞，所以性能很高；</li>
<li>Nginx 使用了“职责链”模式，多个模块分工合作，自由组合，以流水线的方式处理 HTTP 请求。</li>
</ul>
<h2 id="OpenResty：更灵活的Web服务器"><a href="#OpenResty：更灵活的Web服务器" class="headerlink" title="OpenResty：更灵活的Web服务器"></a>OpenResty：更灵活的Web服务器</h2><ul>
<li>“一个人很难超越时代，而时代却可以轻易超越所有人”，Nginx 当初设计时针对的应用场景已经发生了变化，它的一些缺点也就暴露出来了。</li>
<li>Nginx 的服务管理思路延续了当时的流行做法，使用磁盘上的静态配置文件，所以每次修改后必须重启才能生效。这在业务频繁变动的时候是非常致命的（例如流行的微服务架构），特别是对于拥有成千上万台服务器的网站来说，仅仅增加或者删除一行配置就要分发、重启所有的机器，对运维是一个非常大的挑战，要耗费很多的时间和精力，成本很高，很不灵活，难以“随需应变”。</li>
<li>OpenResty 并不是一个全新的 Web 服务器，而是基于 Nginx，它利用了 Nginx 模块化、可扩展的特性，开发了一系列的增强模块，并把它们打包整合，形成了一个“一站式”的 Web 开发平台。</li>
<li>虽然 OpenResty 的核心是 Nginx，但它又超越了 Nginx，关键就在于其中的 ngx_lua 模块，把小巧灵活的 Lua 语言嵌入了 Nginx，可以用脚本的方式操作 Nginx 内部的进程、多路复用、阶段式处理等各种构件。<h3 id="动态的-Lua"><a href="#动态的-Lua" class="headerlink" title="动态的 Lua"></a>动态的 Lua</h3></li>
<li>OpenResty 里的一个关键模块是 ngx_lua，它为 Nginx 引入了脚本语言 Lua。</li>
<li>Lua 的设计目标是嵌入到其他应用程序里运行，为其他编程语言带来“脚本化”能力，所以它的“个头”比较小，功能集有限，不追求“大而全”，而是“小而美”，大多数时间都“隐匿”在其他应用程序的后面，是“无名英雄”。你或许玩过或者听说过《魔兽世界》《愤怒的小鸟》吧，它们就在内部嵌入了 Lua，使用 Lua 来调用底层接口，充当“胶水语言”（glue language），编写游戏逻辑脚本，提高开发效率。</li>
<li>作为脚本语言，Lua 还有一个重要的“代码热加载”特性，不需要重启进程，就能够从磁盘、Redis 或者任何其他地方加载数据，随时替换内存里的代码片段。这就带来了“动态配置”，让 OpenResty 能够永不停机，在微秒、毫秒级别实现配置和业务逻辑的实时更新，比起 Nginx 秒级的重启是一个极大的进步。<h3 id="高效率的-Lua"><a href="#高效率的-Lua" class="headerlink" title="高效率的 Lua"></a>高效率的 Lua</h3></li>
<li>OpenResty 能够高效运行的一大“秘技”是它的“同步非阻塞”编程范式，如果你要开发 OpenResty 应用就必须时刻铭记于心。“同步非阻塞”本质上还是一种“多路复用”</li>
<li>epoll 是操作系统级别的“多路复用”，运行在内核空间。而 OpenResty 的“同步非阻塞”则是基于 Lua 内建的“协程”，是应用程序级别的“多路复用”，运行在用户空间，所以它的资源消耗要更少。</li>
</ul>
<h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><ul>
<li>Nginx 依赖于磁盘上的静态配置文件，修改后必须重启才能生效，缺乏灵活性；</li>
<li>OpenResty 基于 Nginx，打包了很多有用的模块和库，是一个高性能的 Web 开发平台；</li>
<li>OpenResty 的工作语言是 Lua，它小巧灵活，执行效率高，支持“代码热加载”；</li>
<li>OpenResty 的核心编程范式是“同步非阻塞”，使用协程，不需要异步回调函数；</li>
<li>OpenResty 也使用“阶段式处理”的工作模式，但因为在阶段里执行的都是 Lua 代码，所以非常灵活，配合 Redis 等外部数据库能够实现各种动态配置。</li>
</ul>
<h2 id="WAF：保护我们的网络服务"><a href="#WAF：保护我们的网络服务" class="headerlink" title="WAF：保护我们的网络服务"></a>WAF：保护我们的网络服务</h2><h3 id="Web-服务遇到的威胁"><a href="#Web-服务遇到的威胁" class="headerlink" title="Web 服务遇到的威胁"></a>Web 服务遇到的威胁</h3><ul>
<li><p>第一种叫“DDoS”攻击（distributed denial-of-service attack），有时候也叫“洪水攻击”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">黑客会控制许多“僵尸”计算机，向目标服务器发起大量无效请求。</span><br><span class="line">因为服务器无法区分正常用户和黑客，只能“照单全收”，这样就挤占了正常用户所应有的资源。</span><br><span class="line">如果黑客的攻击强度很大，就会像“洪水”一样对网站的服务能力造成冲击，耗尽带宽、CPU 和内存，导致网站完全无法提供正常服务。</span><br></pre></td></tr></table></figure>
</li>
<li><p>“SQL 注入”（SQL injection）应该算是最著名的一种“代码注入”攻击了，它利用了服务器字符串拼接形成 SQL 语句的漏洞，构造出非正常的 SQL 语句，获取数据库内部的敏感信息。</p>
</li>
<li>另一种“HTTP 头注入”攻击的方式也是类似的原理，它在“Host”“User-Agent”“X-Forwarded-For”等字段里加入了恶意数据或代码，服务端程序如果解析不当，就会执行预设的恶意代码。</li>
<li>利用 Cookie 的攻击手段，“跨站脚本”（XSS）攻击，它属于“JS 代码注入”，利用 JavaScript 脚本获取未设防的 Cookie。</li>
</ul>
<h3 id="网络应用防火墙"><a href="#网络应用防火墙" class="headerlink" title="网络应用防火墙"></a>网络应用防火墙</h3><ul>
<li>传统“防火墙”工作在三层或者四层，隔离了外网和内网，使用预设的规则，只允许某些特定 IP 地址和端口号的数据包通过，拒绝不符合条件的数据流入或流出内网，实质上是一种网络数据过滤设备。</li>
<li>WAF 也是一种“防火墙”，但它工作在七层，看到的不仅是 IP 地址和端口号，还能看到整个 HTTP 报文，所以就能够对报文内容做更深入细致的审核，使用更复杂的条件、规则来过滤数据。说白了，WAF 就是一种“HTTP 入侵检测和防御系统”。</li>
<li>通常一款产品能够称为 WAF，要具备下面的一些功能：</li>
</ul>
<ol>
<li>IP 黑名单和白名单，拒绝黑名单上地址的访问，或者只允许白名单上的用户访问；</li>
<li>URI 黑名单和白名单，与 IP 黑白名单类似，允许或禁止对某些 URI 的访问；</li>
<li>防护 DDoS 攻击，对特定的 IP 地址限连限速；</li>
<li>过滤请求报文，防御“代码注入”攻击；</li>
<li>过滤响应报文，防御敏感信息外泄；</li>
<li>审计日志，记录所有检测到的入侵操作。</li>
</ol>
<ul>
<li>在网络安全领域必须时刻记得“木桶效应”（也叫“短板效应”）。网站的整体安全不在于你加固的最强的那个方向，而是在于你可能都没有意识到的“短板”。黑客往往会“避重就轻”，只要发现了网站的一个弱点，就可以“一点突破”，其他方面的安全措施也就都成了“无用功”。</li>
</ul>
<h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><ul>
<li>Web 服务通常都运行在公网上，容易受到“DDoS”、“代码注入”等各种黑客攻击，影响正常的服务，所以必须要采取措施加以保护；</li>
<li>WAF 是一种“HTTP 入侵检测和防御系统”，工作在七层，为 Web 服务提供全面的防护；</li>
<li>ModSecurity 是一个开源的、生产级的 WAF 产品，核心组成部分是“规则引擎”和“规则集”，两者的关系有点像杀毒引擎和病毒特征库；</li>
<li>WAF 实质上是模式匹配与数据过滤，所以会消耗 CPU，增加一些计算成本，降低服务能力，使用时需要在安全与性能之间找到一个“平衡点”。</li>
</ul>
<h2 id="CDN：加速我们的网络服务"><a href="#CDN：加速我们的网络服务" class="headerlink" title="CDN：加速我们的网络服务"></a>CDN：加速我们的网络服务</h2><h3 id="什么是-CDN？"><a href="#什么是-CDN？" class="headerlink" title="什么是 CDN？"></a>什么是 CDN？</h3><ul>
<li>CDN 有三个关键词：“内容”“分发”和“网络”。CDN 的最核心原则是“就近访问”，如果用户能够在本地几十公里的距离之内获取到数据，那么时延就基本上变成 0 了。</li>
<li>缓存代理”技术。使用“推”或者“拉”的手段，把源站的内容逐级缓存到网络的每一个节点上。</li>
<li>用户在上网的时候就不直接访问源站，而是访问离他“最近的”一个 CDN 节点，术语叫“边缘节点”（edge node），其实就是缓存了源站内容的代理服务器，这样一来就省去了“长途跋涉”的时间成本，实现了“网络加速”。</li>
<li>套用一句广告词来形容 CDN 吧，我觉得非常恰当：“我们不生产内容，我们只是内容的搬运工。”CDN，正是把“数据传输”这件看似简单的事情“做大做强”“做专做精”，就像专门的快递公司一样，在互联网世界里实现了它的价值。<h3 id="CDN-的负载均衡"><a href="#CDN-的负载均衡" class="headerlink" title="CDN 的负载均衡"></a>CDN 的负载均衡</h3></li>
<li>它有两个关键组成部分：全局负载均衡和缓存系统，对应的是 DNS和缓存代理技术。</li>
<li>全局负载均衡（Global Sever Load Balance）一般简称为 GSLB，它是 CDN 的“大脑”，主要的职责是当用户接入网络的时候在 CDN 专网中挑选出一个“最佳”节点提供服务，解决的是用户如何找到“最近的”边缘节点，对整个 CDN 网络进行“负载均衡”。GSLB 最常见的实现方式是“DNS 负载均衡”</li>
<li>CDN 的全局负载均衡系统，“智能调度”，主要的依据有这么几个：</li>
</ul>
<ol>
<li>看用户的 IP 地址，查表得知地理位置，找相对最近的边缘节点；</li>
<li>看用户所在的运营商网络，找相同网络的边缘节点；</li>
<li>检查边缘节点的负载情况，找负载较轻的节点；</li>
<li>其他，比如节点的“健康状况”、服务能力、带宽、响应时间等。</li>
</ol>
<h3 id="CDN-的缓存代理"><a href="#CDN-的缓存代理" class="headerlink" title="CDN 的缓存代理"></a>CDN 的缓存代理</h3><ul>
<li>缓存系统是 CDN 的另一个关键组成部分，相当于 CDN 的“心脏”。如果缓存系统的服务能力不够，不能很好地满足用户的需求，那 GSLB 调度算法再优秀也没有用。</li>
<li>两个 CDN 的关键概念：“命中”和“回源”。“命中”就是指用户访问的资源恰好在缓存系统里，可以直接返回给用户；“回源”则正相反，缓存里没有，必须用代理的方式回源站取。</li>
<li>相应地，也就有了两个衡量 CDN 服务质量的指标：“命中率”和“回源率”。命中率就是命中次数与所有访问次数之比，回源率是回源次数与所有访问次数之比。显然，好的 CDN 应该是命中率越高越好，回源率越低越好。现在的商业 CDN 命中率都在 90% 以上，相当于把源站的服务能力放大了 10 倍以上。</li>
</ul>
<h2 id="WebSocket：沙盒里的TCP"><a href="#WebSocket：沙盒里的TCP" class="headerlink" title="WebSocket：沙盒里的TCP"></a>WebSocket：沙盒里的TCP</h2><ul>
<li>“WebSocket”是一种基于 TCP 的轻量级网络通信协议，在地位上是与 HTTP“平级”的。</li>
</ul>
<h3 id="为什么要有-WebSocket"><a href="#为什么要有-WebSocket" class="headerlink" title="为什么要有 WebSocket"></a>为什么要有 WebSocket</h3><ul>
<li>WebSocket 与 HTTP/2 一样，都是为了解决 HTTP 某方面的缺陷而诞生的。HTTP/2 针对的是“队头阻塞”，而 WebSocket 针对的是“请求 - 应答”通信模式。</li>
<li>“请求 - 应答”是一种“半双工”的通信模式，虽然可以双向收发数据，但同一时刻只能一个方向上有动作，传输效率低。更关键的一点，它是一种“被动”通信模式，服务器只能“被动”响应客户端的请求，无法主动向客户端发送数据。</li>
<li>虽然后来的 HTTP/2、HTTP/3 新增了 Stream、Server Push 等特性，但“请求 - 应答”依然是主要的工作方式。这就导致 HTTP 难以应用在动态页面、即时消息、网络游戏等要求“实时通信”的领域。<h3 id="WebSocket-的特点"><a href="#WebSocket-的特点" class="headerlink" title="WebSocket 的特点"></a>WebSocket 的特点</h3></li>
<li>WebSocket 是一个真正“全双工”的通信协议，与 TCP 一样，客户端和服务器都可以随时向对方发送数据，而不用像 HTTP“你拍一，我拍一”那么“客套”。</li>
<li>WebSocket 采用了二进制帧结构，语法、语义与 HTTP 完全不兼容，但因为它的主要运行环境是浏览器，为了便于推广和应用，就不得不“搭便车”，在使用习惯上尽量向 HTTP 靠拢，这就是它名字里“Web”的含义。</li>
<li>服务发现方面，WebSocket 没有使用 TCP 的“IP 地址 + 端口号”，而是延用了 HTTP 的 URI 格式，但开头的协议名不是“http”，引入的是两个新的名字：“ws”和“wss”，分别表示明文和加密的 WebSocket 协议。</li>
<li>WebSocket 的默认端口也选择了 80 和 443，因为现在互联网上的防火墙屏蔽了绝大多数的端口，只对 HTTP 的 80、443 端口“放行”，所以 WebSocket 就可以“伪装”成 HTTP 协议，比较容易地“穿透”防火墙，与服务器建立连接。<h3 id="WebSocket-的帧结构"><a href="#WebSocket-的帧结构" class="headerlink" title="WebSocket 的帧结构"></a>WebSocket 的帧结构</h3></li>
<li>不过 WebSocket 和 HTTP/2 的关注点不同，WebSocket 更侧重于“实时通信”，而 HTTP/2 更侧重于提高传输效率，所以两者的帧结构也有很大的区别。</li>
<li>WebSocket 虽然有“帧”，但却没有像 HTTP/2 那样定义“流”，也就不存在“多路复用”“优先级”等复杂的特性，而它自身就是“全双工”的，也就不需要“服务器推送”。所以综合起来，WebSocket 的帧学习起来会简单一些。<h3 id="WebSocket-的握手"><a href="#WebSocket-的握手" class="headerlink" title="WebSocket 的握手"></a>WebSocket 的握手</h3></li>
<li>和 TCP、TLS 一样，WebSocket 也要有一个握手过程，然后才能正式收发数据。</li>
<li>WebSocket 的握手是一个标准的 HTTP GET 请求，但要带上两个协议升级的专用头字段：“Connection: Upgrade”，表示要求协议“升级”；“Upgrade: websocket”，表示要“升级”成 WebSocket 协议。</li>
<li>另外，为了防止普通的 HTTP 消息被“意外”识别成 WebSocket，握手消息还增加了两个额外的认证用头字段（所谓的“挑战”，Challenge）：Sec-WebSocket-Key：一个 Base64 编码的 16 字节随机数，作为简单的认证密钥；Sec-WebSocket-Version：协议的版本号，当前必须是 13。</li>
<li>服务器收到 HTTP 请求报文，看到上面的四个字段，就知道这不是一个普通的 GET 请求，而是 WebSocket 的升级请求，于是就不走普通的 HTTP 处理流程，而是构造一个特殊的“101 Switching Protocols”响应报文，通知客户端，接下来就不用 HTTP 了，全改用 WebSocket 协议通信。（有点像 TLS 的“Change Cipher Spec”）</li>
<li>WebSocket 的握手响应报文也是有特殊格式的，要用字段“Sec-WebSocket-Accept”验证客户端请求报文，同样也是为了防止误连接。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">encode_base64(</span><br><span class="line">  sha1( </span><br><span class="line">    Sec-WebSocket-Key + &apos;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&apos; ))</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h3><ul>
<li>HTTP 的“请求 - 应答”模式不适合开发“实时通信”应用，效率低，难以实现动态页面，所以出现了 WebSocket；</li>
<li>WebSocket 是一个“全双工”的通信协议，相当于对 TCP 做了一层“薄薄的包装”，让它运行在浏览器环境里；</li>
<li>WebSocket 使用兼容 HTTP 的 URI 来发现服务，但定义了新的协议名“ws”和“wss”，端口号也沿用了 80 和 443；</li>
<li>WebSocket 使用二进制帧，结构比较简单，特殊的地方是有个“掩码”操作，客户端发数据必须掩码，服务器则不用；</li>
<li>WebSocket 利用 HTTP 协议实现连接握手，发送 GET 请求要求“协议升级”，握手过程中有个非常简单的认证机制，目的是防止误连接。</li>
</ul>
<h2 id="HTTP性能优化面面观（上）"><a href="#HTTP性能优化面面观（上）" class="headerlink" title="HTTP性能优化面面观（上）"></a>HTTP性能优化面面观（上）</h2><h3 id="HTTP-服务器"><a href="#HTTP-服务器" class="headerlink" title="HTTP 服务器"></a>HTTP 服务器</h3><ul>
<li>衡量服务器性能的主要指标有三个：吞吐量（requests per second）、并发数（concurrency）和响应时间（time per request）。除了上面的三个基本性能指标，服务器还要考虑 CPU、内存、硬盘和网卡等系统资源的占用程度，利用率过高或者过低都可能有问题。</li>
</ul>
<ol>
<li>吞吐量就是我们常说的 RPS，每秒的请求次数，也有叫 TPS、QPS，它是服务器最基本的性能指标，RPS 越高就说明服务器的性能越好。</li>
<li>并发数反映的是服务器的负载能力，也就是服务器能够同时支持的客户端数量，当然也是越多越好，能够服务更多的用户。</li>
<li>响应时间反映的是服务器的处理能力，也就是快慢程度，响应时间越短，单位时间内服务器就能够给越多的用户提供服务，提高吞吐量和并发数。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">在 Linux 上，最常用的性能测试工具可能就是 ab（Apache Bench）了，比如，下面的命令指定了并发数 100，总共发送 10000 个请求：</span><br><span class="line"></span><br><span class="line">ab -c 100 -n 10000 &apos;http://www.xxx.com&apos;</span><br><span class="line"></span><br><span class="line">系统资源监控方面，Linux 自带的工具也非常多，常用的有 uptime、top、vmstat、netstat、sar 等等，可能你比我还要熟悉，我就列几个简单的例子吧：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">top             #查看CPU和内存占用情况</span><br><span class="line">vmstat  2       #每2秒检查一次系统状态</span><br><span class="line">sar -n DEV 2    #看所有网卡的流量，定时2秒检查</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="HTTP-客户端"><a href="#HTTP-客户端" class="headerlink" title="HTTP 客户端"></a>HTTP 客户端</h3><ul>
<li>客户端是信息的消费者，一切数据都要通过网络从服务器获取，所以它最基本的性能指标就是“延迟”（latency）。所谓的“延迟”其实就是“等待”，等待数据到达客户端时所花费的时间。但因为 HTTP 的传输链路很复杂，所以延迟的原因也就多种多样。</li>
</ul>
<ol>
<li>首先，我们必须谨记有一个“不可逾越”的障碍——光速，因为地理距离而导致的延迟是无法克服的，访问数千公里外的网站显然会有更大的延迟。</li>
<li>其次，第二个因素是带宽，它又包括接入互联网时的电缆、WiFi、4G 和运营商内部网络、运营商之间网络的各种带宽，每一处都有可能成为数据传输的瓶颈，降低传输速度，增加延迟。</li>
<li>第三个因素是 DNS 查询，如果域名在本地没有缓存，就必须向 DNS 系统发起查询，引发一连串的网络通信成本，而在获取 IP 地址之前客户端只能等待，无法访问网站。</li>
<li>第四个因素是 TCP 握手，你应该对它比较熟悉了吧，必须要经过 SYN、SYN/ACK、ACK 三个包之后才能建立连接，它带来的延迟由光速和带宽共同决定。</li>
<li>建立 TCP 连接之后，就是正常的数据收发了，后面还有解析 HTML、执行 JavaScript、排版渲染等等，这些也会耗费一些时间。不过它们已经不属于 HTTP 了，所以不在今天的讨论范围之内。</li>
</ol>
<ul>
<li>因为有“队头阻塞”，浏览器对每个域名最多开 6 个并发连接（HTTP/1.1），当页面里链接很多的时候就必须排队等待（Queued、Queueing）</li>
<li>浏览器要预先分配资源，调度连接</li>
<li>连接前必须要解析域名</li>
<li>与网站服务器建立连接的成本很高</li>
<li>实际发送数据非常快</li>
<li>之后就是等待服务器的响应，专有名词叫 TTFB（Time To First Byte），也就是“首字节响应时间”，里面包括了服务器的处理时间和网络传输时间</li>
<li>接收数据也是非常快的</li>
</ul>
<h3 id="HTTP-传输链路"><a href="#HTTP-传输链路" class="headerlink" title="HTTP 传输链路"></a>HTTP 传输链路</h3><ul>
<li>“第一公里”是指网站的出口，也就是服务器接入互联网的传输线路，它的带宽直接决定了网站对外的服务能力，也就是吞吐量等指标。显然，优化性能应该在这“第一公里”加大投入，尽量购买大带宽，接入更多的运营商网络。</li>
<li>“中间一公里”就是由许多小网络组成的实际的互联网，其实它远不止“一公里”，而是非常非常庞大和复杂的网络，地理距离、网络互通都严重影响了传输速度。好在这里面有一个 HTTP 的“好帮手”——CDN，它可以帮助网站跨越“千山万水”，让这段距离看起来真的就好像只有“一公里”。</li>
<li>“最后一公里”是用户访问互联网的入口，对于固网用户就是光纤、网线，对于移动用户就是 WiFi、基站。以前它是客户端性能的主要瓶颈，延迟大带宽小，但随着近几年 4G 和高速宽带的普及，“最后一公里”的情况已经好了很多，不再是制约性能的主要因素了。</li>
</ul>
<h3 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h3><ul>
<li>性能优化是一个复杂的概念，在 HTTP 里可以分解为服务器性能优化、客户端性能优化和传输链路优化；</li>
<li>服务器有三个主要的性能指标：吞吐量、并发数和响应时间，此外还需要考虑资源利用率；</li>
<li>客户端的基本性能指标是延迟，影响因素有地理距离、带宽、DNS 查询、TCP 握手等；</li>
<li>从服务器到客户端的传输链路可以分为三个部分，我们能够优化的是前两个部分，也就是“第一公里”和“中间一公里”；</li>
<li>有很多工具可以测量这些指标，服务器端有 ab、top、sar 等，客户端可以使用测试网站，浏览器的开发者工具。</li>
</ul>
<h2 id="HTTP性能优化面面观（下）"><a href="#HTTP性能优化面面观（下）" class="headerlink" title="HTTP性能优化面面观（下）"></a>HTTP性能优化面面观（下）</h2><ul>
<li>总的来说，任何计算机系统的优化都可以分成这么几类：硬件软件、内部外部、花钱不花钱。</li>
<li>投资购买现成的硬件最简单的优化方式，比如换上更强的 CPU、更快的网卡、更大的带宽、更多的服务器，效果也会“立竿见影”，直接提升网站的服务能力，也就实现了 HTTP 优化。</li>
<li>另外，花钱购买外部的软件或者服务也是一种行之有效的优化方式，最“物有所值”的应该算是 CDN 了。CDN 专注于网络内容交付，帮助网站解决“中间一公里”的问题，还有很多其他非常专业的优化功能。把网站交给 CDN 运营，就好像是“让网站坐上了喷气飞机”，能够直达用户，几乎不需要费什么力气就能够达成很好的优化效果。</li>
<li>不过这些“花钱”的手段实在是太没有“技术含量”了，属于“懒人”（无贬义）的做法。<h3 id="开源"><a href="#开源" class="headerlink" title="开源"></a>开源</h3></li>
<li>这个“开源”可不是 Open Source，而是指抓“源头”，开发网站服务器自身的潜力，在现有条件不变的情况下尽量挖掘出更多的服务能力。</li>
<li>首先，我们应该选用高性能的 Web 服务器，最佳选择当然就是 Nginx/OpenResty 了，尽量不要选择基于 Java、Python、Ruby 的其他服务器，它们用来做后面的业务逻辑服务器更好。利用 Nginx 强大的反向代理能力实现“动静分离”，动态页面交给 Tomcat、Django、Rails，图片、样式表等静态资源交给 Nginx。</li>
<li>Nginx 或者 OpenResty 自身也有很多配置参数可以用来进一步调优，举几个例子，比如说禁用负载均衡锁、增大连接池，绑定 CPU 等等，相关的资料有很多。</li>
<li>对于 HTTP 协议一定要启用长连接。TCP 和 SSL 建立新连接的成本是非常高的，有可能会占到客户端总延迟的一半以上。长连接虽然不能优化连接握手，但可以把成本“均摊”到多次请求里，这样只有第一次请求会有延迟，之后的请求就不会有连接延迟，总体的延迟也就降低了。</li>
<li>在现代操作系统上都已经支持 TCP 的新特性“TCP Fast Open”（Win10、iOS9、Linux 4.1），它的效果类似 TLS 的“False Start”，可以在初次握手的时候就传输数据，也就是 0-RTT，所以我们应该尽可能在操作系统和 Nginx 里开启这个特性，减少外网和内网里的握手延迟。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">下面给出一个简短的 Nginx 配置示例，启用了长连接等优化参数，实现了动静分离。</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen 80 deferred reuseport backlog=4096 fastopen=1024; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  keepalive_timeout  60;</span><br><span class="line">  keepalive_requests 10000;</span><br><span class="line">  </span><br><span class="line">  location ~* \.(png)$ &#123;</span><br><span class="line">    root /var/images/png/;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  location ~* \.(php)$ &#123;</span><br><span class="line">    proxy_pass http://php_back_end;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><ul>
<li>“节流”是指减少客户端和服务器之间收发的数据量，在有限的带宽里传输更多的内容。</li>
<li>“节流”最基本的做法就是使用 HTTP 协议内置的“数据压缩”编码，不仅可以选择标准的 gzip，还可以积极尝试新的压缩算法 br，它有更好的压缩效果。</li>
<li>不过在数据压缩的时候应当注意选择适当的压缩率，不要追求最高压缩比，否则会耗费服务器的计算资源，增加响应时间，降低服务能力，反而会“得不偿失”。</li>
<li>HTML/CSS/JavaScript 属于纯文本，就可以采用特殊的“压缩”，去掉源码里多余的空格、换行、注释等元素。这样“压缩”之后的文本虽然看起来很混乱，对“人类”不友好，但计算机仍然能够毫无障碍地阅读，不影响浏览器上的运行效果。</li>
<li>图片在 HTTP 传输里占有非常高的比例，虽然它本身已经被压缩过了，不能被 gzip、br 处理，但仍然有优化的空间。比如说，去除图片里的拍摄时间、地点、机型等元数据，适当降低分辨率，缩小尺寸。图片的格式也很关键，尽量选择高压缩率的格式，有损格式应该用 JPEG，无损格式应该用 Webp 格式。</li>
<li>对于小文本或者小图片，还有一种叫做“资源合并”（Concatenation）的优化方式，就是把许多小资源合并成一个大资源，用一个请求全下载到客户端，然后客户端再用 JavaScript、CSS 切分后使用，好处是节省了请求次数，但缺点是处理比较麻烦。</li>
<li>刚才说的几种数据压缩针对的都是 HTTP 报文里的 body，在 HTTP/1 里没有办法可以压缩 header，但我们也可以采取一些手段来减少 header 的大小，不必要的字段就尽量不发（例如 Server、X-Powered-By）。</li>
<li>网站经常会使用 Cookie 来记录用户的数据，浏览器访问网站时每次都会带上 Cookie，冗余度很高。所以应当少使用 Cookie，减少 Cookie 记录的数据量，总使用 domain 和 path 属性限定 Cookie 的作用域，尽可能减少 Cookie 的传输。如果客户端是现代浏览器，还可以使用 HTML5 里定义的 Web Local Storage，避免使用 Cookie。</li>
<li>DNS 解析域名会耗费不少的时间，如果网站拥有多个域名，那么域名解析获取 IP 地址就是一个不小的成本，所以应当适当“收缩”域名，限制在两三个左右，减少解析完整域名所需的时间，让客户端尽快从系统缓存里获取解析结果。</li>
<li>重定向引发的客户端延迟也很高，它不仅增加了一次请求往返，还有可能导致新域名的 DNS 解析，是 HTTP 前端性能优化的“大忌”。除非必要，应当尽量不使用重定向，或者使用 Web 服务器的“内部重定向”。<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3></li>
<li>它不仅是 HTTP，也是任何计算机系统性能优化的“法宝”，把它和上面的“开源”“节流”搭配起来应用于传输链路，就能够让 HTTP 的性能再上一个台阶。</li>
<li>利用好缓存功能的关键是理解它的工作原理，为每个资源都添加 ETag 和 Last-modified 字段，再用 Cache-Control、Expires 设置好缓存控制属性。</li>
<li>其中最基本的是 max-age 有效期，标记资源可缓存的时间。对于图片、CSS 等静态资源可以设置较长的时间，比如一天或者一个月，对于动态资源，除非是实时性非常高，也可以设置一个较短的时间，比如 1 秒或者 5 秒。</li>
<li>这样一旦资源到达客户端，就会被缓存起来，在有效期内都不会再向服务器发送请求，也就是：“没有请求的请求，才是最快的请求。”</li>
</ul>
<h3 id="HTTP-2-1"><a href="#HTTP-2-1" class="headerlink" title="HTTP/2"></a>HTTP/2</h3><ul>
<li>HTTP 性能优化还有一个选择，那就是把协议由 HTTP/1 升级到 HTTP/2。</li>
<li>你已经知道了 HTTP/2 的很多优点，它消除了应用层的队头阻塞，拥有头部压缩、二进制帧、多路复用、流量控制、服务器推送等许多新特性，大幅度提升了 HTTP 的传输效率。</li>
<li>对于 HTTP/2 来说，一个域名使用一个 TCP 连接才能够获得最佳性能，如果开多个域名，就会浪费带宽和服务器资源，也会降低 HTTP/2 的效率，所以“域名收缩”在 HTTP/2 里是必须要做的。</li>
<li>“资源合并”在 HTTP/1 里减少了多次请求的成本，但在 HTTP/2 里因为有头部压缩和多路复用，传输小文件的成本很低，所以合并就失去了意义。而且“资源合并”还有一个缺点，就是降低了缓存的可用性，只要一个小文件更新，整个缓存就完全失效，必须重新下载。</li>
<li>所以在现在的大带宽和 CDN 应用场景下，应当尽量少用资源合并（JavaScript、CSS 图片合并，数据内嵌），让资源的粒度尽可能地小，才能更好地发挥缓存的作用。</li>
</ul>
<h3 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h3><ul>
<li>花钱购买硬件、软件或者服务可以直接提升网站的服务能力，其中最有价值的是 CDN；</li>
<li>不花钱也可以优化 HTTP，三个关键词是“开源”“节流”和“缓存”；</li>
<li>后端应该选用高性能的 Web 服务器，开启长连接，提升 TCP 的传输效率；</li>
<li>前端应该启用 gzip、br 压缩，减小文本、图片的体积，尽量少传不必要的头字段；</li>
<li>缓存是无论何时都不能忘记的性能优化利器，应该总使用 Etag 或 Last-modified 字段标记资源；</li>
<li>升级到 HTTP/2 能够直接获得许多方面的性能提升，但要留意一些 HTTP/1 的“反模式”。</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/学习/">学习</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/学习/">学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网站/">网站</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/资源/">资源</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-algorithm" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2021/03/29/algorithm/" class="article-date">
      <time datetime="2021-03-28T16:00:00.000Z" itemprop="datePublished">2021-03-29</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/29/algorithm/">算法</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>/*<em>
 </em>假设有任意多张面额为 2 元、3 元、7 元的货币，现要用它们凑出 100 元，求总共有多少种可能性。<br> */<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function test1() &#123;</span><br><span class="line">  let count = 0;</span><br><span class="line">  for (let i = 0; i &lt;= 100 / 7; i++) &#123;</span><br><span class="line">    //这里针对j可以优化一波</span><br><span class="line">    for (let j = 0; j &lt;= 100 / 3; j++) &#123;</span><br><span class="line">      if (100 - i * 7 - j * 3 &gt;= 0 &amp;&amp; (100 - i * 7 - j * 3) % 2 == 0) &#123;</span><br><span class="line">        count += 1;</span><br><span class="line">        console.log(</span><br><span class="line">          `$&#123;count&#125;:7元:$&#123;i&#125;张,3元:$&#123;j&#125;张,2元:$&#123;(100 - i * 7 - j * 3) / 2&#125;张`</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(`一共有$&#123;count&#125;种可能性`);</span><br><span class="line">&#125;</span><br><span class="line">//test1();</span><br></pre></td></tr></table></figure></p>
<p>/**</p>
<ul>
<li>查找出一个数组中，出现次数最多的那个元素的数值。</li>
<li>例如，输入数组 a = [1,2,3,4,5,5,6 ] 中，查找出现次数最多的数值。</li>
<li>从数组中可以看出，只有 5 出现了 2 次，其余都是 1 次。显然 5 出现的次数最多，则输出 5。<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function test2(arr) &#123;</span><br><span class="line">  //记录数组元素出现次数  采用map数据结构，查找的时间复杂度是o(1)</span><br><span class="line">  let res = new Map();</span><br><span class="line">  //出现最多次数</span><br><span class="line">  let max = -1;</span><br><span class="line">  for (let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">    if (res.has(arr[i])) &#123;</span><br><span class="line">      res.set(arr[i], res.get(arr[i]) + 1);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      res.set(arr[i], 1);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  //获取出现次数的最大值</span><br><span class="line">  max = Math.max.apply(null, [...res.values()]);</span><br><span class="line">  for (let [key, value] of res) &#123;</span><br><span class="line">    if (value === max) console.log(`$&#123;key&#125;出现的次数最多，出现了$&#123;value&#125;次`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//test2([1, 2, 3, 4, 5, 5, 6]);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</li>
<li>有效字符串需满足：左括号必须与相同类型的右括号匹配，左括号必须以正确的顺序匹配。</li>
<li>例如，{ [ ( ) ( ) ] } 是合法的，而 { ( [ ) ] } 是非法的。</li>
<li>思路：</li>
<li>从左到右顺序遍历字符串。</li>
<li>当出现左括号时，压栈。</li>
<li>当出现右括号时，出栈。</li>
<li>并且判断当前右括号，和被出栈的左括号是否是互相匹配的一对。</li>
<li>如果不是，则字符串非法。当遍历完成之后，如果栈为空。则合法。<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function test3(data) &#123;</span><br><span class="line">  //左括号</span><br><span class="line">  const typesLeft = [&quot;(&quot;, &quot;[&quot;, &quot;&#123;&quot;];</span><br><span class="line">  //右括号</span><br><span class="line">  const typesRight = [&quot;)&quot;, &quot;]&quot;, &quot;&#125;&quot;];</span><br><span class="line">  //括号</span><br><span class="line">  const types = [&quot;()&quot;, &quot;[]&quot;, &quot;&#123;&#125;&quot;];</span><br><span class="line"></span><br><span class="line">  //存储 模拟栈</span><br><span class="line">  const store = [];</span><br><span class="line"></span><br><span class="line">  for (let type of data) &#123;</span><br><span class="line">      //匹配到左括号时，进行入栈操作</span><br><span class="line">    if (typesLeft.includes(type)) &#123;</span><br><span class="line">      store.push(type);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      //匹配到右括号时，进行出栈操作，检验当前括号是否合法</span><br><span class="line">      const left = store.pop();</span><br><span class="line">      if (!types.includes(`$&#123;left&#125;$&#123;type&#125;`)) &#123;</span><br><span class="line">        console.log(&quot;非法字符串&quot;);</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//test3([&apos;(&apos;,&apos;&#123;&apos;,&apos;&#125;&apos;,&apos;&#125;&apos;,&apos;)&apos;])</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>约瑟夫环是一个数学的应用问题，具体为，已知 n 个人（以编号 1，2，3…n 分别表示）围坐在一张圆桌周围。</li>
<li>从编号为 k 的人开始报数，数到 m 的那个人出列；</li>
<li>他的下一个人又从 1 开始报数，数到 m 的那个人又出列；</li>
<li>依此规律重复下去，直到圆桌周围的人全部出列。</li>
<li>这个问题的输入变量就是 n 和 m，即 n 个人和数到 m 的出列的人。输出的结果，就是 n 个人出列的顺序。</li>
<li>这个问题，用队列的方法实现是个不错的选择。它的结果就是出列的顺序，恰好满足队列对处理顺序敏感的前提。因此，求解方式也是基于队列的先进先出原则。</li>
<li>解法如下：</li>
<li>先把所有人都放入循环队列中。注意这个循环队列的长度要大于或者等于 n。</li>
<li>从第一个人开始依次出队列，出队列一次则计数变量 i 自增。如果 i 比 m 小，则还需要再入队列。</li>
<li>直到i等于 m 的人出队列时，就不用再让这个人进队列了。而是放入一个用来记录出队列顺序的数组中。</li>
<li>直到数完 n 个人为止。当队列为空时，则表示队列中的 n 个人都出队列了，这时结束队列循环，输出数组内记录的元素。<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">//n个人，从编号为k的人开始报数，</span><br><span class="line">function test4(persons, k, m) &#123;</span><br><span class="line">  //退出的人</span><br><span class="line">  const exitPersons = [];</span><br><span class="line">  //计数器</span><br><span class="line">  let count = 1;</span><br><span class="line"></span><br><span class="line">  //第一次</span><br><span class="line">  for (let &#123; name, num &#125; of persons) &#123;</span><br><span class="line">    if (num &lt; k) &#123;</span><br><span class="line">      persons.shift();</span><br><span class="line">      persons.push(&#123;</span><br><span class="line">        name,</span><br><span class="line">        num,</span><br><span class="line">      &#125;);</span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br><span class="line">    break;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //还有人时</span><br><span class="line">  while (persons.length) &#123;</span><br><span class="line">    const person = persons.shift();</span><br><span class="line">    if (count &lt; m) &#123;</span><br><span class="line">      persons.push(person);</span><br><span class="line">      count++;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      //找到目标后，重置计数器</span><br><span class="line">      count = 1;</span><br><span class="line">      exitPersons.push(person);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  //console.log(exitPersons);</span><br><span class="line">&#125;</span><br><span class="line">// test4(</span><br><span class="line">//   [</span><br><span class="line">//     &#123; name: &quot;赵一&quot;, num: 1 &#125;,</span><br><span class="line">//     &#123; name: &quot;钱二&quot;, num: 2 &#125;,</span><br><span class="line">//     &#123; name: &quot;孙三&quot;, num: 3 &#125;,</span><br><span class="line">//     &#123; name: &quot;李四&quot;, num: 4 &#125;,</span><br><span class="line">//     &#123; name: &quot;周五&quot;, num: 5 &#125;,</span><br><span class="line">//     &#123; name: &quot;吴六&quot;, num: 6 &#125;,</span><br><span class="line">//     &#123; name: &quot;郑七&quot;, num: 7 &#125;,</span><br><span class="line">//     &#123; name: &quot;王八&quot;, num: 8 &#125;,</span><br><span class="line">//   ],</span><br><span class="line">//   2,</span><br><span class="line">//   4</span><br><span class="line">// );</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>10</li>
<li>/  \</li>
<li>8   12</li>
<li>/ \  / \</li>
<li>6   9 11 13</li>
<li>给定一棵树，按照层次顺序遍历并打印这棵树。<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">const root = &#123;</span><br><span class="line">  value: 10,</span><br><span class="line">  left: &#123; value: 8, left: &#123; value: 6 &#125;, right: &#123; value: 9 &#125; &#125;,</span><br><span class="line">  right: &#123; value: 12, left: &#123; value: 11 &#125;, right: &#123; value: 13 &#125; &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">function test5(root) &#123;</span><br><span class="line">  //模拟队列</span><br><span class="line">  const queue = [];</span><br><span class="line">  //根节点入队列</span><br><span class="line">  queue.push(root);</span><br><span class="line">  while (queue.length) &#123;</span><br><span class="line">    //当前节点</span><br><span class="line">    const current = queue.shift();</span><br><span class="line">    console.log(current.value);</span><br><span class="line">    //左节点</span><br><span class="line">    if (current.left) &#123;</span><br><span class="line">      queue.push(current.left);</span><br><span class="line">    &#125;</span><br><span class="line">    //右节点</span><br><span class="line">    if (current.right) &#123;</span><br><span class="line">      queue.push(current.right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//test5(root);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>10</li>
<li>/  \</li>
<li>8   12</li>
<li>/ \  / \</li>
<li>6   9 11 13</li>
<li>二叉树的三种遍历方式<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//前序</span><br><span class="line">function test6(node) &#123;</span><br><span class="line">  if (!node) return;</span><br><span class="line">  console.log(node.value);</span><br><span class="line">  test6(node.left);</span><br><span class="line">  test6(node.right);</span><br><span class="line">&#125;</span><br><span class="line">//test6(root)</span><br><span class="line">//中序</span><br><span class="line">function test7(node) &#123;</span><br><span class="line">  if (!node) return;</span><br><span class="line">  test7(node.left);</span><br><span class="line">  console.log(node.value);</span><br><span class="line">  test7(node.right);</span><br><span class="line">&#125;</span><br><span class="line">//test7(root)</span><br><span class="line">//后序</span><br><span class="line">function test8(node) &#123;</span><br><span class="line">  if (!node) return;</span><br><span class="line">  test8(node.left);</span><br><span class="line">  test8(node.right);</span><br><span class="line">  console.log(node.value);</span><br><span class="line">&#125;</span><br><span class="line">//test8(root)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>给定一个整数数组 arr 和一个目标值 target，请你在该数组中找出加和等于目标值的那两个整数，并返回它们的在数组中下标。</li>
<li>你可以假设，原数组中没有重复元素，而且有且只有一组答案。但是，数组中的元素只能使用一次。例如，arr = [1, 2, 3, 4, 5, 6]，target = 4。因为，arr[0] + arr[2] = 1 + 3 = 4 = target，则输出 0，2。<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function test9(data, target) &#123;</span><br><span class="line">  for (const item of data) &#123;</span><br><span class="line">    if (data.includes(target - item) &amp;&amp; target - item !== item)</span><br><span class="line">      console.log(`$&#123;target&#125;=$&#123;item&#125;+$&#123;target - item&#125;`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//test9([1,2,3,4,5,6],4)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>汉诺塔问题(递归)</li>
<li>从左到右有 x、y、z 三根柱子，其中 x 柱子上面有从小叠到大的 n 个圆盘。现要求将 x 柱子上的圆盘移到 z 柱子上去。要求是，每次只能移动一个盘子，且大盘子不能被放在小盘子上面。求移动的步骤。</li>
<li><hr>
</li>
<li>我们的原问题是，把从小到大的 n 个盘子，从 x 移动到 z。</li>
<li>我们可以将这个大问题拆解为以下 3 个小问题：</li>
<li>把从小到大的 n-1 个盘子，从 x 移动到 y；</li>
<li>接着把最大的一个盘子，从 x 移动到 z；</li>
<li>再把从小到大的 n-1 个盘子，从 y 移动到 z。</li>
<li><hr>
</li>
<li>经过仔细分析可见，汉诺塔问题是完全可以用递归实现的。我们定义汉诺塔的递归函数为 hanio()。这个函数的输入参数包括了：</li>
<li>3 根柱子的标记 x、y、z；</li>
<li>待移动的盘子数量 n。</li>
<li><hr>
</li>
<li>具体代码如下所示，在代码中，hanio(n, x, y, z)，代表了把 n 个盘子由 x 移动到 z。根据分析，我们知道递归体包含 3 个步骤：</li>
<li>把从小到大的 n-1 个盘子从 x 移动到 y，那么代码就是 hanio(n-1, x, z, y)；</li>
<li>再把最大的一个盘子从 x 移动到 z，那么直接完成一次移动的动作就可以了；</li>
<li>再把从小到大的 n-1 个盘子从 y 移动到 z，那么代码就是 hanio(n-1, y, x, z)。对于终止条件则需要判断 n 的大小。如果 n 等于 1，那么同样直接移动就可以了。<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function test10(n, x, y, z) &#123;</span><br><span class="line">  if (n &lt; 1) return console.log(&quot;汉诺塔层数不能小于1&quot;);</span><br><span class="line">  if (n === 1) return console.log(`移动$&#123;x&#125;到$&#123;z&#125;`);</span><br><span class="line">  test10(n - 1, x, z, y);</span><br><span class="line">  console.log(`移动$&#123;x&#125;到$&#123;z&#125;`);</span><br><span class="line">  test10(n - 1, y, x, z);</span><br><span class="line">&#125;</span><br><span class="line">//test10(3, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>斐波那契数列。(递归)</li>
<li>斐波那契数列是：0，1，1，2，3，5，8，13，21，34，55，89，144……。</li>
<li>你会发现，这个数列中元素的性质是，某个数等于它前面两个数的和；</li>
<li>也就是 a[n+2] = a[n+1] + a[n]。至于起始两个元素，则分别为 0 和 1。</li>
<li>在这个数列中的数字，就被称为斐波那契数。</li>
<li><hr>
</li>
<li>写一个函数，输入 x，输出斐波那契数列中第 x 位的元素。</li>
<li>例如，输入 4，输出 2；输入 9，输出 21。</li>
<li>要求：需要用递归的方式来实现。<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const target = 9;</span><br><span class="line">const data = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144];</span><br><span class="line">function test11(data, x) &#123;</span><br><span class="line">  if (x === 1) return 0;</span><br><span class="line">  if (x === 2) return 1;</span><br><span class="line">  if (x &gt; 2) data[x] = test11(data, x - 1) + test11(data, x - 2);</span><br><span class="line">  //输出结果</span><br><span class="line">  if (x === target) console.log(data[x]);</span><br><span class="line">  return data[x];</span><br><span class="line">&#125;</span><br><span class="line">//test11(data, target);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>/*<em>
 </em>二分 (基于有序)<br> */<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function test12(data, target) &#123;</span><br><span class="line">  //低</span><br><span class="line">  let low = 0;</span><br><span class="line">  //高</span><br><span class="line">  let high = data.length - 1;</span><br><span class="line">  //中</span><br><span class="line">  let middle = 0;</span><br><span class="line">  //计数器</span><br><span class="line">  let count = 1;</span><br><span class="line">  while (low &lt;= high) &#123;</span><br><span class="line">    middle = Math.floor((low + high) / 2);</span><br><span class="line">    if (target === data[middle]) &#123;</span><br><span class="line">      console.log(`找了$&#123;count&#125;次`);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (target &gt; data[middle]) &#123;</span><br><span class="line">      low = middle + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (target &lt; data[middle]) &#123;</span><br><span class="line">      high = middle - 1;</span><br><span class="line">    &#125;</span><br><span class="line">    count++;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(&quot;没有找到&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//test12([2, 4, 6, 7], 4);</span><br></pre></td></tr></table></figure></p>
<p>/*<em>
 </em>在一个有序数组中，查找出第一个大于 9 的数字，假设一定存在。<br> <em>例如，arr = { -1, 3, 3, 7, 10, 14, 14 }; 则返回 10。
 </em>查找的目标数字具备这样的性质：<br> <em>第一，它比 9 大；
 </em>第二，它前面的数字（除非它是第一个数字），比 9 小。<br> <em>因此，当我们作出向左走或向右走的决策时，必须满足这两个条件。
 </em>/<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function test13(data, target) &#123;</span><br><span class="line">  let low = 0;</span><br><span class="line">  let high = data.length - 1;</span><br><span class="line">  let middle = 0;</span><br><span class="line">  while (low &lt;= high) &#123;</span><br><span class="line">    middle = Math.floor((low + high) / 2);</span><br><span class="line">    if (target &gt;= data[middle]) &#123;</span><br><span class="line">      if (target &lt; data[middle + 1]) return data[middle + 1];</span><br><span class="line">      low = middle + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (target &lt; data[middle]) &#123;</span><br><span class="line">      if (target &gt; data[middle - 1]) return data[middle];</span><br><span class="line">      high = middle - 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//console.log(test13([-1, 3, 3, 7, 10, 14, 14], 9));</span><br></pre></td></tr></table></figure></p>
<p>/**</p>
<ul>
<li>冒泡排序<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function test14(data) &#123;</span><br><span class="line">  for (let i = 0; i &lt; data.length; i++) &#123;</span><br><span class="line">    //j &lt; data.length - i 每一轮都会筛选出一个最值，减少没有必要的比较次数</span><br><span class="line">    for (let j = 0; j &lt; data.length - i; j++) &#123;</span><br><span class="line">      //交换位置</span><br><span class="line">      if (data[j] &gt; data[j + 1]) &#123;</span><br><span class="line">        data[j + 1] = data[j] + data[j + 1];</span><br><span class="line">        data[j] = data[j + 1] - data[j];</span><br><span class="line">        data[j + 1] = data[j + 1] - data[j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(data);</span><br><span class="line">&#125;</span><br><span class="line">//test14([-1, 3, -3, 7, 10, 14, 14]);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>插入排序</li>
<li>选取未排序的元素，插入到已排序区间的合适位置，直到未排序区间为空。</li>
<li>插入排序顾名思义，就是从左到右维护一个已经排好序的序列。直到所有的待排数据全都完成插入的动作。<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">function test15(data) &#123;</span><br><span class="line">  for (let i = 1; i &lt; data.length; i++) &#123;</span><br><span class="line">    //记录当前遍历的元素</span><br><span class="line">    let current = data[i];</span><br><span class="line">    for (let j = i - 1; j &gt;= 0; j--) &#123;</span><br><span class="line">      if (data[j] &gt; current) &#123;</span><br><span class="line">        data[j + 1] = data[j] + data[j + 1];</span><br><span class="line">        data[j] = data[j + 1] - data[j];</span><br><span class="line">        data[j + 1] = data[j + 1] - data[j];</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//test15([-1, 3, -3, 7, 10, 14, 14]);</span><br><span class="line">function test16(data) &#123;</span><br><span class="line">  for (let i = 1; i &lt; data.length; i++) &#123;</span><br><span class="line">    //记录当前遍历的元素</span><br><span class="line">    let current = data[i];</span><br><span class="line">    let j = i - 1;</span><br><span class="line">    for (; j &gt;= 0; j--) &#123;</span><br><span class="line">      if (data[j] &gt; current) &#123;</span><br><span class="line">        data[j + 1] = data[j];</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    data[j + 1] = current;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//test16([-1, 3, -3, 7, 10, 14, 14]);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>归并排序</li>
<li>归并排序的原理就是分治法。</li>
<li>它首先将数组不断地二分，直到最后每个部分只包含 1 个数据。</li>
<li>然后再对每个部分分别进行排序，最后将排序好的相邻的两部分合并在一起，这样整个数组就有序了。<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">function test17(data) &#123;</span><br><span class="line">  //临时数组</span><br><span class="line">  let temp = [];</span><br><span class="line">  //开始下标</span><br><span class="line">  let start = 0;</span><br><span class="line">  //结束下标</span><br><span class="line">  let end = data.length - 1;</span><br><span class="line"></span><br><span class="line">  //拆分</span><br><span class="line">  function split(data, temp, start, end) &#123;</span><br><span class="line">    if (start &lt; end) &#123;</span><br><span class="line">      //中间下标</span><br><span class="line">      let mid = Math.floor((start + end) / 2);</span><br><span class="line"></span><br><span class="line">      //对左边进行拆分</span><br><span class="line">      split(data, temp, start, mid);</span><br><span class="line">      //对右边进行拆分</span><br><span class="line">      split(data, temp, mid + 1, end);</span><br><span class="line">      //合并左右部分</span><br><span class="line">      merge(data, temp, start, mid, end);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //合并</span><br><span class="line">  function merge(data, temp, start, mid, end) &#123;</span><br><span class="line">    //左边开始下标</span><br><span class="line">    let leftStart = start;</span><br><span class="line">    //右边开始下标</span><br><span class="line">    let rightStart = mid + 1;</span><br><span class="line">    //临时数组开始下标</span><br><span class="line">    let left = start;</span><br><span class="line"></span><br><span class="line">    //左边部分和右边部分都未走完时</span><br><span class="line">    while (leftStart &lt;= mid &amp;&amp; rightStart &lt;= end) &#123;</span><br><span class="line">      if (data[leftStart] &gt; data[rightStart]) &#123;</span><br><span class="line">        temp[left++] = data[rightStart++];</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        temp[left++] = data[leftStart++];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //左边部分未走完时</span><br><span class="line">    while (leftStart &lt;= mid) &#123;</span><br><span class="line">      temp[left++] = data[leftStart++];</span><br><span class="line">    &#125;</span><br><span class="line">    //右边部分未走完时</span><br><span class="line">    while (rightStart &lt;= end) &#123;</span><br><span class="line">      temp[left++] = data[rightStart++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //每次合并完更新原数据</span><br><span class="line">    for (let i = 0; i &lt; temp.length; i++) &#123;</span><br><span class="line">      data[i] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  split(data, temp, start, end);</span><br><span class="line">  console.log(data);</span><br><span class="line">&#125;</span><br><span class="line">//test17([-1, -3, -3, 7, 10, 14, 14]);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>快速排序</li>
<li>快速排序法的原理也是分治法。</li>
<li>它的每轮迭代，会选取数组中任意一个数据作为分区点，将小于它的元素放在它的左侧，大于它的放在它的右侧。</li>
<li>再利用分治思想，继续分别对左右两侧进行同样的操作，直至每个区间缩小为 1，则完成排序。<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">function test18(data, start, end) &#123;</span><br><span class="line">  if (start &gt;= end) return;</span><br><span class="line"></span><br><span class="line">  //取数据第一个值作为参考值</span><br><span class="line">  let temp = data[start];</span><br><span class="line">  //左指针</span><br><span class="line">  let left = start;</span><br><span class="line">  //右指针</span><br><span class="line">  let right = end;</span><br><span class="line">  while (left &lt; right) &#123;</span><br><span class="line">    //从右</span><br><span class="line">    while (temp &lt;= data[right] &amp;&amp; left &lt; right) &#123;</span><br><span class="line">      right--;</span><br><span class="line">    &#125;</span><br><span class="line">    //从左</span><br><span class="line">    while (temp &gt;= data[left] &amp;&amp; left &lt; right) &#123;</span><br><span class="line">      left++;</span><br><span class="line">    &#125;</span><br><span class="line">    //此时的left和right位置元素交换位置</span><br><span class="line">    /**</span><br><span class="line">     * 1.可以使用变量交换两个元素</span><br><span class="line">     * 2.这里的交换方法针对left和right相同情况时做了一层判断</span><br><span class="line">     */</span><br><span class="line">    if (left !== right) &#123;</span><br><span class="line">      data[right] = data[left] + data[right];</span><br><span class="line">      data[left] = data[right] - data[left];</span><br><span class="line">      data[right] = data[right] - data[left];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  //参考值与此时的结束位置元素交换位置  (判断情况与上面类似)</span><br><span class="line">  if (start !== left) &#123;</span><br><span class="line">    data[start] = data[left] + data[start];</span><br><span class="line">    data[left] = data[start] - data[left];</span><br><span class="line">    data[start] = data[start] - data[left];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  test18(data, start, left - 1);</span><br><span class="line">  test18(data, left + 1, end);</span><br><span class="line">  console.log(data);</span><br><span class="line">&#125;</span><br><span class="line">//test18([-1, -3, -3, 7, 10, 14, 14], 0, 6);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>假设有且仅有 1 个最大公共子串。</li>
<li>比如，输入 a = “13452439”， b = “123456”。由于字符串 “345” 同时在 a 和 b 中出现，且是同时出现在 a 和 b 中的最长子串。因此输出 “345”。<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function test19(strA, strB) &#123;</span><br><span class="line">  //记录字符串a的下标</span><br><span class="line">  let indexB = -1;</span><br><span class="line">  //记录字符串b的下标</span><br><span class="line">  let indexA = -1;</span><br><span class="line">  let map = new Map();</span><br><span class="line">  for (let i = 0; i &lt; strA.length; i++) &#123;</span><br><span class="line">    indexA = i;</span><br><span class="line">    indexB = strB.indexOf(strA[i]);</span><br><span class="line">    //strA[i]是否存在strB中</span><br><span class="line">    if (indexB !== -1) &#123;</span><br><span class="line">      let str = strA[i];</span><br><span class="line">      map.set(str, str.length);</span><br><span class="line">      for (let j = indexB + 1; j &lt; strB.length; j++) &#123;</span><br><span class="line">        if (strA[++indexA] === strB[j]) &#123;</span><br><span class="line">          str += strB[j];</span><br><span class="line">          map.set(str, str.length);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  for (const [key, value] of map) &#123;</span><br><span class="line">    if (value === Math.max.apply(null, [...map.values()])) &#123;</span><br><span class="line">      console.log(`最大公共字符串为：$&#123;key&#125;`);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//test19(&quot;13145612439&quot;, &quot;1234562&quot;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>两个有序数组查找合并之后的中位数。给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出这两个正序数组合在一起之后的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</li>
<li>你可以假设 nums1 和 nums2 不会同时为空，所有的数字全都不相等。还可以再假设，如果数字个数为偶数个，中位数就是中间偏左的那个元素。</li>
<li>例如：nums1 = [1, 3, 5, 7, 9]</li>
<li>nums2 = [2, 4, 8, 12]</li>
<li>输出 5。<br>*/</li>
</ul>
<p>/**</p>
<ul>
<li>小明从小就喜欢数学，喜欢在笔记里记录很多表达式。他觉得现在的表达式写法很麻烦，为了提高运算符优先级，不得不添加很多括号。如果不小心漏了一个右括号的话，就差之毫厘，谬之千里了。</li>
<li>因此他改用前缀表达式，例如把 (2 + 3) <em> 4写成</em> + 2 3 4，这样就能避免使用括号了。这样的表达式虽然书写简单，但计算却不够直观。请你写一个程序帮他计算这些前缀表达式。</li>
<li>在这个题目中，输入就是前缀表达式，输出就是计算的结果。你可以假设除法为整除，即“5/3=1”。例如，输入字符串为 + 2 3，输出 5；输入字符串为 <em> + 2 2 3，输出为 12；输入字符串为 </em> 2 + 2 3，输出为 10。</li>
<li>我们给出一些提示。假设输入字符串为 <em> 2 + 2 3，即 2</em>(2+3)。第一个字符为运算符号 *，它将对两个数字进行乘法。如果后面紧接着的字符不全是数字字符，那就需要暂存下来，先计算后面的算式。一旦后面的计算完成，就需要接着从后往前去继续计算。</li>
<li>因为从后往前是一种逆序动作，我们能够很自然地想到可以用栈的数据结构进行存储。你可以尝试利用栈，去解决这个问题。<br>*/</li>
</ul>
<p>/**</p>
<ul>
<li>给定一个方格棋盘，从左上角出发到右下角有多少种方法</li>
<li>在一个方格棋盘里，左上角是起点，右下角是终点。每次只能向右或向下，移向相邻的格子。同时，棋盘中有若干个格子是陷阱，不可经过，必须绕开行走。</li>
<li>要求用动态规划的方法，求出从起点到终点总共有多少种不同的路径。例如，输入二维矩阵 m 代表棋盘，其中，1 表示格子可达，-1 表示陷阱。输出可行的路径数量为 2。<br>*/</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/学习/">学习</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/学习/">学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网站/">网站</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/资源/">资源</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-react" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2021/03/25/react/" class="article-date">
      <time datetime="2021-03-24T16:00:00.000Z" itemprop="datePublished">2021-03-25</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/25/react/">react进阶</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="fiber"><a href="#fiber" class="headerlink" title="fiber"></a>fiber</h2><h3 id="requestIdleCallback"><a href="#requestIdleCallback" class="headerlink" title="requestIdleCallback"></a>requestIdleCallback</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">window.requestIdleCallback()方法将在浏览器的空闲时段内调用的函数排队。</span><br><span class="line">这使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，如动画和输入响应。函数一般会按先进先调用的顺序执行，</span><br><span class="line">然而，如果回调函数指定了执行超时时间timeout，则有可能为了在超时前执行函数而打乱执行顺序。</span><br><span class="line"></span><br><span class="line">返回值为一个ID，可以把它传入 Window.cancelIdleCallback() 方法来结束回调。</span><br><span class="line"></span><br><span class="line">①参数callback:一个在事件循环空闲时即将被调用的函数的引用。函数会接收到一个名为 IdleDeadline 的参数，这个参数可以获取当前空闲时间以及回调是否在超时时间前已经执行的状态。</span><br><span class="line">②参数options：可选，包括可选的配置参数。具有如下属性：timeout：如果指定了timeout并具有一个正值，并且尚未通过超时毫秒数调用回调，那么回调会在下一次空闲时期被强制执行，尽管这样很可能会对性能造成负面影响。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function calc(deadline)&#123;</span><br><span class="line">if(deadline.timeRemaining()&gt;1)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">requestIdleCallback(calc)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">btn1.onclick=()=&gt;&#123;</span><br><span class="line">requestIdleCallback(calc)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">btn2.onclick=()=&gt;&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="旧版Stack算法"><a href="#旧版Stack算法" class="headerlink" title="旧版Stack算法"></a>旧版Stack算法</h3><ul>
<li>React 16之前比对更新虚拟Dom的过程采用循环加递归实现，一旦任务开始执行就无法进行中断，如果组件数量庞大，主线程会被长期占用，直到虚拟DOM树更新完成主线程才能被释放。主线程被长期占用会导致用户交互、动画等任务无法立即执行，页面就会卡顿，影响用户体验。</li>
<li>解决方案</li>
</ul>
<ol>
<li>利用浏览器的空闲时间执行任务（requestIdleCallback）,避免主线程的长期占用</li>
<li>放弃递归，只采用循环，循环可以中断</li>
<li>任务拆分，将任务拆分成一个一个的子任务。</li>
</ol>
<h3 id="fiber-1"><a href="#fiber-1" class="headerlink" title="fiber"></a>fiber</h3><ul>
<li>分两步：1.构建Fiber（可中断）2.提交Commit（不可中断）</li>
<li>Dom初始渲染：虚拟DOM =&gt; Fiber =&gt; Fiber [] =&gt;Dom </li>
<li>Dom更新：newFiber vs oldFiber =&gt; Fiber [] =&gt; Dom</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   type   节点；类型（元素、文本、组件）</span><br><span class="line">   props  节点属性</span><br><span class="line">   stateNode 节点Dom对象 | 组件实例对象</span><br><span class="line">   tag 节点标记（hostRoot || hostComponent || classComponent || functionComponent）</span><br><span class="line">   effects 数组，存储需要更改的fiber对象</span><br><span class="line">   effectTag 当前Fiber需要被执行的操作（新增、删除、修改）</span><br><span class="line">   parent 当前Fiber的父级Fiber</span><br><span class="line">   child 当前Fiber的子级Fiber</span><br><span class="line">   sibling 当前Fiber的下一个兄弟Fiber</span><br><span class="line">   alternate Fiber备份  fiber比对时使用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">//子任务</span><br><span class="line">const subTask=null</span><br><span class="line"></span><br><span class="line">let pendingCommit=null</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const commitAllWork = fiber =&gt;&#123;</span><br><span class="line">  fiber.effects.forEach(item=&gt;&#123;</span><br><span class="line">  </span><br><span class="line">  if(item.effectTag===&apos;update&apos;)&#123;</span><br><span class="line">  </span><br><span class="line">    //更新</span><br><span class="line">	</span><br><span class="line">	if(item.typr===item.alternate.type)&#123;</span><br><span class="line">	</span><br><span class="line">	  updateNodeElement(item.stateNode,item,item.alternate)</span><br><span class="line">	</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">	   //节点类型不同</span><br><span class="line">	  item.parent.stateNode.replaceChild(item.stateNode,item.alternate.stateNode)</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">   if(item.effectTag===&apos;placement&apos;)&#123;</span><br><span class="line">   </span><br><span class="line">    let fiber=item</span><br><span class="line">	let parentFiber = item.parent</span><br><span class="line">	</span><br><span class="line">	while(parentFiber.tag===&apos;class_component&apos;||parentFiber.tag===&apos;function_component&apos;)&#123;</span><br><span class="line">	  parentFiber=parentFiber.parent</span><br><span class="line">	&#125;</span><br><span class="line">	if(fiber.tag===&apos;host_component&apos;)&#123;</span><br><span class="line">	 parentFiber.stateNode.appendChild(fiber.stateNode)</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  //备份旧fiber节点对象</span><br><span class="line">  fiber.stateNode.__rootFiberContainer=fiber</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//获取子任务</span><br><span class="line">const getFirstTask=()=&gt;&#123;</span><br><span class="line"></span><br><span class="line">//从任务队列中获取任务</span><br><span class="line">const task =   taskQueue.pop()</span><br><span class="line"></span><br><span class="line">//返回最外层节点的fiber对象</span><br><span class="line">return &#123;</span><br><span class="line">  props:task.props,</span><br><span class="line">  stateNode:task.dom,</span><br><span class="line">  tag:&apos;host_root&apos;,</span><br><span class="line">  effects:[],</span><br><span class="line">  child:null,</span><br><span class="line">  alternate:task.dom.__rootFiberContainer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const reconcileChildren=(fiber,children)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">//children可能为对象或数组</span><br><span class="line"></span><br><span class="line">const arrChildren=Array.isArray(children)?children:[children]</span><br><span class="line"></span><br><span class="line">let index=0</span><br><span class="line">let element=null</span><br><span class="line">let newFiber=null</span><br><span class="line">let prevFiber=null</span><br><span class="line"></span><br><span class="line">let alternate=null</span><br><span class="line"></span><br><span class="line">if(fiber.alternate&amp;&amp;fiber.alternate.child)&#123;</span><br><span class="line"> alternate=fiber.alternate.child</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">while(index &lt; arrChildren.length)&#123;</span><br><span class="line"> element=arrChildren[index]</span><br><span class="line"> </span><br><span class="line"> if(element&amp;&amp;alternate)&#123;</span><br><span class="line"> //更新</span><br><span class="line"> newFiber=&#123;</span><br><span class="line">  type:element.type,</span><br><span class="line">  props:element.props,</span><br><span class="line">  tag:getTag(element),</span><br><span class="line">  effects:[],</span><br><span class="line">  effectTag:&apos;update&apos;,</span><br><span class="line">  parent:fiber,</span><br><span class="line">  alternate</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">   newFiber.stateNode=createStateNode(newFiber)</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> &#125;else if(element&amp;&amp;!alternate)&#123;</span><br><span class="line"> </span><br><span class="line"> //初始渲染</span><br><span class="line"> //子级Fiber对象</span><br><span class="line"> newFiber=&#123;</span><br><span class="line">  type:element.type,</span><br><span class="line">  props:element.props,</span><br><span class="line">  tag:getTag(element),</span><br><span class="line">  effects:[],</span><br><span class="line">  effectTag:&apos;placement&apos;,</span><br><span class="line">  parent:fiber</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> if(element.type===alternate.type)&#123;</span><br><span class="line">  newFiber.stateNode=alternate.stateNode</span><br><span class="line"> &#125;else&#123;</span><br><span class="line">  //类型不同 不需要比对</span><br><span class="line">  newFiber.stateNode=createStateNode(newFiber)</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">  </span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> //为父级Fiber添加子级Fiber</span><br><span class="line"> if(index===0)&#123;</span><br><span class="line">  fiber.child=newFiber</span><br><span class="line"> </span><br><span class="line"> &#125;else&#123;</span><br><span class="line">   prevFiber.sibling=newFiber</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> if(alternate&amp;&amp;alternate.sibling)&#123;</span><br><span class="line">  alternate=alternate.sibling</span><br><span class="line"> &#125;else&#123;</span><br><span class="line">  alternate=null</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> prevFiber=newFiber</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> index++</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const executeTask= fiber =&gt;&#123;</span><br><span class="line"></span><br><span class="line">if(fiber.tag===&apos;class_component)&#123;</span><br><span class="line"></span><br><span class="line">reconcileChildren(fiber,fiber.stateNode.render())</span><br><span class="line">&#125;else if(fiber.tag===&apos;function_component)&#123;</span><br><span class="line">  reconcileChildren(fiber,fiber.stateNode())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">else&#123;</span><br><span class="line">reconcileChildren(fiber,fiber.props.children)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> //子级处理</span><br><span class="line"> if(fiber.child)&#123;</span><br><span class="line"> </span><br><span class="line">  return fiber.children</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> //同级处理</span><br><span class="line"> let currentExecuteFiber=fiber</span><br><span class="line"> </span><br><span class="line"> while(currentExecuteFiber.parent)&#123;</span><br><span class="line"> //构建effects数组</span><br><span class="line">   currentExecuteFiber.parent.effects=currentExecuteFiber.parent.effects.concat(currentExecuteFiber.effects.concat([currentExecuteFiber]))</span><br><span class="line"> </span><br><span class="line">   if(currentExecuteFiber.sibling)&#123;</span><br><span class="line">   return currentExecuteFiber.sibling</span><br><span class="line">   &#125;</span><br><span class="line">   currentExecuteFiber=currentExecuteFiber.parent</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> pendingCommit=currentExecuteFiber</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const workLoop=deadline=&gt;&#123;</span><br><span class="line"></span><br><span class="line">//子任务不存在时，先获取子任务</span><br><span class="line"> if(!subTask)&#123;</span><br><span class="line">  subTask=getFirstTask()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> //存在子任务并且浏览器有空余时间</span><br><span class="line"> </span><br><span class="line"> while(subTask&amp;&amp;dealline.timeRemaining()&gt;1)&#123;</span><br><span class="line">   subTask =   executeTask(subTask)</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> if(pendingCommit)&#123;</span><br><span class="line"> </span><br><span class="line">  commitAllWork(pendingCommit)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const performTask=deadline=&gt;&#123;</span><br><span class="line"> //执行任务</span><br><span class="line">  workLoop(deadline)</span><br><span class="line">  </span><br><span class="line">  //还有未执行的子任务或任务</span><br><span class="line">  if(subTask || !taskQueue.isEmpty())&#123;</span><br><span class="line">     requestIdleCallback(performTask)</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export const render=(element,dom)=&gt;&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//添加任务       任务：通过虚拟Dom对象构建Fiber对象</span><br><span class="line">tackQueue.push(&#123;</span><br><span class="line"> dom,</span><br><span class="line"> props:&#123;children:element&#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//任务调度</span><br><span class="line">requestIdleCallback(performTask)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const createStateNode=fiber=&gt;&#123;</span><br><span class="line"> if(fiber.tag===&apos;host_component&apos;)&#123;</span><br><span class="line">   return createDOMElement(fiber)</span><br><span class="line"> &#125;else&#123;</span><br><span class="line">   return createReactInstance(fiber)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const createReactInstance=fiber=&gt;&#123;</span><br><span class="line">   let instance=null</span><br><span class="line">   if(fiber.tag===&apos;class_component&apos;)&#123;</span><br><span class="line">     instance=new fiber.type(fiber.props)</span><br><span class="line">   &#125;else&#123;</span><br><span class="line">     instance=fiber.type</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return instance</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const getTag= vdom=&gt;&#123;</span><br><span class="line">  if(typeof vdom.type===&apos;string&apos;)&#123;</span><br><span class="line">    return &apos;host_component&apos; </span><br><span class="line">  &#125;else if(Object.getPrototypeOf(vdom.type)=== Component)&#123;</span><br><span class="line">    return &apos;class_component&apos;</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">     return &apos;function_component&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/学习/">学习</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/学习/">学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网站/">网站</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/资源/">资源</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-vue" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2021/03/25/vue/" class="article-date">
      <time datetime="2021-03-24T16:00:00.000Z" itemprop="datePublished">2021-03-25</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/25/vue/">vue进阶</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="Vue初始化"><a href="#Vue初始化" class="headerlink" title="Vue初始化"></a>Vue初始化</h2><h3 id="Vue-prototype-mount"><a href="#Vue-prototype-mount" class="headerlink" title="Vue.prototype.$mount"></a>Vue.prototype.$mount</h3><ol>
<li>文件路径：vue/src/platforms/web/entry-runtime-with-compiler.js </li>
<li>new Vue()时，会调用Vue构造函数，Vue构造函数里面会调用_init方法，_init方法里面会调用$mount方法,将template编译成render函数，接着调用mountComponent方法，创建updateComponent方法，updateComponent里面调用_update，_updae接受_render方法将render函数生成的虚拟Dom转换成真实DOM并挂载到页面当中。<br>3.注册Vue.compile方法，传递一个HTML字符串返回render函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">//处理el</span><br><span class="line">export function query (el: string | Element): Element &#123;</span><br><span class="line">  //如果是字符串时，通过选择器获取dom</span><br><span class="line">  if (typeof el === &apos;string&apos;) &#123;</span><br><span class="line">    const selected = document.querySelector(el)</span><br><span class="line">	//如果没有找到对应dom，会返回一个div</span><br><span class="line">    if (!selected) &#123;</span><br><span class="line">      process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; warn(</span><br><span class="line">        &apos;Cannot find element: &apos; + el</span><br><span class="line">      )</span><br><span class="line">      return document.createElement(&apos;div&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    return selected</span><br><span class="line">  &#125; </span><br><span class="line">  //不是字符串时直接返回</span><br><span class="line">  else &#123;</span><br><span class="line">    return el</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//获取outerHtml</span><br><span class="line">function getOuterHTML (el: Element): string &#123;</span><br><span class="line">  if (el.outerHTML) &#123;</span><br><span class="line">    return el.outerHTML</span><br><span class="line">  &#125; </span><br><span class="line">  //获取不到outerHtml时</span><br><span class="line">  else &#123;</span><br><span class="line">    const container = document.createElement(&apos;div&apos;)</span><br><span class="line">    container.appendChild(el.cloneNode(true))</span><br><span class="line">    return container.innerHTML</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Vue.prototype.$mount = function (el?: string | Element,hydrating?: boolean): Component &#123;</span><br><span class="line"></span><br><span class="line">  //先对el进行处理</span><br><span class="line">  el = el &amp;&amp; query(el);</span><br><span class="line"> //如果el是body或html时，在开发环境会有警告</span><br><span class="line">  if (el === document.body || el === document.documentElement) &#123;</span><br><span class="line">    process.env.NODE_ENV !== &quot;production&quot; &amp;&amp;</span><br><span class="line">      warn(</span><br><span class="line">        `Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`</span><br><span class="line">      );</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line"> //获取options选项</span><br><span class="line">  const options = this.$options;</span><br><span class="line"> //如果没有传render函数</span><br><span class="line">  if (!options.render) &#123;</span><br><span class="line">    //获取模板字符串</span><br><span class="line">    let template = options.template;</span><br><span class="line">    //对模板字符串进行处理</span><br><span class="line">    if (template) &#123;</span><br><span class="line"></span><br><span class="line">      if (typeof template === &quot;string&quot;) &#123;</span><br><span class="line">        if (template.charAt(0) === &quot;#&quot;) &#123;</span><br><span class="line">          template = idToTemplate(template);</span><br><span class="line">          /* istanbul ignore if */</span><br><span class="line">          if (process.env.NODE_ENV !== &quot;production&quot; &amp;&amp; !template) &#123;</span><br><span class="line">            warn(</span><br><span class="line">              `Template element not found or is empty: $&#123;options.template&#125;`,</span><br><span class="line">              this</span><br><span class="line">            );</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else if (template.nodeType) &#123;</span><br><span class="line">        template = template.innerHTML;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        if (process.env.NODE_ENV !== &quot;production&quot;) &#123;</span><br><span class="line">          warn(&quot;invalid template option:&quot; + template, this);</span><br><span class="line">        &#125;</span><br><span class="line">        return this;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    //没有模板时，获取el的outerHtml作为模板</span><br><span class="line">    else if (el) &#123;</span><br><span class="line">      template = getOuterHTML(el);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //将模板生成渲染函数</span><br><span class="line">    if (template) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //进行挂载</span><br><span class="line">  return mount.call(this, el, hydrating);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="mountComponent"><a href="#mountComponent" class="headerlink" title="mountComponent"></a>mountComponent</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">vue/src/core/instance/lifecycle.js </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export function mountComponent (</span><br><span class="line">  vm: Component,</span><br><span class="line">  el: ?Element,</span><br><span class="line">  hydrating?: boolean</span><br><span class="line">): Component &#123;</span><br><span class="line">  vm.$el = el</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  if (!vm.$options.render) &#123;</span><br><span class="line">    vm.$options.render = createEmptyVNode</span><br><span class="line">	</span><br><span class="line">	// 运行时、开发环境下  没有传入render函数传入template</span><br><span class="line">    if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">      /* istanbul ignore if */</span><br><span class="line">      if ((vm.$options.template &amp;&amp; vm.$options.template.charAt(0) !== &apos;#&apos;) ||</span><br><span class="line">        vm.$options.el || el) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          &apos;You are using the runtime-only build of Vue where the template &apos; +</span><br><span class="line">          &apos;compiler is not available. Either pre-compile the templates into &apos; +</span><br><span class="line">          &apos;render functions, or use the compiler-included build.&apos;,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        warn(</span><br><span class="line">          &apos;Failed to mount component: template or render function not defined.&apos;,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  //触发beforeMount钩子函数</span><br><span class="line">  callHook(vm, &apos;beforeMount&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  let updateComponent</span><br><span class="line">  /* istanbul ignore if */</span><br><span class="line">  if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">    updateComponent = () =&gt; &#123;</span><br><span class="line">      const name = vm._name</span><br><span class="line">      const id = vm._uid</span><br><span class="line">      const startTag = `vue-perf-start:$&#123;id&#125;`</span><br><span class="line">      const endTag = `vue-perf-end:$&#123;id&#125;`</span><br><span class="line"></span><br><span class="line">      mark(startTag)</span><br><span class="line">      const vnode = vm._render()</span><br><span class="line">      mark(endTag)</span><br><span class="line">      measure(`vue $&#123;name&#125; render`, startTag, endTag)</span><br><span class="line"></span><br><span class="line">      mark(startTag)</span><br><span class="line">      vm._update(vnode, hydrating)</span><br><span class="line">      mark(endTag)</span><br><span class="line">      measure(`vue $&#123;name&#125; patch`, startTag, endTag)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  </span><br><span class="line">  else &#123;</span><br><span class="line">    updateComponent = () =&gt; &#123;</span><br><span class="line">	//_render调用render方法返回虚拟Dom  _update将虚拟Dom转换成真是Dom</span><br><span class="line">      vm._update(vm._render(), hydrating)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // we set this to vm._watcher inside the watcher&apos;s constructor</span><br><span class="line">  // since the watcher&apos;s initial patch may call $forceUpdate (e.g. inside child</span><br><span class="line">  // component&apos;s mounted hook), which relies on vm._watcher being already defined</span><br><span class="line">  new Watcher(vm, updateComponent, noop, &#123;</span><br><span class="line">    before () &#123;</span><br><span class="line">      if (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123;</span><br><span class="line">        callHook(vm, &apos;beforeUpdate&apos;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, true /* isRenderWatcher */)</span><br><span class="line">  hydrating = false</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // manually mounted instance, call mounted on self</span><br><span class="line">  // mounted is called for render-created child components in its inserted hook</span><br><span class="line">  if (vm.$vnode == null) &#123;</span><br><span class="line">    vm._isMounted = true</span><br><span class="line">	</span><br><span class="line">	//触发mounted钩子函数</span><br><span class="line">    callHook(vm, &apos;mounted&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">  return vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="vue初始化过程"><a href="#vue初始化过程" class="headerlink" title="vue初始化过程"></a>vue初始化过程</h3><ol>
<li><p>vue构造函数   vue/src/core/instance/index.js /</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import &#123; initMixin &#125; from &apos;./init&apos;</span><br><span class="line">import &#123; stateMixin &#125; from &apos;./state&apos;</span><br><span class="line">import &#123; renderMixin &#125; from &apos;./render&apos;</span><br><span class="line">import &#123; eventsMixin &#125; from &apos;./events&apos;</span><br><span class="line">import &#123; lifecycleMixin &#125; from &apos;./lifecycle&apos;</span><br><span class="line">import &#123; warn &#125; from &apos;../util/index&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//不使用class是为了后续方便在vue.prototype上混入实例成员</span><br><span class="line">function Vue (options) &#123;</span><br><span class="line"></span><br><span class="line">  //开发环境必须使用new关键字调用Vue构造函数</span><br><span class="line">  if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp;</span><br><span class="line">    !(this instanceof Vue)</span><br><span class="line">  ) &#123;</span><br><span class="line">    warn(&apos;Vue is a constructor and should be called with the `new` keyword&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">  //初始化options</span><br><span class="line">  this._init(options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">initMixin(Vue)   //注册Vue.prototype._init方法</span><br><span class="line">stateMixin(Vue)    //注册vue实例相关方法 $data/$props/$set/$delete/$watch实例方法</span><br><span class="line">eventsMixin(Vue)    //注册事件相关方法   $on/$once/$off/$emit</span><br><span class="line">lifecycleMixin(Vue)  //注册生命周期相关方法  _update/$forceUpdate/$destory</span><br><span class="line">renderMixin(Vue)    //$nextTick/_render</span><br><span class="line"></span><br><span class="line">export default Vue</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化全局Api       vue/src/core/index.js /</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &apos;./instance/index&apos;</span><br><span class="line">import &#123; initGlobalAPI &#125; from &apos;./global-api/index&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">initGlobalAPI(Vue)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Vue.version = &apos;__VERSION__&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>initGlobalAPI 初始化vue的静态方法  文件路径 vue/src/core/global-api/index.js /</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">export function initGlobalAPI (Vue: GlobalAPI) &#123;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    //vue.config全局配置对象</span><br><span class="line">    Object.defineProperty(Vue, &apos;config&apos;, configDef)</span><br><span class="line">  </span><br><span class="line">    Vue.util = &#123;</span><br><span class="line">      warn,</span><br><span class="line">      extend,</span><br><span class="line">      mergeOptions,</span><br><span class="line">      defineReactive</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">   //静态方法 set/delete/nextTick</span><br><span class="line">    Vue.set = set</span><br><span class="line">    Vue.delete = del</span><br><span class="line">    Vue.nextTick = nextTick</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    //让一个对象可响应</span><br><span class="line">    Vue.observable = &lt;T&gt;(obj: T): T =&gt; &#123;</span><br><span class="line">      observe(obj)</span><br><span class="line">      return obj</span><br><span class="line">    &#125;</span><br><span class="line">    //components/filters/directives/初始化</span><br><span class="line">    Vue.options = Object.create(null)</span><br><span class="line">    ASSET_TYPES.forEach(type =&gt; &#123;</span><br><span class="line">      Vue.options[type + &apos;s&apos;] = Object.create(null)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    Vue.options._base = Vue</span><br><span class="line">  </span><br><span class="line">    //keep-alive组件注册  浅拷贝</span><br><span class="line">    extend(Vue.options.components, builtInComponents)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">   </span><br><span class="line">    initUse(Vue)  //Vue.use  用来注册插件</span><br><span class="line">    initMixin(Vue)  /Vue.mixin  //实现混入</span><br><span class="line">    initExtend(Vue)  /Vue.extend  // 基于传入的options返回一个组件的构造函数</span><br><span class="line">    initAssetRegisters(Vue) /Vue.directive/Vue.component/Vue.filter初始化</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注册一些跟平台相关的全局的指令和组件    vue/src/platforms/web/runtime/index.js </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// install platform runtime directives &amp; components</span><br><span class="line">extend(Vue.options.directives, platformDirectives)   v-model v-show</span><br><span class="line">extend(Vue.options.components, platformComponents)   v-transition-group  v-transition</span><br><span class="line"></span><br><span class="line">// install platform patch function</span><br><span class="line">Vue.prototype.__patch__ = inBrowser ? patch : noop   将虚拟Dom转换成真是DOM</span><br><span class="line"></span><br><span class="line">// public mount method           挂载，将dom渲染到页面上面</span><br><span class="line">Vue.prototype.$mount = function (</span><br><span class="line">  el?: string | Element,</span><br><span class="line">  hydrating?: boolean</span><br><span class="line">): Component &#123;</span><br><span class="line">  el = el &amp;&amp; inBrowser ? query(el) : undefined</span><br><span class="line">  return mountComponent(this, el, hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="静态成员初始化"><a href="#静态成员初始化" class="headerlink" title="静态成员初始化"></a>静态成员初始化</h4><ol>
<li><p>Vue.use        vue/src/core/global-api/use.js </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">export function initUse (Vue: GlobalAPI) &#123;</span><br><span class="line">   //参数为函数或对象</span><br><span class="line">  Vue.use = function (plugin: Function | Object) &#123;</span><br><span class="line">   //已经安装的插件</span><br><span class="line">    const installedPlugins = (this._installedPlugins || (this._installedPlugins = []))</span><br><span class="line">	//已经安装过的插件不会再次安装</span><br><span class="line">    if (installedPlugins.indexOf(plugin) &gt; -1) &#123;</span><br><span class="line">      return this</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // additional parameters   把参数的第一个元素去除，第一个元素是插件</span><br><span class="line">    const args = toArray(arguments, 1)</span><br><span class="line">    args.unshift(this)   //args数组第一项插入this(Vue)</span><br><span class="line">	//参数为对象时，有一个install方法，调用install方法</span><br><span class="line">    if (typeof plugin.install === &apos;function&apos;) &#123;</span><br><span class="line">      plugin.install.apply(plugin, args)</span><br><span class="line">    &#125; </span><br><span class="line">	//参数为函数时,直接调用</span><br><span class="line">	else if (typeof plugin === &apos;function&apos;) &#123;</span><br><span class="line">      plugin.apply(null, args)</span><br><span class="line">    &#125;</span><br><span class="line">    installedPlugins.push(plugin)</span><br><span class="line">    return this</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Vue.mixin        vue/src/core/global-api/mixin.js </p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mergeOptions &#125; from &apos;../util/index&apos;</span><br><span class="line"></span><br><span class="line">export function initMixin (Vue: GlobalAPI) &#123;</span><br><span class="line">  将选项对象与Vue全局options对象进行合并</span><br><span class="line">  Vue.mixin = function (mixin: Object) &#123;</span><br><span class="line">    this.options = mergeOptions(this.options, mixin)</span><br><span class="line">    return this</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><p>Vue.extend   vue/src/core/global-api/extend.js </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"> Vue.extend = function (extendOptions: Object): Function &#123;</span><br><span class="line">    extendOptions = extendOptions || &#123;&#125;</span><br><span class="line">	</span><br><span class="line">	//Vue构造函数</span><br><span class="line">    const Super = this</span><br><span class="line">    const SuperId = Super.cid</span><br><span class="line">    const cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = &#123;&#125;)</span><br><span class="line">    if (cachedCtors[SuperId]) &#123;</span><br><span class="line">      return cachedCtors[SuperId]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const name = extendOptions.name || Super.options.name</span><br><span class="line">    if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; name) &#123;</span><br><span class="line">      validateComponentName(name)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //定义构造函数 调用_init初始化方法</span><br><span class="line">    const Sub = function VueComponent (options) &#123;</span><br><span class="line">      this._init(options)</span><br><span class="line">    &#125;</span><br><span class="line">	//继承Vue</span><br><span class="line">    Sub.prototype = Object.create(Super.prototype)</span><br><span class="line">    Sub.prototype.constructor = Sub</span><br><span class="line">    Sub.cid = cid++</span><br><span class="line">	</span><br><span class="line">	//合并options</span><br><span class="line">    Sub.options = mergeOptions(</span><br><span class="line">      Super.options,</span><br><span class="line">      extendOptions</span><br><span class="line">    )</span><br><span class="line">    Sub[&apos;super&apos;] = Super</span><br><span class="line"></span><br><span class="line">    // For props and computed properties, we define the proxy getters on</span><br><span class="line">    // the Vue instances at extension time, on the extended prototype. This</span><br><span class="line">    // avoids Object.defineProperty calls for each instance created.</span><br><span class="line">    if (Sub.options.props) &#123;</span><br><span class="line">      initProps(Sub)</span><br><span class="line">    &#125;</span><br><span class="line">    if (Sub.options.computed) &#123;</span><br><span class="line">      initComputed(Sub)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // allow further extension/mixin/plugin usage</span><br><span class="line">    Sub.extend = Super.extend</span><br><span class="line">    Sub.mixin = Super.mixin</span><br><span class="line">    Sub.use = Super.use</span><br><span class="line"></span><br><span class="line">    // create asset registers, so extended classes</span><br><span class="line">    // can have their private assets too.</span><br><span class="line">    ASSET_TYPES.forEach(function (type) &#123;</span><br><span class="line">      Sub[type] = Super[type]</span><br><span class="line">    &#125;)</span><br><span class="line">    // enable recursive self-lookup</span><br><span class="line">    if (name) &#123;</span><br><span class="line">      Sub.options.components[name] = Sub</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // keep a reference to the super options at extension time.</span><br><span class="line">    // later at instantiation we can check if Super&apos;s options have</span><br><span class="line">    // been updated.</span><br><span class="line">    Sub.superOptions = Super.options</span><br><span class="line">    Sub.extendOptions = extendOptions</span><br><span class="line">    Sub.sealedOptions = extend(&#123;&#125;, Sub.options)</span><br><span class="line"></span><br><span class="line">    // cache constructor</span><br><span class="line">    cachedCtors[SuperId] = Sub</span><br><span class="line">    return Sub</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Vue.directive/Vue.component/Vue.filter/   vue/src/core/global-api/assets.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ASSET_TYPES.forEach(type =&gt; &#123;</span><br><span class="line">    Vue[type] = function (</span><br><span class="line">      id: string,</span><br><span class="line">      definition: Function | Object</span><br><span class="line">    ): Function | Object | void &#123;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	  //没有传定义时</span><br><span class="line">      if (!definition) &#123;</span><br><span class="line">        return this.options[type + &apos;s&apos;][id]</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        /* istanbul ignore if */</span><br><span class="line">        if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; type === &apos;component&apos;) &#123;</span><br><span class="line">          validateComponentName(id)</span><br><span class="line">        &#125;  </span><br><span class="line">		//isPlainObject:&apos;[object Object]&apos;</span><br><span class="line">        if (type === &apos;component&apos; &amp;&amp; isPlainObject(definition)) &#123;</span><br><span class="line">          definition.name = definition.name || id</span><br><span class="line">          definition = this.options._base.extend(definition)</span><br><span class="line">        &#125;</span><br><span class="line">        if (type === &apos;directive&apos; &amp;&amp; typeof definition === &apos;function&apos;) &#123;</span><br><span class="line">          definition = &#123; bind: definition, update: definition &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">		//全局注册</span><br><span class="line">        this.options[type + &apos;s&apos;][id] = definition</span><br><span class="line">        return definition</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="实例成员初始化"><a href="#实例成员初始化" class="headerlink" title="实例成员初始化"></a>实例成员初始化</h4><ol>
<li><p>initMixin  给Vue实例增加_init方法    vue/src/core/instance/init.js </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"> Vue.prototype._init = function (options?: Object) &#123;</span><br><span class="line">    const vm: Component = this</span><br><span class="line">    // a uid</span><br><span class="line">    vm._uid = uid++</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    let startTag, endTag</span><br><span class="line">    /* istanbul ignore if */</span><br><span class="line">    if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">      startTag = `vue-perf-start:$&#123;vm._uid&#125;`</span><br><span class="line">      endTag = `vue-perf-end:$&#123;vm._uid&#125;`</span><br><span class="line">      mark(startTag)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // a flag to avoid this being observed</span><br><span class="line">	//当前实例是vue实例</span><br><span class="line">    vm._isVue = true</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">    // merge options  组件</span><br><span class="line">    if (options &amp;&amp; options._isComponent) &#123;</span><br><span class="line">      // optimize internal component instantiation</span><br><span class="line">      // since dynamic options merging is pretty slow, and none of the</span><br><span class="line">      // internal component options needs special treatment.</span><br><span class="line">      initInternalComponent(vm, options)</span><br><span class="line">    &#125; </span><br><span class="line">	</span><br><span class="line">	else &#123;</span><br><span class="line">	  //将用户传入的options和vue构造函数中的options进行合并</span><br><span class="line">      vm.$options = mergeOptions(</span><br><span class="line">        resolveConstructorOptions(vm.constructor),</span><br><span class="line">        options || &#123;&#125;,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">    /* istanbul ignore else */</span><br><span class="line">    if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">      initProxy(vm)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      vm._renderProxy = vm</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">    // expose real self</span><br><span class="line">    vm._self = vm</span><br><span class="line">    initLifecycle(vm)    //初始化跟生命周期相关的变量 $children/$parent/$root/$refs</span><br><span class="line">    initEvents(vm)</span><br><span class="line">    initRender(vm)       //$slots/$scopedSlots/$createElement/_c/$attrs/$listeners</span><br><span class="line">    callHook(vm, &apos;beforeCreate&apos;)    // 触发beforeCreate钩子函数</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">    initInjections(vm) // resolve injections before data/props</span><br><span class="line">    initState(vm)      // _props/methods/_data/computed/watch</span><br><span class="line">    initProvide(vm) // resolve provide after data/props</span><br><span class="line">    callHook(vm, &apos;created&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /* istanbul ignore if */</span><br><span class="line">    if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">      vm._name = formatComponentName(vm, false)</span><br><span class="line">      mark(endTag)</span><br><span class="line">      measure(`vue $&#123;vm._name&#125; init`, startTag, endTag)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //挂载，渲染页面</span><br><span class="line">    if (vm.$options.el) &#123;</span><br><span class="line">      vm.$mount(vm.$options.el)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">initState(vm)                  vue/src/core/instance/state.js</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export function initState (vm: Component) &#123;</span><br><span class="line">  vm._watchers = []</span><br><span class="line">  const opts = vm.$options</span><br><span class="line">  </span><br><span class="line">  //defineReactive</span><br><span class="line">  if (opts.props) initProps(vm, opts.props)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  // 将选项中的methods成员注入到vue实例中  methods中的成员必须是function不建议使用_或$开头且不能与props成员重复</span><br><span class="line">  if (opts.methods) initMethods(vm, opts.methods)</span><br><span class="line"> </span><br><span class="line"> // 响应式处理data         data中的成员不能与props/methods成员重复，不能以_或$开头</span><br><span class="line"> if (opts.data) &#123;</span><br><span class="line">    initData(vm)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    observe(vm._data = &#123;&#125;, true /* asRootData */)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  if (opts.computed) initComputed(vm, opts.computed)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  if (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123;</span><br><span class="line">    initWatch(vm, opts.watch)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>stateMixin  $data/$props/$set/$delete/$watch    vue/src/core/instance/state.js /</p>
</li>
<li>eventsMixin  $on/$off/$once/$emit/    vue/src/core/instance/events.js /</li>
<li>lifecycleMixin  $forceUpdate/$destroy/_update    vue/src/core/instance/lifecycle.js /</li>
<li>renderMixin  $nextTick/_render   vue/src/core/instance/render.js /</li>
</ol>
<h2 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h2><h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">vue/src/core/observer/index.js</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Attempt to create an observer instance for a value,</span><br><span class="line"> * returns the new observer if successfully observed,</span><br><span class="line"> * or the existing observer if the value already has one.</span><br><span class="line"> */</span><br><span class="line">export function observe (value: any, asRootData: ?boolean): Observer | void &#123;</span><br><span class="line">  //不是对象时</span><br><span class="line">  if (!isObject(value) || value instanceof VNode) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  let ob: Observer | void</span><br><span class="line">  </span><br><span class="line">  if (hasOwn(value, &apos;__ob__&apos;) &amp;&amp; value.__ob__ instanceof Observer) &#123;</span><br><span class="line">    ob = value.__ob__</span><br><span class="line">  &#125; </span><br><span class="line">  </span><br><span class="line">  else if (</span><br><span class="line">    shouldObserve &amp;&amp;</span><br><span class="line">    !isServerRendering() &amp;&amp;</span><br><span class="line">    (Array.isArray(value) || isPlainObject(value)) &amp;&amp;</span><br><span class="line">    Object.isExtensible(value) &amp;&amp;</span><br><span class="line">    !value._isVue</span><br><span class="line">  ) &#123;</span><br><span class="line">  //创建Observer对象</span><br><span class="line">    ob = new Observer(value)</span><br><span class="line">  &#125;</span><br><span class="line">  if (asRootData &amp;&amp; ob) &#123;</span><br><span class="line">    ob.vmCount++</span><br><span class="line">  &#125;</span><br><span class="line">  return ob</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Observer class that is attached to each observed</span><br><span class="line"> * object. Once attached, the observer converts the target</span><br><span class="line"> * object&apos;s property keys into getter/setters that</span><br><span class="line"> * collect dependencies and dispatch updates.</span><br><span class="line"> */</span><br><span class="line">export class Observer &#123;</span><br><span class="line">  value: any; //被观察的对象</span><br><span class="line">  dep: Dep;    //依赖</span><br><span class="line">  vmCount: number; // number of vms that have this object as root $data</span><br><span class="line"></span><br><span class="line">  constructor (value: any) &#123;</span><br><span class="line">    this.value = value</span><br><span class="line">    this.dep = new Dep()</span><br><span class="line">    this.vmCount = 0</span><br><span class="line">    def(value, &apos;__ob__&apos;, this)</span><br><span class="line">	//数组处理</span><br><span class="line">    if (Array.isArray(value)) &#123;</span><br><span class="line">      if (hasProto) &#123;</span><br><span class="line">        protoAugment(value, arrayMethods)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        copyAugment(value, arrayMethods, arrayKeys)</span><br><span class="line">      &#125;</span><br><span class="line">      this.observeArray(value)</span><br><span class="line">    &#125; </span><br><span class="line">	//对象处理</span><br><span class="line">	else &#123;</span><br><span class="line">      this.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Walk through all properties and convert them into</span><br><span class="line">   * getter/setters. This method should only be called when</span><br><span class="line">   * value type is Object.</span><br><span class="line">   */</span><br><span class="line">  walk (obj: Object) &#123;</span><br><span class="line">    const keys = Object.keys(obj)</span><br><span class="line">    for (let i = 0; i &lt; keys.length; i++) &#123;</span><br><span class="line">      defineReactive(obj, keys[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Observe a list of Array items.</span><br><span class="line">   */</span><br><span class="line">  observeArray (items: Array&lt;any&gt;) &#123;</span><br><span class="line">    for (let i = 0, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">      observe(items[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="defineReactive"><a href="#defineReactive" class="headerlink" title="defineReactive"></a>defineReactive</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">vue/src/core/observer/index.js </span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Define a reactive property on an Object.</span><br><span class="line"> */</span><br><span class="line">export function defineReactive (</span><br><span class="line">  obj: Object,</span><br><span class="line">  key: string,</span><br><span class="line">  val: any,</span><br><span class="line">  customSetter?: ?Function,</span><br><span class="line">  shallow?: boolean //浅   false时为深度监听</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">   //收集依赖 watcher</span><br><span class="line">  const dep = new Dep()</span><br><span class="line"></span><br><span class="line">  //获取对象的属性描述对象</span><br><span class="line">  const property = Object.getOwnPropertyDescriptor(obj, key)</span><br><span class="line">  </span><br><span class="line">  //不可配置  不能delete/object.defineProperty操作</span><br><span class="line">  if (property &amp;&amp; property.configurable === false) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // cater for pre-defined getter/setters</span><br><span class="line">  const getter = property &amp;&amp; property.get</span><br><span class="line">  const setter = property &amp;&amp; property.set</span><br><span class="line">  if ((!getter || setter) &amp;&amp; arguments.length === 2) &#123;</span><br><span class="line">    val = obj[key]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let childOb = !shallow &amp;&amp; observe(val)</span><br><span class="line">  Object.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true,</span><br><span class="line">	</span><br><span class="line">    get: function reactiveGetter () &#123;</span><br><span class="line">	 //用户传入getter时先调用</span><br><span class="line">      const value = getter ? getter.call(obj) : val</span><br><span class="line">	  //如果存在依赖对象watcher，则收集依赖</span><br><span class="line">      if (Dep.target) &#123;</span><br><span class="line">	    //收集依赖</span><br><span class="line">        dep.depend()</span><br><span class="line">        if (childOb) &#123;</span><br><span class="line">		  //子对象收集依赖</span><br><span class="line">          childOb.dep.depend()</span><br><span class="line">		  //数组</span><br><span class="line">          if (Array.isArray(value)) &#123;</span><br><span class="line">            dependArray(value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return value</span><br><span class="line">    &#125;,</span><br><span class="line">    set: function reactiveSetter (newVal) &#123;</span><br><span class="line">      const value = getter ? getter.call(obj) : val</span><br><span class="line">	  </span><br><span class="line">	  //新值旧值相等</span><br><span class="line">      /* eslint-disable no-self-compare */      NaN</span><br><span class="line">      if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      /* eslint-enable no-self-compare */</span><br><span class="line">      if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; customSetter) &#123;</span><br><span class="line">        customSetter()</span><br><span class="line">      &#125;</span><br><span class="line">      // #7981: for accessor properties without setter</span><br><span class="line">      if (getter &amp;&amp; !setter) return</span><br><span class="line">	  //存在setter时进行调用</span><br><span class="line">      if (setter) &#123;</span><br><span class="line">        setter.call(obj, newVal)</span><br><span class="line">      &#125; </span><br><span class="line">	  </span><br><span class="line">	  else &#123;</span><br><span class="line">        val = newVal</span><br><span class="line">      &#125;</span><br><span class="line">      childOb = !shallow &amp;&amp; observe(newVal)</span><br><span class="line">      dep.notify()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">数组处理</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const arrayProto = Array.prototype</span><br><span class="line">export const arrayMethods = Object.create(arrayProto)</span><br><span class="line"></span><br><span class="line">const methodsToPatch = [</span><br><span class="line">  &apos;push&apos;,</span><br><span class="line">  &apos;pop&apos;,</span><br><span class="line">  &apos;shift&apos;,</span><br><span class="line">  &apos;unshift&apos;,</span><br><span class="line">  &apos;splice&apos;,</span><br><span class="line">  &apos;sort&apos;,</span><br><span class="line">  &apos;reverse&apos;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Intercept mutating methods and emit events</span><br><span class="line"> */</span><br><span class="line">methodsToPatch.forEach(function (method) &#123;</span><br><span class="line">  // cache original method</span><br><span class="line">  const original = arrayProto[method]</span><br><span class="line">  def(arrayMethods, method, function mutator (...args) &#123;</span><br><span class="line">  </span><br><span class="line">    //调用原型上的方法</span><br><span class="line">    const result = original.apply(this, args)</span><br><span class="line">    const ob = this.__ob__</span><br><span class="line">    let inserted</span><br><span class="line">    switch (method) &#123;</span><br><span class="line">      case &apos;push&apos;:</span><br><span class="line">      case &apos;unshift&apos;:</span><br><span class="line">        inserted = args</span><br><span class="line">        break</span><br><span class="line">      case &apos;splice&apos;:</span><br><span class="line">        inserted = args.slice(2)</span><br><span class="line">        break</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	//对新增的元素进行响应式处理</span><br><span class="line">    if (inserted) ob.observeArray(inserted)</span><br><span class="line">    // notify change</span><br><span class="line">	</span><br><span class="line">	//通知依赖更新视图</span><br><span class="line">    ob.dep.notify()</span><br><span class="line">    return result</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * A dep is an observable that can have multiple</span><br><span class="line"> * directives subscribing to it.</span><br><span class="line"> */</span><br><span class="line">export default class Dep &#123;</span><br><span class="line">  static target: ?Watcher;</span><br><span class="line">  id: number;</span><br><span class="line">  subs: Array&lt;Watcher&gt;;</span><br><span class="line"></span><br><span class="line">  constructor () &#123;</span><br><span class="line">    this.id = uid++</span><br><span class="line">    this.subs = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addSub (sub: Watcher) &#123;</span><br><span class="line">    this.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  removeSub (sub: Watcher) &#123;</span><br><span class="line">    remove(this.subs, sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  depend () &#123;</span><br><span class="line">    if (Dep.target) &#123;</span><br><span class="line">      Dep.target.addDep(this)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  notify () &#123;</span><br><span class="line">    // stabilize the subscriber list first</span><br><span class="line">    const subs = this.subs.slice()</span><br><span class="line">    if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; !config.async) &#123;</span><br><span class="line">      // subs aren&apos;t sorted in scheduler if not running async</span><br><span class="line">      // we need to sort them now to make sure they fire in correct</span><br><span class="line">      // order</span><br><span class="line">      subs.sort((a, b) =&gt; a.id - b.id)</span><br><span class="line">    &#125;</span><br><span class="line">    for (let i = 0, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">      subs[i].update()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Dep.target用来存放目前正在使用的watcher 全局唯一，并且一次也只能有一个watcher被使用</span><br><span class="line">// The current target watcher being evaluated.</span><br><span class="line">// This is globally unique because only one watcher</span><br><span class="line">// can be evaluated at a time.</span><br><span class="line">Dep.target = null</span><br><span class="line">const targetStack = []</span><br><span class="line"></span><br><span class="line">export function pushTarget (target: ?Watcher) &#123;</span><br><span class="line">  targetStack.push(target)</span><br><span class="line">  Dep.target = target</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function popTarget () &#123;</span><br><span class="line">  targetStack.pop()</span><br><span class="line">  Dep.target = targetStack[targetStack.length - 1]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">渲染watcher:每个组件对应一个mountComponent方法，每个mountComponent对应一个Watcher对象</span><br><span class="line">用户watcher/computed watcher在initState时进行初始化</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">new Watcher时会调用Watcher的get方法，Watcher的get方法会调用Dep的pushTarget方法，Dep的pushTarget方法会设置全局Watcher给Dep.target</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Watcher分为用户watcher/computed watcher/渲染watcher</span><br><span class="line"></span><br><span class="line">渲染watcher创建时机：src/core/instance/lifecycle.js    mountComponent方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">数据更新时调用Dep的notify方法，遍历Dep的subs，调用每个watcher的update方法，computed watcher和用户watcher调用watcher的run方法，渲染watcher调用queueWatcher方法将watcher加入队列，在queueWatcher方法中调用flushSchedulerQueue方法，在flushSchedulerQueue方法中对watcher按照id从小到大排序，接着遍历watcher，调用run方法。</span><br><span class="line"></span><br><span class="line">watcher的run方法调用watcher的get方法，watcher的get方法会调用watcher的getter方法，渲染watcher的getter方法存储的是updateComponent方法。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * A watcher parses an expression, collects dependencies,</span><br><span class="line"> * and fires callback when the expression value changes.</span><br><span class="line"> * This is used for both the $watch() api and directives.</span><br><span class="line"> */</span><br><span class="line">export default class Watcher &#123;</span><br><span class="line">  vm: Component;</span><br><span class="line">  expression: string;</span><br><span class="line">  cb: Function;</span><br><span class="line">  id: number;</span><br><span class="line">  deep: boolean;</span><br><span class="line">  user: boolean;</span><br><span class="line">  lazy: boolean;</span><br><span class="line">  sync: boolean;</span><br><span class="line">  dirty: boolean;</span><br><span class="line">  active: boolean;</span><br><span class="line">  deps: Array&lt;Dep&gt;;</span><br><span class="line">  newDeps: Array&lt;Dep&gt;;</span><br><span class="line">  depIds: SimpleSet;</span><br><span class="line">  newDepIds: SimpleSet;</span><br><span class="line">  before: ?Function;</span><br><span class="line">  getter: Function;</span><br><span class="line">  value: any;</span><br><span class="line"></span><br><span class="line">  constructor (</span><br><span class="line">    vm: Component,</span><br><span class="line">    expOrFn: string | Function,</span><br><span class="line">    cb: Function,</span><br><span class="line">    options?: ?Object,</span><br><span class="line">    isRenderWatcher?: boolean</span><br><span class="line">  ) &#123;</span><br><span class="line">    this.vm = vm</span><br><span class="line">    if (isRenderWatcher) &#123;</span><br><span class="line">      vm._watcher = this</span><br><span class="line">    &#125;</span><br><span class="line">    vm._watchers.push(this)</span><br><span class="line">    // options</span><br><span class="line">    if (options) &#123;</span><br><span class="line">      this.deep = !!options.deep</span><br><span class="line">      this.user = !!options.user</span><br><span class="line">      this.lazy = !!options.lazy</span><br><span class="line">      this.sync = !!options.sync</span><br><span class="line">      this.before = options.before</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.deep = this.user = this.lazy = this.sync = false</span><br><span class="line">    &#125;</span><br><span class="line">    this.cb = cb</span><br><span class="line">    this.id = ++uid // uid for batching</span><br><span class="line">    this.active = true</span><br><span class="line">    this.dirty = this.lazy // for lazy watchers</span><br><span class="line">    this.deps = []</span><br><span class="line">    this.newDeps = []</span><br><span class="line">    this.depIds = new Set()</span><br><span class="line">    this.newDepIds = new Set()</span><br><span class="line">    this.expression = process.env.NODE_ENV !== &apos;production&apos;</span><br><span class="line">      ? expOrFn.toString()</span><br><span class="line">      : &apos;&apos;</span><br><span class="line">	  </span><br><span class="line">	  </span><br><span class="line">	  </span><br><span class="line">	  //updateComponent方法</span><br><span class="line">    // parse expression for getter</span><br><span class="line">    if (typeof expOrFn === &apos;function&apos;) &#123;</span><br><span class="line">      this.getter = expOrFn</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.getter = parsePath(expOrFn)</span><br><span class="line">      if (!this.getter) &#123;</span><br><span class="line">        this.getter = noop</span><br><span class="line">        process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; warn(</span><br><span class="line">          `Failed watching path: &quot;$&#123;expOrFn&#125;&quot; ` +</span><br><span class="line">          &apos;Watcher only accepts simple dot-delimited paths. &apos; +</span><br><span class="line">          &apos;For full control, use a function instead.&apos;,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    this.value = this.lazy</span><br><span class="line">      ? undefined</span><br><span class="line">      : this.get()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Evaluate the getter, and re-collect dependencies.</span><br><span class="line">   */</span><br><span class="line">  get () &#123;</span><br><span class="line">    pushTarget(this)</span><br><span class="line">    let value</span><br><span class="line">    const vm = this.vm</span><br><span class="line">    try &#123;</span><br><span class="line">	  //updateComponent方法调用</span><br><span class="line">      value = this.getter.call(vm, vm)</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">      if (this.user) &#123;</span><br><span class="line">        handleError(e, vm, `getter for watcher &quot;$&#123;this.expression&#125;&quot;`)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        throw e</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      // &quot;touch&quot; every property so they are all tracked as</span><br><span class="line">      // dependencies for deep watching</span><br><span class="line">      if (this.deep) &#123;</span><br><span class="line">        traverse(value)</span><br><span class="line">      &#125;</span><br><span class="line">      popTarget()</span><br><span class="line">      this.cleanupDeps()</span><br><span class="line">    &#125;</span><br><span class="line">    return value</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Add a dependency to this directive.</span><br><span class="line">   */</span><br><span class="line">  addDep (dep: Dep) &#123;</span><br><span class="line">    const id = dep.id</span><br><span class="line">    if (!this.newDepIds.has(id)) &#123;</span><br><span class="line">      this.newDepIds.add(id)</span><br><span class="line">      this.newDeps.push(dep)</span><br><span class="line">      if (!this.depIds.has(id)) &#123;</span><br><span class="line">        dep.addSub(this)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Clean up for dependency collection.</span><br><span class="line">   */</span><br><span class="line">  cleanupDeps () &#123;</span><br><span class="line">    let i = this.deps.length</span><br><span class="line">    while (i--) &#123;</span><br><span class="line">      const dep = this.deps[i]</span><br><span class="line">      if (!this.newDepIds.has(dep.id)) &#123;</span><br><span class="line">        dep.removeSub(this)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    let tmp = this.depIds</span><br><span class="line">    this.depIds = this.newDepIds</span><br><span class="line">    this.newDepIds = tmp</span><br><span class="line">    this.newDepIds.clear()</span><br><span class="line">    tmp = this.deps</span><br><span class="line">    this.deps = this.newDeps</span><br><span class="line">    this.newDeps = tmp</span><br><span class="line">    this.newDeps.length = 0</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Subscriber interface.</span><br><span class="line">   * Will be called when a dependency changes.</span><br><span class="line">   */</span><br><span class="line">  update () &#123;</span><br><span class="line">    /* istanbul ignore else */</span><br><span class="line">    if (this.lazy) &#123;</span><br><span class="line">      this.dirty = true</span><br><span class="line">    &#125; else if (this.sync) &#123;</span><br><span class="line">      this.run()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      queueWatcher(this)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Scheduler job interface.</span><br><span class="line">   * Will be called by the scheduler.</span><br><span class="line">   */</span><br><span class="line">  run () &#123;</span><br><span class="line">    if (this.active) &#123;</span><br><span class="line">      const value = this.get()</span><br><span class="line">      if (</span><br><span class="line">        value !== this.value ||</span><br><span class="line">        // Deep watchers and watchers on Object/Arrays should fire even</span><br><span class="line">        // when the value is the same, because the value may</span><br><span class="line">        // have mutated.</span><br><span class="line">        isObject(value) ||</span><br><span class="line">        this.deep</span><br><span class="line">      ) &#123;</span><br><span class="line">        // set new value</span><br><span class="line">        const oldValue = this.value</span><br><span class="line">        this.value = value</span><br><span class="line">        if (this.user) &#123;</span><br><span class="line">          const info = `callback for watcher &quot;$&#123;this.expression&#125;&quot;`</span><br><span class="line">          invokeWithErrorHandling(this.cb, this.vm, [value, oldValue], this.vm, info)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          this.cb.call(this.vm, value, oldValue)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Evaluate the value of the watcher.</span><br><span class="line">   * This only gets called for lazy watchers.</span><br><span class="line">   */</span><br><span class="line">  evaluate () &#123;</span><br><span class="line">    this.value = this.get()</span><br><span class="line">    this.dirty = false</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Depend on all deps collected by this watcher.</span><br><span class="line">   */</span><br><span class="line">  depend () &#123;</span><br><span class="line">    let i = this.deps.length</span><br><span class="line">    while (i--) &#123;</span><br><span class="line">      this.deps[i].depend()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Remove self from all dependencies&apos; subscriber list.</span><br><span class="line">   */</span><br><span class="line">  teardown () &#123;</span><br><span class="line">    if (this.active) &#123;</span><br><span class="line">      // remove self from vm&apos;s watcher list</span><br><span class="line">      // this is a somewhat expensive operation so we skip it</span><br><span class="line">      // if the vm is being destroyed.</span><br><span class="line">      if (!this.vm._isBeingDestroyed) &#123;</span><br><span class="line">        remove(this.vm._watchers, this)</span><br><span class="line">      &#125;</span><br><span class="line">      let i = this.deps.length</span><br><span class="line">      while (i--) &#123;</span><br><span class="line">        this.deps[i].removeSub(this)</span><br><span class="line">      &#125;</span><br><span class="line">      this.active = false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="set-set"><a href="#set-set" class="headerlink" title="$set/set"></a>$set/set</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Set a property on an object. Adds the new property and</span><br><span class="line"> * triggers change notification if the property doesn&apos;t</span><br><span class="line"> * already exist.</span><br><span class="line"> */</span><br><span class="line">export function set (target: Array&lt;any&gt; | Object, key: any, val: any): any &#123;</span><br><span class="line">  if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp;</span><br><span class="line">    (isUndef(target) || isPrimitive(target))</span><br><span class="line">  ) &#123;</span><br><span class="line">    warn(`Cannot set reactive property on undefined, null, or primitive value: $&#123;(target: any)&#125;`)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  //数组时 调用splice方法</span><br><span class="line">  if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123;</span><br><span class="line">    target.length = Math.max(target.length, key)</span><br><span class="line">    target.splice(key, 1, val)</span><br><span class="line">    return val</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  if (key in target &amp;&amp; !(key in Object.prototype)) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    return val</span><br><span class="line">  &#125;</span><br><span class="line">  const ob = (target: any).__ob__</span><br><span class="line">  if (target._isVue || (ob &amp;&amp; ob.vmCount)) &#123;</span><br><span class="line">    process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; warn(</span><br><span class="line">      &apos;Avoid adding reactive properties to a Vue instance or its root $data &apos; +</span><br><span class="line">      &apos;at runtime - declare it upfront in the data option.&apos;</span><br><span class="line">    )</span><br><span class="line">    return val</span><br><span class="line">  &#125;</span><br><span class="line">  if (!ob) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    return val</span><br><span class="line">  &#125;</span><br><span class="line">  //把key设为响应式属性</span><br><span class="line">  defineReactive(ob.value, key, val)</span><br><span class="line">  //发送通知</span><br><span class="line">  ob.dep.notify()</span><br><span class="line">  return val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="delete-delete"><a href="#delete-delete" class="headerlink" title="$delete/delete"></a>$delete/delete</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Delete a property and trigger change if necessary.</span><br><span class="line"> */</span><br><span class="line">export function del (target: Array&lt;any&gt; | Object, key: any) &#123;</span><br><span class="line">  if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp;</span><br><span class="line">    (isUndef(target) || isPrimitive(target))</span><br><span class="line">  ) &#123;</span><br><span class="line">    warn(`Cannot delete reactive property on undefined, null, or primitive value: $&#123;(target: any)&#125;`)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  //数组处理</span><br><span class="line">  if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123;</span><br><span class="line">    target.splice(key, 1)</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  const ob = (target: any).__ob__</span><br><span class="line">  if (target._isVue || (ob &amp;&amp; ob.vmCount)) &#123;</span><br><span class="line">    process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; warn(</span><br><span class="line">      &apos;Avoid deleting properties on a Vue instance or its root $data &apos; +</span><br><span class="line">      &apos;- just set it to null.&apos;</span><br><span class="line">    )</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  if (!hasOwn(target, key)) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  //delete 操作符</span><br><span class="line">  delete target[key]</span><br><span class="line">  if (!ob) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  ob.dep.notify()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="nextTick-nextTick"><a href="#nextTick-nextTick" class="headerlink" title="$nextTick/nextTick"></a>$nextTick/nextTick</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//Promise.resolve()</span><br><span class="line">if (typeof Promise !== &apos;undefined&apos; &amp;&amp; isNative(Promise)) &#123;</span><br><span class="line">  const p = Promise.resolve()</span><br><span class="line">  timerFunc = () =&gt; &#123;</span><br><span class="line">    p.then(flushCallbacks)</span><br><span class="line">    // In problematic UIWebViews, Promise.then doesn&apos;t completely break, but</span><br><span class="line">    // it can get stuck in a weird state where callbacks are pushed into the</span><br><span class="line">    // microtask queue but the queue isn&apos;t being flushed, until the browser</span><br><span class="line">    // needs to do some other work, e.g. handle a timer. Therefore we can</span><br><span class="line">    // &quot;force&quot; the microtask queue to be flushed by adding an empty timer.</span><br><span class="line">    if (isIOS) setTimeout(noop)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask = true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//MutationObserver</span><br><span class="line"> else if (!isIE &amp;&amp; typeof MutationObserver !== &apos;undefined&apos; &amp;&amp; (</span><br><span class="line">  isNative(MutationObserver) ||</span><br><span class="line">  // PhantomJS and iOS 7.x</span><br><span class="line">  MutationObserver.toString() === &apos;[object MutationObserverConstructor]&apos;</span><br><span class="line">)) &#123;</span><br><span class="line">  // Use MutationObserver where native Promise is not available,</span><br><span class="line">  // e.g. PhantomJS, iOS7, Android 4.4</span><br><span class="line">  // (#6466 MutationObserver is unreliable in IE11)</span><br><span class="line">  let counter = 1</span><br><span class="line">  const observer = new MutationObserver(flushCallbacks)</span><br><span class="line">  const textNode = document.createTextNode(String(counter))</span><br><span class="line">  observer.observe(textNode, &#123;</span><br><span class="line">    characterData: true</span><br><span class="line">  &#125;)</span><br><span class="line">  timerFunc = () =&gt; &#123;</span><br><span class="line">    counter = (counter + 1) % 2</span><br><span class="line">    textNode.data = String(counter)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask = true</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">//setImmediate</span><br><span class="line">else if (typeof setImmediate !== &apos;undefined&apos; &amp;&amp; isNative(setImmediate)) &#123;</span><br><span class="line">  // Fallback to setImmediate.</span><br><span class="line">  // Technically it leverages the (macro) task queue,</span><br><span class="line">  // but it is still a better choice than setTimeout.</span><br><span class="line">  timerFunc = () =&gt; &#123;</span><br><span class="line">    setImmediate(flushCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">//setTimeout</span><br><span class="line">else &#123;</span><br><span class="line">  // Fallback to setTimeout.</span><br><span class="line">  timerFunc = () =&gt; &#123;</span><br><span class="line">    setTimeout(flushCallbacks, 0)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export function nextTick (cb?: Function, ctx?: Object) &#123;</span><br><span class="line">  let _resolve</span><br><span class="line">  callbacks.push(() =&gt; &#123;</span><br><span class="line">    if (cb) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        cb.call(ctx)</span><br><span class="line">      &#125; catch (e) &#123;</span><br><span class="line">        handleError(e, ctx, &apos;nextTick&apos;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (_resolve) &#123;</span><br><span class="line">      _resolve(ctx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  if (!pending) &#123;</span><br><span class="line">    pending = true</span><br><span class="line">    timerFunc()</span><br><span class="line">  &#125;</span><br><span class="line">  // $flow-disable-line</span><br><span class="line">  if (!cb &amp;&amp; typeof Promise !== &apos;undefined&apos;) &#123;</span><br><span class="line">    return new Promise(resolve =&gt; &#123;</span><br><span class="line">      _resolve = resolve</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="响应式总结"><a href="#响应式总结" class="headerlink" title="响应式总结"></a>响应式总结</h3><ul>
<li>在_init方法中调用initState方法，在initState方法中调用initData方法，在initData方法中调用observe(value)方法</li>
<li>observe(value)方法会判断value是否是对象，如果是对象会接着判断是否有<strong>ob</strong>属性，有则直接返回，没有则直接创建Observe对象，返回Observe对象。</li>
<li>Observe构造函数中会给value添加一个不可枚举<strong>ob</strong>字段，记录当前的observe对象。接着对数组、对象做响应式处理，当数据发生改变时，会找到对应的Observe对象，在Observe对象中调用dep的notify方法，通知watcher更新视图。</li>
<li>数组的响应式处理会对push/pop/shift/unshift/sort/reverse/splice方法进行处理，接着对数组的成员进行响应式处理。</li>
<li>对象的响应式处理则直接调用walk方法，遍历对象的每个属性，调用defineReactive方法</li>
<li>defineReactive方法会为每个属性创建Dep对象收集依赖，如果属性是对象，则调用observe方法进行响应式处理。在getter中为属性收集依赖，属性的值为对象时，也会为属性的值收集依赖。在setter中，调用dep的notify方法发送通知，如果新值是对象时，调用observe进行响应式处理。</li>
<li>在watcher对象的get方法中调用pushTarget方法记录Dep.target属性，在访问data中成员时，出触发defineReactive的getter收集依赖，吧属性对应的watcher添加到dep的subs数组中，如果属性值也是对象，也会为属性值收集依赖。</li>
<li>渲染watcher，当数据发生改变时会调用dep的notify方法，通知watcher调用update方法，update方法中会调用queueWatcher方法,queueWatcher方法会判断watcher是否被处，没有被处理的话会被添加到queue队列中，并调用flushSchedulerQueue方法，flushSchedulerQueue方法中会触发beforeUpdate钩子函数/调用watcher的run方法（run()=&gt;get()=&gt;getter()=&gt;updateComponent()）/清空上一次依赖/触发activated钩子函数/触发updated钩子函数。</li>
</ul>
<h2 id="虚拟Dom"><a href="#虚拟Dom" class="headerlink" title="虚拟Dom"></a>虚拟Dom</h2><h3 id="createElement"><a href="#createElement" class="headerlink" title="createElement"></a>createElement</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">export function _createElement (</span><br><span class="line">  context: Component,</span><br><span class="line">  tag?: string | Class&lt;Component&gt; | Function | Object,</span><br><span class="line">  data?: VNodeData,</span><br><span class="line">  children?: any,</span><br><span class="line">  normalizationType?: number</span><br><span class="line">): VNode | Array&lt;VNode&gt; &#123;</span><br><span class="line">  </span><br><span class="line"> </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  let vnode, ns</span><br><span class="line">  </span><br><span class="line">  //html元素</span><br><span class="line">  if (typeof tag === &apos;string&apos;) &#123;</span><br><span class="line">    let Ctor</span><br><span class="line">    ns = (context.$vnode &amp;&amp; context.$vnode.ns) || config.getTagNamespace(tag)</span><br><span class="line">    if (config.isReservedTag(tag)) &#123;</span><br><span class="line">      // platform built-in elements</span><br><span class="line">      if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; isDef(data) &amp;&amp; isDef(data.nativeOn) &amp;&amp; data.tag !== &apos;component&apos;) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          `The .native modifier for v-on is only valid on components but it was used on &lt;$&#123;tag&#125;&gt;.`,</span><br><span class="line">          context</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      vnode = new VNode(</span><br><span class="line">        config.parsePlatformTagName(tag), data, children,</span><br><span class="line">        undefined, undefined, context</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //自定义组件</span><br><span class="line">	else if ((!data || !data.pre) &amp;&amp; isDef(Ctor = resolveAsset(context.$options, &apos;components&apos;, tag))) &#123;</span><br><span class="line">      // component</span><br><span class="line">      vnode = createComponent(Ctor, data, context, children, tag)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // unknown or unlisted namespaced elements</span><br><span class="line">      // check at runtime because it may get assigned a namespace when its</span><br><span class="line">      // parent normalizes children</span><br><span class="line">      vnode = new VNode(</span><br><span class="line">        tag, data, children,</span><br><span class="line">        undefined, undefined, context</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  </span><br><span class="line">  //创建组件</span><br><span class="line">  else &#123;</span><br><span class="line">    // direct component options / constructor</span><br><span class="line">    vnode = createComponent(tag, data, context, children)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  if (Array.isArray(vnode)) &#123;</span><br><span class="line">    return vnode</span><br><span class="line">  &#125; else if (isDef(vnode)) &#123;</span><br><span class="line">    if (isDef(ns)) applyNS(vnode, ns)</span><br><span class="line">    if (isDef(data)) registerDeepBindings(data)</span><br><span class="line">    return vnode</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return createEmptyVNode()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//相同节点判断</span><br><span class="line">function sameVnode (a, b) &#123;</span><br><span class="line">  return (</span><br><span class="line">    a.key === b.key &amp;&amp;</span><br><span class="line">    a.asyncFactory === b.asyncFactory &amp;&amp; (</span><br><span class="line">      (</span><br><span class="line">        a.tag === b.tag &amp;&amp;</span><br><span class="line">        a.isComment === b.isComment &amp;&amp;</span><br><span class="line">        isDef(a.data) === isDef(b.data) &amp;&amp;</span><br><span class="line">        sameInputType(a, b)</span><br><span class="line">      ) || (</span><br><span class="line">        isTrue(a.isAsyncPlaceholder) &amp;&amp;</span><br><span class="line">        isUndef(b.asyncFactory.error)</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//节点比对</span><br><span class="line"></span><br><span class="line"> function patchVnode (</span><br><span class="line">    oldVnode,</span><br><span class="line">    vnode,</span><br><span class="line">    insertedVnodeQueue,</span><br><span class="line">    ownerArray,</span><br><span class="line">    index,</span><br><span class="line">    removeOnly</span><br><span class="line">  ) &#123;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    if (oldVnode === vnode) &#123;</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (isDef(vnode.elm) &amp;&amp; isDef(ownerArray)) &#123;</span><br><span class="line">      // clone reused vnode</span><br><span class="line">      vnode = ownerArray[index] = cloneVNode(vnode)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const elm = vnode.elm = oldVnode.elm</span><br><span class="line"></span><br><span class="line">    if (isTrue(oldVnode.isAsyncPlaceholder)) &#123;</span><br><span class="line">      if (isDef(vnode.asyncFactory.resolved)) &#123;</span><br><span class="line">        hydrate(oldVnode.elm, vnode, insertedVnodeQueue)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        vnode.isAsyncPlaceholder = true</span><br><span class="line">      &#125;</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // reuse element for static trees.</span><br><span class="line">    // note we only do this if the vnode is cloned -</span><br><span class="line">    // if the new node is not cloned it means the render functions have been</span><br><span class="line">    // reset by the hot-reload-api and we need to do a proper re-render.</span><br><span class="line">    if (isTrue(vnode.isStatic) &amp;&amp;</span><br><span class="line">      isTrue(oldVnode.isStatic) &amp;&amp;</span><br><span class="line">      vnode.key === oldVnode.key &amp;&amp;</span><br><span class="line">      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))</span><br><span class="line">    ) &#123;</span><br><span class="line">      vnode.componentInstance = oldVnode.componentInstance</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">    let i</span><br><span class="line">    const data = vnode.data</span><br><span class="line">    if (isDef(data) &amp;&amp; isDef(i = data.hook) &amp;&amp; isDef(i = i.prepatch)) &#123;</span><br><span class="line">      i(oldVnode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //获取子节点</span><br><span class="line">    const oldCh = oldVnode.children</span><br><span class="line">    const ch = vnode.children</span><br><span class="line">    if (isDef(data) &amp;&amp; isPatchable(vnode)) &#123;</span><br><span class="line">      for (i = 0; i &lt; cbs.update.length; ++i) cbs.update[i](oldVnode, vnode)</span><br><span class="line">      if (isDef(i = data.hook) &amp;&amp; isDef(i = i.update)) i(oldVnode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	//新节点没有文本</span><br><span class="line">    if (isUndef(vnode.text)) &#123;</span><br><span class="line">	  //新旧节点都有子节点时</span><br><span class="line">      if (isDef(oldCh) &amp;&amp; isDef(ch)) &#123;</span><br><span class="line">        if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)</span><br><span class="line">      &#125;</span><br><span class="line">	  //新节点有子节点，老节点没有子节点</span><br><span class="line">	  else if (isDef(ch)) &#123;</span><br><span class="line">        if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">		 //检查是否有重复key</span><br><span class="line">          checkDuplicateKeys(ch)</span><br><span class="line">        &#125;</span><br><span class="line">		//清空老节点文本内容</span><br><span class="line">        if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, &apos;&apos;)</span><br><span class="line">		//将新节点的子节点转换成dom元素并添加到dom树</span><br><span class="line">        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue)</span><br><span class="line">      &#125; </span><br><span class="line">	   //老节点有子节点，新点没子节点</span><br><span class="line">	  else if (isDef(oldCh)) &#123;</span><br><span class="line">	  //删除老节点中的子节点</span><br><span class="line">        removeVnodes(oldCh, 0, oldCh.length - 1)</span><br><span class="line">      &#125;</span><br><span class="line">	  //老节点有文本，新节点没有文本 </span><br><span class="line">	  else if (isDef(oldVnode.text)) &#123;</span><br><span class="line">	  //清空老节点文本内容</span><br><span class="line">        nodeOps.setTextContent(elm, &apos;&apos;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">	//新老节点都有文本节点</span><br><span class="line">	else if (oldVnode.text !== vnode.text) &#123;</span><br><span class="line">	//修改文本</span><br><span class="line">      nodeOps.setTextContent(elm, vnode.text)</span><br><span class="line">    &#125;</span><br><span class="line">    if (isDef(data)) &#123;</span><br><span class="line">      if (isDef(i = data.hook) &amp;&amp; isDef(i = i.postpatch)) i(oldVnode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//更新子节点</span><br><span class="line"></span><br><span class="line">function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) &#123;</span><br><span class="line">     </span><br><span class="line">	 </span><br><span class="line">	//新老节点子节点开始节点索引</span><br><span class="line">    let oldStartIdx = 0</span><br><span class="line">    let newStartIdx = 0</span><br><span class="line">	//老节点子节点结束节点索引</span><br><span class="line">    let oldEndIdx = oldCh.length - 1</span><br><span class="line">	//老节点开始子节点</span><br><span class="line">    let oldStartVnode = oldCh[0]</span><br><span class="line">    let oldEndVnode = oldCh[oldEndIdx]</span><br><span class="line">    let newEndIdx = newCh.length - 1</span><br><span class="line">    let newStartVnode = newCh[0]</span><br><span class="line">    let newEndVnode = newCh[newEndIdx]</span><br><span class="line">    let oldKeyToIdx, idxInOld, vnodeToMove, refElm</span><br><span class="line"></span><br><span class="line">    // removeOnly is a special flag used only by &lt;transition-group&gt;</span><br><span class="line">    // to ensure removed elements stay in correct relative positions</span><br><span class="line">    // during leaving transitions</span><br><span class="line">    const canMove = !removeOnly</span><br><span class="line"></span><br><span class="line">    if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">      checkDuplicateKeys(newCh)</span><br><span class="line">    </span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">    //当新节点和老节点都没有遍历完成时</span><br><span class="line">    while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">      if (isUndef(oldStartVnode)) &#123;</span><br><span class="line">        oldStartVnode = oldCh[++oldStartIdx] // Vnode has been moved left</span><br><span class="line">      &#125; else if (isUndef(oldEndVnode)) &#123;</span><br><span class="line">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">      &#125;</span><br><span class="line">	  </span><br><span class="line">      //老节点子节点的开始节点和新节点子节点的开始节点是相同节点时</span><br><span class="line">	  else if (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">        oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">        newStartVnode = newCh[++newStartIdx]</span><br><span class="line">      &#125; </span><br><span class="line">	  //老节点子节点的结束节点和新节点子节点的结束节点是相同节点时</span><br><span class="line">	  else if (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)</span><br><span class="line">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">        newEndVnode = newCh[--newEndIdx]</span><br><span class="line">      &#125;</span><br><span class="line">      //老节点子节点的开始节点和新节点子节点的结束节点是相同节点时	  </span><br><span class="line">	  else if (sameVnode(oldStartVnode, newEndVnode)) &#123; // Vnode moved right</span><br><span class="line">	  </span><br><span class="line">	    //进行patchVnode，并将oldStartVnode移动到最后</span><br><span class="line">        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)</span><br><span class="line">        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))</span><br><span class="line">        oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">        newEndVnode = newCh[--newEndIdx]</span><br><span class="line">      &#125;</span><br><span class="line">      //老节点子节点的结束节点和新节点子节点的开始节点是相同节点时	  </span><br><span class="line">	  else if (sameVnode(oldEndVnode, newStartVnode)) &#123; // Vnode moved left</span><br><span class="line">	  </span><br><span class="line">	   //进行patchVnode，并将oldEndVnode移动到最前</span><br><span class="line">        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)</span><br><span class="line">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">        newStartVnode = newCh[++newStartIdx]</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       //以上情况都不满足时，依次对比新老节点</span><br><span class="line">	  else &#123;</span><br><span class="line">	   //从新节点子节点的开始节点开始，在老节点子节点中找相同节点</span><br><span class="line">	   //先通过key查找，如果没有找到，再通过sameVnode查找</span><br><span class="line">        if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">        idxInOld = isDef(newStartVnode.key)</span><br><span class="line">          ? oldKeyToIdx[newStartVnode.key]</span><br><span class="line">          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">		  </span><br><span class="line">		//如果没有找到</span><br><span class="line">        if (isUndef(idxInOld)) &#123; // New element</span><br><span class="line">		  //创建节点插入到最前面</span><br><span class="line">          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)</span><br><span class="line">        &#125; </span><br><span class="line">		else &#123;</span><br><span class="line">          vnodeToMove = oldCh[idxInOld]</span><br><span class="line">		  </span><br><span class="line">		  //如果两个节点是相同节点</span><br><span class="line">          if (sameVnode(vnodeToMove, newStartVnode)) &#123;</span><br><span class="line">		   //执行patchVnode，并将查找到的老节点移动到最前面</span><br><span class="line">            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">            oldCh[idxInOld] = undefined</span><br><span class="line">            canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)</span><br><span class="line">          &#125; </span><br><span class="line">		  else &#123;</span><br><span class="line">            // same key but different element. treat as new element</span><br><span class="line">            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        newStartVnode = newCh[++newStartIdx]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	//老节点子节点遍历完，新节点子节点未遍历完</span><br><span class="line">    if (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">	  //说明新节点子节点比老节点子节点多，把新节点剩余的子节点插入到老节点子节点后面</span><br><span class="line">      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm</span><br><span class="line">      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)</span><br><span class="line">    &#125; </span><br><span class="line">	//新节点子节点遍历完，老节点子节点未遍历完</span><br><span class="line">	else if (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">	 //删除老节点剩余子节点</span><br><span class="line">      removeVnodes(oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">arr:[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;]</span><br><span class="line"></span><br><span class="line">arr.splice(1,0,&apos;x&apos;)</span><br><span class="line"></span><br><span class="line">arr：[&apos;a&apos;,&apos;x&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;]</span><br><span class="line"></span><br><span class="line">没有设置key时，更新了三次dom，插入了一次dom</span><br><span class="line">设置key时，插入了一次dom   （key的设置决定了相同节点的判断）</span><br></pre></td></tr></table></figure>
<h2 id="模板编译-https-template-explorer-vuejs-org"><a href="#模板编译-https-template-explorer-vuejs-org" class="headerlink" title="模板编译 (https://template-explorer.vuejs.org/)"></a>模板编译 (<a href="https://template-explorer.vuejs.org/" target="_blank" rel="noopener">https://template-explorer.vuejs.org/</a>)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">将模板字符串转换成抽象语法树，对抽象语法树进行优化，将抽象语法树转换成字符串形式的js代码，最终将字符串形式的js代码转换成函数（return new Function(code)）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export function installRenderHelpers (target: any) &#123;</span><br><span class="line">  target._o = markOnce</span><br><span class="line">  target._n = toNumber</span><br><span class="line">  target._s = toString</span><br><span class="line">  target._l = renderList</span><br><span class="line">  target._t = renderSlot</span><br><span class="line">  target._q = looseEqual</span><br><span class="line">  target._i = looseIndexOf</span><br><span class="line">  target._m = renderStatic</span><br><span class="line">  target._f = resolveFilter</span><br><span class="line">  target._k = checkKeyCodes</span><br><span class="line">  target._b = bindObjectProps</span><br><span class="line">  target._v = createTextVNode</span><br><span class="line">  target._e = createEmptyVNode</span><br><span class="line">  target._u = resolveScopedSlots</span><br><span class="line">  target._g = bindObjectListeners</span><br><span class="line">  target._d = bindDynamicKeys</span><br><span class="line">  target._p = prependModifier</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="baseCompile-astexplorer-net"><a href="#baseCompile-astexplorer-net" class="headerlink" title="baseCompile (astexplorer.net)"></a>baseCompile (astexplorer.net)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">export const createCompiler = createCompilerCreator(function baseCompile (</span><br><span class="line">  template: string,</span><br><span class="line">  options: CompilerOptions</span><br><span class="line">): CompiledResult &#123;</span><br><span class="line"></span><br><span class="line">  //把模板转换成ast抽象语法树</span><br><span class="line">  //抽象语法树，通过树形的方式来描述代码结构</span><br><span class="line">  const ast = parse(template.trim(), options)</span><br><span class="line">  if (options.optimize !== false) &#123;</span><br><span class="line">    //优化抽象语法书</span><br><span class="line">    optimize(ast, options)</span><br><span class="line">  &#125;</span><br><span class="line">  //把抽象语法树转换成字符串形式的js代码</span><br><span class="line">  const code = generate(ast, options)</span><br><span class="line">  return &#123;</span><br><span class="line">    ast,</span><br><span class="line">    render: code.render,</span><br><span class="line">    staticRenderFns: code.staticRenderFns</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>为什么使用抽象语法树？ </li>
</ul>
<ol>
<li>模板字符串转换成AST后，可以通过AST对模板进行优化处理</li>
<li>标记模板中的静态内容，在patch过程中可以直接跳过静态内容</li>
<li>在patch过程中静态内容不需要对比和重新渲染</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">export function optimize (root: ?ASTElement, options: CompilerOptions) &#123;</span><br><span class="line">  if (!root) return</span><br><span class="line">  isStaticKey = genStaticKeysCached(options.staticKeys || &apos;&apos;)</span><br><span class="line">  isPlatformReservedTag = options.isReservedTag || no</span><br><span class="line">  </span><br><span class="line">  //标记静态节点</span><br><span class="line">  // first pass: mark all non-static nodes.</span><br><span class="line">  markStatic(root)</span><br><span class="line">  // second pass: mark static roots.</span><br><span class="line">  </span><br><span class="line">  //标记静态根节点</span><br><span class="line">  markStaticRoots(root, false)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function isStatic (node: ASTNode): boolean &#123;</span><br><span class="line">  //表达式</span><br><span class="line">  if (node.type === 2) &#123; // expression</span><br><span class="line">    return false</span><br><span class="line">  &#125;</span><br><span class="line">  //静态文本</span><br><span class="line">  if (node.type === 3) &#123; // text</span><br><span class="line">    return true</span><br><span class="line">  &#125;</span><br><span class="line">  return !!(node.pre || (</span><br><span class="line">    !node.hasBindings &amp;&amp; // no dynamic bindings</span><br><span class="line">    !node.if &amp;&amp; !node.for &amp;&amp; // not v-if or v-for or v-else</span><br><span class="line">    !isBuiltInTag(node.tag) &amp;&amp; // not a built-in</span><br><span class="line">    isPlatformReservedTag(node.tag) &amp;&amp; // not a component</span><br><span class="line">    !isDirectChildOfTemplateFor(node) &amp;&amp;</span><br><span class="line">    Object.keys(node).every(isStaticKey)</span><br><span class="line">  ))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function markStaticRoots (node: ASTNode, isInFor: boolean) &#123;</span><br><span class="line">  if (node.type === 1) &#123;</span><br><span class="line">    if (node.static || node.once) &#123;</span><br><span class="line">      node.staticInFor = isInFor</span><br><span class="line">    &#125;</span><br><span class="line">    // For a node to qualify as a static root, it should have children that</span><br><span class="line">    // are not just static text. Otherwise the cost of hoisting out will</span><br><span class="line">    // outweigh the benefits and it&apos;s better off to just always render it fresh.</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	//如果一个元素内只有文本节点，此时这个元素不是静态根节点</span><br><span class="line">	//vue认为这种优化会带来负面影响</span><br><span class="line">    if (node.static &amp;&amp; node.children.length &amp;&amp; !(</span><br><span class="line">      node.children.length === 1 &amp;&amp;</span><br><span class="line">      node.children[0].type === 3</span><br><span class="line">    )) &#123;</span><br><span class="line">      node.staticRoot = true</span><br><span class="line">      return</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      node.staticRoot = false</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">    if (node.children) &#123;</span><br><span class="line">      for (let i = 0, l = node.children.length; i &lt; l; i++) &#123;</span><br><span class="line">        markStaticRoots(node.children[i], isInFor || !!node.for)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (node.ifConditions) &#123;</span><br><span class="line">      for (let i = 1, l = node.ifConditions.length; i &lt; l; i++) &#123;</span><br><span class="line">        markStaticRoots(node.ifConditions[i].block, isInFor)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><h3 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h3><ul>
<li><p>全局注册</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line">Vue.Component(&apos;component-name&apos;,&#123;</span><br><span class="line"> template:&apos;&apos;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export function initAssetRegisters (Vue: GlobalAPI) &#123;</span><br><span class="line">  /**</span><br><span class="line">   * Create asset registration methods.</span><br><span class="line">   */</span><br><span class="line">  ASSET_TYPES.forEach(type =&gt; &#123;</span><br><span class="line">    Vue[type] = function (</span><br><span class="line">      id: string,</span><br><span class="line">      definition: Function | Object</span><br><span class="line">    ): Function | Object | void &#123;</span><br><span class="line">      if (!definition) &#123;</span><br><span class="line">        return this.options[type + &apos;s&apos;][id]</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        /* istanbul ignore if */</span><br><span class="line">        if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; type === &apos;component&apos;) &#123;</span><br><span class="line">          validateComponentName(id)</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">		//参数时对象时 调用Vue.extend方法</span><br><span class="line">        if (type === &apos;component&apos; &amp;&amp; isPlainObject(definition)) &#123;</span><br><span class="line">          definition.name = definition.name || id</span><br><span class="line">          definition = this.options._base.extend(definition)</span><br><span class="line">        &#125;</span><br><span class="line">        if (type === &apos;directive&apos; &amp;&amp; typeof definition === &apos;function&apos;) &#123;</span><br><span class="line">          definition = &#123; bind: definition, update: definition &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">		//参数时函数时</span><br><span class="line">        this.options[type + &apos;s&apos;][id] = definition</span><br><span class="line">        return definition</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Vue.extend = function (extendOptions: Object): Function &#123;</span><br><span class="line">    extendOptions = extendOptions || &#123;&#125;</span><br><span class="line">    const Super = this</span><br><span class="line">    const SuperId = Super.cid</span><br><span class="line">    const cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = &#123;&#125;)</span><br><span class="line">    if (cachedCtors[SuperId]) &#123;</span><br><span class="line">      return cachedCtors[SuperId]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const name = extendOptions.name || Super.options.name</span><br><span class="line">    if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; name) &#123;</span><br><span class="line">      validateComponentName(name)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const Sub = function VueComponent (options) &#123;</span><br><span class="line">      this._init(options)</span><br><span class="line">    &#125;</span><br><span class="line">    Sub.prototype = Object.create(Super.prototype)</span><br><span class="line">    Sub.prototype.constructor = Sub</span><br><span class="line">    Sub.cid = cid++</span><br><span class="line">    Sub.options = mergeOptions(</span><br><span class="line">      Super.options,</span><br><span class="line">      extendOptions</span><br><span class="line">    )</span><br><span class="line">    Sub[&apos;super&apos;] = Super</span><br><span class="line"></span><br><span class="line">    // For props and computed properties, we define the proxy getters on</span><br><span class="line">    // the Vue instances at extension time, on the extended prototype. This</span><br><span class="line">    // avoids Object.defineProperty calls for each instance created.</span><br><span class="line">    if (Sub.options.props) &#123;</span><br><span class="line">      initProps(Sub)</span><br><span class="line">    &#125;</span><br><span class="line">    if (Sub.options.computed) &#123;</span><br><span class="line">      initComputed(Sub)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // allow further extension/mixin/plugin usage</span><br><span class="line">    Sub.extend = Super.extend</span><br><span class="line">    Sub.mixin = Super.mixin</span><br><span class="line">    Sub.use = Super.use</span><br><span class="line"></span><br><span class="line">    // create asset registers, so extended classes</span><br><span class="line">    // can have their private assets too.</span><br><span class="line">    ASSET_TYPES.forEach(function (type) &#123;</span><br><span class="line">      Sub[type] = Super[type]</span><br><span class="line">    &#125;)</span><br><span class="line">    // enable recursive self-lookup</span><br><span class="line">    if (name) &#123;</span><br><span class="line">      Sub.options.components[name] = Sub</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // keep a reference to the super options at extension time.</span><br><span class="line">    // later at instantiation we can check if Super&apos;s options have</span><br><span class="line">    // been updated.</span><br><span class="line">    Sub.superOptions = Super.options</span><br><span class="line">    Sub.extendOptions = extendOptions</span><br><span class="line">    Sub.sealedOptions = extend(&#123;&#125;, Sub.options)</span><br><span class="line"></span><br><span class="line">    // cache constructor</span><br><span class="line">    cachedCtors[SuperId] = Sub</span><br><span class="line">    return Sub</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//组件创建</span><br><span class="line"></span><br><span class="line">export function createComponent (</span><br><span class="line">  Ctor: Class&lt;Component&gt; | Function | Object | void,</span><br><span class="line">  data: ?VNodeData,</span><br><span class="line">  context: Component,</span><br><span class="line">  children: ?Array&lt;VNode&gt;,</span><br><span class="line">  tag?: string</span><br><span class="line">): VNode | Array&lt;VNode&gt; | void &#123;</span><br><span class="line"> </span><br><span class="line">  const name = Ctor.options.name || tag</span><br><span class="line">  const vnode = new VNode(</span><br><span class="line">    `vue-component-$&#123;Ctor.cid&#125;$&#123;name ? `-$&#123;name&#125;` : &apos;&apos;&#125;`,</span><br><span class="line">    data, undefined, undefined, undefined, context,</span><br><span class="line">    &#123; Ctor, propsData, listeners, tag, children &#125;,</span><br><span class="line">    asyncFactory</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  return vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>局部注册</p>
</li>
</ul>
<h2 id="vue3响应式原理"><a href="#vue3响应式原理" class="headerlink" title="vue3响应式原理"></a>vue3响应式原理</h2><ul>
<li>通过proxy对象实现属性监听，初始化时不需要遍历所有属性</li>
<li>多层属性嵌套，在访问属性的过程中处理下一级属性</li>
<li>默认监听动态添加的属性</li>
<li>默认监听属性的删除操作</li>
<li>默认监听数组索引和length属性</li>
<li>可以作为单独模块使用</li>
</ul>
<h3 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h3><ul>
<li>将对象转换成响应式对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//是否对象</span><br><span class="line">const isObject =val=&gt;val!==null&amp;&amp;typeof val === &apos;object&apos;</span><br><span class="line"></span><br><span class="line">const convert=target=&gt;isObject(target)?reactive(target):target</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const hasOwnPorperty=Object.prototype.hasOwnPorperty</span><br><span class="line"></span><br><span class="line">const hasOwn=(target,key)=&gt; hasOwnPorperty.call(target,key)</span><br><span class="line"></span><br><span class="line">export function reactive(target)&#123;</span><br><span class="line">//不是对象，直接返回</span><br><span class="line">  if(!isObject(target)) return target</span><br><span class="line"></span><br><span class="line">   const handler=&#123;</span><br><span class="line">   </span><br><span class="line">   get (target,key,receiver)&#123;</span><br><span class="line">   </span><br><span class="line">     //收集依赖</span><br><span class="line">    track(target,key)</span><br><span class="line">   </span><br><span class="line">    const result=Reflect.get(target,key,receiver)</span><br><span class="line">   </span><br><span class="line">    return convert(result)</span><br><span class="line">   </span><br><span class="line">   &#125;,</span><br><span class="line"> </span><br><span class="line">   set (target,key,value,receiver)&#123;</span><br><span class="line">   </span><br><span class="line">   const oldValue=Reflect.get(target,key,receiver)</span><br><span class="line">   </span><br><span class="line">   let result=true</span><br><span class="line">   </span><br><span class="line">   if(oldValue!==value)&#123;</span><br><span class="line">   result=Reflect.set(target,key,value,receiver)</span><br><span class="line">   </span><br><span class="line">    //触发更新</span><br><span class="line">    trigger(target,key)</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   return result</span><br><span class="line">   </span><br><span class="line">   &#125;,</span><br><span class="line">   </span><br><span class="line">   deleteProperty (target,key)&#123;</span><br><span class="line">   </span><br><span class="line">   const hasKey=hasOwn(target,key)</span><br><span class="line">   </span><br><span class="line">   const result=Reflect.deleteProperty(target,key)</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">    if(hasKey&amp;&amp;result)&#123;</span><br><span class="line">	</span><br><span class="line">	 //触发更新</span><br><span class="line">	  </span><br><span class="line">	  trigger(target,key)</span><br><span class="line">	&#125;</span><br><span class="line">	return result</span><br><span class="line">   </span><br><span class="line">   &#125;,</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">export function ref(raw)&#123;</span><br><span class="line"></span><br><span class="line">//raw是ref创建的对象直接返回</span><br><span class="line">if(isObject(raw)&amp;&amp;raw.__v_isRef) return</span><br><span class="line"></span><br><span class="line">//如果raw是对象，则调用reactive</span><br><span class="line">let value=convert(raw)</span><br><span class="line"></span><br><span class="line">const r=&#123;</span><br><span class="line"> __v_isRef:true,</span><br><span class="line"> get value()&#123;</span><br><span class="line">   track(r,&apos;value&apos;)</span><br><span class="line">   return value</span><br><span class="line"> &#125;,</span><br><span class="line"> </span><br><span class="line"> set value(newValue)&#123;</span><br><span class="line"> </span><br><span class="line">  if(newValue!==value)&#123;</span><br><span class="line">    raw=newValue</span><br><span class="line">	value=convert(raw)</span><br><span class="line">    trigger(r,&apos;value&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"> </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">return r</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ref可以吧基本数据类型转换成响应式对象</span><br><span class="line">ref返回的对象，重新赋值成对象也是响应式对象，reactive处理</span><br><span class="line">reactive返回的对象，重新赋值丢失响应式，因为重新赋值的对象不再是proxy对象</span><br><span class="line">reactive返回的对象不可以解构，可以使用toRefs处理</span><br></pre></td></tr></table></figure>
<h3 id="toRefs"><a href="#toRefs" class="headerlink" title="toRefs"></a>toRefs</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">export function toRefs(proxy)&#123;</span><br><span class="line"></span><br><span class="line">const ret=proxy instanceof Array? new Array(proxy.length):&#123;&#125;</span><br><span class="line"></span><br><span class="line">for(const key in proxy)&#123;</span><br><span class="line">ret[key]=toProxyRef(proxy,key)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return ret</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">-----</span><br><span class="line"></span><br><span class="line">function toProxyRef(proxy,key)&#123;</span><br><span class="line"></span><br><span class="line">const r =&#123;</span><br><span class="line">  __v_isRef:true,</span><br><span class="line">  get value()&#123;</span><br><span class="line">  return proxy[key]</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  set value(newvalue)&#123;</span><br><span class="line">  proxy[key]=newValue</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">return r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export function computed(getter)&#123;</span><br><span class="line">const result =ref()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">effect(()=&gt; &#123;result.value=getter()&#125;)</span><br><span class="line"></span><br><span class="line">return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="收集依赖"><a href="#收集依赖" class="headerlink" title="收集依赖"></a>收集依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">targetMap   new WeakMap()   key:目标对象  value：depsMap</span><br><span class="line"></span><br><span class="line">depsMap new Map()  key:目标对象的属性名称 value:dep</span><br><span class="line"></span><br><span class="line">dep new set() value:effect的函数</span><br></pre></td></tr></table></figure>
<h3 id="effect-track"><a href="#effect-track" class="headerlink" title="effect/track"></a>effect/track</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">let activeEffect=null</span><br><span class="line"></span><br><span class="line">export function effect(callback)&#123;</span><br><span class="line"></span><br><span class="line">activeEffect=callback</span><br><span class="line"></span><br><span class="line">callback()</span><br><span class="line"></span><br><span class="line">activeEffect=null</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-----------------------------------------------</span><br><span class="line"></span><br><span class="line">//目标对象弱引用字典</span><br><span class="line">let targetMap=new WeakMap()</span><br><span class="line"></span><br><span class="line">export function track(target,key)&#123;</span><br><span class="line"></span><br><span class="line">if(!activeEffect) return</span><br><span class="line"></span><br><span class="line">//目标对象字典</span><br><span class="line">let depsMap=targetMap.get(target)</span><br><span class="line"></span><br><span class="line">if(!depsMap)&#123;</span><br><span class="line">targetMap.set(target,(depsMap=new Map()))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//effect的函数</span><br><span class="line">let dep=depsMap.get(key)</span><br><span class="line"></span><br><span class="line">if(!key)&#123;</span><br><span class="line"></span><br><span class="line">depsMap.set(key,(dep=new Set()))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dep.add(activeEffect)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="trigger"><a href="#trigger" class="headerlink" title="trigger"></a>trigger</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">export function trigger(target,key)&#123;</span><br><span class="line"></span><br><span class="line">const depsMap=targetMap.get(target)</span><br><span class="line"></span><br><span class="line">if(!depsMap) return</span><br><span class="line"></span><br><span class="line">const dep=depsMap.get(key)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//触发effect的函数</span><br><span class="line">if(dep)&#123;</span><br><span class="line"></span><br><span class="line">deo.forEach(effect=&gt; effect())</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/学习/">学习</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/学习/">学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网站/">网站</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/资源/">资源</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-core" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2021/03/25/core/" class="article-date">
      <time datetime="2021-03-24T16:00:00.000Z" itemprop="datePublished">2021-03-25</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/25/core/">核心进阶</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ol>
<li>基础类型存储在栈内存，被引用或拷贝时，会创建一个完全相等的变量；<blockquote>
<p><code>Undefined</code> <code>Null</code> <code>String</code> <code>Number</code> <code>Boolean</code> <code>Symbol</code> <code>BigInt</code></p>
</blockquote>
</li>
<li>引用类型存储在堆内存，存储的是地址，多个引用指向同一个地址，这里会涉及一个“共享”的概念。<blockquote>
<p><code>Object</code><br><code>Array</code> <code>Date</code> <code>RegExp</code> <code>Function</code> <code>Math</code></p>
</blockquote>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">let a = &#123;</span><br><span class="line">  name: &quot;Julia&quot;,</span><br><span class="line"></span><br><span class="line">  age: 20,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function change(o) &#123;</span><br><span class="line">  o.age = 24;</span><br><span class="line">  //关键   变量o改变内存指向 跟a已经没有关系</span><br><span class="line">  o = &#123;</span><br><span class="line">    name: &quot;Kath&quot;,</span><br><span class="line">    age: 30,</span><br><span class="line">  &#125;;</span><br><span class="line">  return o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let b = change(a);</span><br><span class="line"></span><br><span class="line">console.log(b.age); // 第一个console   30</span><br><span class="line"></span><br><span class="line">console.log(a.age); // 第二个console   24</span><br></pre></td></tr></table></figure>
<h2 id="数据类型检测"><a href="#数据类型检测" class="headerlink" title="数据类型检测"></a>数据类型检测</h2><ol>
<li>typeof<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">typeof 1 // &apos;number&apos;</span><br><span class="line"></span><br><span class="line">typeof &apos;1&apos; // &apos;string&apos;</span><br><span class="line"></span><br><span class="line">typeof undefined // &apos;undefined&apos;</span><br><span class="line"></span><br><span class="line">typeof true // &apos;boolean&apos;</span><br><span class="line"></span><br><span class="line">typeof Symbol() // &apos;symbol&apos;</span><br><span class="line"></span><br><span class="line">typeof null // &apos;object&apos;       !!!!!!!!!!!!!!!!</span><br><span class="line"></span><br><span class="line">typeof [] // &apos;object&apos;</span><br><span class="line"></span><br><span class="line">typeof &#123;&#125; // &apos;object&apos;</span><br><span class="line"></span><br><span class="line">typeof console // &apos;object&apos;</span><br><span class="line"></span><br><span class="line">typeof console.log // &apos;function&apos;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>虽然 typeof null 会输出 object，但这只是 JS 存在的一个悠久 Bug，不代表 null 就是引用数据类型，并且 null 本身也不是对象。因此，null 在 typeof 之后返回的是有问题的结果，不能作为判断 null 的方法。如果你需要在 if 语句中判断是否为 null，直接通过 ‘===null’来判断就好。</li>
<li>引用数据类型 Object，用 typeof 来判断的话，除了 function 会判断为 OK 以外，其余都是 ‘object’，是无法判断出来的。</li>
</ul>
<ol start="2">
<li>instanceof<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">let Car = function() &#123;&#125;</span><br><span class="line"></span><br><span class="line">let benz = new Car()</span><br><span class="line"></span><br><span class="line">benz instanceof Car // true</span><br><span class="line"></span><br><span class="line">let car = new String(&apos;Mercedes Benz&apos;)</span><br><span class="line"></span><br><span class="line">car instanceof String // true</span><br><span class="line"></span><br><span class="line">let str = &apos;Covid-19&apos;</span><br><span class="line"></span><br><span class="line">str instanceof String // false</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------------------------------</span><br><span class="line"></span><br><span class="line">function myInstanceof(left, right) &#123;</span><br><span class="line"></span><br><span class="line">  // 这里先用typeof来判断基础数据类型，如果是，直接返回false</span><br><span class="line"></span><br><span class="line">  if(typeof left !== &apos;object&apos; || left === null) return false;</span><br><span class="line"></span><br><span class="line">  // getPrototypeOf是Object对象自带的API，能够拿到参数的原型对象</span><br><span class="line"></span><br><span class="line">  let proto = Object.getPrototypeOf(left);</span><br><span class="line"></span><br><span class="line">  while(true) &#123;                  //循环往下寻找，直到找到相同的原型对象</span><br><span class="line"></span><br><span class="line">    if(proto === null) return false;</span><br><span class="line"></span><br><span class="line">    if(proto === right.prototype) return true;//找到相同原型对象，返回true</span><br><span class="line"></span><br><span class="line">    proto = Object.getPrototypeof(proto);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 验证一下自己实现的myInstanceof是否OK</span><br><span class="line"></span><br><span class="line">console.log(myInstanceof(new Number(123), Number));    // true</span><br><span class="line"></span><br><span class="line">console.log(myInstanceof(123, Number));                // false</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>instanceof 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型；</li>
<li>而 typeof 也存在弊端，它虽然可以判断基础数据类型（null 除外），但是引用数据类型中，除了 function 类型以外，其他的也无法判断。</li>
</ul>
<ol start="3">
<li>Object.prototype.toString<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString(&#123;&#125;)       // &quot;[object Object]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(&#123;&#125;)  // 同上结果，加上call也ok</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(1)    // &quot;[object Number]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(&apos;1&apos;)  // &quot;[object String]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(true)  // &quot;[object Boolean]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(function()&#123;&#125;)  // &quot;[object Function]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(null)   //&quot;[object Null]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(undefined) //&quot;[object Undefined]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(/123/g)    //&quot;[object RegExp]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(new Date()) //&quot;[object Date]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call([])       //&quot;[object Array]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(document)  //&quot;[object HTMLDocument]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(window)   //&quot;[object Window]&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function getType(obj)&#123;</span><br><span class="line">  let type  = typeof obj;</span><br><span class="line">  if (type !== &quot;object&quot;) &#123;    // 先进行typeof判断，如果是基础数据类型，直接返回</span><br><span class="line">    return type;</span><br><span class="line">  &#125;</span><br><span class="line">  // 对于typeof返回结果是object的，再进行如下的判断，正则返回结果</span><br><span class="line">  return Object.prototype.toString.call(obj).replace(/^\[object (\S+)\]$/, &apos;$1&apos;);  // 注意正则中间有个空格</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><ol>
<li>强制类型转换 Number()、parseInt()、parseFloat()、toString()、String()、Boolean()<blockquote>
<p>Number() 方法的强制转换规则<br>如果是布尔值，true 和 false 分别被转换为 1 和 0；<br>如果是数字，返回自身；<br>如果是 null，返回 0；<br>如果是 undefined，返回 NaN；<br>如果是字符串，遵循以下规则：如果字符串中只包含数字（或者是 0X / 0x 开头的十六进制数字字符串，允许包含正负号），则将其转换为十进制；如果字符串中包含有效的浮点格式，将其转换为浮点数值；如果是空字符串，将其转换为 0；如果不是以上格式的字符串，均返回 NaN；<br>如果是 Symbol，抛出错误；<br>如果是对象，并且部署了 [Symbol.toPrimitive] ，那么调用此方法，否则调用对象的 valueOf() 方法，然后依据前面的规则转换返回的值；如果转换的结果是 NaN ，则调用对象的 toString() 方法，再次依照前面的顺序转换返回对应的值</p>
</blockquote>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Number(true);        // 1</span><br><span class="line"></span><br><span class="line">Number(false);       // 0</span><br><span class="line"></span><br><span class="line">Number(&apos;0111&apos;);      //111</span><br><span class="line"></span><br><span class="line">Number(null);        //0</span><br><span class="line"></span><br><span class="line">Number(&apos;&apos;);          //0</span><br><span class="line"></span><br><span class="line">Number(&apos;1a&apos;);        //NaN</span><br><span class="line"></span><br><span class="line">Number(-0X11);       //-17</span><br><span class="line"></span><br><span class="line">Number(&apos;0X11&apos;)       //17</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Boolean() 方法的强制转换规则<br>除了 undefined、 null、 false、 ‘’、 0（包括 +0，-0）、 NaN 转换出来是 false，其他都是 true。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Boolean(0)          //false</span><br><span class="line"></span><br><span class="line">Boolean(null)       //false</span><br><span class="line"></span><br><span class="line">Boolean(undefined)  //false</span><br><span class="line"></span><br><span class="line">Boolean(NaN)        //false</span><br><span class="line"></span><br><span class="line">Boolean(1)          //true</span><br><span class="line"></span><br><span class="line">Boolean(13)         //true</span><br><span class="line"></span><br><span class="line">Boolean(&apos;12&apos;)       //true</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>‘==’ 的隐式类型转换规则</li>
</ol>
<ul>
<li>如果类型相同，无须进行类型转换；</li>
<li>如果其中一个操作值是 null 或者 undefined，那么另一个操作符必须为 null 或者 undefined，才会返回 true，否则都返回 false；</li>
<li>如果其中一个是 Symbol 类型，那么返回 false；</li>
<li>两个操作值如果为 string 和 number 类型，那么就会将字符串转换为 number；</li>
<li>如果一个操作值是 boolean，那么转换成 number；</li>
<li>如果一个操作值为 object 且另一方为 string、number 或者 symbol，就会把 object 转为原始类型再进行判断（调用 object 的 valueOf/toString 方法进行转换）。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">null == undefined       // true  规则2</span><br><span class="line"></span><br><span class="line">null == 0               // false 规则2</span><br><span class="line"></span><br><span class="line">&apos;&apos; == null              // false 规则2</span><br><span class="line"></span><br><span class="line">&apos;&apos; == 0                 // true  规则4 字符串转隐式转换成Number之后再对比</span><br><span class="line"></span><br><span class="line">&apos;123&apos; == 123            // true  规则4 字符串转隐式转换成Number之后再对比</span><br><span class="line"></span><br><span class="line">0 == false              // true  e规则 布尔型隐式转换成Number之后再对比</span><br><span class="line"></span><br><span class="line">1 == true               // true  e规则 布尔型隐式转换成Number之后再对比</span><br><span class="line"></span><br><span class="line">var a = &#123;</span><br><span class="line"></span><br><span class="line">  value: 0,</span><br><span class="line"></span><br><span class="line">  valueOf: function() &#123;</span><br><span class="line"></span><br><span class="line">    this.value++;</span><br><span class="line"></span><br><span class="line">    return this.value;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 注意这里a又可以等于1、2、3</span><br><span class="line"></span><br><span class="line">console.log(a == 1 &amp;&amp; a == 2 &amp;&amp; a ==3);  //true f规则 Object隐式转换</span><br><span class="line"></span><br><span class="line">// 注：但是执行过3遍之后，再重新执行a==3或之前的数字就是false，因为value已经加上去了，这里需要注意一下</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="3">
<li>‘+’ 的隐式类型转换规则</li>
</ol>
<ul>
<li>如果其中有一个是字符串，另外一个是 undefined、null 或布尔型，则调用 toString() 方法进行字符串拼接；如果是纯对象、数组、正则等，则默认调用对象的转换方法会存在优先级，然后再进行拼接。</li>
<li>如果其中有一个是数字，另外一个是 undefined、null、布尔型或数字，则会将其转换成数字进行加法运算，对象的情况还是参考上一条规则。</li>
<li>如果其中一个是字符串、一个是数字，则按照字符串规则进行拼接</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1 + 2        // 3  常规情况</span><br><span class="line"></span><br><span class="line">&apos;1&apos; + &apos;2&apos;    // &apos;12&apos; 常规情况</span><br><span class="line"></span><br><span class="line">// 下面看一下特殊情况</span><br><span class="line"></span><br><span class="line">&apos;1&apos; + undefined   // &quot;1undefined&quot; 规则1，undefined转换字符串</span><br><span class="line"></span><br><span class="line">&apos;1&apos; + null        // &quot;1null&quot; 规则1，null转换字符串</span><br><span class="line"></span><br><span class="line">&apos;1&apos; + true        // &quot;1true&quot; 规则1，true转换字符串</span><br><span class="line"></span><br><span class="line">&apos;1&apos; + 1n          // &apos;11&apos; 比较特殊字符串和BigInt相加，BigInt转换为字符串</span><br><span class="line"></span><br><span class="line">1 + undefined     // NaN  规则2，undefined转换数字相加NaN</span><br><span class="line"></span><br><span class="line">1 + null          // 1    规则2，null转换为0</span><br><span class="line"></span><br><span class="line">1 + true          // 2    规则2，true转换为1，二者相加为2</span><br><span class="line"></span><br><span class="line">1 + 1n            // 错误  不能把BigInt和Number类型直接混合相加</span><br><span class="line"></span><br><span class="line">&apos;1&apos; + 3           // &apos;13&apos; 规则3，字符串拼接</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>Object 的转换规则</li>
</ol>
<ul>
<li>如果部署了 Symbol.toPrimitive 方法，优先调用再返回；</li>
<li>调用 valueOf()，如果转换为基础类型，则返回；</li>
<li>调用 toString()，如果转换为基础类型，则返回；</li>
<li>如果都没有返回基础类型，会报错。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line"></span><br><span class="line">  value: 1,</span><br><span class="line"></span><br><span class="line">  valueOf() &#123;</span><br><span class="line"></span><br><span class="line">    return 2;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line"></span><br><span class="line">    return &apos;3&apos;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  [Symbol.toPrimitive]() &#123;</span><br><span class="line"></span><br><span class="line">    return 4</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(obj + 1); // 输出5</span><br><span class="line"></span><br><span class="line">// 因为有Symbol.toPrimitive，就优先执行这个；如果Symbol.toPrimitive这段代码删掉，则执行valueOf打印结果为3；如果valueOf也去掉，则调用toString返回&apos;31&apos;(字符串拼接)</span><br><span class="line"></span><br><span class="line">// 再看两个特殊的case：</span><br><span class="line"></span><br><span class="line">10 + &#123;&#125;</span><br><span class="line"></span><br><span class="line">// &quot;10[object Object]&quot;，注意：&#123;&#125;会默认调用valueOf是&#123;&#125;，不是基础类型继续转换，调用toString，返回结果&quot;[object Object]&quot;，于是和10进行&apos;+&apos;运算，按照字符串拼接规则来，参考&apos;+&apos;的规则C</span><br><span class="line"></span><br><span class="line">[1,2,undefined,4,5] + 10</span><br><span class="line"></span><br><span class="line">// &quot;1,2,,4,510&quot;，注意[1,2,undefined,4,5]会默认先调用valueOf结果还是这个数组，不是基础数据类型继续转换，也还是调用toString，返回&quot;1,2,,4,5&quot;，然后再和10进行运算，还是按照字符串拼接规则，参考&apos;+&apos;的第3条规则</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h2><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><ol>
<li>Object.assign<br><em>注意点</em></li>
</ol>
<ul>
<li>它不会拷贝对象的继承属性；</li>
<li>它不会拷贝对象的不可枚举的属性；</li>
<li>可以拷贝 Symbol 类型的属性。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">let obj1 = &#123; a:&#123; b:1 &#125;, sym:Symbol(1)&#125;; </span><br><span class="line"></span><br><span class="line">Object.defineProperty(obj1, &apos;innumerable&apos; ,&#123;</span><br><span class="line"></span><br><span class="line">    value:&apos;不可枚举属性&apos;,</span><br><span class="line"></span><br><span class="line">    enumerable:false</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">let obj2 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Object.assign(obj2,obj1)</span><br><span class="line"></span><br><span class="line">obj1.a.b = 2;</span><br><span class="line"></span><br><span class="line">console.log(&apos;obj1&apos;,obj1);</span><br><span class="line"></span><br><span class="line">console.log(&apos;obj2&apos;,obj2);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="2">
<li>扩展运算符<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/* 对象的拷贝 */</span><br><span class="line"></span><br><span class="line">let obj = &#123;a:1,b:&#123;c:1&#125;&#125;</span><br><span class="line"></span><br><span class="line">let obj2 = &#123;...obj&#125;</span><br><span class="line"></span><br><span class="line">obj.a = 2</span><br><span class="line"></span><br><span class="line">console.log(obj)  //&#123;a:2,b:&#123;c:1&#125;&#125; console.log(obj2); //&#123;a:1,b:&#123;c:1&#125;&#125;</span><br><span class="line"></span><br><span class="line">obj.b.c = 2</span><br><span class="line"></span><br><span class="line">console.log(obj)  //&#123;a:2,b:&#123;c:2&#125;&#125; console.log(obj2); //&#123;a:1,b:&#123;c:2&#125;&#125;</span><br><span class="line"></span><br><span class="line">/* 数组的拷贝 */</span><br><span class="line"></span><br><span class="line">let arr = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">let newArr = [...arr]; //跟arr.slice()是一样的效果</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>扩展运算符 和 object.assign 有同样的缺陷，也就是实现的浅拷贝的功能差不多，但是如果属性都是基本类型的值，使用扩展运算符进行浅拷贝会更加方便。</li>
</ul>
<ol start="3">
<li>concat 拷贝数组<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">let newArr = arr.concat();</span><br><span class="line"></span><br><span class="line">newArr[1] = 100;</span><br><span class="line"></span><br><span class="line">console.log(arr);  // [ 1, 2, 3 ]</span><br><span class="line"></span><br><span class="line">console.log(newArr); // [ 1, 100, 3 ]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>concat 只能用于数组的浅拷贝，使用场景比较局限。</li>
</ul>
<ol start="4">
<li>slice 拷贝数组</li>
</ol>
<ul>
<li>slice 方法也比较有局限性，因为它仅仅针对数组类型。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, 2, &#123;val: 4&#125;];</span><br><span class="line"></span><br><span class="line">let newArr = arr.slice();</span><br><span class="line"></span><br><span class="line">newArr[2].val = 1000;</span><br><span class="line"></span><br><span class="line">console.log(arr);  //[ 1, 2, &#123; val: 1000 &#125; ]</span><br></pre></td></tr></table></figure>
<ul>
<li>浅拷贝只能拷贝一层对象。如果存在对象的嵌套，那么浅拷贝将无能为力。因此深拷贝就是为了解决这个问题而生的，它能解决多层对象嵌套问题，彻底实现拷贝。</li>
</ul>
<ol start="5">
<li>浅拷贝</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">const shallowClone = (target) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  if (typeof target === &apos;object&apos; &amp;&amp; target !== null) &#123;</span><br><span class="line"></span><br><span class="line">    const cloneTarget = Array.isArray(target) ? []: &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    for (let prop in target) &#123;</span><br><span class="line"></span><br><span class="line">      //是否是自有属性</span><br><span class="line">      if (target.hasOwnProperty(prop)) &#123;</span><br><span class="line"></span><br><span class="line">          cloneTarget[prop] = target[prop];</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return cloneTarget;</span><br><span class="line"></span><br><span class="line">  &#125; else &#123;</span><br><span class="line"></span><br><span class="line">    return target;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><ol>
<li>JSON.stringify()<br><em>弊端</em></li>
</ol>
<ul>
<li>拷贝的对象的值中如果有函数、undefined、symbol 这几种类型，经过 JSON.stringify 序列化之后的字符串中这个键值对会消失；</li>
<li>拷贝 Date 引用类型会变成字符串；</li>
<li>无法拷贝不可枚举的属性；</li>
<li>无法拷贝对象的原型链；</li>
<li>拷贝 RegExp 引用类型会变成空对象；</li>
<li>对象中含有 NaN、Infinity 以及 -Infinity，JSON 序列化的结果会变成 null；</li>
<li>无法拷贝对象的循环应用，即对象成环 (obj[key] = obj)。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">function Obj() &#123; </span><br><span class="line"></span><br><span class="line">  this.func = function () &#123; alert(1) &#125;; </span><br><span class="line"></span><br><span class="line">  this.obj = &#123;a:1&#125;;</span><br><span class="line"></span><br><span class="line">  this.arr = [1,2,3];</span><br><span class="line"></span><br><span class="line">  this.und = undefined; </span><br><span class="line"></span><br><span class="line">  this.reg = /123/; </span><br><span class="line"></span><br><span class="line">  this.date = new Date(0); </span><br><span class="line"></span><br><span class="line">  this.NaN = NaN;</span><br><span class="line"></span><br><span class="line">  this.infinity = Infinity;</span><br><span class="line"></span><br><span class="line">  this.sym = Symbol(1);</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">let obj1 = new Obj();</span><br><span class="line"></span><br><span class="line">Object.defineProperty(obj1,&apos;innumerable&apos;,&#123; </span><br><span class="line"></span><br><span class="line">  enumerable:false,</span><br><span class="line"></span><br><span class="line">  value:&apos;innumerable&apos;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&apos;obj1&apos;,obj1);</span><br><span class="line"></span><br><span class="line">let str = JSON.stringify(obj1);</span><br><span class="line"></span><br><span class="line">let obj2 = JSON.parse(str);</span><br><span class="line"></span><br><span class="line">console.log(&apos;obj2&apos;,obj2);</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 JSON.stringify 方法实现深拷贝对象，虽然到目前为止还有很多无法实现的功能，但是这种方法足以满足日常的开发需求，并且是最简单和快捷的。</li>
</ul>
<ol start="2">
<li>手写递归实现<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">let obj1 = &#123;</span><br><span class="line"></span><br><span class="line">  a:&#123;</span><br><span class="line"></span><br><span class="line">    b:1</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function deepClone(obj) &#123; </span><br><span class="line"></span><br><span class="line">  let cloneObj = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  for(let key in obj) &#123;                 //遍历</span><br><span class="line"></span><br><span class="line">    if(typeof obj[key] ===&apos;object&apos;) &#123; </span><br><span class="line"></span><br><span class="line">      cloneObj[key] = deepClone(obj[key])  //是对象就再次调用该函数递归</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">      cloneObj[key] = obj[key]  //基本类型的话直接复制值</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return cloneObj</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let obj2 = deepClone(obj1);</span><br><span class="line"></span><br><span class="line">obj1.a.b = 2;</span><br><span class="line"></span><br><span class="line">console.log(obj2);   //  &#123;a:&#123;b:1&#125;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><em>弊端</em></p>
<ul>
<li>这个深拷贝函数并不能复制不可枚举的属性以及 Symbol 类型；</li>
<li>这种方法只是针对普通的引用类型的值做递归复制，而对于 Array、Date、RegExp、Error、Function 这样的引用类型并不能正确地拷贝；</li>
<li>对象的属性里面成环，即循环引用没有解决。</li>
</ul>
<ol start="3">
<li>改进后递归实现<br><em>注意点</em></li>
</ol>
<ul>
<li>针对能够遍历对象的不可枚举属性以及 Symbol 类型，我们可以使用 Reflect.ownKeys 方法；</li>
<li>当参数为 Date、RegExp 类型，则直接生成一个新的实例返回；</li>
<li>利用 Object 的 getOwnPropertyDescriptors 方法可以获得对象的所有属性，以及对应的特性，顺便结合 Object 的 create 方法创建一个新对象，并继承传入原对象的原型链；</li>
<li>利用 WeakMap 类型作为 Hash 表，因为 WeakMap 是弱引用类型，可以有效防止内存泄漏（你可以关注一下 Map 和 weakMap 的关键区别，这里要用 weakMap），作为检测循环引用很有帮助，如果存在循环，则引用直接返回 WeakMap 存储的值。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">const isComplexDataType = obj =&gt; (typeof obj === &apos;object&apos; || typeof obj === &apos;function&apos;) &amp;&amp; (obj !== null)</span><br><span class="line"></span><br><span class="line">const deepClone = function (obj, hash = new WeakMap()) &#123;</span><br><span class="line"></span><br><span class="line">  if (obj.constructor === Date) </span><br><span class="line"></span><br><span class="line">  return new Date(obj)       // 日期对象直接返回一个新的日期对象</span><br><span class="line"></span><br><span class="line">  if (obj.constructor === RegExp)</span><br><span class="line"></span><br><span class="line">  return new RegExp(obj)     //正则对象直接返回一个新的正则对象</span><br><span class="line"></span><br><span class="line">  //如果循环引用了就用 weakMap 来解决</span><br><span class="line"></span><br><span class="line">  if (hash.has(obj)) return hash.get(obj)</span><br><span class="line"></span><br><span class="line">  let allDesc = Object.getOwnPropertyDescriptors(obj)</span><br><span class="line"></span><br><span class="line">  //遍历传入参数所有键的特性</span><br><span class="line"></span><br><span class="line">  let cloneObj = Object.create(Object.getPrototypeOf(obj), allDesc)</span><br><span class="line"></span><br><span class="line">  //继承原型链</span><br><span class="line"></span><br><span class="line">  hash.set(obj, cloneObj)</span><br><span class="line"></span><br><span class="line">  for (let key of Reflect.ownKeys(obj)) &#123; </span><br><span class="line"></span><br><span class="line">    cloneObj[key] = (isComplexDataType(obj[key]) &amp;&amp; typeof obj[key] !== &apos;function&apos;) ? deepClone(obj[key], hash) : obj[key]</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return cloneObj</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 下面是验证代码</span><br><span class="line"></span><br><span class="line">let obj = &#123;</span><br><span class="line"></span><br><span class="line">  num: 0,</span><br><span class="line"></span><br><span class="line">  str: &apos;&apos;,</span><br><span class="line"></span><br><span class="line">  boolean: true,</span><br><span class="line"></span><br><span class="line">  unf: undefined,</span><br><span class="line"></span><br><span class="line">  nul: null,</span><br><span class="line"></span><br><span class="line">  obj: &#123; name: &apos;我是一个对象&apos;, id: 1 &#125;,</span><br><span class="line"></span><br><span class="line">  arr: [0, 1, 2],</span><br><span class="line"></span><br><span class="line">  func: function () &#123; console.log(&apos;我是一个函数&apos;) &#125;,</span><br><span class="line"></span><br><span class="line">  date: new Date(0),</span><br><span class="line"></span><br><span class="line">  reg: new RegExp(&apos;/我是一个正则/ig&apos;),</span><br><span class="line"></span><br><span class="line">  [Symbol(&apos;1&apos;)]: 1,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.defineProperty(obj, &apos;innumerable&apos;, &#123;</span><br><span class="line"></span><br><span class="line">  enumerable: false, value: &apos;不可枚举属性&apos; &#125;</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">obj = Object.create(obj, Object.getOwnPropertyDescriptors(obj))</span><br><span class="line"></span><br><span class="line">obj.loop = obj    // 设置loop成循环引用的属性</span><br><span class="line"></span><br><span class="line">let cloneObj = deepClone(obj)</span><br><span class="line"></span><br><span class="line">cloneObj.arr.push(4)</span><br><span class="line"></span><br><span class="line">console.log(&apos;obj&apos;, obj)</span><br><span class="line"></span><br><span class="line">console.log(&apos;cloneObj&apos;, cloneObj)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ol>
<li>原型链继承<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function Parent1() &#123;</span><br><span class="line"></span><br><span class="line">  this.name = &apos;parent1&apos;;</span><br><span class="line"></span><br><span class="line">  this.play = [1, 2, 3]</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child1() &#123;</span><br><span class="line"></span><br><span class="line">  this.type = &apos;child2&apos;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child1.prototype = new Parent1();</span><br><span class="line">let c1=new Child1()</span><br><span class="line">let c2=new Child1()</span><br><span class="line">console.log(c1.__proto__===c2.__proto__); //true</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>两个实例使用的是同一个原型对象。它们的内存空间是共享的，当一个发生变化的时候，另外一个也随之进行了变化，这就是使用原型链继承方式的一个缺点。</p>
<ol start="2">
<li>构造函数继承（借助 call）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">function Parent1()&#123;</span><br><span class="line"></span><br><span class="line">  this.name = &apos;parent1&apos;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Parent1.prototype.getName = function () &#123;</span><br><span class="line"></span><br><span class="line">  return this.name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function Child1()&#123;</span><br><span class="line"></span><br><span class="line">  Parent1.call(this);</span><br><span class="line"></span><br><span class="line">  this.type = &apos;child1&apos;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let child = new Child1();</span><br><span class="line"></span><br><span class="line">console.log(child);  // 没问题</span><br><span class="line"></span><br><span class="line">console.log(child.getName());  // 会报错</span><br></pre></td></tr></table></figure>
<p>构造函数实现继承的优缺点，它使父类的引用属性不会被共享，优化了第一种继承方式的弊端；<br>但是随之而来的缺点也比较明显——只能继承父类的实例属性和方法，不能继承原型属性或者方法。</p>
<ol start="3">
<li><p>组合继承（前两种组合）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">function Parent3 () &#123;</span><br><span class="line"></span><br><span class="line">  this.name = &apos;parent3&apos;;</span><br><span class="line"></span><br><span class="line">  this.play = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Parent3.prototype.getName = function () &#123;</span><br><span class="line"></span><br><span class="line">  return this.name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child3() &#123;</span><br><span class="line"></span><br><span class="line">  // 第二次调用 Parent3()</span><br><span class="line"></span><br><span class="line">  Parent3.call(this);</span><br><span class="line"></span><br><span class="line">  this.type = &apos;child3&apos;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 第一次调用 Parent3()</span><br><span class="line"></span><br><span class="line">Child3.prototype = new Parent3();</span><br><span class="line"></span><br><span class="line">// 手动挂上构造器，指向自己的构造函数</span><br><span class="line"></span><br><span class="line">Child3.prototype.constructor = Child3;</span><br><span class="line"></span><br><span class="line">var s3 = new Child3();</span><br><span class="line"></span><br><span class="line">var s4 = new Child3();</span><br><span class="line"></span><br><span class="line">s3.play.push(4);</span><br><span class="line"></span><br><span class="line">console.log(s3.play, s4.play);  // 不互相影响</span><br><span class="line"></span><br><span class="line">console.log(s3.getName()); // 正常输出&apos;parent3&apos;</span><br><span class="line"></span><br><span class="line">console.log(s4.getName()); // 正常输出&apos;parent3&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>原型式继承</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">let parent4 = &#123;</span><br><span class="line"></span><br><span class="line">  name: &quot;parent4&quot;,</span><br><span class="line"></span><br><span class="line">  friends: [&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;],</span><br><span class="line"></span><br><span class="line">  getName: function() &#123;</span><br><span class="line"></span><br><span class="line">    return this.name;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let person4 = Object.create(parent4);</span><br><span class="line"></span><br><span class="line">person4.name = &quot;tom&quot;;</span><br><span class="line"></span><br><span class="line">person4.friends.push(&quot;jerry&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let person5 = Object.create(parent4);</span><br><span class="line"></span><br><span class="line">person5.friends.push(&quot;lucy&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">console.log(person4.name);</span><br><span class="line"></span><br><span class="line">console.log(person4.name === person4.getName());</span><br><span class="line"></span><br><span class="line">console.log(person5.name);</span><br><span class="line"></span><br><span class="line">console.log(person4.friends);</span><br><span class="line"></span><br><span class="line">console.log(person5.friends);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>最后两个输出结果是一样的，关于引用数据类型“共享”的问题，其实 Object.create 方法是可以为一些对象实现浅拷贝的。<br>关于这种继承方式的缺点也很明显，多个实例的引用类型属性指向相同的内存，存在篡改的可能。</p>
<ol start="5">
<li>寄生式继承</li>
</ol>
<ul>
<li><p>使用原型式继承可以获得一份目标对象的浅拷贝，然后利用这个浅拷贝的能力再进行增强，添加一些方法，这样的继承方式就叫作寄生式继承。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"> let parent5 = &#123;</span><br><span class="line"></span><br><span class="line">  name: &quot;parent5&quot;,</span><br><span class="line"></span><br><span class="line">  friends: [&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;],</span><br><span class="line"></span><br><span class="line">  getName: function() &#123;</span><br><span class="line"></span><br><span class="line">    return this.name;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function clone(original) &#123;</span><br><span class="line"></span><br><span class="line">  let clone = Object.create(original);</span><br><span class="line"></span><br><span class="line">  clone.getFriends = function() &#123;</span><br><span class="line"></span><br><span class="line">    return this.friends;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return clone;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let person5 = clone(parent5);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">console.log(person5.getName());</span><br><span class="line"></span><br><span class="line">console.log(person5.getFriends());</span><br></pre></td></tr></table></figure>
</li>
<li><p>虽然其优缺点和原型式继承一样，但是对于普通对象的继承方式来说，寄生式继承相比于原型式继承，还是在父类基础上添加了更多的方法。</p>
</li>
</ul>
<ol start="6">
<li>寄生组合式继承</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">function clone (parent, child) &#123;</span><br><span class="line"></span><br><span class="line">  // 这里改用 Object.create 就可以减少组合继承中多进行一次构造的过程</span><br><span class="line"></span><br><span class="line">  child.prototype = Object.create(parent.prototype);</span><br><span class="line"></span><br><span class="line">  child.prototype.constructor = child;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function Parent6() &#123;</span><br><span class="line"></span><br><span class="line">  this.name = &apos;parent6&apos;;</span><br><span class="line"></span><br><span class="line">  this.play = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> Parent6.prototype.getName = function () &#123;</span><br><span class="line"></span><br><span class="line">  return this.name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child6() &#123;</span><br><span class="line"></span><br><span class="line">  Parent6.call(this);</span><br><span class="line"></span><br><span class="line">  this.friends = &apos;child5&apos;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">clone(Parent6, Child6);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Child6.prototype.getFriends = function () &#123;</span><br><span class="line"></span><br><span class="line">  return this.friends;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let person6 = new Child6();</span><br><span class="line"></span><br><span class="line">console.log(person6);</span><br><span class="line"></span><br><span class="line">console.log(person6.getName());</span><br><span class="line"></span><br><span class="line">console.log(person6.getFriends());</span><br></pre></td></tr></table></figure>
<ul>
<li>这种寄生组合式继承方式，基本可以解决前几种继承方式的缺点，较好地实现了继承想要的结果，同时也减少了构造次数，减少了性能的开销</li>
</ul>
<ol start="7">
<li>ES6 的 extends 关键字实现逻辑<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line"></span><br><span class="line">  constructor(name) &#123;</span><br><span class="line"></span><br><span class="line">    this.name = name</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 原型方法</span><br><span class="line"></span><br><span class="line">  // 即 Person.prototype.getName = function() &#123; &#125;</span><br><span class="line"></span><br><span class="line">  // 下面可以简写为 getName() &#123;...&#125;</span><br><span class="line"></span><br><span class="line">  getName = function () &#123;</span><br><span class="line"></span><br><span class="line">    console.log(&apos;Person:&apos;, this.name)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Gamer extends Person &#123;</span><br><span class="line"></span><br><span class="line">  constructor(name, age) &#123;</span><br><span class="line"></span><br><span class="line">    // 子类中存在构造函数，则需要在使用“this”之前首先调用 super()。</span><br><span class="line"></span><br><span class="line">    super(name)</span><br><span class="line"></span><br><span class="line">    this.age = age</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const asuna = new Gamer(&apos;Asuna&apos;, 20)</span><br><span class="line"></span><br><span class="line">asuna.getName() // 成功访问到父类的方法</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>利用 babel 这个编译工具，将 ES6 的代码编译成 ES5</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">function _possibleConstructorReturn (self, call) &#123; </span><br><span class="line"></span><br><span class="line">		// ...</span><br><span class="line"></span><br><span class="line">		return call &amp;&amp; (typeof call === &apos;object&apos; || typeof call === &apos;function&apos;) ? call : self; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _inherits (subClass, superClass) &#123; </span><br><span class="line"></span><br><span class="line">    // 这里可以看到</span><br><span class="line"></span><br><span class="line">	subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, &#123; </span><br><span class="line"></span><br><span class="line">		constructor: &#123; </span><br><span class="line"></span><br><span class="line">			value: subClass, </span><br><span class="line"></span><br><span class="line">			enumerable: false, </span><br><span class="line"></span><br><span class="line">			writable: true, </span><br><span class="line"></span><br><span class="line">			configurable: true </span><br><span class="line"></span><br><span class="line">		&#125; </span><br><span class="line"></span><br><span class="line">	&#125;); </span><br><span class="line"></span><br><span class="line">	if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var Parent = function Parent () &#123;</span><br><span class="line"></span><br><span class="line">	// 验证是否是 Parent 构造出来的 this</span><br><span class="line"></span><br><span class="line">	_classCallCheck(this, Parent);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var Child = (function (_Parent) &#123;</span><br><span class="line"></span><br><span class="line">	_inherits(Child, _Parent);</span><br><span class="line"></span><br><span class="line">	function Child () &#123;</span><br><span class="line"></span><br><span class="line">		_classCallCheck(this, Child);</span><br><span class="line"></span><br><span class="line">		return _possibleConstructorReturn(this, (Child.__proto__ || Object.getPrototypeOf(Child)).apply(this, arguments));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	return Child;</span><br><span class="line"></span><br><span class="line">&#125;(Parent));</span><br></pre></td></tr></table></figure>
<p>从上面编译完成的源码中可以看到，它采用的也是寄生组合继承方式，因此也证明了这种方式是较优的解决继承的方式。</p>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><ul>
<li>不管是什么样的计算机程序语言，运行在对应的代码引擎上，对应的使用内存过程大致逻辑是一样的，可以分为这三个步骤：</li>
</ul>
<ol>
<li>分配你所需要的系统内存空间；</li>
<li>使用分配到的内存进行读或者写等操作；</li>
<li>不需要使用内存时，将其空间释放或者归还。</li>
</ol>
<ul>
<li><p>在 JavaScript 中，当我们创建变量（对象，字符串等）的时候，系统会自动给对象分配对应的内存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var a = 123; // 给数值变量分配栈内存</span><br><span class="line"></span><br><span class="line">var etf = &quot;ARK&quot;; // 给字符串分配栈内存</span><br><span class="line"></span><br><span class="line">// 给对象及其包含的值分配堆内存</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line"></span><br><span class="line">  name: &apos;tom&apos;,</span><br><span class="line"></span><br><span class="line">  age: 13</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">// 给数组及其包含的值分配内存（就像对象一样）</span><br><span class="line"></span><br><span class="line">var a = [1, null, &quot;PSAC&quot;]; </span><br><span class="line"></span><br><span class="line">// 给函数（可调用的对象）分配内存</span><br><span class="line"></span><br><span class="line">function sum(a, b)&#123;</span><br><span class="line"></span><br><span class="line">  return a + b;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>栈内存中的基本类型，可以通过操作系统直接处理；<br>而堆内存中的引用类型，正是由于可以经常变化，大小不固定，因此需要 JavaScript 的引擎通过垃圾回收机制来处理。</p>
<h3 id="chrome内存回收机制"><a href="#chrome内存回收机制" class="headerlink" title="chrome内存回收机制"></a>chrome内存回收机制</h3></li>
<li>在 Chrome 浏览器中，JavaScript 的 V8 引擎被限制了内存的使用，根据不同的操作系统（操作系统有 64 位和 32 位的）内存大小会不同，大的可以到 1.4G 的空间，小的只能到 0.7G 的空间。</li>
<li>为什么要去限制内存使用呢？<br>大致是两个原因：V8 最开始是为浏览器而设计的引擎，早些年由于 Web 应用都比较简单，其实并未考虑占据过多的内存空间；<br>另外又由于被 V8 的垃圾回收机制所限制，比如清理大量的内存时会耗费很多时间，这样会引起 JavaScript 执行的线程被挂起，会影响当前执行的页面应用的性能。<h4 id="新生代内存回收"><a href="#新生代内存回收" class="headerlink" title="新生代内存回收"></a>新生代内存回收</h4></li>
<li>新生代的内存回收的空间，在 64 位操作系统下分配为 32MB，正是因为新生代中的变量存活时间短，不太容易产生太大的内存压力，因此不够大也是可以理解的。</li>
<li>系统会将分配给新生代的内存空间分为两部分：正在使用的内存空间[1]，闲置的内存空间[2]<br>当浏览器开始进行内存的垃圾回收时，JavaScript 的 V8 引擎会将[1]的对象检查一遍。如果引擎检测是存活对象，那么会复制到[2]去；如果不是存活的对象，则直接进行系统回收。当所有[1]的对象没有了的时候，等再有新生代的对象产生时，[1][2]对调，这样来循环处理。</li>
<li><code>算法 Scavenge</code>，它主要就是解决内存碎片<h4 id="老生代内存回收"><a href="#老生代内存回收" class="headerlink" title="老生代内存回收"></a>老生代内存回收</h4></li>
<li>新生代中的变量如果经过回收之后依然一直存在，那么就会被放入到老生代内存中。</li>
<li>只要是已经经历过一次 Scavenge 算法回收的，就可以晋升为老生代内存的对象</li>
<li>对于内存空间比较大的，就不适合用 Scavenge 算法了。</li>
<li>老生代内存中的垃圾回收,采用了 <code>Mark-Sweep（标记清除）</code> 和 <code>Mark-Compact（标记整理）</code>的策略</li>
</ul>
<ol>
<li>标记清除（Mark-Sweep）<br>分为两个阶段：标记阶段和清除阶段。<br>首先它会遍历堆上的所有的对象，分别对它们打上标记；然后在代码执行过程结束之后，对使用过的变量取消标记。<br>那么没取消标记的就是没有使用过的变量，因此在清除阶段，就会把还有标记的进行整体清除，从而释放内存空间。</li>
</ol>
<p>通过标记清除之后，还是会出现内存碎片的问题。标记整理策略（Mark-Compact）用来解决内存碎片的问题。</p>
<ol start="2">
<li>标记整理（Mark-Compact）<br>标记整理添加了活动对象整理阶段，处理过程中会将所有的活动对象往一端靠拢，整体移动完成后，直接清理掉边界外的内存。<br>Scavenge 算法比较适合内存较小的情况处理；而对于老生代内存较大、变量较多的时候，还是需要采用“标记-清除”结合“标记-整理”这样的方式处理内存问题，并尽量避免内存碎片的产生。<h3 id="内存泄漏与优化"><a href="#内存泄漏与优化" class="headerlink" title="内存泄漏与优化"></a>内存泄漏与优化</h3></li>
</ol>
<ul>
<li>内存泄漏的场景：</li>
</ul>
<ol>
<li>过多的缓存未释放；</li>
<li>闭包太多未释放；</li>
<li>定时器或者回调太多未释放；</li>
<li>太多无效的 DOM 未释放；</li>
<li>全局变量太多未被发现。</li>
</ol>
<h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><h3 id="时间、空间复杂度"><a href="#时间、空间复杂度" class="headerlink" title="时间、空间复杂度"></a>时间、空间复杂度</h3><p>通常，复杂度的计算方法遵循以下几个原则：</p>
<ol>
<li>首先，复杂度与具体的常系数无关，例如 O(n) 和 O(2n) 表示的是同样的复杂度。<br>我们详细分析下，O(2n) 等于 O(n+n)，也等于 O(n) + O(n)。<br>也就是说，一段 O(n) 复杂度的代码只是先后执行两遍 O(n)，其复杂度是一致的。</li>
<li>其次，多项式级的复杂度相加的时候，选择高者作为结果，例如 O(n²)+O(n) 和 O(n²) 表示的是同样的复杂度。<br>具体分析一下就是，O(n²)+O(n) = O(n²+n)。随着 n 越来越大，二阶多项式的变化率是要比一阶多项式更大的。<br>因此，只需要通过更大变化率的二阶多项式来表征复杂度就可以了。</li>
<li>值得一提的是，O(1) 也是表示一个特殊复杂度，含义为某个任务通过有限可数的资源即可完成。<br>此处有限可数的具体意义是，与输入数据量 n 无关。</li>
<li>一个顺序结构的代码，时间复杂度是 O(1)。</li>
<li>二分查找，或者更通用地说是采用分而治之的二分策略，时间复杂度都是 O(logn)。这个我们会在后续课程讲到。</li>
<li>一个简单的 for 循环，时间复杂度是 O(n)。</li>
<li>两个顺序执行的 for 循环，时间复杂度是 O(n)+O(n)=O(2n)，其实也是 O(n)。</li>
<li>两个嵌套的 for 循环，时间复杂度是 O(n²)。</li>
<li>程序优化的最核心的思路，简单梳理如下：<br>第一步，暴力解法。在没有任何时间、空间约束下，完成代码任务的开发。<br>第二步，无效操作处理。将代码中的无效计算、无效存储剔除，降低时间或空间复杂度。<br>第三步，时空转换。设计合理数据结构，完成时间复杂度向空间复杂度的转移。<h3 id="增删查"><a href="#增删查" class="headerlink" title="增删查"></a>增删查</h3></li>
<li>链表和数组一样，都是 O(n) 空间复杂度的复杂数据结构。但其区别之一就是，数组有 index 的索引，而链表没有。<br>① 有了 index 的索引，所以我们就可以直接进行查找操作来，这里的时间复杂度为 O(1)。<br>② 链表因为没有索引，只能“一个接一个”地按照位置条件查找，在这种情况下时间复杂度就是 O (n)。</li>
<li>数据处理的基本操作只有 3 个，分别是增、删、查。其中，增和删又可以细分为在数据结构中间的增和删，以及在数据结构最后的增和删。<br>区别就在于原数据的位置是否发生改变。查找又可以细分为按照位置条件的查找和按照数据数值特征的查找。<br>几乎所有的数据处理，都是这些基本操作的组合和叠加。<h3 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h3></li>
</ol>
<ul>
<li>最常用的是链式表达，通常也叫作线性链表或者链表。</li>
</ul>
<ol>
<li>虽然链表在新增和删除数据上有优势，但仔细思考就会发现，这个优势并不实用。这主要是因为，在新增数据时，通常会伴随一个查找的动作。例如，在第五个结点后，新增一个新的数据结点，那么执行的操作就包含两个步骤：<br>①第一步，查找第五个结点；<br>②第二步，再新增一个数据结点。整体的复杂度就是 O(n) + O(1)，也就是O(n)。</li>
<li>线性表真正的价值在于，它对数据的存储方式是按照顺序的存储。<br>如果数据的元素个数不确定，且需要经常进行数据的新增和删除时，那么链表会比较合适。<br>如果数据元素大小确定，删除插入的操作并不多，那么数组可能更适合些。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">例 1，链表的翻转。给定一个链表，输出翻转后的链表。例如，输入1 -&gt;2 -&gt; 3 -&gt; 4 -&gt;5，输出 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1。</span><br><span class="line">我们来仔细看一下这个问题的难点在哪里，这里有两种情况：</span><br><span class="line">如果是数组的翻转，这会非常容易。原因在于，数组在连续的空间进行存储，可以直接求解出数组的长度。而且，数组可以通过索引值去查找元素，然后对相应的数据进行交换操作而完成翻转。</span><br><span class="line">但对于某个单向链表，它的指针结构造成了它的数据通路有去无回，一旦修改了某个指针，后面的数据就会造成失联的状态。为了解决这个问题，我们需要构造三个指针 prev、curr 和 next，对当前结点、以及它之前和之后的结点进行缓存，再完成翻转动作。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">例 2，给定一个奇数个元素的链表，查找出这个链表中间位置的结点的数值。</span><br><span class="line">这个问题也是利用了链表的长度无法直接获取的不足做文章，解决办法如下：</span><br><span class="line">一个暴力的办法是，先通过一次遍历去计算链表的长度，这样我们就知道了链表中间位置是第几个。接着再通过一次遍历去查找这个位置的数值。</span><br><span class="line">除此之外，还有一个巧妙的办法，就是利用快慢指针进行处理。其中快指针每次循环向后跳转两次，而慢指针每次向后跳转一次。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">例 3，判断链表是否有环。</span><br><span class="line">假设链表有环，这个环里面就像是一个跑步赛道的操场一样。经过多次循环之后，快指针和慢指针都会进入到这个赛道中，就好像两个跑步选手在比赛。</span><br><span class="line">快指针每次走两格，而慢指针每次走一格，相对而言，快指针每次循环会多走一步。</span><br><span class="line">这就意味着：如果链表存在环，快指针和慢指针一定会在环内相遇，即 fast == slow 的情况一定会发生。</span><br><span class="line">反之，则最终会完成循环，二者从未相遇。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><h4 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h4><ol>
<li>栈的顺序存储可以借助数组来实现。一般来说，会把数组的首元素存在栈底，最后一个元素放在栈顶。<br>然后定义一个 top 指针来指示栈顶元素在数组中的位置。假设栈中只有一个数据元素，则 top = 0。<br>一般以 top 是否为 -1 来判定是否为空栈。<br>当定义了栈的最大容量为 StackSize 时，则栈顶 top 必须小于 StackSize。</li>
<li>对于查找操作，栈没有额外的改变，跟线性表一样，它也需要遍历整个栈来完成基于某些条件的数值查找。</li>
<li>删除数据元素，即出栈操作，只需要 top - 1 就可以了。<h4 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h4></li>
<li>关于链式栈，就是用链表的方式对栈的表示。</li>
<li>在链式栈中进行删除操作时，只能在栈顶进行操作。因此，将栈顶的 top 指针指向栈顶元素的 next 指针即可完成删除。</li>
<li>对于链式栈来说，新增删除数据元素没有任何循环操作，其时间复杂度均为 O(1)。</li>
</ol>
<ul>
<li>不管是顺序栈还是链栈，数据的新增、删除、查找与线性表的操作原理极为相似，时间复杂度完全一样，都依赖当前位置的指针来进行数据对象的操作。区别仅仅在于新增和删除的对象，只能是栈顶的数据结点。<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3>队列也存在这两种存储方式，即顺序队列和链式队列：</li>
</ul>
<ol>
<li>顺序队列，依赖数组来实现，其中的数据在内存中也是顺序存储。</li>
<li>而链式队列，则依赖链表来实现，其中的数据依赖每个结点的指针互联，在内存中并不是顺序存储。链式队列，实际上就是只能尾进头出的线性表的单链表。</li>
<li>队列从队头（front）删除元素，从队尾（rear）插入元素。</li>
<li>队列新增数据的操作，就是利用 rear 指针在队尾新增一个数据元素。这个过程不会影响其他数据，时间复杂度为 O(1)</li>
<li>队列删除数据的操作与栈不同。队列元素出口在队列头部，即下标为 0 的位置。当利用 front 指针删除一个数据时，队列中剩余的元素都需要向前移动一个位置，以保证队列头部下标为 0 的位置不为空，此时时间复杂度就变成 O(n) <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">采用顺序存储的队列时，我们可以通过移动指针的方式来删除数据，这样就不需要移动剩余的数据了。</span><br><span class="line">但是，这样的操作，也可能会产生数组越界的问题。</span><br><span class="line">两个简单粗暴的解决方法就是：</span><br><span class="line">1. 不惜消耗 O(n) 的时间复杂度去移动数据；</span><br><span class="line">2. 或者开辟足够大的内存空间确保数组不会越界。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h4><ol>
<li>循环队列进行新增数据元素操作时，首先判断队列是否为满。<br>如果不满，则可以将新元素赋值给队尾，然后让 rear 指针向后移动一个位置。<br>如果已经排到队列最后的位置，则 rea r指针重新指向头部。</li>
<li>循环队列进行删除操作时，即出队列操作，需要判断队列是否为空，然后将队头元素赋值给返回值，front 指针向后移一个位置。<br>如果已经排到队列最后的位置，就把 front 指针重新指向到头部。<br>这个过程就好像钟表的指针转到了表盘的尾部 12 点的位置后，又重新回到了表盘头部 1 点钟的位置。<br>这样就能在不开辟大量存储空间的前提下，不采用 O(n) 的操作，也能通过移动数据来完成频繁的新增和删除数据。</li>
<li>此时，又会产生新的问题，即当队列为空时，有 front 指针和 rear 指针相等。<br>而现在的队列是满的，同样有 front 指针和 rear 指针相等。<br>那么怎样判断队列到底是空还是满呢？常用的方法是，设置一个标志变量 flag 来区别队列是空还是满。<h4 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h4></li>
<li>链式队列就是一个单链表，同时增加了 front 指针和 rear 指针。<br>链式队列和单链表一样，通常会增加一个头结点，并另 front 指针指向头结点。<br>头结点不存储数据，只是用来辅助标识。</li>
<li>特别值得一提的是，如果这个链表除去头结点外只剩一个元素，那么删除仅剩的一个元素后，rear 指针就变成野指针了。<br>这时候，需要让 rear 指针指向头结点。也许你前面会对头结点存在的意义产生怀疑，似乎没有它也不影响增删的操作。</li>
<li>那么为何队列还特被强调要有头结点呢？<br>这主要是为了防止删除最后一个有效数据结点后， front 指针和 rear 指针变成野指针，导致队列没有意义了。<br>有了头结点后，哪怕队列为空，头结点依然存在，能让 front 指针和 rear 指针依然有意义。</li>
</ol>
<ul>
<li>空间性能方面，循环队列必须有一个固定的长度，因此存在存储元素数量和空间的浪费问题，而链式队列不存在这种问题，所以在空间上，链式队列更为灵活一些。</li>
<li>通常情况下，在可以确定队列长度最大值时，建议使用循环队列。无法确定队列长度时，应考虑使用链式队列。队列具有先进先出的特点，很像现实中人们排队买票的场景。在面对数据处理顺序非常敏感的问题时，队列一定是个不错的技术选型。<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3></li>
<li>树是由结点和边组成的，不存在环的一种数据结构。</li>
<li>没有父结点，则可以称为根结点</li>
<li>没有子结点，则称为叶子结点</li>
<li>树中结点的最大层次数，就是这棵树的树深（称为深度，也称为高度）</li>
<li>树数据的查找操作和链表一样，都需要遍历每一个数据去判断，所以时间复杂度是 O(n)。</li>
<li>对于查找操作，如果是普通二叉树，则查找的时间复杂度和遍历一样，都是 O(n)。如果是二叉查找树，则可以在 O(logn) 的时间复杂度内完成查找动作。<h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4></li>
<li>在二叉树中，每个结点最多有两个分支，即每个结点最多有两个子结点，分别称作左子结点和右子结点。</li>
<li>满二叉树，定义为除了叶子结点外，所有结点都有 2 个子结点。</li>
<li>完全二叉树，定义为除了最后一层以外，其他层的结点个数都达到最大，并且最后一层的叶子结点都靠左排列。之所以称为完全二叉树，是从存储空间利用效率的视角来看的。对于一棵完全二叉树而言，仅仅浪费了下标为 0 的存储位置。而如果是一棵非完全二叉树，则会浪费大量的存储空间。</li>
<li>存储二叉树有两种办法，一种是基于指针的链式存储法，另一种是基于数组的顺序存储法。</li>
<li>根据基于数组的顺序存储法，我们可以发现如果结点 X 的下标为 i，那么 X 的左子结点总是存放在 2 <em> i 的位置，X 的右子结点总是存放在 2 </em> i + 1 的位置。<h5 id="二叉查找树（二叉搜索树）"><a href="#二叉查找树（二叉搜索树）" class="headerlink" title="二叉查找树（二叉搜索树）"></a>二叉查找树（二叉搜索树）</h5></li>
<li>在二叉查找树中的任意一个结点，其左子树中的每个结点的值，都要小于这个结点的值。</li>
<li>在二叉查找树中的任意一个结点，其右子树中每个结点的值，都要大于这个结点的值。</li>
<li>在二叉查找树中，会尽可能规避两个结点数值相等的情况。</li>
<li>对二叉查找树进行中序遍历，就可以输出一个从小到大的有序数据队列。</li>
<li>在利用二叉查找树执行查找操作时，我们可以进行以下判断：</li>
</ul>
<ol>
<li>首先判断根结点是否等于要查找的数据，如果是就返回。</li>
<li>如果根结点大于要查找的数据，就在左子树中递归执行查找动作，直到叶子结点。</li>
<li>如果根结点小于要查找的数据，就在右子树中递归执行查找动作，直到叶子结点。</li>
<li>这样的“二分查找”所消耗的时间复杂度就可以降低为 O(logn)。</li>
</ol>
<ul>
<li>二叉查找树插入数据的时间复杂度是 O(logn)。但这并不意味着它比普通二叉树要复杂。原因在于这里的时间复杂度更多是消耗在了遍历数据去找到查找位置上，真正执行插入动作的时间复杂度仍然是 O(1)。</li>
<li>二叉查找树的删除操作会比较复杂，这是因为删除完某个结点后的树，仍然要满足二叉查找树的性质。</li>
</ul>
<ol>
<li>情况一，如果要删除的结点是某个叶子结点，则直接删除，将其父结点指针指向 null 即可。</li>
<li>情况二，如果要删除的结点只有一个子结点，只需要将其父结点指向的子结点的指针换成其子结点的指针即可。</li>
<li>情况三，如果要删除的结点有两个子结点，则有两种可行的操作方式。①找到这个结点的左子树中最大的结点，替换要删除的结点。②找到这个结点的右子树中最小的结点，替换要删除的结点。<h5 id="Trie-树，或字典树"><a href="#Trie-树，或字典树" class="headerlink" title="Trie 树，或字典树"></a>Trie 树，或字典树</h5></li>
</ol>
<ul>
<li>根结点不包含字符</li>
<li>除根结点外每一个结点都只包含一个字符；</li>
<li>从根结点到某一叶子结点，路径上经过的字符连接起来，即为集合中的某个字符串。<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3></li>
<li>哈希表的设计采用了函数映射的思想，将记录的存储位置与记录的关键字关联起来。这样的设计方式，能够快速定位到想要查找的记录，而且不需要与表中存在的记录的关键字比较后再来进行查找。</li>
<li>如果有一种方法，可以实现“地址 = f (关键字)”的映射关系，那么就可以快速完成基于数据的数值的查找了。这就是哈希表的核心思想</li>
<li>Hash 函数设计的好坏会直接影响到对哈希表的操作效率。</li>
<li>哈希冲突，是需要在设计哈希函数时进行规避的</li>
<li>常用的设计哈希函数的方法：</li>
</ul>
<ol>
<li>直接定制法<br>哈希函数为关键字到地址的线性函数。如，H (key) = a*key + b。 这里，a 和 b 是设置好的常数。</li>
<li>数字分析法<br>假设关键字集合中的每个关键字 key 都是由 s 位数字组成（k1,k2,…,Ks），并从中提取分布均匀的若干位组成哈希地址。上面张一、张二、张三、张四的手机号信息存储，就是使用的这种方法。</li>
<li>平方取中法<br>如果关键字的每一位都有某些数字重复出现，并且频率很高，我们就可以先求关键字的平方值，通过平方扩大差异，然后取中间几位作为最终存储地址。</li>
<li>折叠法<br>如果关键字的位数很多，可以将关键字分割为几个等长的部分，取它们的叠加和的值（舍去进位）作为哈希地址。</li>
<li>除留余数法<br>预先设置一个数 p，然后对关键字进行取余运算。即地址为 key mod p。</li>
</ol>
<ul>
<li>解决哈希冲突</li>
</ul>
<ol>
<li>开放定址法<br>即当一个关键字和另一个关键字发生冲突时，使用某种探测技术在哈希表中形成一个探测序列，然后沿着这个探测序列依次查找下去。当碰到一个空的单元时，则插入其中。<br>常用的探测方法是线性探测法。<br>比如有一组关键字 {12，13，25，23}，采用的哈希函数为 key mod 11。<br>当插入 12，13，25 时可以直接插入，地址分别为 1、2、3。而当插入 23 时，哈希地址为 23 mod 11 = 1。然而，地址 1 已经被占用，因此沿着地址 1 依次往下探测，直到探测到地址 4，发现为空，则将 23 插入其中。</li>
<li>链地址法<br>将哈希地址相同的记录存储在一张线性链表中。</li>
</ol>
<ul>
<li>哈希表相对于其他数据结构有很多的优势。它可以提供非常快速的插入-删除-查找操作，无论多少数据，插入和删除值需要接近常量的时间。在查找方面，哈希表的速度比树还要快，基本可以瞬间查找到想要的元素。</li>
<li>哈希表也有一些不足。哈希表中的数据是没有顺序概念的，所以不能以一种固定的方式（比如从小到大）来遍历其中的元素。在数据处理顺序敏感的问题时，选择哈希表并不是个好的处理方法。同时，哈希表中的 key 是不允许重复的，在重复性非常高的数据中，哈希表也不是个好的选择。<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3></li>
<li>递归的核心思想是把规模大的问题转化为规模小的相似的子问题来解决。</li>
<li>当一个问题同时满足以下 2 个条件时，就可以使用递归的方法求解：</li>
</ul>
<ol>
<li>可以拆解为除了数据规模以外，求解思路完全相同的子问题；</li>
<li>存在终止条件。<h3 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h3></li>
</ol>
<ul>
<li>分治法的核心思想就是“分而治之”。</li>
<li>利用分而治之的思想，就可以把一个大规模、高难度的问题，分解为若干个小规模、低难度的小问题。随后，开发者将面对多个简单的问题，并很快地找到答案各个击破。在把这些简单问题解决好之后，我们通过把这些小问题的答案合并，就得到了原问题的答案。</li>
<li>二分查找，则是利用分治法去解决查找问题。通常二分查找需要一个前提，那就是输入的数列是有序的。</li>
<li>二分查找的时间复杂度是 O(logn)，这也是分治法普遍具备的特性。当你面对某个代码题，而且约束了时间复杂度是 O(logn) 或者是 O(nlogn) 时，可以想一下分治法是否可行。</li>
<li>二分查找的循环次数并不确定。一般是达到某个条件就跳出循环。因此，编码的时候，多数会采用 while 循环加 break 跳出的代码结构。</li>
<li>二分查找处理的原问题必须是有序的。因此，当你在一个有序数据环境中处理问题时，可以考虑分治法。相反，如果原问题中的数据并不是有序的，则使用分治法的可能性就会很低了。<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3></li>
<li>衡量一个排序算法的优劣，我们主要会从以下 3 个角度进行分析：</li>
</ul>
<ol>
<li>时间复杂度，具体包括，最好时间复杂度、最坏时间复杂度以及平均时间复杂度。</li>
<li>空间复杂度，如果空间复杂度为 1，也叫作原地排序。</li>
<li>稳定性，排序的稳定性是指相等的数据对象，在排序之后，顺序是否能保证不变。</li>
<li>排序最暴力的方法，时间复杂度是 O(n*n)。这恰如冒泡排序和插入排序。</li>
<li>当我们利用算法思维去解决问题时，就会想到尝试分治法。此时，利用归并排序就能让时间复杂度降低到 O(nlogn)。然而，归并排序需要额外开辟临时空间。一方面是为了保证稳定性，另一方面则是在归并时，由于在数组中插入元素导致了数据挪移的问题。</li>
<li>为了规避因此而带来的时间损耗，此时我们采用快速排序。通过交换操作，可以解决插入元素导致的数据挪移问题，而且降低了不必要的空间开销。但是由于其动态二分的交换数据，导致了由此得出的排序结果并不稳定。</li>
<li>如果对数据规模比较小的数据进行排序，可以选择时间复杂度为 O(n<em>n) 的排序算法。因为当数据规模小的时候，时间复杂度 O(nlogn) 和 O(n</em>n) 的区别很小，它们之间仅仅相差几十毫秒，因此对实际的性能影响并不大。</li>
<li>但对数据规模比较大的数据进行排序，就需要选择时间复杂度为 O(nlogn) 的排序算法了。归并排序的空间复杂度为 O(n)，也就意味着当排序 100M 的数据，就需要 200M 的空间，所以对空间资源消耗会很多。快速排序在平均时间复杂度为 O(nlogn)，但是如果分区点选择不好的话，最坏的时间复杂度也有可能逼近 O(n*n)。而且快速排序不具备稳定性，这也需要看你所面对的问题是否有稳定性的需求。<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4></li>
</ol>
<ul>
<li>冒泡排序最好时间复杂度是 O(n)，也就是当输入数组刚好是顺序的时候，只需要挨个比较一遍就行了，不需要做交换操作，所以时间复杂度为 O(n)。</li>
<li>冒泡排序最坏时间复杂度会比较惨，是 O(n<em>n)。也就是说当数组刚好是完全逆序的时候，每轮排序都需要挨个比较 n 次，并且重复 n 次，所以时间复杂度为 O(n</em>n)。</li>
<li>很显然，当输入数组杂乱无章时，它的平均时间复杂度也是 O(n*n)。</li>
<li>冒泡排序不需要额外的空间，所以空间复杂度是 O(1)。冒泡排序过程中，当元素相同时不做交换，所以冒泡排序是稳定的排序算法。<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4></li>
<li>选取未排序的元素，插入到已排序区间的合适位置，直到未排序区间为空。插入排序顾名思义，就是从左到右维护一个已经排好序的序列。直到所有的待排数据全都完成插入的动作。</li>
<li>插入排序最好时间复杂度是 O(n)，即当数组刚好是完全顺序时，每次只用比较一次就能找到正确的位置。这个过程重复 n 次，就可以清空未排序区间。</li>
<li>插入排序最坏时间复杂度则需要 O(n<em>n)。即当数组刚好是完全逆序时，每次都要比较 n 次才能找到正确位置。这个过程重复 n 次，就可以清空未排序区间，所以最坏时间复杂度为 O(n</em>n)。</li>
<li>插入排序的平均时间复杂度是 O(n<em>n)。这是因为往数组中插入一个元素的平均时间复杂度为 O(n)，而插入排序可以理解为重复 n 次的数组插入操作，所以平均时间复杂度为 O(n</em>n)。</li>
<li>插入排序不需要开辟额外的空间，所以空间复杂度是 O(1)。<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4></li>
<li>归并排序法的原理是分治法。</li>
<li>对于归并排序，它采用了二分的迭代方式，复杂度是 logn。</li>
<li>每次的迭代，需要对两个有序数组进行合并，这样的动作在 O(n) 的时间复杂度下就可以完成。因此，归并排序的复杂度就是二者的乘积 O(nlogn)。同时，它的执行频次与输入序列无关，因此，归并排序最好、最坏、平均时间复杂度都是 O(nlogn)。</li>
<li>空间复杂度方面，由于每次合并的操作都需要开辟基于数组的临时内存空间，所以空间复杂度为 O(n)。归并排序合并的时候，相同元素的前后顺序不变，所以归并是稳定的排序算法。<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4></li>
<li>快速排序法的原理也是分治法。</li>
<li>的每轮迭代，会选取数组中任意一个数据作为分区点，将小于它的元素放在它的左侧，大于它的放在它的右侧。再利用分治思想，继续分别对左右两侧进行同样的操作，直至每个区间缩小为 1，则完成排序。</li>
<li>在快排的最好时间的复杂度下，如果每次选取分区点时，都能选中中位数，把数组等分成两个，那么此时的时间复杂度和归并一样，都是 O(n*logn)。</li>
<li>而在最坏的时间复杂度下，也就是如果每次分区都选中了最小值或最大值，得到不均等的两组。那么就需要 n 次的分区操作，每次分区平均扫描 n / 2 个元素，此时时间复杂度就退化为 O(n*n) 了。</li>
<li>快速排序法在大部分情况下，统计上是很难选到极端情况的。因此它平均的时间复杂度是 O(n*logn)。</li>
<li>快速排序法的空间方面，使用了交换法，因此空间复杂度为 O(1)。</li>
<li>很显然，快速排序的分区过程涉及交换操作，所以快排是不稳定的排序算法。<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3></li>
<li>从数学的视角来看，动态规划是一种运筹学方法，是在多轮决策过程中的最优方法。</li>
<li>从分治法的视角来看，每个子问题必须相互独立。但在多轮决策中，这个假设显然不成立。这也是动态规划方法产生的原因之一。</li>
<li>动态规划有一个重要概念叫作状态。</li>
<li>一般而言，具有如下几个特征的问题，可以采用动态规划求解：</li>
</ul>
<ol>
<li>最优子结构。它的含义是，原问题的最优解所包括的子问题的解也是最优的。例如，某个策略使得 A 到 G 是最优的。假设它途径了 Fi，那么它从 A 到 Fi 也一定是最优的。</li>
<li>无后效性。某阶段的决策，无法影响先前的状态。可以理解为今天的动作改变不了历史。</li>
<li>有重叠子问题。也就是，子问题之间不独立。这个性质是动态规划区别于分治法的条件。如果原问题不满足这个特征，也是可以用动态规划求解的，无非就是杀鸡用了宰牛刀。<h2 id="new-apply-call-bind"><a href="#new-apply-call-bind" class="headerlink" title="new/apply/call/bind"></a>new/apply/call/bind</h2><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3></li>
</ol>
<ul>
<li>new 关键词的主要作用就是执行一个构造函数、返回一个实例对象，在 new 的过程中，根据构造函数的情况，来确定是否可以接受参数的传递。</li>
<li>new 在这个生成实例的过程中,大致分为以下几个步骤:</li>
</ul>
<ol>
<li>创建一个新对象；</li>
<li>将构造函数的作用域赋给新对象（this 指向新对象）；</li>
<li>执行构造函数中的代码（为这个新对象添加属性）；</li>
<li>返回新对象。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//如果不用 new 这个关键词，会发生什么样的变化呢？</span><br><span class="line">function Person()&#123;</span><br><span class="line"></span><br><span class="line">  this.name = &apos;Jack&apos;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p = Person();</span><br><span class="line"></span><br><span class="line">console.log(p) // undefined</span><br><span class="line"></span><br><span class="line">console.log(name) // Jack</span><br><span class="line"></span><br><span class="line">console.log(p.name) // &apos;name&apos; of undefined</span><br><span class="line"></span><br><span class="line">//当构造函数中有 return 一个对象的操作，结果又会是什么样子呢？</span><br><span class="line">function Person()&#123;</span><br><span class="line"></span><br><span class="line">   this.name = &apos;Jack&apos;; </span><br><span class="line"></span><br><span class="line">   return &#123;age: 18&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p = new Person(); </span><br><span class="line"></span><br><span class="line">console.log(p)  // &#123;age: 18&#125;</span><br><span class="line"></span><br><span class="line">console.log(p.name) // undefined</span><br><span class="line"></span><br><span class="line">console.log(p.age) // 18</span><br></pre></td></tr></table></figure>
<ul>
<li><p>构造函数必须是返回一个对象，如果返回的不是对象，那么还是会按照 new 的实现步骤，返回新生成的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line"></span><br><span class="line">   this.name = &apos;Jack&apos;; </span><br><span class="line"></span><br><span class="line">   return &apos;tom&apos;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p = new Person(); </span><br><span class="line"></span><br><span class="line">console.log(p)  // &#123;name: &apos;Jack&apos;&#125;</span><br><span class="line"></span><br><span class="line">console.log(p.name) // Jack</span><br></pre></td></tr></table></figure>
</li>
<li><p>new 关键词执行之后总是会返回一个对象，要么是实例对象，要么是 return 语句指定的对象。</p>
<h3 id="call-apply-bind"><a href="#call-apply-bind" class="headerlink" title="call/apply/bind"></a>call/apply/bind</h3></li>
<li><p>call、apply 和 bind 是挂在 Function 对象上的三个方法，调用这三个方法的必须是一个函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func.call(thisArg, param1, param2, ...)</span><br><span class="line"></span><br><span class="line">func.apply(thisArg, [param1,param2,...])</span><br><span class="line"></span><br><span class="line">func.bind(thisArg, param1, param2, ...)</span><br></pre></td></tr></table></figure>
</li>
<li><p>bind 虽然改变了 func 的 this 指向，但不是马上执行，而这两个（call、apply）是在改变了函数的 this 指向之后立马执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">let a = &#123;</span><br><span class="line"></span><br><span class="line">  name: &apos;jack&apos;,</span><br><span class="line"></span><br><span class="line">  getName: function(msg) &#123;</span><br><span class="line"></span><br><span class="line">    return msg + this.name;</span><br><span class="line"></span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let b = &#123;</span><br><span class="line"></span><br><span class="line">  name: &apos;lily&apos;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(a.getName(&apos;hello~&apos;));  // hello~jack</span><br><span class="line"></span><br><span class="line">console.log(a.getName.call(b, &apos;hi~&apos;));  // hi~lily</span><br><span class="line"></span><br><span class="line">console.log(a.getName.apply(b, [&apos;hi~&apos;]))  // hi~lily</span><br><span class="line"></span><br><span class="line">let name = a.getName.bind(b, &apos;hello~&apos;);</span><br><span class="line"></span><br><span class="line">console.log(name());  // hello~lily</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="手写实现"><a href="#手写实现" class="headerlink" title="手写实现"></a>手写实现</h3><h4 id="new-1"><a href="#new-1" class="headerlink" title="new"></a>new</h4><ul>
<li>new 被调用后大致做了哪几件事情。</li>
</ul>
<ol>
<li>让实例可以访问到私有属性；</li>
<li>让实例可以访问构造函数原型（constructor.prototype）所在原型链上的属性；</li>
<li>构造函数返回的最后结果是引用数据类型。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function _new(ctor, ...args) &#123;</span><br><span class="line"></span><br><span class="line">    if(typeof ctor !== &apos;function&apos;) &#123;</span><br><span class="line"></span><br><span class="line">      throw &apos;ctor must be a function&apos;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let obj = new Object();</span><br><span class="line"></span><br><span class="line">    obj.__proto__ = Object.create(ctor.prototype);</span><br><span class="line"></span><br><span class="line">    //关键  this指向</span><br><span class="line">    let res = ctor.apply(obj,  [...args]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    let isObject = typeof res === &apos;object&apos; &amp;&amp; res !== null;</span><br><span class="line"></span><br><span class="line">    let isFunction = typeof res === &apos;function&apos;;</span><br><span class="line"></span><br><span class="line">    return isObject || isFunction ? res : obj;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="call-apply"><a href="#call-apply" class="headerlink" title="call/apply"></a>call/apply</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.call = function (context, ...args) &#123;</span><br><span class="line"></span><br><span class="line">  var context = context || window;</span><br><span class="line">  //当前this指向Function.prototype上面的方法</span><br><span class="line">  context.fn = this;</span><br><span class="line"></span><br><span class="line">  var result = eval(&apos;context.fn(...args)&apos;);</span><br><span class="line"></span><br><span class="line">  delete context.fn</span><br><span class="line"></span><br><span class="line">  return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Function.prototype.apply = function (context, args) &#123;</span><br><span class="line"></span><br><span class="line">  let context = context || window;</span><br><span class="line">  //当前this指向Function.prototype上面的方法</span><br><span class="line">  context.fn = this;</span><br><span class="line"></span><br><span class="line">  let result = eval(&apos;context.fn(...args)&apos;);</span><br><span class="line"></span><br><span class="line">  delete context.fn</span><br><span class="line"></span><br><span class="line">  return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind = function (context, ...args) &#123;</span><br><span class="line"></span><br><span class="line">    if (typeof this !== &quot;function&quot;) &#123;</span><br><span class="line"></span><br><span class="line">      throw new Error(&quot;this must be a function&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var self = this;</span><br><span class="line"></span><br><span class="line">    var fbound = function () &#123;</span><br><span class="line"></span><br><span class="line">        self.apply(this instanceof fbound ? this : context, args.concat(Array.prototype.slice.call(arguments)));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(this.prototype) &#123;</span><br><span class="line"></span><br><span class="line">      fbound.prototype = Object.create(this.prototype);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return fbound;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//new (Math.max.bind(this))();</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>方法特征</th>
<th>call</th>
<th>apply</th>
<th>bind</th>
</tr>
</thead>
<tbody>
<tr>
<td>方法参数</td>
<td>多个</td>
<td>单个数组</td>
<td>多个</td>
</tr>
<tr>
<td>方法功能</td>
<td>函数调用改变this</td>
<td>函数调用改变this</td>
<td>函数调用改变this</td>
</tr>
<tr>
<td>返回结果</td>
<td>直接执行</td>
<td>直接执行</td>
<td>返回待执行函数</td>
</tr>
<tr>
<td>底层实现</td>
<td>通过eval</td>
<td>通过eval</td>
<td>间接调用apply</td>
</tr>
</tbody>
</table>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><ul>
<li>红宝书闭包的定义：闭包是指有权访问另外一个函数作用域中的变量的函数。MDN：一个函数和对其周围状态的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。</li>
<li>作用域链，即当前函数一般都会存在上层函数的作用域的引用，那么他们就形成了一条作用域链。 </li>
<li><p>闭包产生的本质就是：当前环境中存在指向父级作用域的引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">function fun1() &#123;</span><br><span class="line"></span><br><span class="line">  var a = 2</span><br><span class="line"></span><br><span class="line">  function fun2() &#123;</span><br><span class="line"></span><br><span class="line">    console.log(a);  //2</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return fun2;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var result = fun1();</span><br><span class="line"></span><br><span class="line">result();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">是不是只有返回函数才算是产生了闭包呢？其实也不是，回到闭包的本质，我们只需要让父级作用域的引用存在即可，因此还可以这么改代码，如下所示。</span><br><span class="line"></span><br><span class="line">var fun3;</span><br><span class="line"></span><br><span class="line">function fun1() &#123;</span><br><span class="line"></span><br><span class="line">  var a = 2</span><br><span class="line"></span><br><span class="line">  fun3 = function() &#123;</span><br><span class="line"></span><br><span class="line">    console.log(a);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun1();</span><br><span class="line"></span><br><span class="line">fun3();</span><br></pre></td></tr></table></figure>
</li>
<li><p>闭包的表现形式</p>
</li>
</ul>
<ol>
<li>返回一个函数</li>
<li><p>在定时器、事件监听、Ajax 请求、Web Workers 或者任何异步中，只要使用了回调函数，实际上就是在使用闭包。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 定时器</span><br><span class="line"></span><br><span class="line">setTimeout(function handler()&#123;</span><br><span class="line"></span><br><span class="line">  console.log(&apos;1&apos;);</span><br><span class="line"></span><br><span class="line">&#125;，1000);</span><br><span class="line"></span><br><span class="line">// 事件监听</span><br><span class="line"></span><br><span class="line">$(&apos;#app&apos;).click(function()&#123;</span><br><span class="line"></span><br><span class="line">  console.log(&apos;Event Listener&apos;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>作为函数参数传递的形式</p>
</li>
<li>IIFE（立即执行函数），创建了闭包，保存了全局作用域（window）和当前函数的作用域，因此可以输出全局的变量<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a = 2;</span><br><span class="line"></span><br><span class="line">(function IIFE()&#123;</span><br><span class="line"></span><br><span class="line">  console.log(a);  // 输出2</span><br><span class="line"></span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">IIFE 这个函数会稍微有些特殊，算是一种自执行匿名函数，这个匿名函数拥有独立的作用域。这不仅可以避免了外界访问此 IIFE 中的变量，而且又不会污染全局作用域，</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>如何解决循环输出问题？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">for(var i = 1; i &lt;= 5; i ++)&#123;</span><br><span class="line"></span><br><span class="line">  setTimeout(function() &#123;</span><br><span class="line"></span><br><span class="line">    console.log(i)</span><br><span class="line"></span><br><span class="line">  &#125;, 0)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">1.setTimeout 为宏任务，由于 JS 中单线程 eventLoop 机制，在主线程同步任务执行完后才去执行宏任务，因此循环结束后 setTimeout 中的回调才依次执行。</span><br><span class="line">2.因为 setTimeout 函数也是一种闭包，往上找它的父级作用域链就是 window，变量 i 为 window 上的全局变量，开始执行 setTimeout 之前变量 i 已经就是 6 了，因此最后输出的连续就都是 6。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li><p>利用 IIFE</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">for(var i = 1;i &lt;= 5;i++)&#123;</span><br><span class="line"></span><br><span class="line">  (function(j)&#123;</span><br><span class="line"></span><br><span class="line">    setTimeout(function timer()&#123;</span><br><span class="line"></span><br><span class="line">      console.log(j)</span><br><span class="line"></span><br><span class="line">    &#125;, 0)</span><br><span class="line"></span><br><span class="line">  &#125;)(i)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 ES6 中的 let</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for(let i = 1; i &lt;= 5; i++)&#123;</span><br><span class="line"></span><br><span class="line">  setTimeout(function() &#123;</span><br><span class="line"></span><br><span class="line">    console.log(i);</span><br><span class="line"></span><br><span class="line">  &#125;,0)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">ES6 中新增的 let 定义变量的方式，使得 ES6 之后 JS 发生革命性的变化，让 JS 有了块级作用域，代码的作用域以块级为单位进行执行。</span><br></pre></td></tr></table></figure>
</li>
<li><p>定时器传入第三个参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for(var i=1;i&lt;=5;i++)&#123;</span><br><span class="line"></span><br><span class="line">  setTimeout(function(j) &#123;</span><br><span class="line"></span><br><span class="line">    console.log(j)</span><br><span class="line"></span><br><span class="line">  &#125;, 0, i)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>由于闭包会使一些变量一直保存在内存中不会自动释放，所以如果大量使用的话就会消耗大量内存，从而影响网页性能。<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><h3 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse"></a>JSON.parse</h3></li>
<li><code>JSON.parse(text[, reviver])</code>第一个参数是需要解析处理的 JSON 字符串，第二个参数是可选参数提供可选的 reviver 函数，用在返回之前对所得到的对象执行变换操作。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const json = &apos;&#123;&quot;result&quot;:true, &quot;count&quot;:2&#125;&apos;;</span><br><span class="line"></span><br><span class="line">const obj = JSON.parse(json);</span><br><span class="line"></span><br><span class="line">console.log(obj.count);</span><br><span class="line"></span><br><span class="line">// 2</span><br><span class="line"></span><br><span class="line">console.log(obj.result);</span><br><span class="line"></span><br><span class="line">// true</span><br><span class="line"></span><br><span class="line">/* 带第二个参数的情况 */</span><br><span class="line"></span><br><span class="line">JSON.parse(&apos;&#123;&quot;p&quot;: 5&#125;&apos;, function (k, v) &#123;</span><br><span class="line"></span><br><span class="line">    if(k === &apos;&apos;) return v;     // 如果k不是空，</span><br><span class="line"></span><br><span class="line">    return v * 2;              // 就将属性值变为原来的2倍返回</span><br><span class="line"></span><br><span class="line">&#125;);                            // &#123; p: 10 &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify"></a>JSON.stringify</h3><ul>
<li><p>JSON.stringify 方法是将一个 JavaScript 对象或值转换为 JSON 字符串，默认该方法其实有三个参数：第一个参数是必选，后面两个是可选参数非必选。第一个参数传入的是要转换的对象；第二个是一个 replacer 函数，比如指定的 replacer 是数组，则可选择性地仅处理包含数组指定的属性；第三个参数用来控制结果字符串里面的间距，后面两个参数整体用得比较少。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">JSON.stringify(&#123; x: 1, y: 2 &#125;);</span><br><span class="line"></span><br><span class="line">// &quot;&#123;&quot;x&quot;:1,&quot;y&quot;:2&#125;&quot;</span><br><span class="line"></span><br><span class="line">JSON.stringify(&#123; x: [10, undefined, function()&#123;&#125;, Symbol(&apos;&apos;)] &#125;)</span><br><span class="line"></span><br><span class="line">// &quot;&#123;&quot;x&quot;:[10,null,null,null]&#125;&quot;</span><br><span class="line"></span><br><span class="line">/* 第二个参数的例子 */</span><br><span class="line"></span><br><span class="line">function replacer(key, value) &#123;</span><br><span class="line"></span><br><span class="line">  if (typeof value === &quot;string&quot;) &#123;</span><br><span class="line"></span><br><span class="line">    return undefined;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return value;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var foo = &#123;foundation: &quot;Mozilla&quot;, model: &quot;box&quot;, week: 4, transport: &quot;car&quot;, month: 7&#125;;</span><br><span class="line"></span><br><span class="line">var jsonString = JSON.stringify(foo, replacer);</span><br><span class="line"></span><br><span class="line">console.log(jsonString);</span><br><span class="line"></span><br><span class="line">// &quot;&#123;&quot;week&quot;:4,&quot;month&quot;:7&#125;&quot;</span><br><span class="line"></span><br><span class="line">/* 第三个参数的例子 */</span><br><span class="line"></span><br><span class="line">JSON.stringify(&#123; a: 2 &#125;, null, &quot; &quot;);</span><br><span class="line"></span><br><span class="line">/* &quot;&#123;</span><br><span class="line"></span><br><span class="line"> &quot;a&quot;: 2</span><br><span class="line"></span><br><span class="line">&#125;&quot;*/</span><br><span class="line"></span><br><span class="line">JSON.stringify(&#123; a: 2 &#125;, null, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">// &quot;&#123;&quot;a&quot;:2&#125;&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">从上面的代码中可以看到，增加第二个参数 replacer 带来的变化：通过替换方法把对象中的属性为字符串的过滤掉，在 stringify 之后返回的仅为数字的属性变成字符串之后的结果；</span><br><span class="line">当第三个参数传入的是多个空格的时候，则会增加结果字符串里面的间距数量，从最后一段代码中可以看到结果。</span><br></pre></td></tr></table></figure>
</li>
<li><p>手动实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line">function jsonStringify(data) &#123;</span><br><span class="line"></span><br><span class="line">  let type = typeof data;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  if(type !== &apos;object&apos;) &#123;</span><br><span class="line"></span><br><span class="line">    let result = data;</span><br><span class="line"></span><br><span class="line">    //data 可能是基础数据类型的情况在这里处理</span><br><span class="line"></span><br><span class="line">    if (Number.isNaN(data) || data === Infinity) &#123;</span><br><span class="line"></span><br><span class="line">       //NaN 和 Infinity 序列化返回 &quot;null&quot;</span><br><span class="line"></span><br><span class="line">       result = &quot;null&quot;;</span><br><span class="line"></span><br><span class="line">    &#125; else if (type === &apos;function&apos; || type === &apos;undefined&apos; || type === &apos;symbol&apos;) &#123;</span><br><span class="line"></span><br><span class="line">      // 由于 function 序列化返回 undefined，因此和 undefined、symbol 一起处理</span><br><span class="line"></span><br><span class="line">       return undefined;</span><br><span class="line"></span><br><span class="line">    &#125; else if (type === &apos;string&apos;) &#123;</span><br><span class="line"></span><br><span class="line">       result = &apos;&quot;&apos; + data + &apos;&quot;&apos;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return String(result);</span><br><span class="line"></span><br><span class="line">  &#125; else if (type === &apos;object&apos;) &#123;</span><br><span class="line"></span><br><span class="line">     if (data === null) &#123;</span><br><span class="line"></span><br><span class="line">        return &quot;null&quot;  // 第01讲有讲过 typeof null 为&apos;object&apos;的特殊情况</span><br><span class="line"></span><br><span class="line">     &#125; else if (data.toJSON &amp;&amp; typeof data.toJSON === &apos;function&apos;) &#123;</span><br><span class="line"></span><br><span class="line">        return jsonStringify(data.toJSON());</span><br><span class="line"></span><br><span class="line">     &#125; else if (data instanceof Array) &#123;</span><br><span class="line"></span><br><span class="line">        let result = [];</span><br><span class="line"></span><br><span class="line">        //如果是数组，那么数组里面的每一项类型又有可能是多样的</span><br><span class="line"></span><br><span class="line">        data.forEach((item, index) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">        if (typeof item === &apos;undefined&apos; || typeof item === &apos;function&apos; || typeof item === &apos;symbol&apos;) &#123;</span><br><span class="line"></span><br><span class="line">               result[index] = &quot;null&quot;;</span><br><span class="line"></span><br><span class="line">           &#125; else &#123;</span><br><span class="line"></span><br><span class="line">               result[index] = jsonStringify(item);</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">         &#125;);</span><br><span class="line"></span><br><span class="line">         result = &quot;[&quot; + result + &quot;]&quot;;</span><br><span class="line"></span><br><span class="line">         return result.replace(/&apos;/g, &apos;&quot;&apos;);</span><br><span class="line"></span><br><span class="line">      &#125; else &#123;</span><br><span class="line"></span><br><span class="line">         // 处理普通对象</span><br><span class="line"></span><br><span class="line">         let result = [];</span><br><span class="line"></span><br><span class="line">         Object.keys(data).forEach((item, index) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">            if (typeof item !== &apos;symbol&apos;) &#123;</span><br><span class="line"></span><br><span class="line">              //key 如果是 symbol 对象，忽略</span><br><span class="line"></span><br><span class="line">              if (data[item] !== undefined &amp;&amp; typeof data[item] !== &apos;function&apos; &amp;&amp; typeof data[item] !== &apos;symbol&apos;) &#123;</span><br><span class="line"></span><br><span class="line">                //键值如果是 undefined、function、symbol 为属性值，忽略</span><br><span class="line"></span><br><span class="line">                result.push(&apos;&quot;&apos; + item + &apos;&quot;&apos; + &quot;:&quot; + jsonStringify(data[item]));</span><br><span class="line"></span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">         &#125;);</span><br><span class="line"></span><br><span class="line">         return (&quot;&#123;&quot; + result + &quot;&#125;&quot;).replace(/&apos;/g, &apos;&quot;&apos;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">手工实现一个 JSON.stringify 方法的基本代码如上面所示，有几个问题还是需要注意一下：</span><br><span class="line">1.由于 function 返回 &apos;null&apos;， 并且 typeof function 能直接返回精确的判断，故在整体逻辑处理基础数据类型的时候，会随着 undefined，symbol 直接处理了；</span><br><span class="line">2.由于 typeof null 的时候返回&apos;object&apos;，故 null 的判断逻辑整体在处理引用数据类型的逻辑里面；</span><br><span class="line">3.关于引用数据类型中的数组，由于数组的每一项的数据类型又有很多的可能性，故在处理数组过程中又将 undefined，symbol，function 作为数组其中一项的情况做了特殊处理；</span><br><span class="line">4.同样在最后处理普通对象的时候，key （键值）也存在和数组一样的问题，故又需要再针对上面这几种情况（undefined，symbol，function）做特殊处理；</span><br><span class="line">5.最后在处理普通对象过程中，对于循环引用的问题暂未做检测，如果是有循环引用的情况，需要抛出 Error；</span><br><span class="line">6.根据官方给出的 JSON.stringify 的第二个以及第三个参数的实现，本段模拟实现的代码并未实现。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">上面实现的这个 jsonStringify 方法和真正的 JSON.stringify 想要得到的效果是否一样呢？请看下面的测试结果。</span><br><span class="line">let nl = null;</span><br><span class="line"></span><br><span class="line">console.log(jsonStringify(nl) === JSON.stringify(nl));</span><br><span class="line"></span><br><span class="line">// true</span><br><span class="line"></span><br><span class="line">let und = undefined;</span><br><span class="line"></span><br><span class="line">console.log(jsonStringify(undefined) === JSON.stringify(undefined));</span><br><span class="line"></span><br><span class="line">// true</span><br><span class="line"></span><br><span class="line">let boo = false;</span><br><span class="line"></span><br><span class="line">console.log(jsonStringify(boo) === JSON.stringify(boo));</span><br><span class="line"></span><br><span class="line">// true</span><br><span class="line"></span><br><span class="line">let nan = NaN;</span><br><span class="line"></span><br><span class="line">console.log(jsonStringify(nan) === JSON.stringify(nan));</span><br><span class="line"></span><br><span class="line">// true</span><br><span class="line"></span><br><span class="line">let inf = Infinity;</span><br><span class="line"></span><br><span class="line">console.log(jsonStringify(Infinity) === JSON.stringify(Infinity));</span><br><span class="line"></span><br><span class="line">// true</span><br><span class="line"></span><br><span class="line">let str = &quot;jack&quot;;</span><br><span class="line"></span><br><span class="line">console.log(jsonStringify(str) === JSON.stringify(str));</span><br><span class="line"></span><br><span class="line">// true</span><br><span class="line"></span><br><span class="line">let reg = new RegExp(&quot;\w&quot;);</span><br><span class="line"></span><br><span class="line">console.log(jsonStringify(reg) === JSON.stringify(reg));</span><br><span class="line"></span><br><span class="line">// true</span><br><span class="line"></span><br><span class="line">let date = new Date();</span><br><span class="line"></span><br><span class="line">console.log(jsonStringify(date) === JSON.stringify(date));</span><br><span class="line"></span><br><span class="line">// true</span><br><span class="line"></span><br><span class="line">let sym = Symbol(1);</span><br><span class="line"></span><br><span class="line">console.log(jsonStringify(sym) === JSON.stringify(sym));</span><br><span class="line"></span><br><span class="line">// true</span><br><span class="line"></span><br><span class="line">let array = [1,2,3];</span><br><span class="line"></span><br><span class="line">console.log(jsonStringify(array) === JSON.stringify(array));</span><br><span class="line"></span><br><span class="line">// true</span><br><span class="line"></span><br><span class="line">let obj = &#123;</span><br><span class="line"></span><br><span class="line">    name: &apos;jack&apos;,</span><br><span class="line"></span><br><span class="line">    age: 18,</span><br><span class="line"></span><br><span class="line">    attr: [&apos;coding&apos;, 123],</span><br><span class="line"></span><br><span class="line">    date: new Date(),</span><br><span class="line"></span><br><span class="line">    uni: Symbol(2),</span><br><span class="line"></span><br><span class="line">    sayHi: function() &#123;</span><br><span class="line"></span><br><span class="line">        console.log(&quot;hi&quot;)</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    info: &#123;</span><br><span class="line"></span><br><span class="line">        sister: &apos;lily&apos;,</span><br><span class="line"></span><br><span class="line">        age: 16,</span><br><span class="line"></span><br><span class="line">        intro: &#123;</span><br><span class="line"></span><br><span class="line">            money: undefined,</span><br><span class="line"></span><br><span class="line">            job: null</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(jsonStringify(obj) === JSON.stringify(obj));</span><br><span class="line"></span><br><span class="line">// true</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Eventloop"><a href="#Eventloop" class="headerlink" title="Eventloop"></a>Eventloop</h2><h3 id="浏览器的-Eventloop"><a href="#浏览器的-Eventloop" class="headerlink" title="浏览器的 Eventloop"></a>浏览器的 Eventloop</h3><ul>
<li>JavaScript 引擎</li>
</ul>
<ol>
<li>调用堆栈（call stack）负责跟踪所有要执行的代码。每当一个函数执行完成时，就会从堆栈中弹出（pop）该执行完成函数；如果有代码需要进去执行的话，就进行 push 操作，</li>
<li>事件队列（event queue）负责将新的 function 发送到队列中进行处理。它遵循 queue 的数据结构特性，先进先出，在该顺序下发送所有操作以进行执行。</li>
<li>每当调用事件队列（event queue）中的异步函数时，都会将其发送到浏览器 API。根据从调用堆栈收到的命令，API 开始自己的单线程操作。其中 setTimeout 方法就是一个比较典型的例子，在堆栈中处理 setTimeout 操作时，会将其发送到相应的 API，该 API 一直等到指定的时间将此操作送回进行处理。它将操作发送到哪里去呢？答案是事件队列（event queue）。这样，就有了一个循环系统，用于在 JavaScript 中运行异步操作。</li>
<li>JavaScript 语言本身是单线程的，而浏览器 API 充当单独的线程。事件循环（Eventloop）促进了这一过程，它会不断检查调用堆栈是否为空。如果为空，则从事件队列中添加新的函数进入调用栈（call stack）；如果不为空，则处理当前函数的调用。我们把整个过程串起来就是这样的一个循环执行流程</li>
</ol>
<ul>
<li>macrotasks(宏任务):<br><code>script(整体代码),setTimeout,setInterval,setImmediate,I/O,UI rendering,event listner</code></li>
<li>microtasks(微任务):<br><code>process.nextTick, Promises, Object.observe, MutationObserver</code></li>
<li>Eventloop 处理宏任务和微任务的逻辑</li>
</ul>
<ol>
<li>JavaScript 引擎首先从宏任务队列（macrotask queue）中取出第一个任务；</li>
<li>执行完毕后，再将微任务（microtask queue）中的所有任务取出，按照顺序分别全部执行（这里包括不仅指开始执行时队列里的微任务），如果在这一步过程中产生新的微任务，也需要执行；</li>
<li>然后再从宏任务队列中取下一个，执行完毕后，再次将 microtask queue 中的全部取出，循环往复，直到两个 queue 中的任务都取完。</li>
<li>总结起来就是：一次 Eventloop 循环会处理一个宏任务和所有这次循环中产生的微任务。</li>
</ol>
<ul>
<li>各种浏览器事件同时触发时，肯定有一个先来后到的排队问题。决定这些事件如何排队触发的机制，就是事件循环。这个排队行为以 JavaScript 开发者的角度来看，主要是分成两个队列：</li>
</ul>
<ol>
<li>一个是 JavaScript 外部的队列。外部的队列主要是浏览器协调的各类事件的队列，标准文件中称之为 Task Queue。下文中为了方便理解统一称为外部队列。</li>
<li>另一个是 JavaScript 内部的队列。这部分主要是 JavaScript 内部执行的任务队列，标准中称之为 Microtask Queue。下文中为了方便理解统一称为内部队列。</li>
</ol>
<ul>
<li>值得注意的是，虽然为了好理解我们管这个叫队列 (Queue)，但是本质上是有序集合 (Set)，因为传统的队列都是先进先出（FIFO）的，而这里的队列则不然，排到最前面但是没有满足条件也是不会执行的（比如外部队列里只有一个 setTimeout 的定时任务，但是时间还没有到，没有满足条件也不会把他出列来执行）。<h4 id="外部队列"><a href="#外部队列" class="headerlink" title="外部队列"></a>外部队列</h4></li>
<li>外部队列（Task Queue  关于 Task，常有人称它为 Marcotask (宏任务)，但 HTML 标准中没有这种说法。），顾名思义就是 JavaScript 外部的事件的队列，这里我们可以先列举一下浏览器中这些外部事件源（Task Source），他们主要有：</li>
</ul>
<ol>
<li>DOM 操作 (页面渲染)</li>
<li>用户交互 (鼠标、键盘)</li>
<li>网络请求 (Ajax 等)</li>
<li>History API 操作</li>
<li>定时器 (setTimeout 等)</li>
</ol>
<ul>
<li>HTML 标准中明确指出一个事件循环由一个或多个外部队列，而每一个外部事件源都有一个对应的外部队列。不同事件源的队列可以有不同的优先级（例如在网络事件和用户交互之间，浏览器可以优先处理鼠标行为，从而让用户感觉更加流程）。</li>
<li>scripts 执行也是一个事件，我们只要归类一下就会发现 JavaScript 的执行也是一个浏览器发起的外部事件。<h4 id="内部队列"><a href="#内部队列" class="headerlink" title="内部队列"></a>内部队列</h4></li>
<li>内部队列（Microtask Queue），即 JavaScript 语言内部的事件队列，在 HTML 标准中，并没有明确规定这个队列的事件源，通常认为有以下几种：</li>
</ul>
<ol>
<li>Promise 的成功 (.then) 与失败 (.catch)</li>
<li>MutationObserver</li>
<li>Object.observe (已废弃)<h3 id="Node-js-的-Eventloop"><a href="#Node-js-的-Eventloop" class="headerlink" title="Node.js 的 Eventloop"></a>Node.js 的 Eventloop</h3></li>
</ol>
<ul>
<li>当 Node.js 开始启动时，会初始化一个 Eventloop，处理输入的代码脚本，这些脚本会进行 API 异步调用，process.nextTick() 方法会开始处理事件循环。</li>
<li>整个流程分为六个阶段，当这六个阶段执行完一次之后，才可以算得上执行了一次 Eventloop 的循环过程</li>
</ul>
<ol>
<li>Timers 阶段：这个阶段执行 setTimeout 和 setInterval。</li>
<li>I/O callbacks 阶段：这个阶段主要执行系统级别的回调函数，比如 TCP 连接失败的回调。</li>
<li>idle，prepare 阶段：只是 Node.js 内部闲置、准备，可以忽略。</li>
<li>poll 阶段：poll 阶段是一个重要且复杂的阶段，几乎所有 I/O 相关的回调，都在这个阶段执行（除了setTimeout、setInterval、setImmediate 以及一些因为 exception 意外关闭产生的回调）</li>
<li>check 阶段：执行 setImmediate() 设定的 callbacks。</li>
<li>close callbacks 阶段：执行关闭请求的回调函数，比如 socket.on(‘close’, …)。</li>
</ol>
<ul>
<li>除了把 Eventloop 的宏任务细分到不同阶段外。node 还引入了一个新的任务队列 Process.nextTick()。可以认为，Process.nextTick() 会在上述各个阶段结束时，在进入下一个阶段之前立即执行（优先级甚至超过 microtask 队列）。</li>
<li>Node.js 和浏览器端宏任务队列的另一个很重要的不同点是，浏览器端任务队列每轮事件循环仅出队一个回调函数接着去执行微任务队列；而 Node.js 端只要轮到执行某个宏任务队列，则会执行完队列中所有的当前任务，但是当前轮次新添加到队尾的任务则会等到下一轮次才会执行。</li>
<li>HTML (浏览器端) 与 libuv (服务端) 面对的场景有很大的差异。首先能直观感受到的区别是：</li>
</ul>
<ol>
<li>事件循环的过程没有 HTML 渲染。只剩下了外部队列和内部队列这两个部分。</li>
<li>外部队列的事件源不同。Node.js 端没有了鼠标等外设但是新增了文件等 IO。</li>
<li>内部队列的事件仅剩下 Promise 的 then 和 catch。</li>
</ol>
<ul>
<li>至于内在的差异，有一个很重要的地方是 Node.js （libuv）在最初设计的时候是允许执行多次外部的事件再切换到内部队列的，而浏览器端一次事件循环只允许执行一次外部事件。</li>
<li>setImmediate 的引入是为了解决 setTimeout 的精度问题，由于 setTimeout 指定的延迟时间是毫秒（ms）但实际一次事件循环的时间可能是纳秒级的，所以在一次事件循环的多个外部队列中，找到某一个队列直接执行其中的 callback 可以得到比 setTimeout 更早执行的效果。我们继续以开始的场景构造一个例子，并在 Node.js 10.x 的版本上执行（存在一次事件循环执行多次外部事件）。这里 setTimeout 在 setImmediate 后面执行的原因是因为 ms 精度的问题，想要手动 fix 这个精度可以插入一段 const now = Date.now(); wihle (Date.now() &lt; now + 1) {} 即可看到 setTimeout 在 setImmediate 之前执行了。</li>
<li>我们可以推测出 Node.js 中的事件循环与浏览器类似，也是外部队列与内部队列的循环，而 setImmediate 在另外一个外部队列中。</li>
<li>其中主要有两点需要关注，一是外部列队在每次事件循环只执行了一个，另一个是 Node.js 的固定了多个外部队列的优先级。setImmediate 的外部队列没有执行完的时候，是不会执行 timeout 的外部队列的。</li>
<li>timer（setTimeout）是第一阶段的原因在 libuv 的文档中有描述 —— 为了减少时间相关的系统调用（System Call）。setImmediate 出现在 check 阶段是蹭了 libuv 中 poll 阶段之后的检查过程（这个过程放在 poll 中也很奇怪，放在 poll 之后感觉比较合适）。</li>
<li>idle, prepare 对应的是 libuv 中的两个叫做 idle 和 prepare 的句柄。由于 I/O 的 poll 过程可能阻塞住事件循环，所以这两个句柄主要是用来触发 poll （阻塞）之前需要触发的回调</li>
<li>由于 poll 可能 block 住事件循环，所以应当有一个外部队列专门用于执行 I/O 的 callback ，并且优先级在 poll 以及 prepare to poll 之前。</li>
<li>另外我们知道网络 IO 可能有非常多的请求同时进来，如果该阶段如果无限制的执行这些 callback，可能导致 Node.js 的进程卡死该阶段，其他外部队列的代码都没发执行了。所以当前外部队列在执行一定数量的 callback 之后会截断。由于截断的这个特性，这个专门执行 I/O callbacks 的外部队列也叫 pengding callbacks</li>
</ul>
<h3 id="EventLoop-对渲染的影响"><a href="#EventLoop-对渲染的影响" class="headerlink" title="EventLoop 对渲染的影响"></a>EventLoop 对渲染的影响</h3><ul>
<li>浏览器作为一个复杂的应用是多线程工作的，除了运行 JS 的线程外，还有渲染线程、定时器触发线程、HTTP 请求线程，等等。JS 线程可以读取并且修改 DOM，而渲染线程也需要读取 DOM，这是一个典型的多线程竞争临界资源的问题。所以浏览器就把这两个线程设计成互斥的，即同时只能有一个线程在执行。</li>
<li>requestAnimationFrame，这个 API 保证在下次浏览器渲染之前一定会被调用，实际上我们完全可以把它看成是一个高级版的 setInterval。它们都是在一段时间后执行回调，但是前者的间隔时间是由浏览器自己不断调整的，而后者只能由用户指定。这样的特性也决定了 requestAnimationFrame 更适合用来做针对每一帧来修改的动画效果。</li>
<li>当然 requestAnimationFrame 不是 Eventloop 里的宏任务，或者说它并不在 Eventloop 的生命周期里，只是浏览器又开放的一个在渲染之前发生的新的 hook。另外需要注意的是微任务的认知概念也需要更新，在执行 animation callback 时也有可能产生微任务（比如 promise 的 callback），会放到 animation queue 处理完后再执行。所以微任务并不是像之前说的那样在每一轮 Eventloop 后处理，而是在 JS 的函数调用栈清空后处理。</li>
<li>但是 requestIdlecallback 却是一个更好理解的概念。当宏任务队列中没有任务可以处理时，浏览器可能存在“空闲状态”。这段空闲时间可以被 requestIdlecallback 利用起来执行一些优先级不高、不必立即执行的任务,当然为了防止浏览器一直处于繁忙状态，导致 requestIdlecallback 可能永远无法执行回调，它还提供了一个额外的 timeout 参数，为这个任务设置一个截止时间。浏览器就可以根据这个截止时间规划这个任务的执行。</li>
</ul>
<h3 id="宏任务、微任务"><a href="#宏任务、微任务" class="headerlink" title="宏任务、微任务"></a>宏任务、微任务</h3><ul>
<li>宏任务和微任务的执行顺序基本是，在 EventLoop 中，每一次循环称为一次 tick，主要的任务顺序如下：</li>
</ul>
<ol>
<li>执行栈选择最先进入队列的宏任务，执行其同步代码直至结束；</li>
<li>检查是否有微任务，如果有则执行直到微任务队列为空；</li>
<li>如果是在浏览器端，那么基本要渲染页面了；</li>
<li>开始下一轮的循环（tick），执行宏任务中的一些异步代码，例如 setTimeout 等。</li>
</ol>
<ul>
<li>Call-Stack（调用栈）也就是执行栈，它是一个栈的结构，符合先进后出的机制，每次一个循环，先执行最先入队的宏任务，然后再执行微任务。不管微任务还是宏任务，它们只要按照顺序进入了执行栈，那么执行栈就还是按照先进后出的规则，一步一步执行。因此根据这个原则，最先进行调用栈的宏任务，一般情况下都是最后返回执行的结果。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">async function async1() &#123;</span><br><span class="line"></span><br><span class="line">  console.log(&quot;async1 start&quot;);</span><br><span class="line"></span><br><span class="line">  await async2();</span><br><span class="line"></span><br><span class="line">  console.log(&quot;async1 end&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function async2() &#123;</span><br><span class="line"></span><br><span class="line">  console.log(&quot;async2&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async1();</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  console.log(&quot;timeout&quot;);</span><br><span class="line"></span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">new Promise(function (resolve) &#123;</span><br><span class="line"></span><br><span class="line">  console.log(&quot;promise1&quot;);</span><br><span class="line"></span><br><span class="line">  resolve();</span><br><span class="line"></span><br><span class="line">&#125;).then(function () &#123;</span><br><span class="line"></span><br><span class="line">  console.log(&quot;promise2&quot;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&quot;script end&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">async1 start</span><br><span class="line">async2</span><br><span class="line">promise1</span><br><span class="line">script end</span><br><span class="line">async1 end</span><br><span class="line">promise2</span><br><span class="line">timeout</span><br></pre></td></tr></table></figure>
<h4 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h4><ul>
<li>如果在浏览器的环境下，宏任务主要分为下面这几个大类：</li>
</ul>
<ol>
<li>渲染事件（比如解析 DOM、计算布局、绘制）；</li>
<li>用户交互事件（比如鼠标点击、滚动页面、放大缩小等）；</li>
<li>setTimeout、setInterval 等；</li>
<li>网络请求完成、文件读写完成事件。</li>
</ol>
<ul>
<li>为了让这些任务在主线程上执行，页面进程引入了消息队列和事件循环机制，我们把这些消息队列中的任务称为宏任务。</li>
<li>宏任务基本上满足了日常的开发需求，而对于时间精度有要求的宏任务就不太能满足了，比如渲染事件、各种 I/O、用户交互的事件等，都随时有可能被添加到消息队列中，JS 代码不能准确掌控任务要添加到队列中的位置，控制不了任务在消息队列中的位置，所以很难控制开始执行任务的时间。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function callback2()&#123;</span><br><span class="line"></span><br><span class="line">    console.log(2)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function callback()&#123;</span><br><span class="line"></span><br><span class="line">    console.log(1)</span><br><span class="line"></span><br><span class="line">    setTimeout(callback2,0)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setTimeout(callback,0)</span><br><span class="line">在上面这段代码中，我的目的是想通过 setTimeout 来设置两个回调任务，并让它们按照前后顺序来执行，中间也不要再插入其他的任务。</span><br><span class="line">但是实际情况我们难以控制，比如在你调用 setTimeout 来设置回调任务的间隙，消息队列中就有可能被插入很多系统级的任务。</span><br><span class="line">如果中间被插入的任务执行时间过久的话，那么就会影响到后面任务的执行了。所以说宏任务的时间粒度比较大，执行的间隔是不能精确控制的。</span><br><span class="line">这就不适用于一些高实时性的需求了，比如后面要讲到的监听 DOM 变化。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h4><ul>
<li>微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。</li>
<li>当 JavaScript 执行一段脚本的时候，V8 会为其创建一个全局执行上下文，同时 V8 引擎也会在内部创建一个微任务队列。这个微任务队列就是用来存放微任务的，因为在当前宏任务执行的过程中，有时候会产生多个微任务，这时候就需要使用这个微任务队列来保存这些微任务了。不过这个微任务队列是给 V8 引擎内部使用的，所以你是无法通过 JavaScript 直接访问的。</li>
<li>在现代浏览器里面，产生微任务有两种方式</li>
</ul>
<ol>
<li>使用 MutationObserver 监控某个 DOM 节点，或者为这个节点添加、删除部分子节点，当 DOM 节点发生变化时，就会产生 DOM 变化记录的微任务。</li>
<li>使用 Promise，当调用 Promise.resolve() 或者 Promise.reject() 的时候，也会产生微任务</li>
</ol>
<ul>
<li>如果在执行微任务的过程中，产生了新的微任务，一样会将该微任务添加到微任务队列中，V8 引擎一直循环执行微任务队列中的任务，直到队列清空才算执行结束。也就是说在执行微任务过程中产生的新的微任务并不会推迟到下一个循环中执行，而是在当前的循环中继续执行，这点是需要注意的。</li>
<li>微任务和宏任务是绑定的，每个宏任务在执行时，会创建自己的微任务队列。</li>
<li>微任务的执行时长会影响当前宏任务的时长。比如一个宏任务在执行过程中，产生了 10 个微任务，执行每个微任务的时间是 10ms，那么执行这 10 个微任务的时间就是 100ms，也可以说这 10 个微任务让宏任务的执行时间延长了 100ms。</li>
<li>在一个宏任务中，分别创建一个用于回调的宏任务和微任务，无论什么情况下，微任务都早于宏任务执行。</li>
</ul>
<h4 id="MutationObserver"><a href="#MutationObserver" class="headerlink" title="MutationObserver"></a>MutationObserver</h4><ul>
<li>MutationObserver API 可以用来监视 DOM 的变化，包括属性的变更、节点的增加、内容的改变等。因为上面我们分析过，在两个任务之间，可能会被渲染进程插入其他的事件，从而影响到响应的实时性。这时候，微任务就可以上场了，在每次 DOM 节点发生变化的时候，渲染引擎将变化记录封装成微任务，并将微任务添加进当前的微任务队列中。这样当执行到检查点的时候，V8 引擎就会按照顺序执行微任务了。</li>
<li>MutationObserver 采用了“异步 + 微任务”的策略：</li>
</ul>
<ol>
<li>通过异步操作解决了同步操作的性能问题；</li>
<li>通过微任务解决了实时性的问题。</li>
</ol>
<h4 id="Process-nextTick"><a href="#Process-nextTick" class="headerlink" title="Process.nextTick"></a>Process.nextTick</h4><ul>
<li>Process.nextick 的运行逻辑：</li>
</ul>
<ol>
<li>Process.nextick 会将 callback 添加到“next tick queue”；</li>
<li>“next tick queue”会在当前 JavaScript stack 执行完成后，下一次 event loop 开始执行前按照 FIFO 出队；</li>
<li>如果递归调用 Process.nextick 可能会导致一个无限循环，需要去适时终止递归。</li>
</ol>
<ul>
<li>可能你已经注意到 Process.nextick 其实是微任务，同时也是异步 API 的一部分。但是从技术上来说 Process.nextick 并不是事件循环（eventloop）的一部分，相反地，“next tick queue”将会在当前操作完成之后立即被处理，而不管当前处于事件循环的哪个阶段。</li>
<li>如果任何时刻你在一个给定的阶段调用 Process.nextick，则所有被传入 Process.nextick 的回调将在事件循环继续往下执行前被执行。这可能会导致一些很糟的情形，因为它允许用户递归调用 Process.nextick 来挂起 I/O 进程的进行，这会导致事件循环永远无法到达轮询阶段。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">let bar;</span><br><span class="line"></span><br><span class="line">function someAsyncApiCall(callback) &#123; callback(); &#125;</span><br><span class="line"></span><br><span class="line">someAsyncApiCall(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  console.log(&apos;bar&apos;, bar);   // undefined</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">bar = 1;</span><br><span class="line"></span><br><span class="line">用户定义函数 someAsyncApiCall() 有一个异步签名，但实际上它是同步执行的。</span><br><span class="line">当它被调用时，提供给 someAsyncApiCall() 的回调函数会在执行 someAsyncApiCall() 本身的同一个事件循环阶段被执行，因为 someAsyncApiCall() 实际上并未执行任何异步操作。</span><br><span class="line">结果就是，即使回调函数尝试引用变量 bar，但此时在作用域中并没有改变量。因为程序还没运行到对 bar 赋值的部分。</span><br><span class="line"></span><br><span class="line">将回调放到 Process.nextick 中，程序依然可以执行完毕，且所有的变量、函数等都在执行回调之前被初始化，它还具有不会被事件循环打断的优点。以下是将上面的例子改用 Process.nextick 的代码：</span><br><span class="line"></span><br><span class="line">let bar;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">function someAsyncApiCall(callback) &#123;</span><br><span class="line"></span><br><span class="line">  process.nextTick(callback);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">someAsyncApiCall(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  console.log(&apos;bar&apos;, bar); // 1</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">bar = 1;</span><br><span class="line"></span><br><span class="line">-------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const EventEmitter = require(&apos;events&apos;);</span><br><span class="line"></span><br><span class="line">const util = require(&apos;util&apos;);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">function MyEmitter() &#123;</span><br><span class="line"></span><br><span class="line">EventEmitter.call(this);</span><br><span class="line"></span><br><span class="line">this.emit(&apos;event&apos;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">util.inherits(MyEmitter, EventEmitter);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">const myEmitter = new MyEmitter();</span><br><span class="line"></span><br><span class="line">myEmitter.on(&apos;event&apos;, () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">console.log(&apos;an event occurred!&apos;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">你无法在构造函数中立即触发一个事件，因为此时程序还未运行到将回调赋值给事件的那段代码。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">因此，在构造函数内部，你可以使用 Process.nextick 设置一个回调以在构造函数执行完毕后触发事件，下面的代码满足了我们的预期。</span><br><span class="line"></span><br><span class="line">const EventEmitter = require(&apos;events&apos;);</span><br><span class="line"></span><br><span class="line">const util = require(&apos;util&apos;);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">function MyEmitter() &#123;</span><br><span class="line"></span><br><span class="line">EventEmitter.call(this);</span><br><span class="line"></span><br><span class="line">process.nextTick(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  this.emit(&apos;event&apos;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">util.inherits(MyEmitter, EventEmitter);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">const myEmitter = new MyEmitter();</span><br><span class="line"></span><br><span class="line">  myEmitter.on(&apos;event&apos;, () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  console.log(&apos;an event occurred!&apos;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">通过上面的改造可以看出，使用 Process.nextick 就可以解决问题了，即使 event 事件还没进行绑定，但也可以让代码在前面进行触发，因为根据代码执行顺序，Process.nextick 是在每一次的事件循环最后执行的。</span><br><span class="line">因此这样写，代码也不会报错，同样又保持了代码的逻辑。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="Vue的nextick"><a href="#Vue的nextick" class="headerlink" title="Vue的nextick"></a>Vue的nextick</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"></span><br><span class="line">  &lt;div class=&quot;app&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div ref=&quot;msg&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div v-if=&quot;msg1&quot;&gt;Message got outside $nextTick: &#123;&#123;msg1&#125;&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div v-if=&quot;msg2&quot;&gt;Message got inside $nextTick: &#123;&#123;msg2&#125;&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;button @click=&quot;changeMsg&quot;&gt;</span><br><span class="line"></span><br><span class="line">      Change the Message</span><br><span class="line"></span><br><span class="line">    &lt;/button&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line"></span><br><span class="line">  el: &apos;.app&apos;,</span><br><span class="line"></span><br><span class="line">  data: &#123;</span><br><span class="line"></span><br><span class="line">    msg: &apos;Vue&apos;,</span><br><span class="line"></span><br><span class="line">    msg1: &apos;&apos;,</span><br><span class="line"></span><br><span class="line">    msg2: &apos;&apos;,</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line"></span><br><span class="line">    changeMsg() &#123;</span><br><span class="line"></span><br><span class="line">      this.msg = &quot;Hello world.&quot;</span><br><span class="line"></span><br><span class="line">      this.msg1 = this.$refs.msg.innerHTML</span><br><span class="line"></span><br><span class="line">      this.$nextTick(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">        this.msg2 = this.$refs.msg.innerHTML</span><br><span class="line"></span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">通过按钮点击之后，div 里面的 msg1 和 msg2 的变化情况。你会发现第一次点击按钮调用 changeMsg 方法时，其实 msg2 并没有变化，因为 msg2 的变化是在下一个 tick 才进行执行的。</span><br></pre></td></tr></table></figure>
<h2 id="JS-代码是如何被浏览器引擎编译、执行的？"><a href="#JS-代码是如何被浏览器引擎编译、执行的？" class="headerlink" title="JS 代码是如何被浏览器引擎编译、执行的？"></a>JS 代码是如何被浏览器引擎编译、执行的？</h2><h3 id="V8-引擎"><a href="#V8-引擎" class="headerlink" title="V8 引擎"></a>V8 引擎</h3><ul>
<li>编译型语言和解释型语言</li>
</ul>
<ol>
<li>编译型语言的特点是在代码运行前编译器直接将对应的代码转换成机器码，运行时不需要再重新翻译，直接可以使用编译后的结果。</li>
<li>解释型语言也是需要将代码转换成机器码，但是和编译型的区别在于运行时需要转换。比较显著的特点是，解释型语言的执行速度要慢于编译型语言，因为解释型语言每次执行都需要把源码转换一次才能执行。</li>
</ol>
<ul>
<li>V8是众多浏览器的 JS 引擎中性能表现最好的一个，并且它是 Chrome 的内核，Node.js 也是基于 V8 引擎研发的。</li>
<li>V8引擎执行 JS 代码要经过以下阶段</li>
</ul>
<ol>
<li>Parse 阶段：V8 引擎负责将 JS 代码转换成 AST（抽象语法树）；</li>
<li>Ignition 阶段：解释器将 AST 转换为字节码，解析执行字节码也会为下一个阶段优化编译提供需要的信息；</li>
<li>TurboFan 阶段：编译器利用上个阶段收集的信息，将字节码优化为可以执行的机器码；</li>
<li>Orinoco 阶段：垃圾回收阶段，将程序中不再使用的内存空间进行回收。<h3 id="生成-AST"><a href="#生成-AST" class="headerlink" title="生成 AST"></a>生成 AST</h3></li>
</ol>
<ul>
<li>Eslint 和 Babel 这两个工具都和 AST 脱不了干系。V8 引擎就是通过编译器（Parse）将源代码解析成 AST 的</li>
<li>AST 在实际工作中应用场景也比较多，大致有下面几个：</li>
</ul>
<ol>
<li>JS 反编译，语法解析；</li>
<li>Babel 编译 ES6 语法；</li>
<li>代码高亮；</li>
<li>关键字匹配；</li>
<li>代码压缩。</li>
</ol>
<ul>
<li>生成 AST 分为两个阶段，一是词法分析，二是语法分析</li>
</ul>
<ol>
<li>词法分析：这个阶段会将源代码拆成最小的、不可再分的词法单元，称为 token。比如这行代码 var a =1；通常会被分解成 var 、a、=、2、; 这五个词法单元。另外刚才代码中的空格在 JavaScript 中是直接忽略的。</li>
<li>语法分析：这个过程是将词法单元转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树，这个树被称为抽象语法树。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line">// 第一段代码</span><br><span class="line"></span><br><span class="line">var a = 1;</span><br><span class="line"></span><br><span class="line">// 第二段代码</span><br><span class="line"></span><br><span class="line">function sum (a,b) &#123;</span><br><span class="line"></span><br><span class="line">  return a + b;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第一段代码，编译后的结果：</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  &quot;type&quot;: &quot;Program&quot;,</span><br><span class="line"></span><br><span class="line">  &quot;start&quot;: 0,</span><br><span class="line"></span><br><span class="line">  &quot;end&quot;: 10,</span><br><span class="line"></span><br><span class="line">  &quot;body&quot;: [</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      &quot;type&quot;: &quot;VariableDeclaration&quot;,</span><br><span class="line"></span><br><span class="line">      &quot;start&quot;: 0,</span><br><span class="line"></span><br><span class="line">      &quot;end&quot;: 10,</span><br><span class="line"></span><br><span class="line">      &quot;declarations&quot;: [</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">          &quot;type&quot;: &quot;VariableDeclarator&quot;,</span><br><span class="line"></span><br><span class="line">          &quot;start&quot;: 4,</span><br><span class="line"></span><br><span class="line">          &quot;end&quot;: 9,</span><br><span class="line"></span><br><span class="line">          &quot;id&quot;: &#123;</span><br><span class="line"></span><br><span class="line">            &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line"></span><br><span class="line">            &quot;start&quot;: 4,</span><br><span class="line"></span><br><span class="line">            &quot;end&quot;: 5,</span><br><span class="line"></span><br><span class="line">            &quot;name&quot;: &quot;a&quot;</span><br><span class="line"></span><br><span class="line">          &#125;,</span><br><span class="line"></span><br><span class="line">          &quot;init&quot;: &#123;</span><br><span class="line"></span><br><span class="line">            &quot;type&quot;: &quot;Literal&quot;,</span><br><span class="line"></span><br><span class="line">            &quot;start&quot;: 8,</span><br><span class="line"></span><br><span class="line">            &quot;end&quot;: 9,</span><br><span class="line"></span><br><span class="line">            &quot;value&quot;: 1,</span><br><span class="line"></span><br><span class="line">            &quot;raw&quot;: &quot;1&quot;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      ],</span><br><span class="line"></span><br><span class="line">      &quot;kind&quot;: &quot;var&quot;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  &quot;sourceType&quot;: &quot;module&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">第二段代码，编译出来的结果：</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  &quot;type&quot;: &quot;Program&quot;,</span><br><span class="line"></span><br><span class="line">  &quot;start&quot;: 0,</span><br><span class="line"></span><br><span class="line">  &quot;end&quot;: 38,</span><br><span class="line"></span><br><span class="line">  &quot;body&quot;: [</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      &quot;type&quot;: &quot;FunctionDeclaration&quot;,</span><br><span class="line"></span><br><span class="line">      &quot;start&quot;: 0,</span><br><span class="line"></span><br><span class="line">      &quot;end&quot;: 38,</span><br><span class="line"></span><br><span class="line">      &quot;id&quot;: &#123;</span><br><span class="line"></span><br><span class="line">        &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line"></span><br><span class="line">        &quot;start&quot;: 9,</span><br><span class="line"></span><br><span class="line">        &quot;end&quot;: 12,</span><br><span class="line"></span><br><span class="line">        &quot;name&quot;: &quot;sum&quot;</span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &quot;expression&quot;: false,</span><br><span class="line"></span><br><span class="line">      &quot;generator&quot;: false,</span><br><span class="line"></span><br><span class="line">      &quot;async&quot;: false,</span><br><span class="line"></span><br><span class="line">      &quot;params&quot;: [</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">          &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line"></span><br><span class="line">          &quot;start&quot;: 14,</span><br><span class="line"></span><br><span class="line">          &quot;end&quot;: 15,</span><br><span class="line"></span><br><span class="line">          &quot;name&quot;: &quot;a&quot;</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">          &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line"></span><br><span class="line">          &quot;start&quot;: 16,</span><br><span class="line"></span><br><span class="line">          &quot;end&quot;: 17,</span><br><span class="line"></span><br><span class="line">          &quot;name&quot;: &quot;b&quot;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      ],</span><br><span class="line"></span><br><span class="line">      &quot;body&quot;: &#123;</span><br><span class="line"></span><br><span class="line">        &quot;type&quot;: &quot;BlockStatement&quot;,</span><br><span class="line"></span><br><span class="line">        &quot;start&quot;: 19,</span><br><span class="line"></span><br><span class="line">        &quot;end&quot;: 38,</span><br><span class="line"></span><br><span class="line">        &quot;body&quot;: [</span><br><span class="line"></span><br><span class="line">          &#123;</span><br><span class="line"></span><br><span class="line">            &quot;type&quot;: &quot;ReturnStatement&quot;,</span><br><span class="line"></span><br><span class="line">            &quot;start&quot;: 23,</span><br><span class="line"></span><br><span class="line">            &quot;end&quot;: 36,</span><br><span class="line"></span><br><span class="line">            &quot;argument&quot;: &#123;</span><br><span class="line"></span><br><span class="line">              &quot;type&quot;: &quot;BinaryExpression&quot;,</span><br><span class="line"></span><br><span class="line">              &quot;start&quot;: 30,</span><br><span class="line"></span><br><span class="line">              &quot;end&quot;: 35,</span><br><span class="line"></span><br><span class="line">              &quot;left&quot;: &#123;</span><br><span class="line"></span><br><span class="line">                &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line"></span><br><span class="line">                &quot;start&quot;: 30,</span><br><span class="line"></span><br><span class="line">                &quot;end&quot;: 31,</span><br><span class="line"></span><br><span class="line">                &quot;name&quot;: &quot;a&quot;</span><br><span class="line"></span><br><span class="line">              &#125;,</span><br><span class="line"></span><br><span class="line">              &quot;operator&quot;: &quot;+&quot;,</span><br><span class="line"></span><br><span class="line">              &quot;right&quot;: &#123;</span><br><span class="line"></span><br><span class="line">                &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line"></span><br><span class="line">                &quot;start&quot;: 34,</span><br><span class="line"></span><br><span class="line">                &quot;end&quot;: 35,</span><br><span class="line"></span><br><span class="line">                &quot;name&quot;: &quot;b&quot;</span><br><span class="line"></span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  &quot;sourceType&quot;: &quot;module&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">从上面编译出的结果可以看到，AST 只是源代码语法结构的一种抽象的表示形式，计算机也不会去直接去识别 JS 代码，转换成抽象语法树也只是识别这一过程中的第一步。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>现在浏览器还不支持 ES6 语法，需要将其转换成 ES5 语法，这个过程就要借助 Babel 来实现。将 ES6 源码解析成 AST，再将 ES6 语法的抽象语法树转成 ES5 的抽象语法树，最后利用它来生成 ES5 的源代码。另外 ESlint 的原理也大致相同，检测流程也是将源码转换成抽象语法树，再利用它来检测代码规范。<h3 id="生成字节码"><a href="#生成字节码" class="headerlink" title="生成字节码"></a>生成字节码</h3></li>
<li>之前的 V8 版本不会经过这个过程，最早只是通过 AST 直接转换成机器码，而后面几个版本中才对此进行了改进。如果将 AST 直接转换为机器码还是会有一些问题存在的，例如：</li>
</ul>
<ol>
<li>直接转换会带来内存占用过大的问题，因为将抽象语法树全部生成了机器码，而机器码相比字节码占用的内存多了很多；</li>
<li>某些 JavaScript 使用场景使用解释器更为合适，解析成字节码，有些代码没必要生成机器码，进而尽可能减少了占用内存过大的问题。</li>
</ol>
<ul>
<li>官方在 V8 的 v5.6 版本中还是将抽象语法树转换成字节码这一过程又加上了，重新加入了字节码的处理过程。再然后，V8 重新引进了 Ignition 解释器，将抽象语法树转换成字节码后，内存占用显著下降了，同时也可以使用 JIT 编译器做进一步的优化。</li>
<li>字节码是介于 AST 和机器码之间的一种代码，需要将其转换成机器码后才能执行，字节码可以理解为是机器码的一种抽象。Ignition 解释器除了可以快速生成没有优化的字节码外，还可以执行部分字节码。<h3 id="生成机器码"><a href="#生成机器码" class="headerlink" title="生成机器码"></a>生成机器码</h3></li>
<li>在 Ignition 解释器处理完之后，如果发现一段代码被重复执行多次的情况，生成的字节码以及分析数据会传给 TurboFan 编译器，它会根据分析数据的情况生成优化好的机器码。再执行这段代码之后，只需要直接执行编译后的机器码，这样性能就会更好。</li>
<li>TurboFan 编译器，它是 JIT 优化的编译器，因为 V8 引擎是多线程的，TurboFan 的编译线程和生成字节码不会在同一个线程上，这样可以和 Ignition 解释器相互配合着使用，不受另一方的影响。</li>
<li>由 Ignition 解释器收集的分析数据被 TurboFan 编译器使用，主要是通过一种推测优化的技术，生成已经优化的机器码来执行。</li>
</ul>
<h2 id="JavaScript引擎如何执行JavaScript代码"><a href="#JavaScript引擎如何执行JavaScript代码" class="headerlink" title="JavaScript引擎如何执行JavaScript代码"></a>JavaScript引擎如何执行JavaScript代码</h2><ul>
<li>JavaScript 代码是需要在 JavaScript 引擎中运行的。我们在说到 JavaScript 运行的时候，常常会提到执行环境、词法环境、作用域、执行上下文、闭包等内容。</li>
<li>JavaScript引擎执行JavaScript代码时会进行词法分析、语法分析、语义分析等处理，最终生成抽象语法树，根据抽象语法树生成机器码</li>
<li>在 V8 引擎中 JavaScript 代码的运行过程主要分成三个阶段：</li>
</ul>
<ol>
<li>语法分析阶段：对代码进行语法分析，检查是否有语法错误</li>
<li>编译阶段：会创建执行上下文，包括变量对象的创建、作用域链的建立、this指向的确立等。每进入一个不同的运行环境，V8引擎都会创建一个执行上下文。</li>
<li>执行阶段：将编译阶段的执行上下文压入调用栈，代码执行结束后，将其弹出调用栈</li>
</ol>
<ul>
<li>前面提到的执行环境、词法环境、作用域、执行上下文等内容都是在编译和执行阶段中产生的概念。<h3 id="执行上下文创建"><a href="#执行上下文创建" class="headerlink" title="执行上下文创建"></a>执行上下文创建</h3></li>
<li>全局环境和函数环境的创建过程如下</li>
</ul>
<ol>
<li>第一次载入JavaScript代码时会创建一个全局环境。全局环境位于最外层，直到应用程序结束后（浏览器、网页关闭等）才会被销毁。</li>
<li>每个函数有自己的运行环境，当函数被调用时，会进入该函数的运行环境。当该环境中的代码全部执行完毕后，该环境会被销毁。不同函数运行环境不一样，同一个函数多次被调用会创建不同的函数环境。</li>
</ol>
<ul>
<li>每进入一个不同的运行环境时，JavaScript 都会创建一个新的执行上下文，该过程包括：</li>
</ul>
<ol>
<li>建立作用域链（Scope Chain）；</li>
<li>创建变量对象（Variable Object，简称 VO）；</li>
<li>确定 this 的指向。<h3 id="创建变量对象"><a href="#创建变量对象" class="headerlink" title="创建变量对象"></a>创建变量对象</h3></li>
</ol>
<ul>
<li>每个执行上下文都会有一个关联的变量对象，该对象上会保存这个上下文中定义的所有变量和函数。</li>
<li>而在浏览器中，全局环境的变量对象是window对象，因此所有的全局变量和函数都是作为window对象的属性和方法创建的。相应的，在 Node 中全局环境的变量对象则是global对象。</li>
<li>创建变量对象将会创建arguments对象（仅函数环境下），同时会检查当前上下文的函数声明和变量声明。</li>
</ul>
<ol>
<li>对于变量声明：此时会给变量分配内存，并将其初始化为undefined（该过程只进行定义声明，执行阶段才执行赋值语句）。</li>
<li>对于函数声明：此时会在内存里创建函数对象，并且直接初始化为该函数对象。</li>
</ol>
<ul>
<li>变量声明和函数声明的处理过程，便是我们常说的变量提升和函数提升，其中函数声明提升会优先于变量声明提升。因为变量提升容易带来变量在预期外被覆盖掉的问题，同时还可能导致本应该被销毁的变量没有被销毁等情况。因此 ES6 中引入了let和const关键字，从而使 JavaScript 也拥有了块级作用域。</li>
<li>在 JavaScript 中，词法环境又分为词法环境（Lexical Environment）和变量环境（Variable Environment）两种，其中：</li>
</ul>
<ol>
<li>变量环境用来记录var/function等变量声明；</li>
<li>词法环境是用来记录let/const/class等变量声明。<h3 id="建立作用域链"><a href="#建立作用域链" class="headerlink" title="建立作用域链"></a>建立作用域链</h3></li>
</ol>
<ul>
<li>作用域就是词法环境，而词法环境由两个成员组成。</li>
</ul>
<ol>
<li>环境记录（Environment Record）：用于记录自身词法环境中的变量对象。</li>
<li>外部词法环境引用（Outer Lexical Environment）：记录外层词法环境的引用。</li>
</ol>
<ul>
<li>通过外部词法环境的引用，作用域可以层层拓展，建立起从里到外延伸的一条作用域链。当某个变量无法在自身词法环境记录中找到时，可以根据外部词法环境引用向外层进行寻找，直到最外层的词法环境中外部词法环境引用为null，这便是作用域链的变量查询。</li>
<li><p>通过外部词法环境的引用，作用域可以层层拓展，建立起从里到外延伸的一条作用域链。当某个变量无法在自身词法环境记录中找到时，可以根据外部词法环境引用向外层进行寻找，直到最外层的词法环境中外部词法环境引用为null，这便是作用域链的变量查询。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">function foo(a) &#123;</span><br><span class="line"></span><br><span class="line">  var b = 2;</span><br><span class="line"></span><br><span class="line">  function c() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  var d = function() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foo(1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在执行foo(1)时，首先进入定义期，此时：</span><br><span class="line">参数变量a的值为1</span><br><span class="line">变量b和d初始化为undefined</span><br><span class="line">函数c创建函数并初始化</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">AO = &#123;</span><br><span class="line"></span><br><span class="line">  arguments: &#123;</span><br><span class="line"></span><br><span class="line">    0: 1,</span><br><span class="line"></span><br><span class="line">    length: 1</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  a: 1,</span><br><span class="line"></span><br><span class="line">  b: undefined,</span><br><span class="line"></span><br><span class="line">  c: reference to function c()&#123;&#125;,</span><br><span class="line"></span><br><span class="line">  d: undefined</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">进入执行期之后，会执行赋值语句进行赋值，此时变量b和d会被赋值为 2 和函数表达式：</span><br><span class="line">AO = &#123;</span><br><span class="line"></span><br><span class="line">   arguments: &#123;</span><br><span class="line"></span><br><span class="line">    0: 1,</span><br><span class="line"></span><br><span class="line">    length: 1</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  a: 1,</span><br><span class="line"></span><br><span class="line">  b: 2,</span><br><span class="line"></span><br><span class="line">  c: reference to function c()&#123;&#125;,</span><br><span class="line"></span><br><span class="line">  d: reference to FunctionExpression &quot;d&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>一般来说，当函数执行结束之后，执行期上下文将被销毁（作用域链和活动对象均被销毁）。但有时候我们想要保留其中一些变量对象，不想被销毁，此时就会使用到闭包。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line"></span><br><span class="line">  var a = 1;</span><br><span class="line"></span><br><span class="line">  function bar() &#123;</span><br><span class="line"></span><br><span class="line">    return a;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return bar;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var b = foo();</span><br><span class="line"></span><br><span class="line">console.log(b()); // 1</span><br><span class="line"></span><br><span class="line">在这个例子中，当b()执行时，foo函数上下文包括作用域都已经被销毁了，为什么foo作用域下的a依然可以被访问到呢？</span><br><span class="line"></span><br><span class="line">这是因为bar函数引用了foo函数变量对象中的值，此时即使创建bar函数的foo函数执行上下文被销毁了，但它的变量对象依然会保留在 JavaScript 内存中，bar函数依然可以通过bar函数的作用域链找到它，并进行访问。这便是我们常说的闭包，即使创建它的上下文已经销毁，它仍然被保留在内存中。</span><br></pre></td></tr></table></figure>
</li>
<li><p>闭包使得我们可以从外部读取局部变量，在大多数项目中都会被使用到，常见的用途包括：</p>
</li>
</ul>
<ol>
<li>用于从外部读取其他函数内部变量的函数；</li>
<li>可以使用闭包来模拟私有方法；</li>
<li>让这些变量的值始终保持在内存中。<h3 id="确定-this-的指向"><a href="#确定-this-的指向" class="headerlink" title="确定 this 的指向"></a>确定 this 的指向</h3></li>
</ol>
<ul>
<li>根据 JavaScript 中函数的调用方式不同，this的指向分为以下情况。</li>
</ul>
<ol>
<li>在全局环境中，this指向全局对象（在浏览器中为window）</li>
<li>在函数内部，this的值取决于函数被调用的方式<br>函数作为对象的方法被调用，this指向调用这个方法的对象<br>函数用作构造函数时（使用new关键字），它的this被绑定到正在构造的新对象</li>
<li>在类的构造函数中，this是一个常规对象，类中所有非静态的方法都会被添加到this的原型中</li>
<li>在箭头函数中，this指向它被创建时的环境</li>
<li>使用apply、call、bind等方式调用：根据 API 不同，可切换函数执行的上下文环境，即this绑定的对象</li>
</ol>
<h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h2><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><ul>
<li>如果一定要解释 Promise 到底是什么，简单来说它就是一个容器，里面保存着某个未来才会结束的事件（通常是异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。</li>
<li>回调地狱有两个主要的问题：</li>
</ul>
<ol>
<li>多层嵌套的问题；</li>
<li>每种任务的处理结果存在两种可能性（成功或失败），那么需要在每种任务执行结束后分别处理这两种可能性。</li>
</ol>
<ul>
<li>Promise 的静态方法</li>
</ul>
<ol>
<li><p>all 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">此方法对于汇总多个 promise 的结果很有用，在 ES6 中可以将多个 Promise.all 异步请求并行操作，返回结果一般有下面两种情况。</span><br><span class="line">1.当所有结果成功返回时按照请求顺序返回成功。</span><br><span class="line">2.当其中有一个失败方法时，则进入失败方法</span><br><span class="line"></span><br><span class="line">//1.获取轮播数据列表</span><br><span class="line"></span><br><span class="line">function getBannerList()&#123;</span><br><span class="line"></span><br><span class="line">  return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">      setTimeout(function()&#123;</span><br><span class="line"></span><br><span class="line">        resolve(&apos;轮播数据&apos;)</span><br><span class="line"></span><br><span class="line">      &#125;,300) </span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//2.获取店铺列表</span><br><span class="line"></span><br><span class="line">function getStoreList()&#123;</span><br><span class="line"></span><br><span class="line">  return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line"></span><br><span class="line">      resolve(&apos;店铺数据&apos;)</span><br><span class="line"></span><br><span class="line">    &#125;,500)</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//3.获取分类列表</span><br><span class="line"></span><br><span class="line">function getCategoryList()&#123;</span><br><span class="line"></span><br><span class="line">  return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line"></span><br><span class="line">      resolve(&apos;分类数据&apos;)</span><br><span class="line"></span><br><span class="line">    &#125;,700)</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function initLoad()&#123; </span><br><span class="line"></span><br><span class="line">  Promise.all([getBannerList(),getStoreList(),getCategoryList()])</span><br><span class="line"></span><br><span class="line">  .then(res=&gt;&#123;</span><br><span class="line"></span><br><span class="line">    console.log(res) </span><br><span class="line"></span><br><span class="line">  &#125;).catch(err=&gt;&#123;</span><br><span class="line"></span><br><span class="line">    console.log(err)</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">initLoad()</span><br></pre></td></tr></table></figure>
</li>
<li><p>allSettled 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Promise.allSettled 的语法及参数跟 Promise.all 类似，唯一的不同在于，执行完之后不会失败，也就是说当 Promise.allSettled 全部处理完成后，我们可以拿到每个 Promise 的状态，而不管其是否处理成功。</span><br><span class="line"></span><br><span class="line">const resolved = Promise.resolve(2);</span><br><span class="line"></span><br><span class="line">const rejected = Promise.reject(-1);</span><br><span class="line"></span><br><span class="line">const allSettledPromise = Promise.allSettled([resolved, rejected]);</span><br><span class="line"></span><br><span class="line">allSettledPromise.then(function (results) &#123;</span><br><span class="line"></span><br><span class="line">  console.log(results);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 返回结果：</span><br><span class="line"></span><br><span class="line">// [</span><br><span class="line"></span><br><span class="line">//    &#123; status: &apos;fulfilled&apos;, value: 2 &#125;,</span><br><span class="line"></span><br><span class="line">//    &#123; status: &apos;rejected&apos;, reason: -1 &#125;</span><br><span class="line"></span><br><span class="line">// ]</span><br></pre></td></tr></table></figure>
</li>
<li><p>any 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">any 方法返回一个 Promise，只要参数 Promise 实例有一个变成 fulfilled 状态，最后 any 返回的实例就会变成 fulfilled 状态；如果所有参数 Promise 实例都变成 rejected 状态，包装实例就会变成 rejected 状态。</span><br><span class="line">const resolved = Promise.resolve(2);</span><br><span class="line"></span><br><span class="line">const rejected = Promise.reject(-1);</span><br><span class="line"></span><br><span class="line">const anyPromise = Promise.any([resolved, rejected]);</span><br><span class="line"></span><br><span class="line">anyPromise.then(function (results) &#123;</span><br><span class="line"></span><br><span class="line">  console.log(results);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 返回结果：</span><br><span class="line"></span><br><span class="line">// 2</span><br></pre></td></tr></table></figure>
</li>
<li><p>race 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"> race 方法返回一个 Promise，只要参数的 Promise 之中有一个实例率先改变状态，则 race 方法的返回状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给 race 方法的回调函数。</span><br><span class="line"> //请求某个图片资源</span><br><span class="line"></span><br><span class="line">function requestImg()&#123;</span><br><span class="line"></span><br><span class="line">  var p = new Promise(function(resolve, reject)&#123;</span><br><span class="line"></span><br><span class="line">    var img = new Image();</span><br><span class="line"></span><br><span class="line">    img.onload = function()&#123; resolve(img); &#125;</span><br><span class="line"></span><br><span class="line">    img.src = &apos;http://www.baidu.com/img/flexible/logo/pc/result.png&apos;;</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return p;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//延时函数，用于给请求计时</span><br><span class="line"></span><br><span class="line">function timeout()&#123;</span><br><span class="line"></span><br><span class="line">  var p = new Promise(function(resolve, reject)&#123;</span><br><span class="line"></span><br><span class="line">    setTimeout(function()&#123; reject(&apos;图片请求超时&apos;); &#125;, 5000);</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return p;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise.race([requestImg(), timeout()])</span><br><span class="line"></span><br><span class="line">.then(function(results)&#123;</span><br><span class="line"></span><br><span class="line">  console.log(results);</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">.catch(function(reason)&#123;</span><br><span class="line"></span><br><span class="line">  console.log(reason);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h3><ul>
<li>通俗来讲 Generator 是一个带星号的“函数”（它并不是真正的函数），可以配合 yield 关键字来暂停或者执行函数。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">function* gen() &#123;</span><br><span class="line"></span><br><span class="line">  console.log(&quot;enter&quot;);</span><br><span class="line"></span><br><span class="line">  let a = yield 1;</span><br><span class="line"></span><br><span class="line">  let b = yield (function () &#123;return 2&#125;)();</span><br><span class="line"></span><br><span class="line">  return 3;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var g = gen()           // 阻塞住，不会执行任何语句</span><br><span class="line"></span><br><span class="line">console.log(g.next())</span><br><span class="line"></span><br><span class="line">console.log(g.next())</span><br><span class="line"></span><br><span class="line">console.log(g.next())</span><br><span class="line"></span><br><span class="line">console.log(g.next()) </span><br><span class="line"></span><br><span class="line">// output:</span><br><span class="line"></span><br><span class="line">// &#123; value: 1, done: false &#125;</span><br><span class="line"></span><br><span class="line">// &#123; value: 2, done: false &#125;</span><br><span class="line"></span><br><span class="line">// &#123; value: 3, done: true &#125;</span><br><span class="line"></span><br><span class="line">// &#123; value: undefined, done: true &#125;</span><br><span class="line"></span><br><span class="line">Generator 的执行有这几个关键点</span><br><span class="line">1. 调用 gen() 后，程序会阻塞住，不会执行任何语句。</span><br><span class="line">2. 调用 g.next() 后，程序继续执行，直到遇到 yield 关键词时执行暂停。</span><br><span class="line">3. 一直执行 next 方法，最后返回一个对象，其存在两个属性：value 和 done。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function* gen1() &#123;</span><br><span class="line"></span><br><span class="line">    yield 1;</span><br><span class="line"></span><br><span class="line">    yield* gen2();</span><br><span class="line"></span><br><span class="line">    yield 4;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function* gen2() &#123;</span><br><span class="line"></span><br><span class="line">    yield 2;</span><br><span class="line"></span><br><span class="line">    yield 3;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var g = gen1();</span><br><span class="line"></span><br><span class="line">console.log(g.next())</span><br><span class="line"></span><br><span class="line">console.log(g.next())</span><br><span class="line"></span><br><span class="line">console.log(g.next())</span><br><span class="line"></span><br><span class="line">console.log(g.next())</span><br><span class="line"></span><br><span class="line">// output:</span><br><span class="line"></span><br><span class="line">// &#123; value: 1, done: false &#125;</span><br><span class="line"></span><br><span class="line">// &#123; value: 2, done: false &#125;</span><br><span class="line"></span><br><span class="line">// &#123; value: 3, done: false &#125;</span><br><span class="line"></span><br><span class="line">// &#123; value: 4, done: false &#125;</span><br><span class="line"></span><br><span class="line">// &#123;value: undefined, done: true&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="thunk-函数"><a href="#thunk-函数" class="headerlink" title="thunk 函数"></a>thunk 函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">let isString = (obj) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  return Object.prototype.toString.call(obj) === &apos;[object String]&apos;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let isFunction = (obj) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  return Object.prototype.toString.call(obj) === &apos;[object Function]&apos;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let isArray = (obj) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  return Object.prototype.toString.call(obj) === &apos;[object Array]&apos;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">可以看到，其中出现了非常多重复的数据类型判断逻辑，平常业务开发中类似的重复逻辑的场景也同样会有很多。我们将它们做一下封装，如下所示。</span><br><span class="line">let isType = (type) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  return (obj) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    return Object.prototype.toString.call(obj) === `[object $&#123;type&#125;]`;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let isString = isType(&apos;String&apos;);</span><br><span class="line"></span><br><span class="line">let isArray = isType(&apos;Array&apos;);</span><br><span class="line"></span><br><span class="line">isString(&quot;123&quot;);    // true</span><br><span class="line"></span><br><span class="line">isArray([1,2,3]);   // true</span><br><span class="line">像 isType 这样的函数我们称为 thunk 函数，它的基本思路都是接收一定的参数，会生产出定制化的函数，最后使用定制化的函数去完成想要实现的功能。</span><br></pre></td></tr></table></figure>
<h4 id="Generator-和-thunk-结合"><a href="#Generator-和-thunk-结合" class="headerlink" title="Generator 和 thunk 结合"></a>Generator 和 thunk 结合</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">const readFileThunk = (filename) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  return (callback) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    fs.readFile(filename, callback);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const gen = function* () &#123;</span><br><span class="line"></span><br><span class="line">  const data1 = yield readFileThunk(&apos;1.txt&apos;)</span><br><span class="line"></span><br><span class="line">  console.log(data1.toString())</span><br><span class="line"></span><br><span class="line">  const data2 = yield readFileThunk(&apos;2.txt&apos;)</span><br><span class="line"></span><br><span class="line">  console.log(data2.toString)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let g = gen();</span><br><span class="line"></span><br><span class="line">g.next().value((err, data1) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  g.next(data1).value((err, data2) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    g.next(data2);</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">上面第三段代码执行起来嵌套的情况还算简单，如果任务多起来，就会产生很多层的嵌套，可读性不强，</span><br><span class="line">function run(gen)&#123;</span><br><span class="line"></span><br><span class="line">  const next = (err, data) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    let res = gen.next(data);</span><br><span class="line"></span><br><span class="line">    if(res.done) return;</span><br><span class="line"></span><br><span class="line">    res.value(next);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  next();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(g);</span><br></pre></td></tr></table></figure>
<h4 id="Generator-和-Promise-结合"><a href="#Generator-和-Promise-结合" class="headerlink" title="Generator 和 Promise 结合"></a>Generator 和 Promise 结合</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">// 最后包装成 Promise 对象进行返回</span><br><span class="line"></span><br><span class="line">const readFilePromise = (filename) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    fs.readFile(filename, (err, data) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">      if(err) &#123;</span><br><span class="line"></span><br><span class="line">        reject(err);</span><br><span class="line"></span><br><span class="line">      &#125;else &#123;</span><br><span class="line"></span><br><span class="line">        resolve(data);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  &#125;).then(res =&gt; res);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> let g = gen();</span><br><span class="line"></span><br><span class="line">// 这块和上面 thunk 的方式一样</span><br><span class="line"></span><br><span class="line">const gen = function* () &#123;</span><br><span class="line"></span><br><span class="line">  const data1 = yield readFilePromise(&apos;1.txt&apos;)</span><br><span class="line"></span><br><span class="line">  console.log(data1.toString())</span><br><span class="line"></span><br><span class="line">  const data2 = yield readFilePromise(&apos;2.txt&apos;)</span><br><span class="line"></span><br><span class="line">  console.log(data2.toString)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 这块和上面 thunk 的方式一样</span><br><span class="line"></span><br><span class="line">function run(gen)&#123;</span><br><span class="line"></span><br><span class="line">  const next = (err, data) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    let res = gen.next(data);</span><br><span class="line"></span><br><span class="line">    if(res.done) return;</span><br><span class="line"></span><br><span class="line">    res.value.then(next);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  next();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(g);</span><br></pre></td></tr></table></figure>
<h4 id="co-函数库"><a href="#co-函数库" class="headerlink" title="co 函数库"></a>co 函数库</h4><ul>
<li>为什么 co 函数库可以自动执行 Generator 函数，它的处理原理是什么呢？</li>
</ul>
<ol>
<li>因为 Generator 函数就是一个异步操作的容器，它需要一种自动执行机制，co 函数接受 Generator 函数作为参数，并最后返回一个 Promise 对象。</li>
<li>在返回的 Promise 对象里面，co 先检查参数 gen 是否为 Generator 函数。如果是，就执行该函数；如果不是就返回，并将 Promise 对象的状态改为 resolved。</li>
<li>co 将 Generator 函数的内部指针对象的 next 方法，包装成 onFulfilled 函数。这主要是为了能够捕捉抛出的错误。</li>
<li>关键的是 next 函数，它会反复调用自身。<h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// readFilePromise 依旧返回 Promise 对象</span><br><span class="line"></span><br><span class="line">const readFilePromise = (filename) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    fs.readFile(filename, (err, data) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">      if(err) &#123;</span><br><span class="line"></span><br><span class="line">        reject(err);</span><br><span class="line"></span><br><span class="line">      &#125;else &#123;</span><br><span class="line"></span><br><span class="line">        resolve(data);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  &#125;).then(res =&gt; res);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 这里把 Generator的 * 换成 async，把 yield 换成 await</span><br><span class="line"></span><br><span class="line">const gen = async function() &#123;</span><br><span class="line"></span><br><span class="line">  const data1 = await readFilePromise(&apos;1.txt&apos;)</span><br><span class="line"></span><br><span class="line">  console.log(data1.toString())</span><br><span class="line"></span><br><span class="line">  const data2 = await readFilePromise(&apos;2.txt&apos;)</span><br><span class="line"></span><br><span class="line">  console.log(data2.toString)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>async 函数对 Generator 函数的改进，主要体现在以下三点<br>内置执行器：Generator 函数的执行必须靠执行器，因为不能一次性执行完成，所以之后才有了开源的 co 函数库。但是，async 函数和正常的函数一样执行，也不用 co 函数库，也不用使用 next 方法，而 async 函数自带执行器，会自动执行。<br>适用性更好：co 函数库有条件约束，yield 命令后面只能是 Thunk 函数或 Promise 对象，但是 async 函数的 await 关键词后面，可以不受约束。<br>可读性更好：async 和 await，比起使用 * 号和 yield，语义更清晰明了。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">async function func() &#123;</span><br><span class="line"></span><br><span class="line">  return 100;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(func());</span><br><span class="line"></span><br><span class="line">// Promise &#123;&lt;fulfilled&gt;: 100&#125;</span><br><span class="line">从执行的结果可以看出，async 函数 func 最后返回的结果直接是 Promise 对象，比较方便让开发者继续往后处理。而之前 Generator 并不会自动执行，需要通过 next 方法控制，最后返回的也并不是 Promise 对象，而是需要通过 co 函数库来实现最后返回 Promise 对象。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="EventEmitter"><a href="#EventEmitter" class="headerlink" title="EventEmitter"></a>EventEmitter</h3><ul>
<li>Node.js的events 模块对外提供了一个 EventEmitter 对象，用于对 Node.js 中的事件进行统一管理。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var events = require(&apos;events&apos;);</span><br><span class="line"></span><br><span class="line">var eventEmitter = new events.EventEmitter();</span><br><span class="line"></span><br><span class="line">eventEmitter.on(&apos;say&apos;,function(name)&#123;</span><br><span class="line"></span><br><span class="line">    console.log(&apos;Hello&apos;,name);</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">eventEmitter.emit(&apos;say&apos;,&apos;Jonh&apos;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="addListener-和-removeListener、on-和-off-方法对比"><a href="#addListener-和-removeListener、on-和-off-方法对比" class="headerlink" title="addListener 和 removeListener、on 和 off 方法对比"></a>addListener 和 removeListener、on 和 off 方法对比</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">addListener 方法的作用是为指定事件添加一个监听器，其实和 on 方法实现的功能是一样的，on 其实就是 addListener 方法的一个别名。</span><br><span class="line">二者实现的作用是一样的，同时 removeListener 方法的作用是为移除某个事件的监听器，同样 off 也是 removeListener 的别名。</span><br><span class="line">var events = require(&apos;events&apos;);</span><br><span class="line"></span><br><span class="line">var emitter = new events.EventEmitter();</span><br><span class="line"></span><br><span class="line">function hello1(name)&#123;</span><br><span class="line"></span><br><span class="line">  console.log(&quot;hello 1&quot;,name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function hello2(name)&#123;</span><br><span class="line"></span><br><span class="line">  console.log(&quot;hello 2&quot;,name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">emitter.addListener(&apos;say&apos;,hello1);</span><br><span class="line"></span><br><span class="line">emitter.addListener(&apos;say&apos;,hello2);</span><br><span class="line"></span><br><span class="line">emitter.emit(&apos;say&apos;,&apos;John&apos;);</span><br><span class="line"></span><br><span class="line">//输出hello 1 John </span><br><span class="line"></span><br><span class="line">//输出hello 2 John</span><br><span class="line"></span><br><span class="line">emitter.removeListener(&apos;say&apos;,hello1);</span><br><span class="line"></span><br><span class="line">emitter.emit(&apos;say&apos;,&apos;John&apos;);</span><br><span class="line"></span><br><span class="line">//相应的，监听say事件的hello1事件被移除</span><br><span class="line"></span><br><span class="line">//只输出hello 2 John</span><br></pre></td></tr></table></figure>
<h4 id="removeListener-和-removeAllListeners"><a href="#removeListener-和-removeAllListeners" class="headerlink" title="removeListener 和 removeAllListeners"></a>removeListener 和 removeAllListeners</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var events = require(&apos;events&apos;);</span><br><span class="line"></span><br><span class="line">var emitter = new events.EventEmitter();</span><br><span class="line"></span><br><span class="line">function hello1(name)&#123;</span><br><span class="line"></span><br><span class="line">  console.log(&quot;hello 1&quot;,name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function hello2(name)&#123;</span><br><span class="line"></span><br><span class="line">  console.log(&quot;hello 2&quot;,name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">emitter.addListener(&apos;say&apos;,hello1);</span><br><span class="line"></span><br><span class="line">emitter.addListener(&apos;say&apos;,hello2);</span><br><span class="line"></span><br><span class="line">emitter.removeAllListeners(&apos;say&apos;);</span><br><span class="line"></span><br><span class="line">emitter.emit(&apos;say&apos;,&apos;John&apos;);</span><br><span class="line"></span><br><span class="line">//removeAllListeners 移除了所有关于 say 事件的监听</span><br><span class="line"></span><br><span class="line">//因此没有任何输出</span><br></pre></td></tr></table></figure>
<h4 id="on-和-once-方法区别"><a href="#on-和-once-方法区别" class="headerlink" title="on 和 once 方法区别"></a>on 和 once 方法区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var events = require(&apos;events&apos;);</span><br><span class="line"></span><br><span class="line">var emitter = new events.EventEmitter();</span><br><span class="line"></span><br><span class="line">function hello(name)&#123;</span><br><span class="line"></span><br><span class="line">  console.log(&quot;hello&quot;,name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">emitter.on(&apos;say&apos;,hello);</span><br><span class="line"></span><br><span class="line">emitter.emit(&apos;say&apos;,&apos;John&apos;);</span><br><span class="line"></span><br><span class="line">emitter.emit(&apos;say&apos;,&apos;Lily&apos;);</span><br><span class="line"></span><br><span class="line">emitter.emit(&apos;say&apos;,&apos;Lucy&apos;);</span><br><span class="line"></span><br><span class="line">//会输出 hello John、hello Lily、hello Lucy，之后还要加也可以继续触发</span><br><span class="line"></span><br><span class="line">emitter.once(&apos;see&apos;,hello);</span><br><span class="line"></span><br><span class="line">emitter.emit(&apos;see&apos;,&apos;Tom&apos;);</span><br><span class="line"></span><br><span class="line">//只会输出一次 hello Tom</span><br></pre></td></tr></table></figure>
<h4 id="实现一个-EventEmitter"><a href="#实现一个-EventEmitter" class="headerlink" title="实现一个 EventEmitter"></a>实现一个 EventEmitter</h4><ul>
<li>自己封装一个能在浏览器中跑的EventEmitter，并应用在你的业务代码中还是能带来不少方便的，它可以帮你实现自定义事件的订阅和发布，从而提升业务开发的便利性。</li>
<li>EventEmitter 采用的正是发布-订阅模式。</li>
<li>发布-订阅模式在观察者模式的基础上，在目标和观察者之间增加了一个调度中心。</li>
<li>在 Vue 框架中不同组件之间的通讯里，有一种解决方案叫 EventBus。和 EventEmitter的思路类似，它的基本用途是将 EventBus 作为组件传递数据的桥梁，所有组件共用相同的事件中心，可以向该中心注册发送事件或接收事件，所有组件都可以收到通知，使用起来非常便利，其核心其实就是发布-订阅模式的落地实现。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function EventEmitter() &#123;</span><br><span class="line"></span><br><span class="line">    this.__events = &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventEmitter.VERSION = &apos;1.0.0&apos;;</span><br><span class="line"></span><br><span class="line">从上面的代码中可以看到，我们先初始化了一个内部的__events 的对象，用来存放自定义事件，以及自定义事件的回调函数。</span><br><span class="line"></span><br><span class="line">EventEmitter.prototype.on = function(eventName, listener)&#123;</span><br><span class="line"></span><br><span class="line">	  if (!eventName || !listener) return;</span><br><span class="line"></span><br><span class="line">      // 判断回调的 listener 是否为函数</span><br><span class="line"></span><br><span class="line">	  if (!isValidListener(listener)) &#123;</span><br><span class="line"></span><br><span class="line">	       throw new TypeError(&apos;listener must be a function&apos;);</span><br><span class="line"></span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	   var events = this.__events;</span><br><span class="line"></span><br><span class="line">	   var listeners = events[eventName] = events[eventName] || [];</span><br><span class="line"></span><br><span class="line">	   var listenerIsWrapped = typeof listener === &apos;object&apos;;</span><br><span class="line"></span><br><span class="line">       // 不重复添加事件，判断是否有一样的</span><br><span class="line"></span><br><span class="line">       if (indexOf(listeners, listener) === -1) &#123;</span><br><span class="line"></span><br><span class="line">           listeners.push(listenerIsWrapped ? listener : &#123;</span><br><span class="line"></span><br><span class="line">               listener: listener,</span><br><span class="line"></span><br><span class="line">               once: false</span><br><span class="line"></span><br><span class="line">           &#125;);</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">	   return this;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 判断是否是合法的 listener</span><br><span class="line"></span><br><span class="line"> function isValidListener(listener) &#123;</span><br><span class="line"></span><br><span class="line">     if (typeof listener === &apos;function&apos;) &#123;</span><br><span class="line"></span><br><span class="line">         return true;</span><br><span class="line"></span><br><span class="line">     &#125; else if (listener &amp;&amp; typeof listener === &apos;object&apos;) &#123;</span><br><span class="line"></span><br><span class="line">         return isValidListener(listener.listener);</span><br><span class="line"></span><br><span class="line">     &#125; else &#123;</span><br><span class="line"></span><br><span class="line">         return false;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 顾名思义，判断新增自定义事件是否存在</span><br><span class="line"></span><br><span class="line">function indexOf(array, item) &#123;</span><br><span class="line"></span><br><span class="line">     var result = -1</span><br><span class="line"></span><br><span class="line">     item = typeof item === &apos;object&apos; ? item.listener : item;</span><br><span class="line"></span><br><span class="line">     for (var i = 0, len = array.length; i &lt; len; i++) &#123;</span><br><span class="line"></span><br><span class="line">         if (array[i].listener === item) &#123;</span><br><span class="line"></span><br><span class="line">             result = i;</span><br><span class="line"></span><br><span class="line">             break;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">从上面的代码中可以看出，on 方法的核心思路就是，当调用订阅一个自定义事件的时候，只要该事件通过校验合法之后，就把该自定义事件 push 到 this.__events 这个对象中存储，等需要出发的时候，则直接从通过获取 __events 中对应事件的 listener 回调函数，而后直接执行该回调方法就能实现想要的效果。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EventEmitter.prototype.emit = function(eventName, args) &#123;</span><br><span class="line"></span><br><span class="line">     // 直接通过内部对象获取对应自定义事件的回调函数</span><br><span class="line"></span><br><span class="line">     var listeners = this.__events[eventName];</span><br><span class="line"></span><br><span class="line">     if (!listeners) return;</span><br><span class="line"></span><br><span class="line">     // 需要考虑多个 listener 的情况</span><br><span class="line"></span><br><span class="line">     for (var i = 0; i &lt; listeners.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">         var listener = listeners[i];</span><br><span class="line"></span><br><span class="line">         if (listener) &#123;</span><br><span class="line"></span><br><span class="line">             listener.listener.apply(this, args || []);</span><br><span class="line"></span><br><span class="line">             // 给 listener 中 once 为 true 的进行特殊处理</span><br><span class="line"></span><br><span class="line">             if (listener.once) &#123;</span><br><span class="line"></span><br><span class="line">                 this.off(eventName, listener.listener)</span><br><span class="line"></span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     return this;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EventEmitter.prototype.off = function(eventName, listener) &#123;</span><br><span class="line"></span><br><span class="line">     var listeners = this.__events[eventName];</span><br><span class="line"></span><br><span class="line">     if (!listeners) return;</span><br><span class="line"></span><br><span class="line">     var index;</span><br><span class="line"></span><br><span class="line">     for (var i = 0, len = listeners.length; i &lt; len; i++) &#123;</span><br><span class="line"></span><br><span class="line">	    if (listeners[i] &amp;&amp; listeners[i].listener === listener) &#123;</span><br><span class="line"></span><br><span class="line">           index = i;</span><br><span class="line"></span><br><span class="line">           break;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // off 的关键</span><br><span class="line"></span><br><span class="line">    if (typeof index !== &apos;undefined&apos;) &#123;</span><br><span class="line"></span><br><span class="line">         listeners.splice(index, 1, null)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return this;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">从上面的代码中可以看出 emit 的处理方式，其实就是拿到对应自定义事件进行 apply 执行，在执行过程中对于一开始 once 方法绑定的自定义事件进行特殊的处理，当once 为 true的时候，再触发 off 方法对该自定义事件进行解绑，从而实现自定义事件一次执行的效果。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EventEmitter.prototype.once = function(eventName, listener）&#123;</span><br><span class="line"></span><br><span class="line">    // 直接调用 on 方法，once 参数传入 true，待执行之后进行 once 处理</span><br><span class="line"></span><br><span class="line">     return this.on(eventName, &#123;</span><br><span class="line"></span><br><span class="line">         listener: listener,</span><br><span class="line"></span><br><span class="line">         once: true</span><br><span class="line"></span><br><span class="line">     &#125;)</span><br><span class="line"></span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line">EventEmitter.prototype.allOff = function(eventName) &#123;</span><br><span class="line"></span><br><span class="line">     // 如果该 eventName 存在，则将其对应的 listeners 的数组直接清空</span><br><span class="line"></span><br><span class="line">     if (eventName &amp;&amp; this.__events[eventName]) &#123;</span><br><span class="line"></span><br><span class="line">         this.__events[eventName] = []</span><br><span class="line"></span><br><span class="line">     &#125; else &#123;</span><br><span class="line"></span><br><span class="line">         this.__events = &#123;&#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">从上面的代码中可以看到，once 方法的本质还是调用 on 方法，只不过传入的参数区分和非一次执行的情况。当再次触发 emit 方法的时候，once 绑定的执行一次之后再进行解绑。</span><br><span class="line"></span><br><span class="line">这样，alloff 方法也很好理解了，其实就是对内部的__events 对象进行清空，清空之后如果再次触发自定义事件，也就无法触发回调函数了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------------------------Low逼版，见笑了-----------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function EventEmitter() &#123;</span><br><span class="line">  this.__events = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventEmitter.VERSION = &quot;1.0.0&quot;;</span><br><span class="line"></span><br><span class="line">//绑定事件</span><br><span class="line">EventEmitter.prototype.on = function (eventName, event) &#123;</span><br><span class="line">  let events = (this.__events[eventName] = this.__events[eventName] || []);</span><br><span class="line">  //是否存在该事件</span><br><span class="line">  let isExist = events.find((ev) =&gt; ev.listener === (event.listener || event));</span><br><span class="line">  if (!isExist) &#123;</span><br><span class="line">    events.push(</span><br><span class="line">      //对象或函数</span><br><span class="line">      event.listener</span><br><span class="line">        ? event</span><br><span class="line">        : &#123;</span><br><span class="line">            once: false,</span><br><span class="line">            listener: event,</span><br><span class="line">          &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return this;</span><br><span class="line">&#125;;</span><br><span class="line">//触发事件</span><br><span class="line">EventEmitter.prototype.emit = function (eventName, args) &#123;</span><br><span class="line">  let events = this.__events[eventName] || [];</span><br><span class="line"></span><br><span class="line">  //多个事件</span><br><span class="line">  for (let event of events) &#123;</span><br><span class="line">    event.listener.apply(this, args || []);</span><br><span class="line">    if (event.once) &#123;</span><br><span class="line">      this.off(eventName, event);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//执行一次</span><br><span class="line">EventEmitter.prototype.once = function (eventName, event) &#123;</span><br><span class="line">  return this.on(eventName, &#123;</span><br><span class="line">    once: true,</span><br><span class="line">    listener: event.listener || event,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">//移除事件</span><br><span class="line">EventEmitter.prototype.off = function (eventName, event) &#123;</span><br><span class="line">  let events = this.__events[eventName] || [];</span><br><span class="line">  //事件下标</span><br><span class="line">  let eventIndex = events.findIndex(</span><br><span class="line">    (ev) =&gt; ev.listener === (event.listener || event)</span><br><span class="line">  );</span><br><span class="line">  //存在该事件时</span><br><span class="line">  if (eventIndex !== -1) events.splice(eventIndex, 1);</span><br><span class="line">&#125;;</span><br><span class="line">//移除所有事件</span><br><span class="line">EventEmitter.prototype.allOff = function (eventName) &#123;</span><br><span class="line">  if (this.__events[eventName]) this.__events[eventName] = [];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="实现符合-Promise-A-规范的-Promise"><a href="#实现符合-Promise-A-规范的-Promise" class="headerlink" title="实现符合 Promise/A+ 规范的 Promise"></a>实现符合 Promise/A+ 规范的 Promise</h3><h4 id="Promise-A-规范"><a href="#Promise-A-规范" class="headerlink" title="Promise/A+ 规范"></a>Promise/A+ 规范</h4><ul>
<li>Promise/A+ 规范的基本术语，如下所示</li>
</ul>
<ol>
<li>“promise”：是一个具有 then 方法的对象或者函数，它的行为符合该规范。</li>
<li>“thenable”：是一个定义了 then 方法的对象或者函数。</li>
<li>“value”：可以是任何一个合法的 JavaScript 的值（包括 undefined、thenable 或 promise）。</li>
<li>“exception”：是一个异常，是在 Promise 里面可以用 throw 语句抛出来的值。</li>
<li>“reason”：是一个 Promise 里 reject 之后返回的拒绝原因。</li>
</ol>
<ul>
<li>Promise/A+ 规范中，对 Promise 的内部状态的描述，如下所示</li>
</ul>
<ol>
<li>一个 Promise 有三种状态：pending、fulfilled 和 rejected。</li>
<li>当状态为 pending 状态时，即可以转换为 fulfilled 或者 rejected 其中之一。</li>
<li>当状态为 fulfilled 状态时，就不能转换为其他状态了，必须返回一个不能再改变的值。</li>
<li>当状态为 rejected 状态时，同样也不能转换为其他状态，必须有一个原因的值也不能改变</li>
</ol>
<ul>
<li>一个 Promise 必须拥有一个 then 方法来访问它的值或者拒绝原因。</li>
</ul>
<ol>
<li><code>promise.then(onFulfilled, onRejected)</code> then 方法有两个参数：onFulfilled 和 onRejected 都是可选参数。</li>
<li>如果 onFulfilled 是函数，则当 Promise 执行结束之后必须被调用，最终返回值为 value，其调用次数不可超过一次。</li>
<li>而 onRejected 除了最后返回的是 reason 外，其他方面和 onFulfilled 在规范上的表述基本一样。</li>
</ol>
<ul>
<li>then 方法其实可以被一个 Promise 调用多次，且必须返回一个 Promise 对象。<h4 id="一步步实现-Promise"><a href="#一步步实现-Promise" class="headerlink" title="一步步实现 Promise"></a>一步步实现 Promise</h4><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">Promise 构造函数接受一个 executor 函数，executor 函数执行完同步或者异步操作后，调用它的两个参数 resolve 和 reject。</span><br><span class="line">function Promise(executor) &#123;</span><br><span class="line"></span><br><span class="line">  var self = this</span><br><span class="line"></span><br><span class="line">  self.status = &apos;pending&apos;   // Promise当前的状态</span><br><span class="line"></span><br><span class="line">  self.data = undefined     // Promise的值</span><br><span class="line"></span><br><span class="line">  self.onResolvedCallback = [] // Promise resolve时的回调函数集</span><br><span class="line"></span><br><span class="line">  self.onRejectedCallback = [] // Promise reject时的回调函数集</span><br><span class="line"></span><br><span class="line">  executor(resolve, reject) // 执行executor并传入相应的参数</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">从上面的代码中可以看出，我们先定义了一个 Promise 的初始状态 pending，以及参数执行函数 executor，并且按照规范设计了一个 resolve 回调函数集合数组 onResolvedCallback 以及 一个 reject 回调函数集合数组，那么构造函数的初始化就基本完成了。</span><br><span class="line"></span><br><span class="line">function Promise(executor) &#123;</span><br><span class="line"></span><br><span class="line">  var self = this</span><br><span class="line"></span><br><span class="line">  self.status = &apos;pending&apos;   // Promise当前的状态</span><br><span class="line"></span><br><span class="line">  self.data = undefined    // Promise的值</span><br><span class="line"></span><br><span class="line">  self.onResolvedCallback = [] // Promise resolve时的回调函数集</span><br><span class="line"></span><br><span class="line">  self.onRejectedCallback = [] // Promise reject时的回调函数集</span><br><span class="line"></span><br><span class="line">  function resolve(value) &#123;</span><br><span class="line"></span><br><span class="line">    // TODO</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function reject(reason) &#123;</span><br><span class="line"></span><br><span class="line">    // TODO</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  try &#123; // 考虑到执行过程中有可能出错，所以我们用try/catch块给包起</span><br><span class="line"></span><br><span class="line">    executor(resolve, reject) // 执行executor</span><br><span class="line"></span><br><span class="line">  &#125; catch(e) &#123;</span><br><span class="line"></span><br><span class="line">    reject(e)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">resolve 和 reject 内部应该怎么实现呢？我们根据规范知道这两个方法主要做的事情就是返回对应状态的值 value 或者 reason，并把 Promise 内部的 status 从 pending 变成对应的状态，并且这个状态在改变了之后是不可以逆转的。</span><br><span class="line"></span><br><span class="line">function Promise(executor) &#123;</span><br><span class="line"></span><br><span class="line">  // ...上面的省略</span><br><span class="line"></span><br><span class="line">  function resolve(value) &#123;</span><br><span class="line"></span><br><span class="line">    if (self.status === &apos;pending&apos;) &#123;</span><br><span class="line"></span><br><span class="line">      self.status = &apos;resolved&apos;</span><br><span class="line"></span><br><span class="line">      self.data = value</span><br><span class="line"></span><br><span class="line">      for(var i = 0; i &lt; self.onResolvedCallback.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">        self.onResolvedCallback[i](value)</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  function reject(reason) &#123;</span><br><span class="line"></span><br><span class="line">    if (self.status === &apos;pending&apos;) &#123;</span><br><span class="line"></span><br><span class="line">      self.status = &apos;rejected&apos;</span><br><span class="line"></span><br><span class="line">      self.data = reason</span><br><span class="line"></span><br><span class="line">      for(var i = 0; i &lt; self.onRejectedCallback.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">        self.onRejectedCallback[i](reason)</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 下面的省略</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">上述代码所展示的，基本就是在判断状态为 pending 之后，把状态改为相应的值，并把对应的 value 和 reason 存在内部的 data 属性上面，之后执行相应的回调函数。</span><br><span class="line">逻辑比较简单，无非是由于 onResolveCallback 和 onRejectedCallback 这两个是数组，需要通过循环来执行，</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="实现-then-方法"><a href="#实现-then-方法" class="headerlink" title="实现 then 方法"></a>实现 then 方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">then 方法是 Promise 执行完之后可以拿到 value 或者 reason 的方法，并且还要保持 then 执行之后，返回的依旧是一个 Promise 方法，还要支持多次调用</span><br><span class="line">Promise.prototype.then = function(onResolved, onRejected) &#123;</span><br><span class="line"></span><br><span class="line">  var self = this</span><br><span class="line"></span><br><span class="line">  var promise2</span><br><span class="line"></span><br><span class="line">  // 根据标准，如果then的参数不是function，则需要忽略它</span><br><span class="line"></span><br><span class="line">  onResolved = typeof onResolved === &apos;function&apos; ? onResolved : function(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  onRejected = typeof onRejected === &apos;function&apos; ? onRejected : function(reason) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  if (self.status === &apos;resolved&apos;) &#123;</span><br><span class="line"></span><br><span class="line">    // 如果promise1的状态已经确定并且是resolved，我们调用onResolved，考虑到有可能throw，所以还需要将其包在try/catch块里</span><br><span class="line"></span><br><span class="line">    return promise2 = new Promise(function(resolve, reject) &#123;</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line"></span><br><span class="line">        var x = onResolved(self.data)</span><br><span class="line"></span><br><span class="line">        if (x instanceof Promise) &#123;</span><br><span class="line"></span><br><span class="line">// 如果onResolved的返回值是一个Promise对象，直接取它的结果作为promise2的结果</span><br><span class="line"></span><br><span class="line">          x.then(resolve, reject)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        resolve(x) // 否则，以它的返回值作为promise2的结果</span><br><span class="line"></span><br><span class="line">      &#125; catch (e) &#123;</span><br><span class="line"></span><br><span class="line">        reject(e) // 如果出错，以捕获到的错误作为promise2的结果</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 此处与前一个if块的逻辑几乎相同，区别在于所调用的是onRejected函数</span><br><span class="line"></span><br><span class="line">  if (self.status === &apos;rejected&apos;) &#123;</span><br><span class="line"></span><br><span class="line">    return promise2 = new Promise(function(resolve, reject) &#123;</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line"></span><br><span class="line">        var x = onRejected(self.data)</span><br><span class="line"></span><br><span class="line">        if (x instanceof Promise) &#123;</span><br><span class="line"></span><br><span class="line">          x.then(resolve, reject)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125; catch (e) &#123;</span><br><span class="line"></span><br><span class="line">        reject(e)</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (self.status === &apos;pending&apos;) &#123;</span><br><span class="line"></span><br><span class="line">  // 如果当前的Promise还处于pending状态，我们并不能确定调用onResolved还是onRejected，只能等到Promise的状态确定后，才能确定如何处理</span><br><span class="line"></span><br><span class="line">    return promise2 = new Promise(function(resolve, reject) &#123;</span><br><span class="line"></span><br><span class="line">      self.onResolvedCallback.push(function(value) &#123;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line"></span><br><span class="line">          var x = onResolved(self.data)</span><br><span class="line"></span><br><span class="line">          if (x instanceof Promise) &#123;</span><br><span class="line"></span><br><span class="line">            x.then(resolve, reject)</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line"></span><br><span class="line">          reject(e)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      self.onRejectedCallback.push(function(reason) &#123;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line"></span><br><span class="line">          var x = onRejected(self.data)</span><br><span class="line"></span><br><span class="line">          if (x instanceof Promise) &#123;</span><br><span class="line"></span><br><span class="line">            x.then(resolve, reject)</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line"></span><br><span class="line">          reject(e)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="完整版"><a href="#完整版" class="headerlink" title="完整版"></a>完整版</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">  module.exports = Promise</span><br><span class="line"></span><br><span class="line">&#125; catch (e) &#123;&#125;</span><br><span class="line"></span><br><span class="line">function Promise(executor) &#123;</span><br><span class="line"></span><br><span class="line">  var self = this</span><br><span class="line"></span><br><span class="line">  self.status = &apos;pending&apos;</span><br><span class="line"></span><br><span class="line">  self.onResolvedCallback = []</span><br><span class="line"></span><br><span class="line">  self.onRejectedCallback = []</span><br><span class="line"></span><br><span class="line">  function resolve(value) &#123;</span><br><span class="line"></span><br><span class="line">    if (value instanceof Promise) &#123;</span><br><span class="line"></span><br><span class="line">      return value.then(resolve, reject)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setTimeout(function() &#123; // 异步执行所有的回调函数</span><br><span class="line"></span><br><span class="line">      if (self.status === &apos;pending&apos;) &#123;</span><br><span class="line"></span><br><span class="line">        self.status = &apos;resolved&apos;</span><br><span class="line"></span><br><span class="line">        self.data = value</span><br><span class="line"></span><br><span class="line">        for (var i = 0; i &lt; self.onResolvedCallback.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">          self.onResolvedCallback[i](value)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function reject(reason) &#123;</span><br><span class="line"></span><br><span class="line">    setTimeout(function() &#123; // 异步执行所有的回调函数</span><br><span class="line"></span><br><span class="line">      if (self.status === &apos;pending&apos;) &#123;</span><br><span class="line"></span><br><span class="line">        self.status = &apos;rejected&apos;</span><br><span class="line"></span><br><span class="line">        self.data = reason</span><br><span class="line"></span><br><span class="line">        for (var i = 0; i &lt; self.onRejectedCallback.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">          self.onRejectedCallback[i](reason)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  try &#123;</span><br><span class="line"></span><br><span class="line">    executor(resolve, reject)</span><br><span class="line"></span><br><span class="line">  &#125; catch (reason) &#123;</span><br><span class="line"></span><br><span class="line">    reject(reason)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function resolvePromise(promise2, x, resolve, reject) &#123;</span><br><span class="line"></span><br><span class="line">  var then</span><br><span class="line"></span><br><span class="line">  var thenCalledOrThrow = false</span><br><span class="line"></span><br><span class="line">  if (promise2 === x) &#123;</span><br><span class="line"></span><br><span class="line">    return reject(new TypeError(&apos;Chaining cycle detected for promise!&apos;))</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (x instanceof Promise) &#123;</span><br><span class="line"></span><br><span class="line">    if (x.status === &apos;pending&apos;) &#123; </span><br><span class="line"></span><br><span class="line">      x.then(function(v) &#123;</span><br><span class="line"></span><br><span class="line">        resolvePromise(promise2, v, resolve, reject)</span><br><span class="line"></span><br><span class="line">      &#125;, reject)</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">      x.then(resolve, reject)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if ((x !== null) &amp;&amp; ((typeof x === &apos;object&apos;) || (typeof x === &apos;function&apos;))) &#123;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line"></span><br><span class="line">      then = x.then</span><br><span class="line"></span><br><span class="line">      if (typeof then === &apos;function&apos;) &#123;</span><br><span class="line"></span><br><span class="line">        then.call(x, function rs(y) &#123;</span><br><span class="line"></span><br><span class="line">          if (thenCalledOrThrow) return</span><br><span class="line"></span><br><span class="line">          thenCalledOrThrow = true</span><br><span class="line"></span><br><span class="line">          return resolvePromise(promise2, y, resolve, reject)</span><br><span class="line"></span><br><span class="line">        &#125;, function rj(r) &#123;</span><br><span class="line"></span><br><span class="line">          if (thenCalledOrThrow) return</span><br><span class="line"></span><br><span class="line">          thenCalledOrThrow = true</span><br><span class="line"></span><br><span class="line">          return reject(r)</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">      &#125; else &#123;</span><br><span class="line"></span><br><span class="line">        resolve(x)</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line"></span><br><span class="line">      if (thenCalledOrThrow) return</span><br><span class="line"></span><br><span class="line">      thenCalledOrThrow = true</span><br><span class="line"></span><br><span class="line">      return reject(e)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125; else &#123;</span><br><span class="line"></span><br><span class="line">    resolve(x)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise.prototype.then = function(onResolved, onRejected) &#123;</span><br><span class="line"></span><br><span class="line">  var self = this</span><br><span class="line"></span><br><span class="line">  var promise2</span><br><span class="line"></span><br><span class="line">  onResolved = typeof onResolved === &apos;function&apos; ? onResolved : function(v) &#123;</span><br><span class="line"></span><br><span class="line">    return v</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onRejected = typeof onRejected === &apos;function&apos; ? onRejected : function(r) &#123;</span><br><span class="line"></span><br><span class="line">    throw r</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (self.status === &apos;resolved&apos;) &#123;</span><br><span class="line"></span><br><span class="line">    return promise2 = new Promise(function(resolve, reject) &#123;</span><br><span class="line"></span><br><span class="line">      setTimeout(function() &#123; // 异步执行onResolved</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line"></span><br><span class="line">          var x = onResolved(self.data)</span><br><span class="line"></span><br><span class="line">          resolvePromise(promise2, x, resolve, reject)</span><br><span class="line"></span><br><span class="line">        &#125; catch (reason) &#123;</span><br><span class="line"></span><br><span class="line">          reject(reason)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (self.status === &apos;rejected&apos;) &#123;</span><br><span class="line"></span><br><span class="line">    return promise2 = new Promise(function(resolve, reject) &#123;</span><br><span class="line"></span><br><span class="line">      setTimeout(function() &#123; // 异步执行onRejected</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line"></span><br><span class="line">          var x = onRejected(self.data)</span><br><span class="line"></span><br><span class="line">          resolvePromise(promise2, x, resolve, reject)</span><br><span class="line"></span><br><span class="line">        &#125; catch (reason) &#123;</span><br><span class="line"></span><br><span class="line">          reject(reason)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (self.status === &apos;pending&apos;) &#123;</span><br><span class="line"></span><br><span class="line">    // 这里之所以没有异步执行，是因为这些函数必然会被resolve或reject调用，而resolve或reject函数里的内容已是异步执行，构造函数里的定义</span><br><span class="line"></span><br><span class="line">    return promise2 = new Promise(function(resolve, reject) &#123;</span><br><span class="line"></span><br><span class="line">      self.onResolvedCallback.push(function(value) &#123;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line"></span><br><span class="line">          var x = onResolved(value)</span><br><span class="line"></span><br><span class="line">          resolvePromise(promise2, x, resolve, reject)</span><br><span class="line"></span><br><span class="line">        &#125; catch (r) &#123;</span><br><span class="line"></span><br><span class="line">          reject(r)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      self.onRejectedCallback.push(function(reason) &#123;</span><br><span class="line"></span><br><span class="line">          try &#123;</span><br><span class="line"></span><br><span class="line">            var x = onRejected(reason)</span><br><span class="line"></span><br><span class="line">            resolvePromise(promise2, x, resolve, reject)</span><br><span class="line"></span><br><span class="line">          &#125; catch (r) &#123;</span><br><span class="line"></span><br><span class="line">            reject(r)</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise.prototype.catch = function(onRejected) &#123;</span><br><span class="line"></span><br><span class="line">  return this.then(null, onRejected)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 最后这个是测试用的，后面会说</span><br><span class="line"></span><br><span class="line">Promise.deferred = Promise.defer = function() &#123;</span><br><span class="line"></span><br><span class="line">  var dfd = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  dfd.promise = new Promise(function(resolve, reject) &#123;</span><br><span class="line"></span><br><span class="line">    dfd.resolve = resolve</span><br><span class="line"></span><br><span class="line">    dfd.reject = reject</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  return dfd</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="另一版"><a href="#另一版" class="headerlink" title="另一版"></a>另一版</h5><ul>
<li>微信公众号文章：<a href="https://mp.weixin.qq.com/s/C-U93BmK0U_iw3sqG0g70g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/C-U93BmK0U_iw3sqG0g70g</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line">// MyPromise.js</span><br><span class="line"></span><br><span class="line">// 先定义三个常量表示状态</span><br><span class="line">const PENDING = &apos;pending&apos;;</span><br><span class="line">const FULFILLED = &apos;fulfilled&apos;;</span><br><span class="line">const REJECTED = &apos;rejected&apos;;</span><br><span class="line"></span><br><span class="line">// 新建 MyPromise 类</span><br><span class="line">class MyPromise &#123;</span><br><span class="line">  constructor(executor)&#123;</span><br><span class="line">    // executor 是一个执行器，进入会立即执行</span><br><span class="line">    // 并传入resolve和reject方法</span><br><span class="line">    try &#123;</span><br><span class="line">      executor(this.resolve, this.reject)</span><br><span class="line">    &#125; catch (error) &#123;</span><br><span class="line">      this.reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 储存状态的变量，初始值是 pending</span><br><span class="line">  status = PENDING;</span><br><span class="line">  // 成功之后的值</span><br><span class="line">  value = null;</span><br><span class="line">  // 失败之后的原因</span><br><span class="line">  reason = null;</span><br><span class="line"></span><br><span class="line">  // 存储成功回调函数</span><br><span class="line">  onFulfilledCallbacks = [];</span><br><span class="line">  // 存储失败回调函数</span><br><span class="line">  onRejectedCallbacks = [];</span><br><span class="line"></span><br><span class="line">  // 更改成功后的状态</span><br><span class="line">  resolve = (value) =&gt; &#123;</span><br><span class="line">    // 只有状态是等待，才执行状态修改</span><br><span class="line">    if (this.status === PENDING) &#123;</span><br><span class="line">      // 状态修改为成功</span><br><span class="line">      this.status = FULFILLED;</span><br><span class="line">      // 保存成功之后的值</span><br><span class="line">      this.value = value;</span><br><span class="line">      // resolve里面将所有成功的回调拿出来执行</span><br><span class="line">      while (this.onFulfilledCallbacks.length) &#123;</span><br><span class="line">        // Array.shift() 取出数组第一个元素，然后（）调用，shift不是纯函数，取出后，数组将失去该元素，直到数组为空</span><br><span class="line">        this.onFulfilledCallbacks.shift()(value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 更改失败后的状态</span><br><span class="line">  reject = (reason) =&gt; &#123;</span><br><span class="line">    // 只有状态是等待，才执行状态修改</span><br><span class="line">    if (this.status === PENDING) &#123;</span><br><span class="line">      // 状态成功为失败</span><br><span class="line">      this.status = REJECTED;</span><br><span class="line">      // 保存失败后的原因</span><br><span class="line">      this.reason = reason;</span><br><span class="line">      // resolve里面将所有失败的回调拿出来执行</span><br><span class="line">      while (this.onRejectedCallbacks.length) &#123;</span><br><span class="line">        this.onRejectedCallbacks.shift()(reason)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  then(onFulfilled, onRejected) &#123;</span><br><span class="line">    const realOnFulfilled = typeof onFulfilled === &apos;function&apos; ? onFulfilled : value =&gt; value;</span><br><span class="line">    const realOnRejected = typeof onRejected === &apos;function&apos; ? onRejected : reason =&gt; &#123;throw reason&#125;;</span><br><span class="line"></span><br><span class="line">    // 为了链式调用这里直接创建一个 MyPromise，并在后面 return 出去</span><br><span class="line">    const promise2 = new MyPromise((resolve, reject) =&gt; &#123;</span><br><span class="line">      const fulfilledMicrotask = () =&gt;  &#123;</span><br><span class="line">        // 创建一个微任务等待 promise2 完成初始化</span><br><span class="line">        queueMicrotask(() =&gt; &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">            // 获取成功回调函数的执行结果</span><br><span class="line">            const x = realOnFulfilled(this.value);</span><br><span class="line">            // 传入 resolvePromise 集中处理</span><br><span class="line">            resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">          &#125; catch (error) &#123;</span><br><span class="line">            reject(error)</span><br><span class="line">          &#125; </span><br><span class="line">        &#125;)  </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      const rejectedMicrotask = () =&gt; &#123; </span><br><span class="line">        // 创建一个微任务等待 promise2 完成初始化</span><br><span class="line">        queueMicrotask(() =&gt; &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">            // 调用失败回调，并且把原因返回</span><br><span class="line">            const x = realOnRejected(this.reason);</span><br><span class="line">            // 传入 resolvePromise 集中处理</span><br><span class="line">            resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">          &#125; catch (error) &#123;</span><br><span class="line">            reject(error)</span><br><span class="line">          &#125; </span><br><span class="line">        &#125;) </span><br><span class="line">      &#125;</span><br><span class="line">      // 判断状态</span><br><span class="line">      if (this.status === FULFILLED) &#123;</span><br><span class="line">        fulfilledMicrotask() </span><br><span class="line">      &#125; else if (this.status === REJECTED) &#123; </span><br><span class="line">        rejectedMicrotask()</span><br><span class="line">      &#125; else if (this.status === PENDING) &#123;</span><br><span class="line">        // 等待</span><br><span class="line">        // 因为不知道后面状态的变化情况，所以将成功回调和失败回调存储起来</span><br><span class="line">        // 等到执行成功失败函数的时候再传递</span><br><span class="line">        this.onFulfilledCallbacks.push(fulfilledMicrotask);</span><br><span class="line">        this.onRejectedCallbacks.push(rejectedMicrotask);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;) </span><br><span class="line">    </span><br><span class="line">    return promise2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // resolve 静态方法</span><br><span class="line">  static resolve (parameter) &#123;</span><br><span class="line">    // 如果传入 MyPromise 就直接返回</span><br><span class="line">    if (parameter instanceof MyPromise) &#123;</span><br><span class="line">      return parameter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 转成常规方式</span><br><span class="line">    return new MyPromise(resolve =&gt;  &#123;</span><br><span class="line">      resolve(parameter);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // reject 静态方法</span><br><span class="line">  static reject (reason) &#123;</span><br><span class="line">    return new MyPromise((resolve, reject) =&gt; &#123;</span><br><span class="line">      reject(reason);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function resolvePromise(promise2, x, resolve, reject) &#123;</span><br><span class="line">  // 如果相等了，说明return的是自己，抛出类型错误并返回</span><br><span class="line">  if (promise2 === x) &#123;</span><br><span class="line">    return reject(new TypeError(&apos;Chaining cycle detected for promise #&lt;Promise&gt;&apos;))</span><br><span class="line">  &#125;</span><br><span class="line">  // 判断x是不是 MyPromise 实例对象</span><br><span class="line">  if(x instanceof MyPromise) &#123;</span><br><span class="line">    // 执行 x，调用 then 方法，目的是将其状态变为 fulfilled 或者 rejected</span><br><span class="line">    // x.then(value =&gt; resolve(value), reason =&gt; reject(reason))</span><br><span class="line">    // 简化之后</span><br><span class="line">    x.then(resolve, reject)</span><br><span class="line">  &#125; else&#123;</span><br><span class="line">    // 普通值</span><br><span class="line">    resolve(x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = MyPromise;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上面是公众号文章分享的<br>下面是自己的再次实现，根据自己理解加了一些注释<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line">class APromise &#123;</span><br><span class="line">  //容器状态</span><br><span class="line">  status = &quot;pending&quot;;</span><br><span class="line">  //处理成功时的容器值</span><br><span class="line">  value = &quot;&quot;;</span><br><span class="line">  //处理失败时的原因</span><br><span class="line">  reason = &quot;&quot;;</span><br><span class="line">  //处理成功回调函数     then方法被多次调用时，采用数组进行存储回调函数</span><br><span class="line">  fullFilledCallbacks = [];</span><br><span class="line">  //处理失败回调函数</span><br><span class="line">  rejectedCallBacks = [];</span><br><span class="line">  //处理成功</span><br><span class="line">  resolve = (value) =&gt; &#123;</span><br><span class="line">    if (this.status === &quot;pending&quot;) &#123;</span><br><span class="line">      this.status = &quot;fullFilled&quot;;</span><br><span class="line">      this.value = value;</span><br><span class="line"></span><br><span class="line">      //处理成功回调</span><br><span class="line">      while (this.fullFilledCallbacks.length) &#123;</span><br><span class="line">        this.fullFilledCallbacks.shift()(value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  //处理成败</span><br><span class="line">  reject = (reason) =&gt; &#123;</span><br><span class="line">    if (this.status === &quot;pending&quot;) &#123;</span><br><span class="line">      this.status = &quot;rejected&quot;;</span><br><span class="line">      this.reason = reason;</span><br><span class="line"></span><br><span class="line">      //处理失败回调</span><br><span class="line">      while (this.rejectedCallBacks.length) &#123;</span><br><span class="line">        this.rejectedCallBacks.shift()(reason);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  //处理then方法回调函数返回值</span><br><span class="line">  resolvePromise = (promise, res, resolve, reject) =&gt; &#123;</span><br><span class="line">    //then方法成功回调返回值和then方法返回值一样时</span><br><span class="line">    if (promise === res) &#123;</span><br><span class="line">      //避免循环引用</span><br><span class="line">      reject(new TypeError(&quot;Chaining cycle detected for promise #&lt;Promise&gt;&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //返回值为promise（这里的promise指then方法成功回调时返回的promise）时</span><br><span class="line">    if (res instanceof APromise) &#123;</span><br><span class="line">      //对返回的promise（这里的promise指then方法成功回调时返回的promise）的处理结果进行处理</span><br><span class="line">      //通过resolve/reject对返回的promise（这里的promise指调用then方法时返回的promise）状态进行处理</span><br><span class="line">      res.then(resolve, reject);</span><br><span class="line">    &#125;</span><br><span class="line">    //普通值</span><br><span class="line">    else &#123;</span><br><span class="line">      resolve(res);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  //处理完成   (rejected/pending逻辑参考fullFilled状态)</span><br><span class="line">  then = (onFullFilled, onRejected) =&gt; &#123;</span><br><span class="line">    // 如果不传，就使用默认函数</span><br><span class="line">    onFullFilled =</span><br><span class="line">      typeof onFullFilled === &quot;function&quot; ? onFullFilled : (value) =&gt; value;</span><br><span class="line">    // 如果不传，就使用默认函数</span><br><span class="line">    onRejected =</span><br><span class="line">      typeof onRejected === &quot;function&quot;</span><br><span class="line">        ? onRejected</span><br><span class="line">        : (reason) =&gt; &#123;</span><br><span class="line">            throw reason;</span><br><span class="line">          &#125;;</span><br><span class="line"></span><br><span class="line">    //返回promise用于链式调用</span><br><span class="line">    const promise = new APromise((resolve, reject) =&gt; &#123;</span><br><span class="line">      //成功回调</span><br><span class="line">      if (this.status === &quot;fullFilled&quot;) &#123;</span><br><span class="line">        // 为了拿到上面返回的promise实例对象，需要创建一个微任务等待promise初始化</span><br><span class="line">        //否则，会报ReferenceError: Cannot access &apos;promise&apos; before initialization</span><br><span class="line">        queueMicrotask(() =&gt; &#123;</span><br><span class="line">          //异常捕获</span><br><span class="line">          try &#123;</span><br><span class="line">            const res = onFullFilled(this.value);</span><br><span class="line">            this.resolvePromise(promise, res, resolve, reject);</span><br><span class="line">          &#125; catch (error) &#123;</span><br><span class="line">            reject(error);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      //失败回调</span><br><span class="line">      if (this.status === &quot;rejected&quot;) &#123;</span><br><span class="line">        queueMicrotask(() =&gt; &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">            const res = onRejected(this.reason);</span><br><span class="line">            this.resolvePromise(promise, res, resolve, reject);</span><br><span class="line">          &#125; catch (error) &#123;</span><br><span class="line">            reject(error);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      //处理异步任务</span><br><span class="line">      if (this.status === &quot;pending&quot;) &#123;</span><br><span class="line">        //对成功、失败回调进行存储。异步任务执行成功后再进行处理</span><br><span class="line">        //对成功处理函数存储</span><br><span class="line">        this.fullFilledCallbacks.push(() =&gt; &#123;</span><br><span class="line">          //异常捕获</span><br><span class="line">          try &#123;</span><br><span class="line">            const res = onFullFilled(this.value);</span><br><span class="line">            this.resolvePromise(promise, res, resolve, reject);</span><br><span class="line">          &#125; catch (error) &#123;</span><br><span class="line">            reject(error);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        //对失败处理函数进行存储</span><br><span class="line">        this.rejectedCallBacks.push(() =&gt; &#123;</span><br><span class="line">          queueMicrotask(() =&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">              const res = onRejected(this.reason);</span><br><span class="line">              this.resolvePromise(promise, res, resolve, reject);</span><br><span class="line">            &#125; catch (error) &#123;</span><br><span class="line">              reject(error);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return promise;</span><br><span class="line">  &#125;;</span><br><span class="line">  constructor(executor) &#123;</span><br><span class="line">    //异常捕获</span><br><span class="line">    try &#123;</span><br><span class="line">      //执行器</span><br><span class="line">      executor(this.resolve, this.reject);</span><br><span class="line">    &#125; catch (error) &#123;</span><br><span class="line">      console.log(error);</span><br><span class="line">      this.reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default APromise;</span><br></pre></td></tr></table></figure></p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul>
<li>可以毫不夸张地说，不深入地了解数组，就不足以写好 JavaScript。<h3 id="数组构造器"><a href="#数组构造器" class="headerlink" title="数组构造器"></a>数组构造器</h3></li>
<li>new Array(arg1, arg2,…)，参数长度为 0 或长度大于等于 2 时，传入的参数将按照顺序依次成为新数组的第 0 至第 N 项（参数长度为 0 时，返回空数组）；</li>
<li>new Array(len)，当 len 不是数值时，处理同上，返回一个只包含 len 元素一项的数组；当 len 为数值时，len 最大不能超过 32 位无符号整型，即需要小于 2 的 32 次方（len 最大为 Math.pow(2,32)），否则将抛出 RangeError。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 使用 Array 构造器，可以自定义长度</span><br><span class="line"></span><br><span class="line">var a = Array(6); // [empty × 6]</span><br><span class="line"></span><br><span class="line">// 使用对象字面量</span><br><span class="line"></span><br><span class="line">var b = [];</span><br><span class="line"></span><br><span class="line">b.length = 6; // [empty × 6]</span><br><span class="line"></span><br><span class="line">let arr3=Array(6,8,9)</span><br><span class="line">console.log(arr3);  //[6, 8, 9]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="新增的构造方法"><a href="#新增的构造方法" class="headerlink" title="新增的构造方法"></a>新增的构造方法</h3><h4 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of"></a>Array.of</h4><ul>
<li>它基本上与 Array 构造器功能一致，唯一的区别就在单个数字参数的处理上。</li>
<li>：当参数为两个时，返回的结果是一致的；当参数是一个时，Array.of 会把参数变成数组里的一项，而构造器则会生成长度和第一个参数相同的空数组。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Array.of(8.0); // [8]</span><br><span class="line"></span><br><span class="line">Array(8.0); // [empty × 8]</span><br><span class="line"></span><br><span class="line">Array.of(8.0, 5); // [8, 5]</span><br><span class="line"></span><br><span class="line">Array(8.0, 5); // [8, 5]</span><br><span class="line"></span><br><span class="line">Array.of(&apos;8&apos;); // [&quot;8&quot;]</span><br><span class="line"></span><br><span class="line">Array(&apos;8&apos;); // [&quot;8&quot;]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from"></a>Array.from</h4><ul>
<li>Array.from 的设计初衷是快速便捷地基于其他对象创建新数组，准确来说就是从一个类似数组的可迭代对象中创建一个新的数组实例。其实就是，只要一个对象有迭代器，Array.from 就能把它变成一个数组（注意：是返回新的数组，不改变原对象）。</li>
<li>Array.from 拥有 3 个参数：</li>
</ul>
<ol>
<li>类似数组的对象，必选；</li>
<li>加工函数，新生成的数组会经过该函数的加工再返回；</li>
<li>this 作用域，表示加工函数执行时 this 的值。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;0: &apos;a&apos;, 1: &apos;b&apos;, 2:&apos;c&apos;, length: 3&#125;;</span><br><span class="line"></span><br><span class="line">Array.from(obj, function(value, index)&#123;</span><br><span class="line"></span><br><span class="line">  console.log(value, index, this, arguments.length);</span><br><span class="line"></span><br><span class="line">  return value.repeat(3);   //必须指定返回值，否则返回 undefined</span><br><span class="line"></span><br><span class="line">&#125;, obj);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><p>如果这里不指定 this 的话，加工函数完全可以是一个箭头函数。上述代码可以简写为如下形式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Array.from(obj, (value) =&gt; value.repeat(3));</span><br><span class="line"></span><br><span class="line">//  控制台返回 (3) [&quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot;]</span><br></pre></td></tr></table></figure>
</li>
<li><p>拥有迭代器的对象还包括 String、Set、Map 等，Array.from 统统可以处理，请看下面的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// String</span><br><span class="line"></span><br><span class="line">Array.from(&apos;abc&apos;);         // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line"></span><br><span class="line">// Set</span><br><span class="line"></span><br><span class="line">Array.from(new Set([&apos;abc&apos;, &apos;def&apos;])); // [&quot;abc&quot;, &quot;def&quot;]</span><br><span class="line"></span><br><span class="line">// Map</span><br><span class="line"></span><br><span class="line">Array.from(new Map([[1, &apos;ab&apos;], [2, &apos;de&apos;]])); </span><br><span class="line"></span><br><span class="line">// [[1, &apos;ab&apos;], [2, &apos;de&apos;]]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Array-的判断"><a href="#Array-的判断" class="headerlink" title="Array 的判断"></a>Array 的判断</h3><ul>
<li><p>在 ES5 提供该方法之前，我们至少有如下 5 种方式去判断一个变量是否为数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var a = [];</span><br><span class="line"></span><br><span class="line">// 1.基于instanceof</span><br><span class="line"></span><br><span class="line">a instanceof Array;</span><br><span class="line"></span><br><span class="line">// 2.基于constructor</span><br><span class="line"></span><br><span class="line">a.constructor === Array;</span><br><span class="line"></span><br><span class="line">// 3.基于Object.prototype.isPrototypeOf</span><br><span class="line"></span><br><span class="line">Array.prototype.isPrototypeOf(a);</span><br><span class="line"></span><br><span class="line">// 4.基于getPrototypeOf</span><br><span class="line"></span><br><span class="line">Object.getPrototypeOf(a) === Array.prototype;</span><br><span class="line"></span><br><span class="line">// 5.基于Object.prototype.toString</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.apply(a) === &apos;[object Array]&apos;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ES6 之后新增了一个 Array.isArray 方法，能直接判断数据类型是否为数组，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">如果 isArray 不存在，那么 Array.isArray 的 polyfill 通常可以这样写：</span><br><span class="line">if (!Array.isArray)&#123;</span><br><span class="line"></span><br><span class="line">  Array.isArray = function(arg)&#123;</span><br><span class="line"></span><br><span class="line">    return Object.prototype.toString.call(arg) === &apos;[object Array]&apos;;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="改变自身的方法"><a href="#改变自身的方法" class="headerlink" title="改变自身的方法"></a>改变自身的方法</h3><ul>
<li>基于 ES6，会改变自身值的方法一共有 9 个，分别为 pop、push、reverse、shift、sort、splice、unshift，以及两个 ES6 新增的方法 copyWithin 和 fill。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">// pop方法</span><br><span class="line"></span><br><span class="line">var array = [&quot;cat&quot;, &quot;dog&quot;, &quot;cow&quot;, &quot;chicken&quot;, &quot;mouse&quot;];</span><br><span class="line"></span><br><span class="line">var item = array.pop();</span><br><span class="line"></span><br><span class="line">console.log(array); // [&quot;cat&quot;, &quot;dog&quot;, &quot;cow&quot;, &quot;chicken&quot;]</span><br><span class="line"></span><br><span class="line">console.log(item); // mouse</span><br><span class="line"></span><br><span class="line">// push方法</span><br><span class="line"></span><br><span class="line">var array = [&quot;football&quot;, &quot;basketball&quot;,  &quot;badminton&quot;];</span><br><span class="line"></span><br><span class="line">var i = array.push(&quot;golfball&quot;);</span><br><span class="line"></span><br><span class="line">console.log(array); </span><br><span class="line"></span><br><span class="line">// [&quot;football&quot;, &quot;basketball&quot;, &quot;badminton&quot;, &quot;golfball&quot;]</span><br><span class="line"></span><br><span class="line">console.log(i); // 4</span><br><span class="line"></span><br><span class="line">// reverse方法</span><br><span class="line"></span><br><span class="line">var array = [1,2,3,4,5];</span><br><span class="line"></span><br><span class="line">var array2 = array.reverse();</span><br><span class="line"></span><br><span class="line">console.log(array); // [5,4,3,2,1]</span><br><span class="line"></span><br><span class="line">console.log(array2===array); // true</span><br><span class="line"></span><br><span class="line">// shift方法</span><br><span class="line"></span><br><span class="line">var array = [1,2,3,4,5];</span><br><span class="line"></span><br><span class="line">var item = array.shift();</span><br><span class="line"></span><br><span class="line">console.log(array); // [2,3,4,5]</span><br><span class="line"></span><br><span class="line">console.log(item); // 1</span><br><span class="line"></span><br><span class="line">// unshift方法</span><br><span class="line"></span><br><span class="line">var array = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];</span><br><span class="line"></span><br><span class="line">var length = array.unshift(&quot;yellow&quot;);</span><br><span class="line"></span><br><span class="line">console.log(array); // [&quot;yellow&quot;, &quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]</span><br><span class="line"></span><br><span class="line">console.log(length); // 4</span><br><span class="line"></span><br><span class="line">// sort方法</span><br><span class="line"></span><br><span class="line">var array = [&quot;apple&quot;,&quot;Boy&quot;,&quot;Cat&quot;,&quot;dog&quot;];</span><br><span class="line"></span><br><span class="line">var array2 = array.sort();</span><br><span class="line"></span><br><span class="line">console.log(array); // [&quot;Boy&quot;, &quot;Cat&quot;, &quot;apple&quot;, &quot;dog&quot;]</span><br><span class="line"></span><br><span class="line">console.log(array2 == array); // true</span><br><span class="line"></span><br><span class="line">// splice方法</span><br><span class="line"></span><br><span class="line">var array = [&quot;apple&quot;,&quot;boy&quot;];</span><br><span class="line"></span><br><span class="line">var splices = array.splice(1,1);</span><br><span class="line"></span><br><span class="line">console.log(array); // [&quot;apple&quot;]</span><br><span class="line"></span><br><span class="line">console.log(splices); // [&quot;boy&quot;]</span><br><span class="line"></span><br><span class="line">// copyWithin方法</span><br><span class="line"></span><br><span class="line">var array = [1,2,3,4,5]; </span><br><span class="line"></span><br><span class="line">var array2 = array.copyWithin(0,3);</span><br><span class="line"></span><br><span class="line">console.log(array===array2,array2);  // true [4, 5, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">// fill方法</span><br><span class="line"></span><br><span class="line">var array = [1,2,3,4,5];</span><br><span class="line"></span><br><span class="line">var array2 = array.fill(10,0,3);</span><br><span class="line"></span><br><span class="line">console.log(array===array2,array2); </span><br><span class="line"></span><br><span class="line">// true [10, 10, 10, 4, 5], 可见数组区间[0,3]的元素全部替换为10</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="不改变自身的方法"><a href="#不改变自身的方法" class="headerlink" title="不改变自身的方法"></a>不改变自身的方法</h3><ul>
<li>基于 ES7，不会改变自身的方法也有 9 个，分别为 concat、join、slice、toString、toLocaleString、indexOf、lastIndexOf、未形成标准的 toSource，以及 ES7 新增的方法 includes。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">// concat方法</span><br><span class="line"></span><br><span class="line">var array = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">var array2 = array.concat(4,[5,6],[7,8,9]);</span><br><span class="line"></span><br><span class="line">console.log(array2); // [1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line"></span><br><span class="line">console.log(array); // [1, 2, 3], 可见原数组并未被修改</span><br><span class="line"></span><br><span class="line">// join方法</span><br><span class="line"></span><br><span class="line">var array = [&apos;We&apos;, &apos;are&apos;, &apos;Chinese&apos;];</span><br><span class="line"></span><br><span class="line">console.log(array.join()); // &quot;We,are,Chinese&quot;</span><br><span class="line"></span><br><span class="line">console.log(array.join(&apos;+&apos;)); // &quot;We+are+Chinese&quot;</span><br><span class="line"></span><br><span class="line">// slice方法</span><br><span class="line"></span><br><span class="line">var array = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;,&quot;four&quot;, &quot;five&quot;];</span><br><span class="line"></span><br><span class="line">console.log(array.slice()); // [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;,&quot;four&quot;, &quot;five&quot;]</span><br><span class="line"></span><br><span class="line">console.log(array.slice(2,3)); // [&quot;three&quot;]</span><br><span class="line"></span><br><span class="line">// toString方法</span><br><span class="line"></span><br><span class="line">var array = [&apos;Jan&apos;, &apos;Feb&apos;, &apos;Mar&apos;, &apos;Apr&apos;];</span><br><span class="line"></span><br><span class="line">var str = array.toString();</span><br><span class="line"></span><br><span class="line">console.log(str); // Jan,Feb,Mar,Apr</span><br><span class="line"></span><br><span class="line">// tolocalString方法</span><br><span class="line"></span><br><span class="line">var array= [&#123;name:&apos;zz&apos;&#125;, 123, &quot;abc&quot;, new Date()];</span><br><span class="line"></span><br><span class="line">var str = array.toLocaleString();</span><br><span class="line"></span><br><span class="line">console.log(str); // [object Object],123,abc,2016/1/5 下午1:06:23</span><br><span class="line"></span><br><span class="line">// indexOf方法</span><br><span class="line"></span><br><span class="line">var array = [&apos;abc&apos;, &apos;def&apos;, &apos;ghi&apos;,&apos;123&apos;];</span><br><span class="line"></span><br><span class="line">console.log(array.indexOf(&apos;def&apos;)); // 1</span><br><span class="line"></span><br><span class="line">// includes方法</span><br><span class="line"></span><br><span class="line">var array = [-0, 1, 2];</span><br><span class="line"></span><br><span class="line">console.log(array.includes(+0)); // true</span><br><span class="line"></span><br><span class="line">console.log(array.includes(1)); // true</span><br><span class="line"></span><br><span class="line">var array = [NaN];</span><br><span class="line"></span><br><span class="line">console.log(array.includes(NaN)); // true</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="数组遍历的方法"><a href="#数组遍历的方法" class="headerlink" title="数组遍历的方法"></a>数组遍历的方法</h3><ul>
<li>基于 ES6，不会改变自身的遍历方法一共有 12 个，分别为 forEach、every、some、filter、map、reduce、reduceRight，以及 ES6 新增的方法 entries、find、findIndex、keys、values。</li>
<li><p>其中，要注意有些遍历方法不会返回处理之后的数组，比如 forEach；有些方法会返回处理之后的数组，比如 filter。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line">// forEach方法</span><br><span class="line"></span><br><span class="line">var array = [1, 3, 5];</span><br><span class="line"></span><br><span class="line">var obj = &#123;name:&apos;cc&apos;&#125;;</span><br><span class="line"></span><br><span class="line">var sReturn = array.forEach(function(value, index, array)&#123;</span><br><span class="line"></span><br><span class="line">  array[index] = value;</span><br><span class="line"></span><br><span class="line">  console.log(this.name); // cc被打印了三次, this指向obj</span><br><span class="line"></span><br><span class="line">&#125;,obj);</span><br><span class="line"></span><br><span class="line">console.log(array); // [1, 3, 5]</span><br><span class="line"></span><br><span class="line">console.log(sReturn); // undefined, 可见返回值为undefined</span><br><span class="line"></span><br><span class="line">// every方法</span><br><span class="line"></span><br><span class="line">var o = &#123;0:10, 1:8, 2:25, length:3&#125;;</span><br><span class="line"></span><br><span class="line">var bool = Array.prototype.every.call(o,function(value, index, obj)&#123;</span><br><span class="line"></span><br><span class="line">  return value &gt;= 8;</span><br><span class="line"></span><br><span class="line">&#125;,o);</span><br><span class="line"></span><br><span class="line">console.log(bool); // true</span><br><span class="line"></span><br><span class="line">// some方法</span><br><span class="line"></span><br><span class="line">var array = [18, 9, 10, 35, 80];</span><br><span class="line"></span><br><span class="line">var isExist = array.some(function(value, index, array)&#123;</span><br><span class="line"></span><br><span class="line">  return value &gt; 20;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(isExist); // true </span><br><span class="line"></span><br><span class="line">// map 方法</span><br><span class="line"></span><br><span class="line">var array = [18, 9, 10, 35, 80];</span><br><span class="line"></span><br><span class="line">array.map(item =&gt; item + 1);</span><br><span class="line"></span><br><span class="line">console.log(array);  // [19, 10, 11, 36, 81]</span><br><span class="line"></span><br><span class="line">// filter 方法</span><br><span class="line"></span><br><span class="line">var array = [18, 9, 10, 35, 80];</span><br><span class="line"></span><br><span class="line">var array2 = array.filter(function(value, index, array)&#123;</span><br><span class="line"></span><br><span class="line">  return value &gt; 20;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(array2); // [35, 80]</span><br><span class="line"></span><br><span class="line">// reduce方法</span><br><span class="line"></span><br><span class="line">var array = [1, 2, 3, 4];</span><br><span class="line"></span><br><span class="line">var s = array.reduce(function(previousValue, value, index, array)&#123;</span><br><span class="line"></span><br><span class="line">  return previousValue * value;</span><br><span class="line"></span><br><span class="line">&#125;,1);</span><br><span class="line"></span><br><span class="line">console.log(s); // 24</span><br><span class="line"></span><br><span class="line">// ES6写法更加简洁</span><br><span class="line"></span><br><span class="line">array.reduce((p, v) =&gt; p * v); // 24</span><br><span class="line"></span><br><span class="line">// reduceRight方法 (和reduce的区别就是从后往前累计)</span><br><span class="line"></span><br><span class="line">var array = [1, 2, 3, 4];</span><br><span class="line"></span><br><span class="line">array.reduceRight((p, v) =&gt; p * v); // 24</span><br><span class="line"></span><br><span class="line">// entries方法</span><br><span class="line"></span><br><span class="line">var array = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];</span><br><span class="line"></span><br><span class="line">var iterator = array.entries();</span><br><span class="line"></span><br><span class="line">console.log(iterator.next().value); // [0, &quot;a&quot;]</span><br><span class="line"></span><br><span class="line">console.log(iterator.next().value); // [1, &quot;b&quot;]</span><br><span class="line"></span><br><span class="line">console.log(iterator.next().value); // [2, &quot;c&quot;]</span><br><span class="line"></span><br><span class="line">console.log(iterator.next().value); // undefined, 迭代器处于数组末尾时, 再迭代就会返回undefined</span><br><span class="line"></span><br><span class="line">// find &amp; findIndex方法</span><br><span class="line"></span><br><span class="line">var array = [1, 3, 5, 7, 8, 9, 10];</span><br><span class="line"></span><br><span class="line">function f(value, index, array)&#123;</span><br><span class="line"></span><br><span class="line">  return value%2==0;     // 返回偶数</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function f2(value, index, array)&#123;</span><br><span class="line"></span><br><span class="line">  return value &gt; 20;     // 返回大于20的数</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(array.find(f)); // 8</span><br><span class="line"></span><br><span class="line">console.log(array.find(f2)); // undefined</span><br><span class="line"></span><br><span class="line">console.log(array.findIndex(f)); // 4</span><br><span class="line"></span><br><span class="line">console.log(array.findIndex(f2)); // -1</span><br><span class="line"></span><br><span class="line">// keys方法</span><br><span class="line"></span><br><span class="line">[...Array(10).keys()];     // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line"></span><br><span class="line">[...new Array(10).keys()]; // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line"></span><br><span class="line">// values方法</span><br><span class="line"></span><br><span class="line">var array = [&quot;abc&quot;, &quot;xyz&quot;];</span><br><span class="line"></span><br><span class="line">var iterator = array.values();</span><br><span class="line"></span><br><span class="line">console.log(iterator.next().value);//abc</span><br><span class="line"></span><br><span class="line">console.log(iterator.next().value);//xyz</span><br></pre></td></tr></table></figure>
</li>
<li><p>reduce 的两个参数</p>
</li>
</ul>
<ol>
<li>首先是 callback（一个在数组的每一项中调用的函数，接受四个参数）：<br>previousValue（上一次调用回调函数时的返回值，或者初始值）<br>currentValue（当前正在处理的数组元素）<br>currentIndex（当前正在处理的数组元素下标）<br>array（调用 reduce() 方法的数组）</li>
<li>然后是 initialValue（可选的初始值，作为第一次调用回调函数时传给 previousValue 的值）。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/* 题目：数组 arr = [1,2,3,4] 求数组的和：*/</span><br><span class="line"></span><br><span class="line">// 第一种方法：</span><br><span class="line"></span><br><span class="line">var arr = [1,2,3,4];</span><br><span class="line"></span><br><span class="line">var sum = 0;</span><br><span class="line"></span><br><span class="line">arr.forEach(function(e)&#123;sum += e;&#125;); // sum = 10</span><br><span class="line"></span><br><span class="line">// 第二种方法</span><br><span class="line"></span><br><span class="line">var arr = [1,2,3,4];</span><br><span class="line"></span><br><span class="line">var sum = 0;</span><br><span class="line"></span><br><span class="line">arr.map(function(obj)&#123;sum += obj&#125;);</span><br><span class="line"></span><br><span class="line">// 第三种方法</span><br><span class="line"></span><br><span class="line">var arr = [1,2,3,4];</span><br><span class="line"></span><br><span class="line">arr.reduce(function(pre,cur)&#123;return pre + cur&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a>类数组</h3><ul>
<li>JavaScript 中有哪些情况下的对象是类数组呢？主要有以下几种：</li>
</ul>
<ol>
<li>函数里面的参数对象 arguments；</li>
<li>用 getElementsByTagName/ClassName/Name 获得的 HTMLCollection；</li>
<li>用 querySelector 获得的 NodeList。<h4 id="如何将类数组转换成数组"><a href="#如何将类数组转换成数组" class="headerlink" title="如何将类数组转换成数组"></a>如何将类数组转换成数组</h4></li>
</ol>
<ul>
<li>类数组借用数组方法转数组<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function sum(a, b) &#123;</span><br><span class="line"></span><br><span class="line">  let args = Array.prototype.slice.call(arguments);</span><br><span class="line"></span><br><span class="line"> // let args = [].slice.call(arguments); // 这样写也是一样效果</span><br><span class="line"></span><br><span class="line">  console.log(args.reduce((sum, cur) =&gt; sum + cur));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(1, 2);  // 3</span><br><span class="line"></span><br><span class="line">function sum(a, b) &#123;</span><br><span class="line"></span><br><span class="line">  let args = Array.prototype.concat.apply([], arguments);</span><br><span class="line"></span><br><span class="line">  console.log(args.reduce((sum, cur) =&gt; sum + cur));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sum(1, 2);  // 3</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="ES6-的方法转数组"><a href="#ES6-的方法转数组" class="headerlink" title="ES6 的方法转数组"></a>ES6 的方法转数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function sum(a, b) &#123;</span><br><span class="line"></span><br><span class="line">  let args = Array.from(arguments);</span><br><span class="line"></span><br><span class="line">  console.log(args.reduce((sum, cur) =&gt; sum + cur));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(1, 2);    // 3</span><br><span class="line"></span><br><span class="line">function sum(a, b) &#123;</span><br><span class="line"></span><br><span class="line">  let args = [...arguments];</span><br><span class="line"></span><br><span class="line">  console.log(args.reduce((sum, cur) =&gt; sum + cur));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(1, 2);    // 3</span><br><span class="line"></span><br><span class="line">function sum(...args) &#123;</span><br><span class="line"></span><br><span class="line">  console.log(args.reduce((sum, cur) =&gt; sum + cur));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(1, 2);    // 3</span><br></pre></td></tr></table></figure>
<h3 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h3><ul>
<li><p>普通的递归实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 方法1</span><br><span class="line"></span><br><span class="line">var a = [1, [2, [3, 4, 5]]];</span><br><span class="line"></span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line"></span><br><span class="line">  let result = [];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  for(let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">    if(Array.isArray(arr[i])) &#123;</span><br><span class="line"></span><br><span class="line">      result = result.concat(flatten(arr[i]));</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">      result.push(arr[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">flatten(a);  //  [1, 2, 3, 4，5]</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用 reduce 函数迭代</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 方法2</span><br><span class="line"></span><br><span class="line">var arr = [1, [2, [3, 4]]];</span><br><span class="line"></span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line"></span><br><span class="line">    return arr.reduce(function(prev, next)&#123;</span><br><span class="line"></span><br><span class="line">        return prev.concat(Array.isArray(next) ? flatten(next) : next)</span><br><span class="line"></span><br><span class="line">    &#125;, [])</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(flatten(arr));//  [1, 2, 3, 4，5]</span><br></pre></td></tr></table></figure>
</li>
<li><p>扩展运算符实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 方法3</span><br><span class="line"></span><br><span class="line">var arr = [1, [2, [3, 4]]];</span><br><span class="line"></span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line"></span><br><span class="line">    while (arr.some(item =&gt; Array.isArray(item))) &#123;</span><br><span class="line"></span><br><span class="line">        arr = [].concat(...arr);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return arr;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(flatten(arr)); //  [1, 2, 3, 4，5]</span><br></pre></td></tr></table></figure>
</li>
<li><p>split 和 toString 共同处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 方法4</span><br><span class="line"></span><br><span class="line">var arr = [1, [2, [3, 4]]];</span><br><span class="line"></span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line"></span><br><span class="line">    return arr.toString().split(&apos;,&apos;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(flatten(arr)); //  [1, 2, 3, 4]</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用 ES6 中的 flat,发现对数组的嵌套层数不确定的时候，最好直接使用 Infinity，可以达到扁平化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 方法5</span><br><span class="line"></span><br><span class="line">var arr = [1, [2, [3, 4]]];</span><br><span class="line"></span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line"></span><br><span class="line">  return arr.flat(Infinity);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(flatten(arr)); //  [1, 2, 3, 4，5]</span><br></pre></td></tr></table></figure>
</li>
<li><p>正则和 JSON 方法共同处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 方法 6</span><br><span class="line"></span><br><span class="line">let arr = [1, [2, [3, [4, 5]]], 6];</span><br><span class="line"></span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line"></span><br><span class="line">  let str = JSON.stringify(arr);</span><br><span class="line"></span><br><span class="line">  str = str.replace(/(\[|\])/g, &apos;&apos;);</span><br><span class="line"></span><br><span class="line">  str = &apos;[&apos; + str + &apos;]&apos;;</span><br><span class="line"></span><br><span class="line">  return JSON.parse(str); </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(flatten(arr)); //  [1, 2, 3, 4，5]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="sort-排序方法的实现原理"><a href="#sort-排序方法的实现原理" class="headerlink" title="sort 排序方法的实现原理"></a>sort 排序方法的实现原理</h3><ul>
<li>sort() 方法用原地算法对数组的元素进行排序，并返回数组。默认排序顺序是在将元素转换为字符串，然后比较它们的UTF-16代码单元值序列时构建的</li>
<li>通过研究源码我们先直接看一下结论，如果要排序的元素个数是 n 的时候，那么就会有以下几种情况：</li>
</ul>
<ol>
<li>当 n&lt;=10 时，采用插入排序；对于很小的数据量，应用插入排序是一个非常不错的选择。</li>
<li>当 n&gt;10 时，采用三路快速排序；<br>快速排序的性能瓶颈在于递归的深度，最坏的情况是每次的哨兵都是最小元素或者最大元素，那么进行 partition（一边是小于哨兵的元素，另一边是大于哨兵的元素）时，就会有一边是空的。<br>如果这么排下去，递归的层数就达到了 n , 而每一层的复杂度是 O(n)，因此快排这时候会退化成 O(n^2) 级别。<br>这种情况是要尽力避免的，那么如何来避免？就是让哨兵元素尽可能地处于数组的中间位置，让最大或者最小的情况尽可能少。</li>
<li>10&lt;n &lt;=1000，采用中位数作为哨兵元素；</li>
<li>n&gt;1000，每隔 200~215 个元素挑出一个元素，放到一个新数组中，然后对它排序，找到中间位置的数，以此作为中位数。<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2></li>
</ol>
<ul>
<li>浏览器在加载页面的时候会用到 GUI 渲染线程和 JavaScript 引擎线程（更详细的浏览器加载和渲染机制将在第 7 讲中介绍）。其中，GUI 渲染线程负责渲染浏览器界面 HTML 元素，JavaScript 引擎线程主要负责处理 JavaScript 脚本程序。由于 JavaScript 在执行过程中还可能会改动界面结构和样式，因此它们之间被设计为互斥的关系。也就是说，当 JavaScript 引擎执行时，GUI 线程会被挂起。</li>
<li>如果我们直接在document.body上进行事件委托，可能会带来额外的问题。由于浏览器在进行页面渲染的时候会有合成的步骤，合成的过程会先将页面分成不同的合成层，而用户与浏览器进行交互的时候需要接收事件。此时，浏览器会将页面上具有事件处理程序的区域进行标记，被标记的区域会与主线程进行通信。</li>
<li>如果我们document.body上被绑定了事件，这时候整个页面都会被标记。即使我们的页面不关心某些部分的用户交互，合成器线程也必须与主线程进行通信，并在每次事件发生时进行等待。这种情况，我们可以使用passive: true选项来解决。<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h3></li>
</ul>
<ol>
<li>盒模型会发生margin外边距叠加，叠加后的值会以最大边距为准。</li>
</ol>
<ul>
<li>需要注意的是，并不是所有情况下都会发生外边距叠加，比如行内框、浮动框或绝对定位框之间的外边距不会叠加。</li>
</ul>
<ol start="2">
<li>们可以通过box-sizing属性进行设置盒模型的计算方式，正常的盒模型默认值是content-box。</li>
</ol>
<ul>
<li>使用box-sizing属性可以解决问题 （调整元素的边框时，不影响元素的宽高），我们可以将元素的box-sizing属性设置为border-box<h3 id="内联元素与块状元素"><a href="#内联元素与块状元素" class="headerlink" title="内联元素与块状元素"></a>内联元素与块状元素</h3></li>
<li>除了内联元素和块状元素，我们还可以将元素设置为inline-block，inline-block可以很方便解决一些问题：使元素居中、给inline元素（<a>/<span>）设置宽高、将多个块状元素放在一行等。<h3 id="文档流和元素定位"><a href="#文档流和元素定位" class="headerlink" title="文档流和元素定位"></a>文档流和元素定位</h3></span></a></li>
<li>文档流布局方式可以使用position样式进行调整，包括：static（默认值）、inherit（继承父元素）、relative（相对定位）、absolute（相对非static父元素绝对定位）、fixed（相对浏览器窗口进行绝对定位）,sticky粘性定位。</li>
<li>这是因为除了同级元素以外，z-index值的设置效果还会受到父元素的z-index值的影响。z-index值的设置只决定同一父元素中的同级子元素的堆叠顺序。因此，即使将某个元素z-index设置为9999999，它依然可能因为父元素的z-index值小于其他父元素同级的元素，而导致该元素依然被其他元素遮挡。<h3 id="常见页面布局方式"><a href="#常见页面布局方式" class="headerlink" title="常见页面布局方式"></a>常见页面布局方式</h3></li>
</ul>
<ol>
<li>传统布局</li>
</ol>
<ul>
<li>除了使用position: fixed或者position: absolute时，会使元素脱离文档流，使用float属性同样会导致元素脱离文档流。</li>
</ul>
<ol start="2">
<li>Flex 布局</li>
<li>Grid 布局<h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2></li>
</ol>
<ul>
<li>每个对象都有<strong>proto</strong>属性来标识自己所继承的原型对象，但只有函数才有prototype属性</li>
<li>对于函数来说，每个函数都有一个prototype属性，该属性为该函数的原型对象</li>
<li>一个对象可通过<strong>proto</strong>访问原型对象上的属性和方法，而该原型同样也可通过<strong>proto</strong>访问它的原型对象，这样我们就在实例和原型之间构造了一条原型链</li>
<li>当 JavaScript 试图访问一个对象的属性时，会基于原型链进行查找。查找的过程是这样的：</li>
</ul>
<ol>
<li>首先会优先在该对象上搜寻。如果找不到，还会依次层层向上搜索该对象的原型对象、该对象的原型对象的原型对象等（套娃警告）；</li>
<li>JavaScript 中的所有对象都来自Object，Object.prototype.<strong>proto</strong> === null。null没有原型，并作为这个原型链中的最后一个环节；</li>
<li>JavaScript 会遍历访问对象的整个原型链，如果最终依然找不到，此时会认为该对象的属性值为undefined。</li>
</ol>
<ul>
<li>原型链继承方式中引用类型的属性被所有实例共享，无法做到实例私有</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/学习/">学习</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/学习/">学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网站/">网站</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/资源/">资源</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  

</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2021 DiamondsZz
            </div>        
        </div>
    </div>
</footer>

    </div>
    
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>

<script src="/js/main.js"></script>

    <script>
        $(document).ready(function() {
            var backgroundnum = 1;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>






<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" "="">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(
            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


  </div>
</body>
</html>