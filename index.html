<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  <meta name="baidu-site-verification" content="L6Lm9d5Crl">
  
  
  
  
  <title>DiamondsZz</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="来自一只野生程序猿...">
<meta property="og:type" content="website">
<meta property="og:title" content="DiamondsZz">
<meta property="og:url" content="https://DiamondsZz.github.io/index.html">
<meta property="og:site_name" content="DiamondsZz">
<meta property="og:description" content="来自一只野生程序猿...">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="DiamondsZz">
<meta name="twitter:description" content="来自一只野生程序猿...">
  
    <link rel="alternative" href="/atom.xml" title="DiamondsZz" type="application/atom+xml">
  
  
  
  <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
    
    
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet">
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: true,
          isPost: false,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>

        <a href="/" class="profilepic">
            
            <img lazy-src="/img/iu.jpeg" class="js-avatar">
            
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">DiamondsZz</a></h1>
        </hgroup>
        
        <p class="header-subtitle">DiamondsZz</p>
        
        
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        
        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                        </ul>
                    </nav>
                </section>
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/css/" style="font-size: 13.33px;">css</a> <a href="/tags/js/" style="font-size: 20px;">js</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/学习/" style="font-size: 16.67px;">学习</a> <a href="/tags/生活，心情/" style="font-size: 10px;">生活，心情</a> <a href="/tags/网站/" style="font-size: 16.67px;">网站</a> <a href="/tags/资源/" style="font-size: 16.67px;">资源</a>
                    </div>
                </section>
                
                
                
                
                <section class="switch-part switch-part3">
                
                    <div id="js-aboutme">矮穷矬!</div>
                </section>
                
            </div>
        </div>
    </header>
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">DiamondsZz</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/img/iu.jpeg" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">DiamondsZz</a></h1>
            </hgroup>
            
            <p class="header-subtitle">DiamondsZz</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                </div>
            </nav>
        </header>
    </div>
</nav>
      <div class="body-wrap">
  
    <article id="post-performance" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2021/05/01/performance/" class="article-date">
      <time datetime="2021-04-30T16:00:00.000Z" itemprop="datePublished">2021-05-01</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/05/01/performance/">performance</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="window-performance"><a href="#window-performance" class="headerlink" title="window.performance"></a>window.performance</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line">connectEnd	HTTP（TCP） 返回浏览器与服务器之间的连接建立时的时间戳。如果建立的是持久连接，则返回值等同于fetchStart属性的值。连接建立指的是所有握手和认证过程全部结束。</span><br><span class="line">connectStart	HTTP（TCP） 域名查询结束的时间戳。如果使用了持续连接(persistent connection)，或者这个信息存储到了缓存或者本地资源上，这个值将和 fetchStart一致。</span><br><span class="line">domComplete	当前文档解析完成，即Document.readyState 变为 &apos;complete&apos;且相对应的readystatechange 被触发时的时间戳</span><br><span class="line">domContentLoadedEventEnd	当所有需要立即执行的脚本已经被执行（不论执行顺序）时的时间戳。</span><br><span class="line">domContentLoadedEventStart	当解析器发送DOMContentLoaded 事件，即所有需要被执行的脚本已经被解析时的时间戳。</span><br><span class="line">domInteractive	当前网页DOM结构结束解析、开始加载内嵌资源时（即Document.readyState属性变为“interactive”、相应的readystatechange事件触发时）的时间戳。</span><br><span class="line">domLoading	当前网页DOM结构开始解析时（即Document.readyState属性变为“loading”、相应的 readystatechange事件触发时）的时间戳。</span><br><span class="line">domainLookupEnd	DNS 域名查询完成的时间。如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等</span><br><span class="line">domainLookupStart	DNS 域名查询开始的UNIX时间戳。如果使用了持续连接(persistent connection)，或者这个信息存储到了缓存或者本地资源上，这个值将和fetchStart一致。</span><br><span class="line">fetchStart	浏览器准备好使用HTTP请求来获取(fetch)文档的时间戳。这个时间点会在检查任何应用缓存之前。</span><br><span class="line">loadEventEnd	当load事件结束，即加载事件完成时的时间戳。如果这个事件还未被发送，或者尚未完成，它的值将会是0.</span><br><span class="line">loadEventStart	load事件被发送时的时间戳。如果这个事件还未被发送，它的值将会是0。</span><br><span class="line">navigationStart	同一个浏览器上一个页面卸载(unload)结束时的时间戳。如果没有上一个页面，这个值会和fetchStart相同。</span><br><span class="line">redirectEnd	最后一个HTTP重定向完成时（也就是说是HTTP响应的最后一个比特直接被收到的时间）的时间戳。如果没有重定向，或者重定向中的一个不同源，这个值会返回0.</span><br><span class="line">redirectStart	第一个HTTP重定向开始时的时间戳。如果没有重定向，或者重定向中的一个不同源，这个值会返回0。</span><br><span class="line">requestStart	返回浏览器向服务器发出HTTP请求时（或开始读取本地缓存时）的时间戳。</span><br><span class="line">responseEnd	返回浏览器从服务器收到（或从本地缓存读取，或从本地资源读取）最后一个字节时（如果在此之前HTTP连接已经关闭，则返回关闭时）的时间戳。</span><br><span class="line">responseStart	返回浏览器从服务器收到（或从本地缓存读取）第一个字节时的时间戳。如果传输层在开始请求之后失败并且连接被重开，该属性将会被数制成新的请求的相对应的发起时间</span><br><span class="line">secureConnectionStart	HTTPS 返回浏览器与服务器开始安全链接的握手时的时间戳。如果当前网页不要求安全连接，则返回0。</span><br><span class="line">unloadEventEnd	和 unloadEventStart 相对应，unload事件处理完成时的时间戳。如果没有上一个页面,这个值会返回0。</span><br><span class="line">unloadEventStart	上一个页面unload事件抛出时的时间戳。如果没有上一个页面，这个值会返回0。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 获取 performance 数据</span><br><span class="line">var performance = &#123;  </span><br><span class="line">    // memory 是非标准属性，只在 Chrome 有</span><br><span class="line">    //内存</span><br><span class="line">    memory: &#123;</span><br><span class="line">        usedJSHeapSize:  16100000, // JS 对象（包括V8引擎内部对象）占用的内存，一定小于 totalJSHeapSize</span><br><span class="line">        totalJSHeapSize: 35100000, // 可使用的内存</span><br><span class="line">        jsHeapSizeLimit: 793000000 // 内存大小限制</span><br><span class="line">    &#125;,</span><br><span class="line"> </span><br><span class="line">    navigation: &#123;</span><br><span class="line">        redirectCount: 0, // 如果有重定向的话，页面通过几次重定向跳转而来</span><br><span class="line">        type: 0           // 0   即 TYPE_NAVIGATENEXT 正常进入的页面（非刷新、非重定向等）</span><br><span class="line">                          // 1   即 TYPE_RELOAD       通过 window.location.reload() 刷新的页面</span><br><span class="line">                          // 2   即 TYPE_BACK_FORWARD 通过浏览器的前进后退按钮进入的页面（历史记录）</span><br><span class="line">                          // 255 即 TYPE_UNDEFINED    非以上方式进入的页面</span><br><span class="line">    &#125;,</span><br><span class="line"> </span><br><span class="line">    timing: &#123;</span><br><span class="line">        // 在同一个浏览器上下文中，前一个网页（与当前页面不一定同域）unload 的时间戳，如果无前一个网页 unload ，则与 fetchStart 值相等</span><br><span class="line">        navigationStart: 1441112691935,</span><br><span class="line"> </span><br><span class="line">        // 前一个网页（与当前页面同域）unload 的时间戳，如果无前一个网页 unload 或者前一个网页与当前页面不同域，则值为 0</span><br><span class="line">        unloadEventStart: 0,</span><br><span class="line"> </span><br><span class="line">        // 和 unloadEventStart 相对应，返回前一个网页 unload 事件绑定的回调函数执行完毕的时间戳</span><br><span class="line">        unloadEventEnd: 0,</span><br><span class="line"> </span><br><span class="line">        // 第一个 HTTP 重定向发生时的时间。有跳转且是同域名内的重定向才算，否则值为 0 </span><br><span class="line">        redirectStart: 0,</span><br><span class="line"> </span><br><span class="line">        // 最后一个 HTTP 重定向完成时的时间。有跳转且是同域名内部的重定向才算，否则值为 0 </span><br><span class="line">        redirectEnd: 0,</span><br><span class="line"> </span><br><span class="line">        // 浏览器准备好使用 HTTP 请求抓取文档的时间，这发生在检查本地缓存之前</span><br><span class="line">        fetchStart: 1441112692155,</span><br><span class="line"> </span><br><span class="line">        // DNS 域名查询开始的时间，如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等</span><br><span class="line">        domainLookupStart: 1441112692155,</span><br><span class="line"> </span><br><span class="line">        // DNS 域名查询完成的时间，如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等</span><br><span class="line">        domainLookupEnd: 1441112692155,</span><br><span class="line"> </span><br><span class="line">        // HTTP（TCP） 开始建立连接的时间，如果是持久连接，则与 fetchStart 值相等</span><br><span class="line">        // 注意如果在传输层发生了错误且重新建立连接，则这里显示的是新建立的连接开始的时间</span><br><span class="line">        connectStart: 1441112692155,</span><br><span class="line"> </span><br><span class="line">        // HTTP（TCP） 完成建立连接的时间（完成握手），如果是持久连接，则与 fetchStart 值相等</span><br><span class="line">        // 注意如果在传输层发生了错误且重新建立连接，则这里显示的是新建立的连接完成的时间</span><br><span class="line">        // 注意这里握手结束，包括安全连接建立完成、SOCKS 授权通过</span><br><span class="line">        connectEnd: 1441112692155,</span><br><span class="line"> </span><br><span class="line">        // HTTPS 连接开始的时间，如果不是安全连接，则值为 0</span><br><span class="line">        secureConnectionStart: 0,</span><br><span class="line"> </span><br><span class="line">        // HTTP 请求读取真实文档开始的时间（完成建立连接），包括从本地读取缓存</span><br><span class="line">        // 连接错误重连时，这里显示的也是新建立连接的时间</span><br><span class="line">        requestStart: 1441112692158,</span><br><span class="line"> </span><br><span class="line">        // HTTP 开始接收响应的时间（获取到第一个字节），包括从本地读取缓存</span><br><span class="line">        responseStart: 1441112692686,</span><br><span class="line"> </span><br><span class="line">        // HTTP 响应全部接收完成的时间（获取到最后一个字节），包括从本地读取缓存</span><br><span class="line">        responseEnd: 1441112692687,</span><br><span class="line"> </span><br><span class="line">        // 开始解析渲染 DOM 树的时间，此时 Document.readyState 变为 loading，并将抛出 readystatechange 相关事件</span><br><span class="line">        domLoading: 1441112692690,</span><br><span class="line"> </span><br><span class="line">        // 完成解析 DOM 树的时间，Document.readyState 变为 interactive，并将抛出 readystatechange 相关事件</span><br><span class="line">        // 注意只是 DOM 树解析完成，这时候并没有开始加载网页内的资源</span><br><span class="line">        domInteractive: 1441112693093,</span><br><span class="line"> </span><br><span class="line">        // DOM 解析完成后，网页内资源加载开始的时间</span><br><span class="line">        // 在 DOMContentLoaded 事件抛出前发生</span><br><span class="line">        domContentLoadedEventStart: 1441112693093,</span><br><span class="line"> </span><br><span class="line">        // DOM 解析完成后，网页内资源加载完成的时间（如 JS 脚本加载执行完毕）</span><br><span class="line">        domContentLoadedEventEnd: 1441112693101,</span><br><span class="line"> </span><br><span class="line">        // DOM 树解析完成，且资源也准备就绪的时间，Document.readyState 变为 complete，并将抛出 readystatechange 相关事件</span><br><span class="line">        domComplete: 1441112693214,</span><br><span class="line"> </span><br><span class="line">        // load 事件发送给文档，也即 load 回调函数开始执行的时间</span><br><span class="line">        // 注意如果没有绑定 load 事件，值为 0</span><br><span class="line">        loadEventStart: 1441112693214,</span><br><span class="line"> </span><br><span class="line">        // load 事件的回调函数执行完毕的时间</span><br><span class="line">        loadEventEnd: 1441112693215</span><br><span class="line"> </span><br><span class="line">        // 字母顺序</span><br><span class="line">        // connectEnd: 1441112692155,</span><br><span class="line">        // connectStart: 1441112692155,</span><br><span class="line">        // domComplete: 1441112693214,</span><br><span class="line">        // domContentLoadedEventEnd: 1441112693101,</span><br><span class="line">        // domContentLoadedEventStart: 1441112693093,</span><br><span class="line">        // domInteractive: 1441112693093,</span><br><span class="line">        // domLoading: 1441112692690,</span><br><span class="line">        // domainLookupEnd: 1441112692155,</span><br><span class="line">        // domainLookupStart: 1441112692155,</span><br><span class="line">        // fetchStart: 1441112692155,</span><br><span class="line">        // loadEventEnd: 1441112693215,</span><br><span class="line">        // loadEventStart: 1441112693214,</span><br><span class="line">        // navigationStart: 1441112691935,</span><br><span class="line">        // redirectEnd: 0,</span><br><span class="line">        // redirectStart: 0,</span><br><span class="line">        // requestStart: 1441112692158,</span><br><span class="line">        // responseEnd: 1441112692687,</span><br><span class="line">        // responseStart: 1441112692686,</span><br><span class="line">        // secureConnectionStart: 0,</span><br><span class="line">        // unloadEventEnd: 0,</span><br><span class="line">        // unloadEventStart: 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 计算加载时间</span><br><span class="line">function getPerformanceTiming() &#123;</span><br><span class="line">    var performance = window.performance;</span><br><span class="line">    if (!performance) &#123;</span><br><span class="line">        // 当前浏览器不支持</span><br><span class="line">        console.log(&apos;你的浏览器不支持 performance 接口&apos;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    var t = performance.timing;</span><br><span class="line">    var times = &#123;&#125;;</span><br><span class="line">    //【重要】页面加载完成的时间</span><br><span class="line">    //【原因】这几乎代表了用户等待页面可用的时间</span><br><span class="line">    times.loadPage = t.loadEventEnd - t.navigationStart;</span><br><span class="line">    //【重要】解析 DOM 树结构的时间</span><br><span class="line">    //【原因】反省下你的 DOM 树嵌套是不是太多了！</span><br><span class="line">    times.domReady = t.domComplete - t.responseEnd;</span><br><span class="line">    //【重要】重定向的时间</span><br><span class="line">    //【原因】拒绝重定向！比如，http://example.com/ 就不该写成 http://example.com</span><br><span class="line">    times.redirect = t.redirectEnd - t.redirectStart;</span><br><span class="line">    //【重要】DNS 查询时间</span><br><span class="line">    //【原因】DNS 预加载做了么？页面内是不是使用了太多不同的域名导致域名查询的时间太长？</span><br><span class="line">    // 可使用 HTML5 Prefetch 预查询 DNS ，见：[HTML5 prefetch](http://segmentfault.com/a/1190000000633364)            </span><br><span class="line">    times.lookupDomain = t.domainLookupEnd - t.domainLookupStart;</span><br><span class="line">    //【重要】读取页面第一个字节的时间</span><br><span class="line">    //【原因】这可以理解为用户拿到你的资源占用的时间，加异地机房了么，加CDN 处理了么？加带宽了么？加 CPU 运算速度了么？</span><br><span class="line">    // TTFB 即 Time To First Byte 的意思</span><br><span class="line">    // 维基百科：https://en.wikipedia.org/wiki/Time_To_First_Byte</span><br><span class="line">    times.ttfb = t.responseStart - t.navigationStart;</span><br><span class="line">    //【重要】内容加载完成的时间</span><br><span class="line">    //【原因】页面内容经过 gzip 压缩了么，静态资源 css/js 等压缩了么？</span><br><span class="line">    times.request = t.responseEnd - t.requestStart;</span><br><span class="line">    //【重要】执行 onload 回调函数的时间</span><br><span class="line">    //【原因】是否太多不必要的操作都放到 onload 回调函数里执行了，考虑过延迟加载、按需加载的策略么？</span><br><span class="line">    times.loadEvent = t.loadEventEnd - t.loadEventStart;</span><br><span class="line">    // DNS 缓存时间</span><br><span class="line">    times.appcache = t.domainLookupStart - t.fetchStart;</span><br><span class="line">    // 卸载页面的时间</span><br><span class="line">    times.unloadEvent = t.unloadEventEnd - t.unloadEventStart;</span><br><span class="line">    // TCP 建立连接完成握手的时间</span><br><span class="line">    times.connect = t.connectEnd - t.connectStart;</span><br><span class="line">    return times;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常见性能指标"><a href="#常见性能指标" class="headerlink" title="常见性能指标"></a>常见性能指标</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FP	页面首次绘制时间</span><br><span class="line">FCP	页面首次有内容绘制的时间</span><br><span class="line">FMP	页面首次有效绘制时间，FMP &gt;= FCP</span><br><span class="line">TTI	页面完全可交互时间</span><br><span class="line">FID	页面加载阶段，用户首次交互操作的延时时间</span><br><span class="line">MPFID	页面加载阶段，用户交互操作可能遇到的最大延时时间</span><br><span class="line">LOAD	页面完全加载的时间（load 事件发生的时间）</span><br></pre></td></tr></table></figure>
<h3 id="FP"><a href="#FP" class="headerlink" title="FP"></a>FP</h3><p>FP (First Paint)指标通常会反映页面的白屏时间，而白屏时间会反映当前 Web 页面的网络加载性能情况，当加载性能非常良好的情况下，白屏的时间就会越短，用户等待内容的时间就会越短，流失的概率就会降低。<br>该指标可以通过 performance.getEntriesByType(‘paint’) 方法获取 PerformancePaintTiming API 提供的打点信息，找到 name 为 first-paint 的对象，描述的即为 FP 的指标数据</p>
<h3 id="FCP"><a href="#FCP" class="headerlink" title="FCP"></a>FCP</h3><p>FCP (First Contentful Paint) 为首次有内容渲染的时间点，在性能统计指标中，从用户开始访问 Web 页面的时间点到 FCP 的时间点这段时间可以被视为无内容时间，一般 FCP &gt;= FP。<br>该指标可以通过 performance.getEntriesByType(‘paint’) 方法获取 PerformancePaintTiming API 提供的打点信息，找到 name 为 first-contentful-paint 的对象，描述的即为 FCP 的指标数据</p>
<h3 id="TTI"><a href="#TTI" class="headerlink" title="TTI"></a>TTI</h3><p>TTI（Time To Interactive），即从页面加载开始到页面处于完全可交互状态所花费的时间。页面处于完全可交互状态时，满足以下 3 个条件：</p>
<ol>
<li>页面已经显示有用内容。</li>
<li>页面上的可见元素关联的事件响应函数已经完成注册。</li>
<li>事件响应函数可以在事件发生后的 50ms 内开始执行。<br>window.performance.getEntriesByType(‘resource’)会返回当前页面加载的所有资源（js、css、img…）的各类性能指标，可用于静态资源性能数据采集。<br>主要类型有：script、link、img、css、xmlhttprequest、beacon、fetch、other。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">connectEnd	一个 DOMHighResTimeStamp，表示浏览器完成建立与服务器的连接以检索资源之后的时间。</span><br><span class="line">connectStart	一个 DOMHighResTimeStamp，表示浏览器开始建立与服务器的连接以检索资源之前的时间。</span><br><span class="line">decodedBodySize	一个 number，表示在删除任何应用的内容编码之后，从消息主体的请求（HTTP 或缓存）中接收到的大小（以八位字节为单位）。</span><br><span class="line">domainLookupEnd	一个 DOMHighResTimeStamp，表示浏览器完成资源的域名查找之后的时间。</span><br><span class="line">domainLookupStart	一个 DOMHighResTimeStamp，表示在浏览器立即开始资源的域名查找之前的时间</span><br><span class="line">duration	返回一个 timestamp，即 responseEnd 和 startTime 属性的差值。</span><br><span class="line">encodedBodySize	一个 number，表示在删除任何应用的内容编码之前，从有效内容主体的请求（HTTP 或缓存）中接收到的大小（以八位字节为单位）。</span><br><span class="line">entryType	返回 &quot;resource&quot;。</span><br><span class="line">fetchStart	一个 DOMHighResTimeStamp，表示浏览器即将开始获取资源之前的时间。</span><br><span class="line">initiatorType	一个 string，代表启动性能条目的资源的类型</span><br><span class="line">name	返回资源 URL。</span><br><span class="line">nextHopProtocol	一个 string，代表用于获取资源的网络协议，由 ALPN 协议 ID（RFC7301） 定义。</span><br><span class="line">redirectEnd	一个 DOMHighResTimeStamp，表示收到上一次重定向响应的发送最后一个字节时的时间。</span><br><span class="line">redirectStart	一个 DOMHighResTimeStamp 代表启动重定向的请求开始之前的时间。</span><br><span class="line">requestStart	一个 DOMHighResTimeStamp，表示浏览器开始向服务器请求资源之前的时间。</span><br><span class="line">responseEnd	一个 DOMHighResTimeStamp，表示在浏览器接收到资源的最后一个字节之后或在传输连接关闭之前（以先到者为准）的时间。</span><br><span class="line">responseStart	一个 DOMHighResTimeStamp，表示浏览器从服务器接收到响应的第一个字节后的时间。</span><br><span class="line">secureConnectionStart	一个 DOMHighResTimeStamp，表示浏览器即将开始握手过程以保护当前连接之前的时间。</span><br><span class="line">serverTiming	一个 PerformanceServerTiming 数组，包含服务器计时指标的 PerformanceServerTiming 条目。</span><br><span class="line">startTime	返回一个 timestamp，表示资源获取开始的时间。该值等效于 fetchStart。</span><br><span class="line">transferSize	一个 number 代表所获取资源的大小（以八位字节为单位）。该大小包括响应标头字段以及响应有效内容主体。</span><br><span class="line">workerStart	一个 DOMHighResTimeStamp， 如果服务 Worker 线程已经在运行，则返回在分派 FetchEvent 之前的时间戳，如果尚未运行，则返回在启动 Service Worker 线程之前的时间戳。如果服务 Worker 未拦截该资源，则该属性将始终返回 0。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="其他指标计算方式"><a href="#其他指标计算方式" class="headerlink" title="其他指标计算方式"></a>其他指标计算方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DNS查询	DNS 阶段耗时	domainLookupEnd - domainLookupStart</span><br><span class="line">TCP连接	TCP 阶段耗时	connectEnd - connectStart</span><br><span class="line">SSL建连	SSL 连接时间	connectEnd - secureConnectionStart</span><br><span class="line">首字节网络请求	首字节响应时间（ttfb）	responseStart - requestStart</span><br><span class="line">内容传输	内容传输，Response阶段耗时	responseEnd - responseStart</span><br><span class="line">DOM解析	Dom解析时间	domInteractive - responseEnd</span><br><span class="line">资源加载	资源加载	loadEventStart - domContentLoadedEventEnd</span><br><span class="line">首字节	首字节	responseStart - fetchStart</span><br><span class="line">DOM Ready	dom ready	domContentLoadedEventEnd - fetchStart</span><br><span class="line">redirect时间	重定向时间	redirectEnd - redirectStart</span><br><span class="line">DOM render	dom渲染耗时	domComplete - domLoading</span><br><span class="line">load	页面加载耗时	loadEventEnd - navigationStart</span><br><span class="line">unload	页面卸载耗时	unloadEventEnd - unloadEventStart</span><br><span class="line">请求耗时	请求耗时	responseEnd - requestStart</span><br><span class="line">白屏时间	白屏时间	domLoading - navigationStart</span><br></pre></td></tr></table></figure>
<h2 id="错误数据采集方案"><a href="#错误数据采集方案" class="headerlink" title="错误数据采集方案"></a>错误数据采集方案</h2><p>目前所能捕捉的错误有三种:</p>
<ol>
<li>资源加载错误，通过 addEventListener(‘error’, callback, true)在捕获阶段捕捉资源加载失败错误。</li>
<li>js 执行错误，通过 window.onerror捕捉 js 错误。<br>跨域的脚本会给出 “Script Error.” 提示，拿不到具体的错误信息和堆栈信息。此时需要在script标签增加crossorigin=”anonymous”属性，同时资源服务器需要增加CORS相关配置，比如Access-Control-Allow-Origin: *</li>
<li>promise 错误，通过 addEventListener(‘unhandledrejection’, callback)捕捉 promise 错误，但是没有发生错误的行数，列数等信息，只能手动抛出相关错误信息。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 在捕获阶段，捕获资源加载失败错误</span><br><span class="line">addEventListener(&apos;error&apos;, e =&gt; &#123;</span><br><span class="line">    const target = e.target</span><br><span class="line">    if (target != window) &#123;</span><br><span class="line">        monitor.errors.push(&#123;</span><br><span class="line">            type: target.localName,</span><br><span class="line">            url: target.src || target.href,</span><br><span class="line">            msg: (target.src || target.href) + &apos; is load error&apos;,</span><br><span class="line">            time: Date.now()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, true)</span><br><span class="line"></span><br><span class="line">// 监听 js 错误</span><br><span class="line">window.onerror = function(msg, url, row, col, error) &#123;</span><br><span class="line">    monitor.errors.push(&#123;</span><br><span class="line">        type: &apos;javascript&apos;,</span><br><span class="line">        row: row,</span><br><span class="line">        col: col,</span><br><span class="line">        msg: error &amp;&amp; error.stack? error.stack : msg,</span><br><span class="line">        url: url,</span><br><span class="line">        time: Date.now()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 监听 promise 错误 缺点是获取不到行数数据</span><br><span class="line">addEventListener(&apos;unhandledrejection&apos;, e =&gt; &#123;</span><br><span class="line">    monitor.errors.push(&#123;</span><br><span class="line">        type: &apos;promise&apos;,</span><br><span class="line">        msg: (e.reason &amp;&amp; e.reason.msg) || e.reason || &apos;&apos;,</span><br><span class="line">        time: Date.now()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="数据上报方案"><a href="#数据上报方案" class="headerlink" title="数据上报方案"></a>数据上报方案</h2><p>在这个场景中，需要考虑两个问题：</p>
<ol>
<li>如果数据上报接口与业务系统使用同一域名，浏览器对请求并发量有限制，所以存在网络资源竞争的可能性。</li>
<li>浏览器通常在页面卸载时会忽略异步ajax请求，如果需要必须进行数据请求，一般在unload或者beforeunload事件中创建同步ajax请求，以此延迟页面卸载。从用户侧角度，就是页面跳转变慢。</li>
</ol>
<ul>
<li>Beacon 接口用来调度向 Web 服务器发送的异步非阻塞请求。</li>
</ul>
<ol>
<li>Beacon 请求使用 HTTP POST方法，并且不需要有响应。</li>
<li>Beacon 请求能确保在页面触发 unload 之前完成初始化。 通俗的讲就是，Beacon可将数据异步发送至服务端，且能够保证在页面卸载完成前发送请求（解决ajax页面卸载会终止请求的问题）。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">navigator.sendBeacon(url, data);</span><br><span class="line">其中 data 参数是可选的，它的类型可以为 ArrayBufferView, Blob, DOMString 或者 FormData。如果浏览器成功地将 beacon 请求加入到待发送的队列里，这个方法将会返回 true ，否则将会返回 false</span><br><span class="line"></span><br><span class="line">使用Beacon时需要后台需要使用post方法接收参数，考虑到跨域问题，后台还需要改造接口配置CORS。同时请求头必须满足CORS-safelisted request-header，其中content-type的类型必须为application/x-www-form-urlencoded, multipart/form-data, 或者text/plain。</span><br><span class="line"></span><br><span class="line">type ContentType = &apos;application/x-www-form-urlencoded&apos; | &apos;multipart/form-data&apos; | &apos;text/plain&apos;;</span><br><span class="line"></span><br><span class="line">const serilizeParams = (params: object) =&gt; &#123;</span><br><span class="line">    return window.btoa(JSON.stringify(params))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function sendBeacon(url: string, params: object) &#123;</span><br><span class="line">  const formData = new FormData()</span><br><span class="line">  formData.append(&apos;params&apos;, serilizeParams(params))</span><br><span class="line">  navigator.sendBeacon(url, formData)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sendBeacon的兼容性问题是不可避免的，不过可以充分利用大部分浏览器会在页面卸载前完成图片的加载的特性，通过在页面添加img的方式上报数据。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function sendImage(url: string, params: object) &#123;</span><br><span class="line">  const img = new Image()</span><br><span class="line"></span><br><span class="line">  img.style.display = &apos;none&apos;</span><br><span class="line"></span><br><span class="line">  const removeImage = function() &#123;</span><br><span class="line">    img.parentNode.removeChild(img)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  img.onload = removeImage</span><br><span class="line">  img.onerror = removeImage</span><br><span class="line"></span><br><span class="line">  img.src = `$&#123;url&#125;?params=$&#123;serilizeParams(params)&#125;`</span><br><span class="line"></span><br><span class="line">  document.body.appendChild(img)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">由于img图片为get请求方式，不同服务器针对uri的长度有限制，长度超过限制时会出现HTTP 414错误，所以还要注意上报频率，减少一次性上传的属性过多。</span><br></pre></td></tr></table></figure>
</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/前端/">前端</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/">js</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-http" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2021/04/25/http/" class="article-date">
      <time datetime="2021-04-24T16:00:00.000Z" itemprop="datePublished">2021-04-25</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/04/25/http/">http协议</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="时势与英雄：HTTP的前世今生"><a href="#时势与英雄：HTTP的前世今生" class="headerlink" title="时势与英雄：HTTP的前世今生"></a>时势与英雄：HTTP的前世今生</h2><h3 id="创世纪"><a href="#创世纪" class="headerlink" title="创世纪"></a>创世纪</h3><ul>
<li>URI：即统一资源标识符，作为互联网上资源的唯一身份；</li>
<li>HTML：即超文本标记语言，描述超文本文档；</li>
<li>HTTP：即超文本传输协议，用来传输超文本。</li>
<li>这三项技术在如今的我们看来已经是稀松平常，但在当时却是了不得的大发明。基于它们，就可以把超文本系统完美地运行在互联网上，让各地的人们能够自由地共享信息，蒂姆把这个系统称为“万维网”（World Wide Web），也就是我们现在所熟知的 Web。所以在这一年，我们的英雄“HTTP”诞生了，从此开始了它伟大的征途。<h3 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP/0.9"></a>HTTP/0.9</h3></li>
<li>20 世纪 90 年代初期的互联网世界非常简陋，计算机处理能力低，存储容量小，网速很慢，还是一片“信息荒漠”。网络上绝大多数的资源都是纯文本，很多通信协议也都使用纯文本，所以 HTTP 的设计也不可避免地受到了时代的限制。</li>
<li>最初设想的系统里的文档都是只读的，所以只允许用“GET”动作从服务器上获取 HTML 文档，并且在响应请求之后立即关闭连接，功能非常有限。<h3 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP/1.0"></a>HTTP/1.0</h3></li>
<li>HTTP/1.0 版本在 1996 年正式发布。它在多方面增强了 0.9 版，形式上已经和我们现在的 HTTP 差别不大了，例如：</li>
</ul>
<ol>
<li>增加了 HEAD、POST 等新方法；</li>
<li>增加了响应状态码，标记可能的错误原因；</li>
<li>引入了协议版本号概念；</li>
<li>引入了 HTTP Header（头部）的概念，让 HTTP 处理请求和响应更加灵活；</li>
<li>传输的数据不再仅限于文本。</li>
</ol>
<ul>
<li>TTP/1.0 的发布对于当时正在蓬勃发展的互联网来说并没有太大的实际意义，各方势力仍然按照自己的意图继续在市场上奋力拼杀。<h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h3></li>
<li>1995 年，网景的 Netscape Navigator 和微软的 Internet Explorer 开始了著名的“浏览器大战”，都希望在互联网上占据主导地位。这场战争的结果你一定早就知道了，最终微软的 IE 取得了决定性的胜利，而网景则“败走麦城”（但后来却凭借 Mozilla Firefox 又扳回一局）。</li>
<li>1999 年，HTTP/1.1 发布了 RFC 文档，编号为 2616，正式确立了延续十余年的传奇。从版本号我们就可以看到，HTTP/1.1 是对 HTTP/1.0 的小幅度修正。但一个重要的区别是：它是一个“正式的标准”，而不是一份可有可无的“参考文档”。这意味着今后互联网上所有的浏览器、服务器、网关、代理等等，只要用到 HTTP 协议，就必须严格遵守这个标准，相当于是互联网世界的一个“立法”。</li>
<li>HTTP/1.1 主要的变更点有：</li>
</ul>
<ol>
<li>增加了 PUT、DELETE 等新的方法；</li>
<li>增加了缓存管理和控制；</li>
<li>明确了连接管理，允许持久连接；</li>
<li>允许响应数据分块（chunked），利于传输大文件；</li>
<li>强制要求 Host 头，让互联网主机托管成为可能。<h3 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h3></li>
</ol>
<ul>
<li>互联网标准化组织以 SPDY 为基础开始制定新版本的 HTTP 协议，最终在 2015 年发布了 HTTP/2，RFC 编号 7540。</li>
<li>HTTP/2 的制定充分考虑了现今互联网的现状：宽带、移动、不安全，在高度兼容 HTTP/1.1 的同时在性能改善方面做了很大努力，主要的特点有：</li>
</ul>
<ol>
<li>二进制协议，不再是纯文本；</li>
<li>可发起多个请求，废弃了 1.1 里的管道；</li>
<li>使用专用算法压缩头部，减少数据传输量；</li>
<li>允许服务器主动向客户端推送数据；</li>
<li>增强了安全性，“事实上”要求加密通信。<h3 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP/3"></a>HTTP/3</h3></li>
</ol>
<ul>
<li>2018 年，互联网标准化组织 IETF 提议将“HTTP over QUIC”更名为“HTTP/3”并获得批准，HTTP/3 正式进入了标准化制订阶段，也许两三年后就会正式发布，到时候我们很可能会跳过 HTTP/2 直接进入 HTTP/3。</li>
</ul>
<h2 id="HTTP是什么？HTTP又不是什么？"><a href="#HTTP是什么？HTTP又不是什么？" class="headerlink" title="HTTP是什么？HTTP又不是什么？"></a>HTTP是什么？HTTP又不是什么？</h2><ul>
<li>HTTP 是一个用在计算机世界里的协议，它确立了一种计算机之间交流通信的规范，以及相关的各种控制和错误处理方式。</li>
<li>HTTP 专门用来在两点之间传输数据，不能用于广播、寻址或路由</li>
<li>HTTP 传输的是文字、图片、音频、视频等超文本数据。</li>
<li>HTTP 是构建互联网的重要基础技术，它没有实体，依赖许多其他的技术来实现，但同时许多技术也都依赖于它。</li>
</ul>
<h2 id="HTTP世界全览（上）：与HTTP相关的各种概念"><a href="#HTTP世界全览（上）：与HTTP相关的各种概念" class="headerlink" title="HTTP世界全览（上）：与HTTP相关的各种概念"></a>HTTP世界全览（上）：与HTTP相关的各种概念</h2><h3 id="网络世界"><a href="#网络世界" class="headerlink" title="网络世界"></a>网络世界</h3><ul>
<li>互联网的正式名称是 Internet，里面存储着无穷无尽的信息资源，我们通常所说的“上网”实际上访问的只是互联网的一个子集“万维网”（World Wide Web），它基于 HTTP 协议，传输 HTML 等超文本资源，能力也就被限制在 HTTP 协议之内。</li>
<li>互联网上还有许多万维网之外的资源，例如常用的电子邮件、BT 和 Magnet 点对点下载、FTP 文件下载、SSH 安全登录、各种即时通信服务等等，它们需要用各自的专有协议来访问。</li>
<li>不过由于 HTTP 协议非常灵活、易于扩展，而且“超文本”的表述能力很强，所以很多其他原本不属于 HTTP 的资源也可以“包装”成 HTTP 来访问，这就是我们为什么能够总看到各种“网页应用”——例如“微信网页版”“邮箱网页版”——的原因。<h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3></li>
<li>常见的浏览器有 Google 的 Chrome、Mozilla 的 Firefox、Apple 的 Safari、Microsoft 的 IE 和 Edge，还有小众的 Opera 以及国内的各种“换壳”的“极速”“安全”浏览器。</li>
<li>浏览器本质上是一个 HTTP 协议中的请求方，使用 HTTP 协议获取网络上的各种资源。当然，为了让我们更好地检索查看网页，它还集成了很多额外的功能。</li>
<li>在 HTTP 协议里，浏览器的角色被称为“User Agent”即“用户代理”，意思是作为访问者的“代理”来发起 HTTP 请求。不过在不引起混淆的情况下，我们通常都简单地称之为“客户端”。<h3 id="Web-服务器"><a href="#Web-服务器" class="headerlink" title="Web 服务器"></a>Web 服务器</h3></li>
<li>比起层出不穷的各种 Web 浏览器，Web 服务器就要少很多了，一只手的手指头就可以数得过来。</li>
</ul>
<ol>
<li>Apache 是老牌的服务器，到今天已经快 25 年了，功能相当完善，相关的资料很多，学习门槛低，是许多创业者建站的入门产品。</li>
<li>Nginx 是 Web 服务器里的后起之秀，特点是高性能、高稳定，且易于扩展。自 2004 年推出后就不断蚕食 Apache 的市场份额，在高流量的网站里更是不二之选。</li>
<li>此外，还有 Windows 上的 IIS、Java 的 Jetty/Tomcat 等，因为性能不是很高，所以在互联网上应用得较少。</li>
</ol>
<ul>
<li>当我们谈到“Web 服务器”时有两个层面的含义：硬件和软件。</li>
</ul>
<ol>
<li>硬件含义就是物理形式或“云”形式的机器，在大多数情况下它可能不是一台服务器，而是利用反向代理、负载均衡等技术组成的庞大集群。但从外界看来，它仍然表现为一台机器，但这个形象是“虚拟的”。</li>
<li>软件含义的 Web 服务器可能我们更为关心，它就是提供 Web 服务的应用程序，通常会运行在硬件含义的服务器上。它利用强大的硬件能力响应海量的客户端 HTTP 请求，处理磁盘上的网页、图片等静态文件，或者把请求转发给后面的 Tomcat、Node.js 等业务应用，返回动态的信息。<h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3></li>
</ol>
<ul>
<li>浏览器通常不会直接连到服务器，中间会经过“重重关卡”，其中的一个重要角色就叫做 CDN。</li>
<li>CDN，全称是“Content Delivery Network”，翻译过来就是“内容分发网络”。它应用了 HTTP 协议里的缓存和代理技术，代替源站响应客户端的请求。</li>
<li>简单来说，它可以缓存源站的数据，让浏览器的请求不用“千里迢迢”地到达源站服务器，直接在“半路”就可以获取响应。如果 CDN 的调度算法很优秀，更可以找到离用户最近的节点，大幅度缩短响应时间。</li>
<li>CDN 也是现在互联网中的一项重要基础设施，除了基本的网络加速外，还提供负载均衡、安全防护、边缘计算、跨运营商网络等功能，能够成倍地“放大”源站服务器的服务能力，很多云服务商都把 CDN 作为产品的一部分<h3 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h3></li>
<li>HTTP 协议并没有规定用户代理后面必须是“真正的人类”，它也完全可以是“机器人”，这些“机器人”的正式名称就叫做“爬虫”（Crawler），实际上是一种可以自动访问 Web 资源的应用程序。</li>
<li>爬虫绝大多数是由各大搜索引擎“放”出来的，抓取网页存入庞大的数据库，再建立关键字索引，这样我们才能够在搜索引擎中快速地搜索到互联网角落里的页面。</li>
<li>爬虫也有不好的一面，它会过度消耗网络资源，占用服务器和带宽，影响网站对真实数据的分析，甚至导致敏感信息泄漏。所以，又出现了“反爬虫”技术，通过各种手段来限制爬虫。其中一项就是“君子协定”robots.txt，约定哪些该爬，哪些不该爬。</li>
</ul>
<h3 id="HTML-WebService-WAF"><a href="#HTML-WebService-WAF" class="headerlink" title="HTML/WebService/WAF"></a>HTML/WebService/WAF</h3><ul>
<li>HTML 是 HTTP 协议传输的主要内容之一，它描述了超文本页面，用各种“标签”定义文字、图片等资源和排版布局，最终由浏览器“渲染”出可视化页面。</li>
<li>Web  Service 是一种由 W3C 定义的应用服务开发规范，使用 client-server 主从架构，通常使用 WSDL 定义服务接口，使用 HTTP 协议传输 XML 或 SOAP 消息，也就是说，它是一个基于 Web（HTTP）的服务架构技术，既可以运行在内网，也可以在适当保护后运行在外网。因为采用了 HTTP 协议传输数据，所以在 Web  Service 架构里服务器和客户端可以采用不同的操作系统或编程语言开发。例如服务器端用 Linux+Java，客户端用 Windows+C#，具有跨平台跨语言的优点。</li>
<li>WAF 是近几年比较“火”的一个词，意思是“网络应用防火墙”。与硬件“防火墙”类似，它是应用层面的“防火墙”，专门检测 HTTP 流量，是防护 Web 应用的安全技术。WAF 通常位于 Web 服务器之前，可以阻止如 SQL 注入、跨站脚本等攻击，目前应用较多的一个开源项目是 ModSecurity，它能够完全集成进 Apache 或 Nginx。</li>
</ul>
<h2 id="HTTP世界全览（下）：与HTTP相关的各种协议"><a href="#HTTP世界全览（下）：与HTTP相关的各种协议" class="headerlink" title="HTTP世界全览（下）：与HTTP相关的各种协议"></a>HTTP世界全览（下）：与HTTP相关的各种协议</h2><h3 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h3><ul>
<li>TCP/IP 协议实际上是一系列网络通信协议的统称，其中最核心的两个协议是 TCP 和 IP，其他的还有 UDP、ICMP、ARP 等等，共同构成了一个复杂但有层次的协议栈。</li>
<li>这个协议栈有四层，最上层是“应用层”，最下层是“链接层”，TCP 和 IP 则在中间：TCP 属于“传输层”，IP 属于“网际层”。</li>
<li>IP 协议是“Internet Protocol”的缩写，主要目的是解决寻址和路由问题，以及如何在两点间传送数据包。IP 协议使用“IP 地址”的概念来定位互联网上的每一台计算机。</li>
<li>现在我们使用的 IP 协议大多数是 v4 版，地址是四个用“.”分隔的数字，例如“192.168.0.1”，总共有 2^32，大约 42 亿个可以分配的地址。看上去好像很多，但互联网的快速发展让地址的分配管理很快就“捉襟见肘”。所以，就又出现了 v6 版，使用 8 组“:”分隔的数字作为地址，容量扩大了很多，有 2^128 个，在未来的几十年里应该是足够用了。</li>
<li>TCP 协议是“Transmission Control Protocol”的缩写，意思是“传输控制协议”，它位于 IP 协议之上，基于 IP 协议提供可靠的、字节流形式的通信，是 HTTP 协议得以实现的基础。</li>
<li>“可靠”是指保证数据不丢失，“字节流”是指保证数据完整，所以在 TCP 协议的两端可以如同操作文件一样访问传输的数据，就像是读写在一个密闭的管道里“流动”的字节。</li>
<li>HTTP 是一个”传输协议”，但它不关心寻址、路由、数据完整性等传输细节，而要求这些工作都由下层来处理。因为互联网上最流行的是 TCP/IP 协议，而它刚好满足 HTTP 的要求，所以互联网上的 HTTP 协议就运行在了 TCP/IP 上，HTTP 也就可以更准确地称为“HTTP over TCP/IP”。<h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3></li>
<li>在 DNS 中，“域名”（Domain Name）又称为“主机名”（Host），为了更好地标记不同国家或组织的主机，让名字更好记，所以被设计成了一个有层次的结构。</li>
<li>域名用“.”分隔成多个单词，级别从左到右逐级升高，最右边的被称为“顶级域名”。对于顶级域名，可能你随口就能说出几个，例如表示商业公司的“com”、表示教育机构的“edu”，表示国家的“cn”“uk”等，买火车票时的域名还记得吗？是“<a href="http://www.12306.cn”。" target="_blank" rel="noopener">www.12306.cn”。</a></li>
<li>想要使用 TCP/IP 协议来通信仍然要使用 IP 地址，所以需要把域名做一个转换，“映射”到它的真实 IP，这就是所谓的“域名解析”。</li>
<li>目前全世界有 13 组根 DNS 服务器，下面再有许多的顶级 DNS、权威 DNS 和更小的本地 DNS，逐层递归地实现域名查询。<h3 id="URI-URL"><a href="#URI-URL" class="headerlink" title="URI/URL"></a>URI/URL</h3></li>
<li>URI（Uniform Resource Identifier），中文名称是 统一资源标识符，使用它就能够唯一地标记互联网上资源。</li>
<li>URI 另一个更常用的表现形式是 URL（Uniform Resource Locator）， 统一资源定位符，也就是我们俗称的“网址”，它实际上是 URI 的一个子集，不过因为这两者几乎是相同的，差异不大，所以通常不会做严格的区分。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">http://nginx.org/en/download.html</span><br><span class="line">URI 主要有三个基本的部分构成：</span><br><span class="line">1.协议名：即访问该资源应当使用的协议，在这里是“http”；</span><br><span class="line">2.主机名：即互联网上主机的标记，可以是域名或 IP 地址，在这里是“nginx.org”；</span><br><span class="line">3.路径：即资源在主机上的位置，使用“/”分隔多级目录，在这里是“/en/download.html”。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><ul>
<li>SSL/TLS，它是一个负责加密通信的安全协议，建立在 TCP/IP 之上，所以也是个可靠的传输协议，可以被用作 HTTP 的下层。</li>
<li>SSL 的全称是“Secure Socket Layer”，由网景公司发明，当发展到 3.0 时被标准化，改名为 TLS，即“Transport Layer Security”，但由于历史的原因还是有很多人称之为 SSL/TLS，或者直接简称为 SSL。</li>
<li>SSL 使用了许多密码学最先进的研究成果，综合了对称加密、非对称加密、摘要算法、数字签名、数字证书等技术，能够在不安全的环境中为通信的双方创建出一个秘密的、安全的传输通道，为 HTTP 套上一副坚固的盔甲。<h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3></li>
<li>代理（Proxy）是 HTTP 协议中请求方和应答方中间的一个环节，作为“中转站”，既可以转发客户端的请求，也可以转发服务器的应答。</li>
<li>代理有很多的种类，常见的有：</li>
</ul>
<ol>
<li>匿名代理：完全“隐匿”了被代理的机器，外界看到的只是代理服务器；</li>
<li>透明代理：顾名思义，它在传输过程中是“透明开放”的，外界既知道代理，也知道客户端；</li>
<li>正向代理：靠近客户端，代表客户端向服务器发送请求</li>
<li>反向代理：靠近服务器端，代表服务器响应客户端的请求；</li>
</ol>
<ul>
<li>CDN，实际上就是一种代理，它代替源站服务器响应客户端的请求，通常扮演着透明代理和反向代理的角色。</li>
<li>由于代理在传输过程中插入了一个“中间层”，所以可以在这个环节做很多有意思的事情，比如：</li>
</ul>
<ol>
<li>负载均衡：把访问请求均匀分散到多台机器，实现访问集群化；</li>
<li>内容缓存：暂存上下行的数据，减轻后端的压力；</li>
<li>安全防护：隐匿 IP, 使用 WAF 等工具抵御网络攻击，保护被代理的机器；</li>
<li>数据处理：提供压缩、加密等额外的功能。</li>
</ol>
<h2 id="常说的“四层”和“七层”到底是什么？“五层”“六层”哪去了？"><a href="#常说的“四层”和“七层”到底是什么？“五层”“六层”哪去了？" class="headerlink" title="常说的“四层”和“七层”到底是什么？“五层”“六层”哪去了？"></a>常说的“四层”和“七层”到底是什么？“五层”“六层”哪去了？</h2><h3 id="TCP-IP-网络分层模型"><a href="#TCP-IP-网络分层模型" class="headerlink" title="TCP/IP 网络分层模型"></a>TCP/IP 网络分层模型</h3><ul>
<li>TCP/IP 协议总共有四层：“从下往上”</li>
</ul>
<ol>
<li>第一层叫“链接层”（link layer），负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标记网络上的设备，所以有时候也叫 MAC 层。</li>
<li>第二层叫“网际层”或者“网络互连层”（internet layer），IP 协议就处在这一层。因为 IP 协议定义了“IP 地址”的概念，所以就可以在“链接层”的基础上，用 IP 地址取代 MAC 地址，把许许多多的局域网、广域网连接成一个虚拟的巨大网络，在这个网络里找设备时只要把 IP 地址再“翻译”成 MAC 地址就可以了。</li>
<li>第三层叫“传输层”（transport layer），这个层次协议的职责是保证数据在 IP 地址标记的两点之间“可靠”地传输，是 TCP 协议工作的层次，另外还有它的一个“小伙伴”UDP。<br>TCP 是一个有状态的协议，需要先与对方建立连接然后才能发送数据，而且保证数据不丢失不重复。<br>而 UDP 则比较简单，它无状态，不用事先建立连接就可以任意发送数据，但不保证数据一定会发到对方。<br>两个协议的另一个重要区别在于数据的形式。TCP 的数据是连续的“字节流”，有先后顺序，而 UDP 则是分散的小数据包，是顺序发，乱序收。</li>
<li>协议栈的第四层叫“应用层”（application layer），由于下面的三层把基础打得非常好，所以在这一层就“百花齐放”了，有各种面向具体应用的协议。例如 Telnet、SSH、FTP、SMTP 等等，当然还有我们的 HTTP。</li>
</ol>
<ul>
<li>MAC地址（英语：Media Access Control Address），直译为媒体存取控制位址，也称为局域网地址（LAN Address），MAC位址，以太网地址（Ethernet Address）或物理地址（Physical Address），它是一个用来确认网络设备位置的位址。在OSI模型中，第三层网络层负责IP地址，第二层数据链路层则负责MAC位址 。MAC地址用于在网络中唯一标示一个网卡，一台设备若有一或多个网卡，则每个网卡都需要并会有一个唯一的MAC地址 。</li>
</ul>
<h3 id="OSI-网络分层模型"><a href="#OSI-网络分层模型" class="headerlink" title="OSI 网络分层模型"></a>OSI 网络分层模型</h3><ul>
<li>OSI，全称是“开放式系统互联通信参考模型”（Open System Interconnection Reference Model）。</li>
<li>OSI 模型分成了七层，部分层次与 TCP/IP 很像，从下到上分别是：</li>
</ul>
<ol>
<li>第一层：物理层，网络的物理形式，例如电缆、光纤、网卡、集线器等等；</li>
<li>第二层：数据链路层，它基本相当于 TCP/IP 的链接层；</li>
<li>第三层：网络层，相当于 TCP/IP 里的网际层；</li>
<li>第四层：传输层，相当于 TCP/IP 里的传输层；</li>
<li>第五层：会话层，维护网络中的连接状态，即保持会话和同步；</li>
<li>第六层：表示层，把数据转换为合适、可理解的语法和语义；</li>
<li>第七层：应用层，面向具体的应用传输数据。<h3 id="两个分层模型的映射关系"><a href="#两个分层模型的映射关系" class="headerlink" title="两个分层模型的映射关系"></a>两个分层模型的映射关系</h3></li>
</ol>
<ul>
<li>OSI 在设计之初就参考了 TCP/IP 等多个协议，可以比较容易但不是很精确地实现对应关系。</li>
</ul>
<ol>
<li>第一层：物理层，TCP/IP 里无对应；</li>
<li>第二层：数据链路层，对应 TCP/IP 的链接层；</li>
<li>第三层：网络层，对应 TCP/IP 的网际层；</li>
<li>第四层：传输层，对应 TCP/IP 的传输层；</li>
<li>第五、六、七层：统一对应到 TCP/IP 的应用层。</li>
</ol>
<ul>
<li>OSI 的分层模型在四层以上分的太细，而 TCP/IP 实际应用时的会话管理、编码转换、压缩等和具体应用经常联系的很紧密，很难分开。例如，HTTP 协议就同时包含了连接管理和数据格式定义。</li>
<li>所谓的“四层负载均衡”就是指工作在传输层上，基于 TCP/IP 协议的特性，例如 IP 地址、端口号等实现对后端服务器的负载均衡。</li>
<li>所谓的“七层负载均衡”就是指工作在应用层上，看到的是 HTTP 协议，解析 HTTP 报文里的 URI、主机名、资源类型等数据，再用适当的策略转发给后端服务器。</li>
</ul>
<h3 id="TCP-IP-协议栈的工作方式"><a href="#TCP-IP-协议栈的工作方式" class="headerlink" title="TCP/IP 协议栈的工作方式"></a>TCP/IP 协议栈的工作方式</h3><ul>
<li>HTTP 协议的传输过程就是这样通过协议栈逐层向下，每一层都添加本层的专有数据，层层打包，然后通过下层发送出去。</li>
<li>接收数据则是相反的操作，从下往上穿过协议栈，逐层拆包，每层去掉本层的专有头，上层就会拿到自己的数据。</li>
<li>但下层的传输过程对于上层是完全“透明”的，上层也不需要关心下层的具体实现细节，所以就 HTTP 层次来看，它不管下层是不是 TCP/IP 协议，看到的只是一个可靠的传输链路，只要把数据加上自己的头，对方就能原样收到。</li>
</ul>
<h2 id="域名里有哪些门道？"><a href="#域名里有哪些门道？" class="headerlink" title="域名里有哪些门道？"></a>域名里有哪些门道？</h2><h3 id="域名的形式"><a href="#域名的形式" class="headerlink" title="域名的形式"></a>域名的形式</h3><ul>
<li>域名是一个有层次的结构，是一串用“.”分隔的多个单词，最右边的被称为“顶级域名”，然后是“二级域名”，层级关系向左依次降低。</li>
<li>域名不仅能够代替 IP 地址，还有许多其他的用途。在 Apache、Nginx 这样的 Web 服务器里，域名可以用来标识虚拟主机，决定由哪个虚拟主机来对外提供服务，比如在 Nginx 里就会使用“server_name”指令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;                       #监听80端口</span><br><span class="line">    server_name  time.diamonds.org;  #主机名是time.diamonds.org</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="域名的解析"><a href="#域名的解析" class="headerlink" title="域名的解析"></a>域名的解析</h3><ul>
<li>就像 IP 地址必须转换成 MAC 地址才能访问主机一样，域名也必须要转换成 IP 地址，这个过程就是“域名解析”。</li>
<li>DNS 的核心系统是一个三层的树状、分布式服务，基本对应域名的结构：</li>
</ul>
<ol>
<li>根域名服务器（Root DNS Server）：管理顶级域名服务器，返回“com”“net”“cn”等顶级域名服务器的 IP 地址；</li>
<li>顶级域名服务器（Top-level DNS Server）：管理各自域名下的权威域名服务器，比如 com 顶级域名服务器可以返回 apple.com 域名服务器的 IP 地址；</li>
<li>权威域名服务器（Authoritative DNS Server）：管理自己域名下主机的 IP 地址，比如 apple.com 权威域名服务器可以返回 <a href="http://www.apple.com" target="_blank" rel="noopener">www.apple.com</a> 的 IP 地址。</li>
</ol>
<ul>
<li>在这里根域名服务器是关键，它必须是众所周知的，否则下面的各级服务器就无从谈起了。目前全世界共有 13 组根域名服务器，又有数百台的镜像，保证一定能够被访问到。</li>
<li><p>有了这个系统以后，任何一个域名都可以在这个树形结构里从顶至下进行查询，就好像是把域名从右到左顺序走了一遍，最终就获得了域名对应的 IP 地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例如，你要访问“www.apple.com”，就要进行下面的三次查询：</span><br><span class="line">1. 访问根域名服务器，它会告诉你“com”顶级域名服务器的地址；</span><br><span class="line">2. 访问“com”顶级域名服务器，它再告诉你“apple.com”域名服务器的地址；</span><br><span class="line">3. 最后访问“apple.com”域名服务器，就得到了“www.apple.com”的地址。</span><br></pre></td></tr></table></figure>
</li>
<li><p>在核心 DNS 系统之外，还有两种手段用来减轻域名解析的压力，并且能够更快地获取结果，基本思路就是“缓存”。</p>
</li>
<li>首先，许多大公司、网络运行商都会建立自己的 DNS 服务器，作为用户 DNS 查询的代理，代替用户访问核心 DNS 系统。这些“野生”服务器被称为“非权威域名服务器”，可以缓存之前的查询结果，如果已经有了记录，就无需再向根服务器发起查询，直接返回对应的 IP 地址。</li>
<li>这些 DNS 服务器的数量要比核心系统的服务器多很多，而且大多部署在离用户很近的地方。比较知名的 DNS 有 Google 的“8.8.8.8”，Microsoft 的“4.2.2.1”，还有 CloudFlare 的“1.1.1.1”等等。</li>
<li>其次，操作系统里也会对 DNS 解析结果做缓存，如果你之前访问过“<a href="http://www.apple.com”，那么下一次在浏览器里再输入这个网址的时候就不会再跑到" target="_blank" rel="noopener">www.apple.com”，那么下一次在浏览器里再输入这个网址的时候就不会再跑到</a> DNS 那里去问了，直接在操作系统里就可以拿到 IP 地址。</li>
<li>另外，操作系统里还有一个特殊的“主机映射”文件，通常是一个可编辑的文本，在 Linux 里是“/etc/hosts”，在 Windows 里是“C:\WINDOWS\system32\drivers\etc\hosts”，如果操作系统在缓存里找不到 DNS 记录，就会找这个文件。</li>
<li>有了上面的“野生”DNS 服务器、操作系统缓存和 hosts 文件后，很多域名解析的工作就都不用“跋山涉水”了，直接在本地或本机就能解决，不仅方便了用户，也减轻了各级 DNS 服务器的压力，效率就大大提升了。</li>
</ul>
<h3 id="域名的“新玩法”"><a href="#域名的“新玩法”" class="headerlink" title="域名的“新玩法”"></a>域名的“新玩法”</h3><ul>
<li>第一种，也是最简单的，“重定向”。因为域名代替了 IP 地址，所以可以让对外服务的域名不变，而主机的 IP 地址任意变动。当主机有情况需要下线、迁移时，可以更改 DNS 记录，让域名指向其他的机器。</li>
<li>第二种，因为域名是一个名字空间，所以可以使用 bind9 等开源软件搭建一个在内部使用的 DNS，作为名字服务器。这样我们开发的各种内部服务就都用域名来标记，比如数据库服务都用域名“mysql.inner.app”，商品服务都用“goods.inner.app”，发起网络通信时也就不必再使用写死的 IP 地址了，可以直接用域名，而且这种方式也兼具了第一种“玩法”的优势。</li>
<li>第三种“玩法”包含了前两种，也就是基于域名实现的负载均衡。这种“玩法”也有两种方式，两种方式可以混用。</li>
</ul>
<ol>
<li>第一种方式，因为域名解析可以返回多个 IP 地址，所以一个域名可以对应多台主机，客户端收到多个 IP 地址后，就可以自己使用轮询算法依次向服务器发起请求，实现负载均衡。</li>
<li>第二种方式，域名解析可以配置内部的策略，返回离客户端最近的主机，或者返回当前服务质量最好的主机，这样在 DNS 端把请求分发到不同的服务器，实现负载均衡。</li>
</ol>
<ul>
<li>不怀好意的 DNS</li>
</ul>
<ol>
<li>“域名屏蔽”，对域名直接不解析，返回错误，让你无法拿到 IP 地址，也就无法访问网站；</li>
<li>“域名劫持”，也叫“域名污染”，你要访问 A 网站，但 DNS 给了你 B 网站。</li>
</ol>
<h2 id="键入网址再按下回车，后面究竟发生了什么？"><a href="#键入网址再按下回车，后面究竟发生了什么？" class="headerlink" title="键入网址再按下回车，后面究竟发生了什么？"></a>键入网址再按下回车，后面究竟发生了什么？</h2><p>###使用 IP 地址访问 Web 服务器</p>
<ul>
<li>在 Chrome 浏览器的地址栏里输入“<a href="http://127.0.0.1/”，再按下回车键" target="_blank" rel="noopener">http://127.0.0.1/”，再按下回车键</a></li>
</ul>
<ol>
<li>因为我们在地址栏里直接输入了 IP 地址“127.0.0.1”，而 Web 服务器的默认端口是 80，所以浏览器就要依照 TCP 协议的规范，使用“三次握手”建立与 Web 服务器的连接。</li>
<li>经过 SYN、SYN/ACK、ACK 的三个包之后，浏览器与服务器的 TCP 连接就建立起来了。</li>
<li>有了可靠的 TCP 连接通道后，HTTP 协议就可以开始工作了。于是，浏览器按照 HTTP 协议规定的格式，通过 TCP 发送了一个“GET / HTTP/1.1”请求报文</li>
<li>随后，Web 服务器回复了第五个包，在 TCP 协议层面确认：“刚才的报文我已经收到了”，不过这个 TCP 包 HTTP 协议是看不见的。</li>
<li>Web 服务器收到报文后在内部就要处理这个请求。同样也是依据 HTTP 协议的规定，解析报文，看看浏览器发送这个请求想要干什么。</li>
<li>它一看，原来是要求获取根目录下的默认文件，好吧，那我就从磁盘上把那个文件全读出来，再拼成符合 HTTP 格式的报文，发回去吧。</li>
<li>同样的，浏览器也要给服务器回复一个 TCP 的 ACK 确认，“你的响应报文收到了，多谢”，即第七个包。</li>
<li>这时浏览器就收到了响应数据，但里面是什么呢？所以也要解析报文。一看，服务器给我的是个 HTML 文件，好，那我就调用排版引擎、JavaScript 引擎等等处理一下，然后在浏览器窗口里展现出了欢迎页面。</li>
<li>这之后还有两个来回，共四个包，重复了相同的步骤。这是浏览器自动请求了作为网站图标的“favicon.ico”文件，与我们输入的网址无关。</li>
<li>至此，“键入网址再按下回车”的全过程就结束了。</li>
</ol>
<ul>
<li>简要叙述一下这次最简单的浏览器 HTTP 请求过程：</li>
</ul>
<ol>
<li>浏览器从地址栏的输入中获得服务器的 IP 地址和端口号；</li>
<li>浏览器用 TCP 的三次握手与服务器建立连接；</li>
<li>浏览器向服务器发送拼好的报文；</li>
<li>服务器收到报文后处理请求，同样拼好报文再发给浏览器；</li>
<li>浏览器解析报文，渲染输出页面。</li>
</ol>
<h3 id="使用域名访问-Web-服务器"><a href="#使用域名访问-Web-服务器" class="headerlink" title="使用域名访问 Web 服务器"></a>使用域名访问 Web 服务器</h3><ul>
<li>在域名解析的过程中会有多级的缓存，浏览器首先看一下自己的缓存里有没有，如果没有就向操作系统的缓存要，还没有就检查本机域名解析文件 hosts，</li>
<li>DNS 解析可能会给出 CDN 服务器的 IP 地址，这样你拿到的就会是 CDN 服务器而不是目标网站的实际地址。</li>
<li>因为 CDN 会缓存网站的大部分资源，比如图片、CSS 样式表，所以有的 HTTP 请求就不需要再发到 Apple，CDN 就可以直接响应你的请求，把数据发给你。</li>
<li>目标网站的服务器对外表现的是一个 IP 地址，但为了能够扛住高并发，在内部也是一套复杂的架构。通常在入口是负载均衡设备，例如四层的 LVS 或者七层的 Nginx，在后面是许多的服务器，构成一个更强更稳定的集群。</li>
<li>负载均衡设备会先访问系统里的缓存服务器，通常有 memory 级缓存 Redis 和 disk 级缓存 Varnish，它们的作用与 CDN 类似，不过是工作在内部网络里，把最频繁访问的数据缓存几秒钟或几分钟，减轻后端应用服务器的压力。</li>
<li>如果缓存服务器里也没有，那么负载均衡设备就要把请求转发给应用服务器了。这里就是各种开发框架大显神通的地方了，例如 Java 的 Tomcat/Netty/Jetty，Python 的 Django，还有 PHP、Node.js、Golang 等等。它们又会再访问后面的 MySQL、PostgreSQL、MongoDB 等数据库服务，实现用户登录、商品查询、购物下单、扣款支付等业务操作，然后把执行的结果返回给负载均衡设备，同时也可能给缓存服务器里也放一份。</li>
<li>应用服务器的输出到了负载均衡设备这里，请求的处理就算是完成了，就要按照原路再走回去，还是要经过许多的路由器、网关、代理。如果这个资源允许缓存，那么经过 CDN 的时候它也会做缓存，这样下次同样的请求就不会到达源站了。</li>
<li>最后网站的响应数据回到了你的设备，它可能是 HTML、JSON、图片或者其他格式的数据，需要由浏览器解析处理才能显示出来，如果数据里面还有超链接，指向别的资源，那么就又要重走一遍整个流程，直到所有的资源都下载完。</li>
</ul>
<h2 id="HTTP报文是什么样子的？"><a href="#HTTP报文是什么样子的？" class="headerlink" title="HTTP报文是什么样子的？"></a>HTTP报文是什么样子的？</h2><ul>
<li>HTTP 的工作模式是非常简单的，由于 TCP/IP 协议负责底层的具体传输工作，HTTP 协议基本上不用在这方面操心太多。单从这一点上来看，所谓的“超文本传输协议”其实并不怎么管“传输”的事情，有点“名不副实”。</li>
<li>HTTP 协议的核心部分是什么呢？答案就是它传输的报文内容。</li>
<li>HTTP 协议在规范文档里详细定义了报文的格式，规定了组成部分，解析规则，还有处理策略，所以可以在 TCP/IP 层之上实现更灵活丰富的功能，例如连接控制，缓存管理、数据编码、内容协商等等。</li>
</ul>
<h3 id="报文结构"><a href="#报文结构" class="headerlink" title="报文结构"></a>报文结构</h3><ul>
<li>拿 TCP 报文来举例，它在实际要传输的数据之前附加了一个 20 字节的头部数据，存储 TCP 协议必须的额外信息，例如发送方的端口号、接收方的端口号、包序号、标志位等等。</li>
<li>有了这个附加的 TCP 头，数据包才能够正确传输，到了目的地后把头部去掉，就可以拿到真正的数据。</li>
<li>HTTP 协议也是与 TCP/UDP 类似，同样也需要在实际传输的数据前附加一些头数据，不过与 TCP/UDP 不同的是，它是一个“纯文本”的协议，所以头数据都是 ASCII 码的文本，可以很容易地用肉眼阅读，不用借助程序解析也能够看懂。</li>
<li>HTTP 协议的请求报文和响应报文的结构基本相同，由三大部分组成：</li>
</ul>
<ol>
<li>起始行（start line）：描述请求或响应的基本信息；</li>
<li>头部字段集合（header）：使用 key-value 形式更详细地说明报文；</li>
<li>消息正文（entity）：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据。</li>
</ol>
<ul>
<li>HTTP 协议规定报文必须有 header，但可以没有 body，而且在 header 之后必须要有一个“空行”，也就是“CRLF”，十六进制的“0D0A”。</li>
<li>虽然 HTTP 协议对 header 的大小没有做限制，但各个 Web 服务器都不允许过大的请求头，因为头部太大可能会占用大量的服务器资源，影响运行效率。<h3 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h3></li>
<li>它简要地描述了客户端想要如何操作服务器端的资源。</li>
<li>请求行由三部分构成：</li>
</ul>
<ol>
<li>请求方法：是一个动词，如 GET/POST，表示对资源的操作；</li>
<li>请求目标：通常是一个 URI，标记了请求方法要操作的资源；</li>
<li>版本号：表示报文使用的 HTTP 协议版本。</li>
</ol>
<ul>
<li>这三个部分通常使用空格（space）来分隔，最后要用 CRLF 换行表示结束。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line"></span><br><span class="line">在这个请求行里，“GET”是请求方法，“/”是请求目标，“HTTP/1.1”是版本号，</span><br><span class="line">把这三部分连起来，意思就是“服务器你好，我想获取网站根目录下的默认文件，</span><br><span class="line">我用的协议版本号是 1.1，请不要用 1.0 或者 2.0 回复我。”</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h3><ul>
<li>响应报文里的起始行，在这里它不叫“响应行”，而是叫“状态行”（status line），意思是服务器响应的状态。</li>
<li>比起请求行来说，状态行要简单一些，同样也是由三部分构成：</li>
</ul>
<ol>
<li>版本号：表示报文使用的 HTTP 协议版本；</li>
<li>状态码：一个三位数，用代码的形式表示处理的结果，比如 200 是成功，500 是服务器错误；</li>
<li>原因：作为数字状态码补充，是更详细的解释文字，帮助人理解原因。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">意思就是：“浏览器你好，我已经处理完了你的请求，这个报文使用的协议版本号是 1.1，状态码是 200，一切 OK。”</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HTTP/1.1 404 Not Found</span><br><span class="line">翻译成人话就是：“抱歉啊浏览器，刚才你的请求收到了，但我没找到你要的资源，错误代码是 404，接下来的事情你就看着办吧。”</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="头部字段"><a href="#头部字段" class="headerlink" title="头部字段"></a>头部字段</h3><ul>
<li>头部字段是 key-value 的形式，key 和 value 之间用“:”分隔，最后用 CRLF 换行表示字段结束。比如在“Host: 127.0.0.1”这一行里 key 就是“Host”，value 就是“127.0.0.1”。</li>
<li>HTTP 头字段非常灵活，不仅可以使用标准里的 Host、Connection 等已有头，也可以任意添加自定义头，这就给 HTTP 协议带来了无限的扩展可能。</li>
<li>不过使用头字段需要注意下面几点：</li>
</ul>
<ol>
<li>字段名不区分大小写，例如“Host”也可以写成“host”，但首字母大写的可读性更好；</li>
<li>字段名里不允许出现空格，可以使用连字符“-”，但不能使用下划线“_”。例如，“test-name”是合法的字段名，而“test name”“test_name”是不正确的字段名；</li>
<li>字段名后面必须紧接着“:”，不能有空格，而“:”后的字段值前可以有多个空格；</li>
<li>字段的顺序是没有意义的，可以任意排列不影响语义；</li>
<li>字段原则上不能重复，除非这个字段本身的语义允许，例如 Set-Cookie。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">GET /09-1 HTTP/1.1</span><br><span class="line">Host:   www.diamonds.com</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GET /09-1 HTTP/1.1</span><br><span class="line">Host : www.diamonds.com</span><br><span class="line"></span><br><span class="line">第一个可以正确获取服务器的响应报文，而第二个得到的会是一个“400 Bad Request”，表示请求报文格式有误，服务器无法正确处理：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HTTP/1.1 400 Bad Request</span><br><span class="line">Server: openresty/1.15.8.1</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="常用头字段"><a href="#常用头字段" class="headerlink" title="常用头字段"></a>常用头字段</h3><ul>
<li>HTTP 协议规定了非常多的头部字段，实现各种各样的功能，但基本上可以分为四大类：</li>
</ul>
<ol>
<li>通用字段：在请求头和响应头里都可以出现；</li>
<li>请求字段：仅能出现在请求头里，进一步说明请求信息或者额外的附加条件；</li>
<li>响应字段：仅能出现在响应头里，补充说明响应报文的信息；</li>
<li>实体字段：它实际上属于通用字段，但专门描述 body 的额外信息。</li>
</ol>
<ul>
<li>对 HTTP 报文的解析和处理实际上主要就是对头字段的处理，理解了头字段也就理解了 HTTP 报文。</li>
<li>Host 字段，它属于请求字段，只能出现在请求头里，它同时也是唯一一个 HTTP/1.1 规范里要求必须出现的字段，也就是说，如果请求头里没有 Host，那这就是一个错误的报文。Host 字段告诉服务器这个请求应该由哪个主机来处理，当一台计算机上托管了多个虚拟主机的时候，服务器端就需要用 Host 字段来选择，有点像是一个简单的“路由重定向”。例如我们的试验环境，在 127.0.0.1 上有三个虚拟主机：“<a href="http://www.diamonds.com”“www.metroid.net”和“origin.io”。那么当使用域名的方式访问时，就必须要用" target="_blank" rel="noopener">www.diamonds.com”“www.metroid.net”和“origin.io”。那么当使用域名的方式访问时，就必须要用</a> Host 字段来区分这三个 IP 相同但域名不同的网站，否则服务器就会找不到合适的虚拟主机，无法处理。</li>
<li>User-Agent 是请求字段，只出现在请求头里。它使用一个字符串来描述发起 HTTP 请求的客户端，服务器可以依据它来返回最合适此浏览器显示的页面。但由于历史的原因，User-Agent 非常混乱，每个浏览器都自称是“Mozilla”“Chrome”“Safari”，企图使用这个字段来互相“伪装”，导致 User-Agent 变得越来越长，最终变得毫无意义。不过有的比较“诚实”的爬虫会在 User-Agent 里用“spider”标明自己是爬虫，所以可以利用这个字段实现简单的反爬虫策略。</li>
<li>Date 字段是一个通用字段，但通常出现在响应头里，表示 HTTP 报文创建的时间，客户端可以使用这个时间再搭配其他字段决定缓存策略。</li>
<li>Server 字段是响应字段，只能出现在响应头里。它告诉客户端当前正在提供 Web 服务的软件名称和版本号，例如在我们的实验环境里它就是“Server: openresty/1.15.8.1”，即使用的是 OpenResty 1.15.8.1。Server 字段也不是必须要出现的，因为这会把服务器的一部分信息暴露给外界，如果这个版本恰好存在 bug，那么黑客就有可能利用 bug 攻陷服务器。所以，有的网站响应头里要么没有这个字段，要么就给出一个完全无关的描述信息。</li>
<li>实体字段里要说的一个是 Content-Length，它表示报文里 body 的长度，也就是请求头或响应头空行后面数据的长度。服务器看到这个字段，就知道了后续有多少数据，可以直接接收。如果没有这个字段，那么 body 就是不定长的，需要使用 chunked 方式分段传输。</li>
</ul>
<h2 id="应该如何理解请求方法？"><a href="#应该如何理解请求方法？" class="headerlink" title="应该如何理解请求方法？"></a>应该如何理解请求方法？</h2><h3 id="标准请求方法"><a href="#标准请求方法" class="headerlink" title="标准请求方法"></a>标准请求方法</h3><ul>
<li>它的实际含义就是客户端发出了一个“动作指令”，要求服务器端对 URI 定位的资源执行这个动作。</li>
<li>目前 HTTP/1.1 规定了八种方法，单词都必须是大写的形式，</li>
</ul>
<ol>
<li>GET：获取资源，可以理解为读取或者下载数据；</li>
<li>HEAD：获取资源的元信息；</li>
<li>POST：向资源提交数据，相当于写入或上传数据；</li>
<li>PUT：类似 POST；</li>
<li>DELETE：删除资源；</li>
<li>CONNECT：建立特殊的连接隧道；</li>
<li>OPTIONS：列出可对资源实行的方法；</li>
<li>TRACE：追踪请求 - 响应的传输路径。</li>
</ol>
<ul>
<li>服务器掌控着所有资源，也就有绝对的决策权力。它收到 HTTP 请求报文后，看到里面的请求方法，可以执行也可以拒绝，或者改变动作的含义，毕竟 HTTP 是一个“协议”，两边都要“商量着来”。</li>
<li>比如，你发起了一个 GET 请求，想获取“/orders”这个文件，但这个文件保密级别比较高，不是谁都能看的，服务器就可以有如下的几种响应方式：</li>
</ul>
<ol>
<li>假装这个文件不存在，直接返回一个 404 Not found 报文；</li>
<li>稍微友好一点，明确告诉你有这个文件，但不允许访问，返回一个 403 Forbidden；</li>
<li>再宽松一些，返回 405 Method Not Allowed，然后用 Allow 头告诉你可以用 HEAD 方法获取文件的元信息。<h3 id="GET-HEAD"><a href="#GET-HEAD" class="headerlink" title="GET/HEAD"></a>GET/HEAD</h3></li>
</ol>
<ul>
<li>GET 方法应该是 HTTP 协议里最知名的请求方法了，它的含义是请求从服务器获取资源，这个资源既可以是静态的文本、页面、图片、视频，也可以是由 PHP、Java 动态生成的页面或者其他格式的数据。GET 方法虽然基本动作比较简单，但搭配 URI 和其他头字段就能实现对资源更精细的操作。例如，在 URI 后使用“#”，就可以在获取页面后直接定位到某个标签所在的位置；使用 If-Modified-Since 字段就变成了“有条件的请求”，仅当资源被修改时才会执行获取动作；使用 Range 字段就是“范围请求”，只获取资源的一部分数据。</li>
<li>HEAD 方法与 GET 方法类似，也是请求从服务器获取资源，服务器的处理机制也是一样的，但服务器不会返回请求的实体数据，只会传回响应头，也就是资源的“元信息”。HEAD 方法可以看做是 GET 方法的一个“简化版”或者“轻量版”。因为它的响应头与 GET 完全相同，所以可以用在很多并不真正需要资源的场合，避免传输 body 数据的浪费。比如，想要检查一个文件是否存在，只要发个 HEAD 请求就可以了，没有必要用 GET 把整个文件都取下来。再比如，要检查文件是否有最新版本，同样也应该用 HEAD，服务器会在响应头里把文件的修改时间传回来。</li>
</ul>
<h3 id="POST-PUT"><a href="#POST-PUT" class="headerlink" title="POST/PUT"></a>POST/PUT</h3><ul>
<li>POST 也是一个经常用到的请求方法，PUT 的作用与 POST 类似，也可以向服务器提交数据，但与 POST 存在微妙的不同，通常 POST 表示的是“新建”“create”的含义，而 PUT 则是“修改”“update”的含义。<h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3></li>
<li>DELETE 方法指示服务器删除资源，因为这个动作危险性太大，所以通常服务器不会执行真正的删除操作，而是对资源做一个删除标记。当然，更多的时候服务器就直接不处理 DELETE 请求。</li>
<li>CONNECT 是一个比较特殊的方法，要求服务器为客户端和另一台远程服务器建立一条特殊的连接隧道，这时 Web 服务器在中间充当了代理的角色。</li>
<li>OPTIONS 方法要求服务器列出可对资源实行的操作方法，在响应头的 Allow 字段里返回。它的功能很有限，用处也不大，有的服务器（例如 Nginx）干脆就没有实现对它的支持。</li>
<li>TRACE 方法多用于对 HTTP 链路的测试或诊断，可以显示出请求 - 响应的传输路径。它的本意是好的，但存在漏洞，会泄漏网站的信息，所以 Web 服务器通常也是禁止使用。<h3 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h3></li>
<li>虽然 HTTP/1.1 里规定了八种请求方法，但它并没有限制我们只能用这八种方法，这也体现了 HTTP 协议良好的扩展性，我们可以任意添加请求动作，只要请求方和响应方都能理解就行。</li>
<li>例如著名的愚人节玩笑 RFC2324，它定义了协议 HTCPCP，即“超文本咖啡壶控制协议”，为 HTTP 协议增加了用来煮咖啡的 BREW 方法，要求添牛奶的 WHEN 方法。</li>
<li>此外，还有一些得到了实际应用的请求方法（WebDAV），例如 MKCOL、COPY、MOVE、LOCK、UNLOCK、PATCH 等。如果有合适的场景，你也可以把它们应用到自己的系统里，比如用 LOCK 方法锁定资源暂时不允许修改，或者使用 PATCH 方法给资源打个小补丁，部分更新数据。但因为这些方法是非标准的，所以需要为客户端和服务器编写额外的代码才能添加支持。<h3 id="安全与幂等"><a href="#安全与幂等" class="headerlink" title="安全与幂等"></a>安全与幂等</h3></li>
<li>在 HTTP 协议里，所谓的“安全”是指请求方法不会“破坏”服务器上的资源，即不会对服务器上的资源造成实质的修改。</li>
<li>按照这个定义，只有 GET 和 HEAD 方法是“安全”的，因为它们是“只读”操作，只要服务器不故意曲解请求方法的处理方式，无论 GET 和 HEAD 操作多少次，服务器上的数据都是“安全的”。而 POST/PUT/DELETE 操作会修改服务器上的资源，增加或删除数据，所以是“不安全”的。</li>
<li>所谓的“幂等”实际上是一个数学用语，被借用到了 HTTP 协议里，意思是多次执行相同的操作，结果也都是相同的，即多次“幂”后结果“相等”。</li>
<li>很显然，GET 和 HEAD 既是安全的也是幂等的，DELETE 可以多次删除同一个资源，效果都是“资源不存在”，所以也是幂等的。POST 和 PUT 的幂等性质就略费解一点。</li>
<li>按照 RFC 里的语义，POST 是“新增或提交数据”，多次提交数据会创建多个资源，所以不是幂等的；而 PUT 是“替换或更新数据”，多次更新一个资源，资源还是会第一次更新的状态，所以是幂等的。可以对比一下 SQL 来加深理解：把 POST 理解成 INSERT，把 PUT 理解成 UPDATE，这样就很清楚了。多次 INSERT 会添加多条记录，而多次 UPDATE 只操作一条记录，而且效果相同。</li>
</ul>
<h2 id="你能写出正确的网址吗？"><a href="#你能写出正确的网址吗？" class="headerlink" title="你能写出正确的网址吗？"></a>你能写出正确的网址吗？</h2><ul>
<li>严格地说，URI统一资源标识符（Uniform Resource Identifier） 不完全等同于网址，它包含有 URL 和 URN 两个部分，在 HTTP 世界里用的网址实际上是 URL——统一资源定位符（Uniform Resource Locator）。但因为 URL 实在是太普及了，所以常常把这两者简单地视为相等。<h3 id="URI-的格式"><a href="#URI-的格式" class="headerlink" title="URI 的格式"></a>URI 的格式</h3></li>
<li>URI 本质上是一个字符串，这个字符串的作用是唯一地标记资源的位置或者名字。它不仅能够标记万维网的资源，也可以标记其他的，如邮件系统、本地文件系统等任意资源。而“资源”既可以是存在磁盘上的静态文本、页面数据，也可以是由 Java、PHP 提供的动态服务。<h3 id="URI-的基本组成"><a href="#URI-的基本组成" class="headerlink" title="URI 的基本组成"></a>URI 的基本组成</h3></li>
<li>URI 第一个组成部分叫 scheme，翻译成中文叫“方案名”或者“协议名”，表示资源应该使用哪种协议来访问。最常见的当然就是“http”了，表示使用 HTTP 协议。另外还有“https”，表示使用经过加密、安全的 HTTPS 协议。此外还有其他不是很常见的 scheme，例如 ftp、ldap、file、news 等。</li>
<li>在 scheme 之后，必须是三个特定的字符“://”，它把 scheme 和后面的部分分离开。URI 的创造者蒂姆·伯纳斯 - 李也曾经私下承认“://”并非必要，当初有些“过于草率”了。</li>
<li>在“://”之后，是被称为“authority”的部分，表示资源所在的主机名，通常的形式是“host:port”，即主机名加端口号。主机名可以是 IP 地址或者域名的形式，必须要有，否则浏览器就会找不到服务器。但端口号有时可以省略，浏览器等客户端会依据 scheme 使用默认的端口号，例如 HTTP 的默认端口号是 80，HTTPS 的默认端口号是 443。</li>
<li>有了协议名和主机地址、端口号，再加上后面标记资源所在位置的 path，浏览器就可以连接服务器访问资源了。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">http://nginx.org</span><br><span class="line">https://tools.ietf.org/html/rfc7230</span><br><span class="line">file:///D:/http_study/www/</span><br><span class="line"></span><br><span class="line">最后一个 URI 要注意了，它的协议名不是“http”，而是“file”，表示这是本地文件，而后面居然有三个斜杠，这是怎么回事？</span><br><span class="line">这三个斜杠里的前两个属于 URI 特殊分隔符“://”，然后后面的“/D:/http_study/www/”是路径，而中间的主机名被“省略”了。</span><br><span class="line">这实际上是 file 类型 URI 的“特例”，它允许省略主机名，默认是本机 localhost。</span><br><span class="line"></span><br><span class="line">但对于 HTTP 或 HTTPS 这样的网络通信协议，主机名是绝对不能省略的。原因之前也说了，会导致浏览器无法找到服务器。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="URI-的查询参数"><a href="#URI-的查询参数" class="headerlink" title="URI 的查询参数"></a>URI 的查询参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">http://www.diamonds.com:8080/11-1?uid=1234&amp;name=mario&amp;referer=xxx</span><br></pre></td></tr></table></figure>
<h3 id="URI-的完整格式"><a href="#URI-的完整格式" class="headerlink" title="URI 的完整格式"></a>URI 的完整格式</h3><ul>
<li>第一个多出的部分是协议名之后、主机名之前的身份信息“user:passwd@”，表示登录主机时的用户名和密码，但现在已经不推荐使用这种形式了（RFC7230），因为它把敏感信息以明文形式暴露出来，存在严重的安全隐患。</li>
<li>第二个多出的部分是查询参数后的片段标识符“#fragment”，它是 URI 所定位的资源内部的一个“锚点”或者说是“标签”，浏览器可以在获取资源后直接跳转到它指示的位置。但片段标识符仅能由浏览器这样的客户端使用，服务器是看不到的。也就是说，浏览器永远不会把带“#fragment”的 URI 发送给服务器，服务器也永远不会用这种方式去处理资源的片段。</li>
</ul>
<h3 id="URI-的编码"><a href="#URI-的编码" class="headerlink" title="URI 的编码"></a>URI 的编码</h3><ul>
<li>URI 引入了编码机制，对于 ASCII 码以外的字符集和特殊字符做一个特殊的操作，把它们转换成与 URI 语义不冲突的形式。这在 RFC 规范里称为“escape”和“unescape”，俗称“转义”。</li>
<li>URI 转义的规则有点“简单粗暴”，直接把非 ASCII 码或特殊字符转换成十六进制字节值，然后前面再加上一个“%”。例如，空格被转义成“%20”，“?”被转义成“%3F”。而中文、日文等则通常使用 UTF-8 编码后再转义，例如“银河”会被转义成“%E9%93%B6%E6%B2%B3”。</li>
<li>不过我们在浏览器的地址栏里通常是不会看到这些转义后的“乱码”的，这实际上是浏览器一种“友好”表现，隐藏了 URI 编码后的“丑陋一面”，</li>
</ul>
<h2 id="响应状态码该怎么用？"><a href="#响应状态码该怎么用？" class="headerlink" title="响应状态码该怎么用？"></a>响应状态码该怎么用？</h2><ul>
<li>RFC 标准把状态码分成了五类，用数字的第一位表示分类，而 0~99 不用，这样状态码的实际可用范围就大大缩小了，由 000~999 变成了 100~599。</li>
</ul>
<ol>
<li>1××：提示信息，表示目前是协议处理的中间状态，还需要后续的操作；</li>
<li>2××：成功，报文已经收到并被正确处理；</li>
<li>3××：重定向，资源位置发生变动，需要客户端重新发送请求；</li>
<li>4××：客户端错误，请求报文有误，服务器无法处理；</li>
<li>5××：服务器错误，服务器在处理请求时内部发生了错误。<h3 id="1××"><a href="#1××" class="headerlink" title="1××"></a>1××</h3></li>
</ol>
<ul>
<li>1××类状态码属于提示信息，是协议处理的中间状态，实际能够用到的时候很少。</li>
<li>“101 Switching Protocols”。它的意思是客户端使用 Upgrade 头字段，要求在 HTTP 协议的基础上改成其他的协议继续通信，比如 WebSocket。而如果服务器也同意变更协议，就会发送状态码 101，但这之后的数据传输就不会再使用 HTTP 了。<h3 id="2××"><a href="#2××" class="headerlink" title="2××"></a>2××</h3></li>
<li>“204 No Content”是另一个很常见的成功状态码，它的含义与“200 OK”基本相同，但响应头后没有 body 数据。所以对于 Web 服务器来说，正确地区分 200 和 204 是很必要的。</li>
<li>“206 Partial Content”是 HTTP 分块下载或断点续传的基础，在客户端发送“范围请求”、要求获取资源的部分数据时出现，它与 200 一样，也是服务器成功处理了请求，但 body 里的数据不是资源的全部，而是其中的一部分。状态码 206 通常还会伴随着头字段“Content-Range”，表示响应报文里 body 数据的具体范围，供客户端确认，例如“Content-Range: bytes 0-99/2000”，意思是此次获取的是总计 2000 个字节的前 100 个字节。<h3 id="3××"><a href="#3××" class="headerlink" title="3××"></a>3××</h3></li>
<li>“301 Moved Permanently”俗称“永久重定向”，含义是此次请求的资源已经不存在了，需要改用新的 URI 再次访问。比如，你的网站升级到了 HTTPS，原来的 HTTP 不打算用了，这就是“永久”的，所以要配置 301 跳转，把所有的 HTTP 流量都切换到 HTTPS。</li>
<li>“302 Found”，曾经的描述短语是“Moved Temporarily”，俗称“临时重定向”，意思是请求的资源还在，但需要暂时用另一个 URI 来访问。301 和 302 都会在响应头里使用字段 Location 指明后续要跳转的 URI，最终的效果很相似，浏览器都会重定向到新的 URI。两者的根本区别在于语义，一个是“永久”，一个是“临时”，所以在场景、用法上差距很大。比如，今天夜里网站后台要系统维护，服务暂时不可用，这就属于“临时”的，可以配置成 302 跳转，把流量临时切换到一个静态通知页面，浏览器看到这个 302 就知道这只是暂时的情况，不会做缓存优化，第二天还会访问原来的地址。</li>
<li>“304 Not Modified” 是一个比较有意思的状态码，它用于 If-Modified-Since 等条件请求，表示资源未修改，用于缓存控制。它不具有通常的跳转含义，但可以理解成“重定向已到缓存的文件”（即“缓存重定向”）。<h3 id="4××"><a href="#4××" class="headerlink" title="4××"></a>4××</h3></li>
<li>“400 Bad Request”是一个通用的错误码，表示请求报文有错误，但具体是数据格式错误、缺少请求头还是 URI 超长它没有明确说，只是一个笼统的错误，客户端看到 400 只会是“一头雾水”“不知所措”。所以，在开发 Web 应用时应当尽量避免给客户端返回 400，而是要用其他更有明确含义的状态码。</li>
<li>“403 Forbidden”实际上不是客户端的请求出错，而是表示服务器禁止访问资源。原因可能多种多样，例如信息敏感、法律禁止等，如果服务器友好一点，可以在 body 里详细说明拒绝请求的原因，不过现实中通常都是直接给一个“闭门羹”。</li>
<li>“404 Not Found”可能是我们最常看见也是最不愿意看到的一个状态码，它的原意是资源在本服务器上未找到，所以无法提供给客户端。但现在已经被“用滥了”，只要服务器“不高兴”就可以给出个 404，而我们也无从得知后面到底是真的未找到，还是有什么别的原因，某种程度上它比 403 还要令人讨厌。</li>
<li>405 Method Not Allowed：不允许使用某些方法操作资源，例如不允许 POST 只能 GET；</li>
<li>406 Not Acceptable：资源无法满足客户端请求的条件，例如请求中文但只有英文；</li>
<li>408 Request Timeout：请求超时，服务器等待了过长的时间；</li>
<li>409 Conflict：多个请求发生了冲突，可以理解为多线程并发时的竞态；</li>
<li>413 Request Entity Too Large：请求报文里的 body 太大；</li>
<li>414 Request-URI Too Long：请求行里的 URI 太大；</li>
<li>429 Too Many Requests：客户端发送了太多的请求，通常是由于服务器的限连策略；</li>
<li>431 Request Header Fields Too Large：请求头某个字段或总体太大；<h3 id="5××"><a href="#5××" class="headerlink" title="5××"></a>5××</h3></li>
<li>“500 Internal Server Error”与 400 类似，也是一个通用的错误码，服务器究竟发生了什么错误我们是不知道的。不过对于服务器来说这应该算是好事，通常不应该把服务器内部的详细信息，例如出错的函数调用栈告诉外界。虽然不利于调试，但能够防止黑客的窥探或者分析。</li>
<li>“501 Not Implemented”表示客户端请求的功能还不支持，这个错误码比 500 要“温和”一些，和“即将开业，敬请期待”的意思差不多，不过具体什么时候“开业”就不好说了。</li>
<li>“502 Bad Gateway”通常是服务器作为网关或者代理时返回的错误码，表示服务器自身工作正常，访问后端服务器时发生了错误，但具体的错误原因也是不知道的。<br>*　“503 Service Unavailable”表示服务器当前很忙，暂时无法响应服务，我们上网时有时候遇到的“网络服务正忙，请稍后重试”的提示信息就是状态码 503。503 是一个“临时”的状态，很可能过几秒钟后服务器就不那么忙了，可以继续提供服务，所以 503 响应报文里通常还会有一个“Retry-After”字段，指示客户端可以在多久以后再次尝试发送请求。</li>
</ul>
<h2 id="HTTP有哪些特点？"><a href="#HTTP有哪些特点？" class="headerlink" title="HTTP有哪些特点？"></a>HTTP有哪些特点？</h2><ul>
<li>灵活可扩展。HTTP 是灵活可扩展的，可以任意添加头字段实现任意功能；</li>
<li>可靠传输。这个特点显而易见，因为 HTTP 协议是基于 TCP/IP 的，而 TCP 本身是一个“可靠”的传输协议，所以 HTTP 自然也就继承了这个特性，能够在请求方和应答方之间“可靠”地传输数据。</li>
<li>应用层协议。虽然出现了许多的应用层协议，但它们都仅关注很小的应用领域，局限在很少的应用场景。例如 FTP 只能传输文件、SMTP 只能发送邮件、SSH 只能远程登录等，在通用的数据传输方面“完全不能打”。所以 HTTP 凭借着可携带任意头字段和实体数据的报文结构，以及连接控制、缓存代理等方便易用的特性，一出现就“技压群雄”，迅速成为了应用层里的“明星”协议。只要不太苛求性能，HTTP 几乎可以传递一切东西，满足各种需求，称得上是一个“万能”的协议。HTTP 完全可以用开玩笑的口吻说：“不要误会，我不是针对 FTP，我是说在座的应用层各位，都是垃圾。”</li>
<li>请求 - 应答。</li>
<li>无状态。“无状态”形象地来说就是“没有记忆能力”。比如，浏览器发了一个请求，说“我是小明，请给我 A 文件。”，服务器收到报文后就会检查一下权限，看小明确实可以访问 A 文件，于是把文件发回给浏览器。接着浏览器还想要 B 文件，但服务器不会记录刚才的请求状态，不知道第二个请求和第一个请求是同一个浏览器发来的，所以浏览器必须还得重复一次自己的身份才行：“我是刚才的小明，请再给我 B 文件。”我们可以再对比一下 UDP 协议，不过它是无连接也无状态的，顺序发包乱序收包，数据包发出去后就不管了，收到后也不会顺序整理。而 HTTP 是有连接无状态，顺序发包顺序收包，按照收发的顺序管理报文。</li>
</ul>
<h2 id="HTTP有哪些优点？又有哪些缺点？"><a href="#HTTP有哪些优点？又有哪些缺点？" class="headerlink" title="HTTP有哪些优点？又有哪些缺点？"></a>HTTP有哪些优点？又有哪些缺点？</h2><ul>
<li>HTTP 最大的优点是简单、灵活和易于扩展；</li>
<li>HTTP 拥有成熟的软硬件环境，应用的非常广泛，是互联网的基础设施；</li>
<li>HTTP 是无状态的，可以轻松实现集群化，扩展性能，但有时也需要用 Cookie 技术来实现“有状态”；</li>
<li>HTTP 是明文传输，数据完全肉眼可见，能够方便地研究分析，但也容易被窃听；</li>
<li>HTTP 是不安全的，无法验证通信双方的身份，也不能判断报文是否被窜改；</li>
<li>HTTP 的性能不算差，但不完全适应现在的互联网，还有很大的提升空间。</li>
</ul>
<h2 id="HTTP的实体数据"><a href="#HTTP的实体数据" class="headerlink" title="HTTP的实体数据"></a>HTTP的实体数据</h2><h3 id="数据类型与编码"><a href="#数据类型与编码" class="headerlink" title="数据类型与编码"></a>数据类型与编码</h3><ul>
<li>在 TCP/IP 协议栈里，传输数据基本上都是“header+body”的格式。但 TCP、UDP 因为是传输层的协议，它们不会关心 body 数据是什么，只要把数据发送到对方就算是完成了任务。</li>
<li>而 HTTP 协议则不同，它是应用层的协议，数据到达之后工作只能说是完成了一半，还必须要告诉上层应用这是什么数据才行，否则上层应用就会“不知所措”。早在 HTTP 协议诞生之前就已经有了针对这种问题的解决方案，不过它是用在电子邮件系统里的，让电子邮件可以发送 ASCII 码以外的任意数据，方案的名字叫做“多用途互联网邮件扩展”（Multipurpose Internet Mail Extensions），简称为 MIME。</li>
<li>MIME 是一个很大的标准规范，但 HTTP 只“顺手牵羊”取了其中的一部分，用来标记 body 的数据类型，这就是我们平常总能听到的“MIME type”。MIME 把数据分成了八大类，每个大类下再细分出多个子类，形式是“type/subtype”的字符串，巧得很，刚好也符合了 HTTP 明文的特点，所以能够很容易地纳入 HTTP 头字段里。</li>
</ul>
<ol>
<li>text：即文本格式的可读数据，我们最熟悉的应该就是 text/html 了，表示超文本文档，此外还有纯文本 text/plain、样式表 text/css 等。</li>
<li>image：即图像文件，有 image/gif、image/jpeg、image/png 等。</li>
<li>audio/video：音频和视频数据，例如 audio/mpeg、video/mp4 等。</li>
<li>application：数据格式不固定，可能是文本也可能是二进制，必须由上层应用程序来解释。常见的有 application/json，application/javascript、application/pdf 等，另外，如果实在是不知道数据是什么类型，像刚才说的“黑盒”，就会是 application/octet-stream，即不透明的二进制数据。</li>
</ol>
<ul>
<li>但仅有 MIME type 还不够，因为 HTTP 在传输时为了节约带宽，有时候还会压缩数据，为了不要让浏览器继续“猜”，还需要有一个“Encoding type”，告诉数据是用的什么编码格式，这样对方才能正确解压缩，还原出原始的数据。</li>
<li>比起 MIME type 来说，Encoding type 就少了很多，常用的只有下面三种：</li>
</ul>
<ol>
<li>gzip：GNU zip 压缩格式，也是互联网上最流行的压缩格式；</li>
<li>deflate：zlib（deflate）压缩格式，流行程度仅次于 gzip；</li>
<li>br：一种专门为 HTTP 优化的新压缩算法（Brotli）。<h3 id="数据类型使用的头字段"><a href="#数据类型使用的头字段" class="headerlink" title="数据类型使用的头字段"></a>数据类型使用的头字段</h3></li>
</ol>
<ul>
<li>客户端用 Accept 头告诉服务器希望接收什么样的数据，而服务器用 Content 头告诉客户端实际发送了什么样的数据。</li>
<li><p>Accept 字段标记的是客户端可理解的 MIME type，可以用“,”做分隔符列出多个类型，让服务器有更多的选择余地，例如下面的这个头：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Accept: text/html,application/xml,image/webp,image/png</span><br><span class="line">这就是告诉服务器：“我能够看懂 HTML、XML 的文本，还有 webp 和 png 的图片，请给我这四类格式的数据”。</span><br></pre></td></tr></table></figure>
</li>
<li><p>相应的，服务器会在响应报文里用头字段 Content-Type 告诉实体数据的真实类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Type: image/png</span><br></pre></td></tr></table></figure>
</li>
<li><p>Accept-Encoding 字段标记的是客户端支持的压缩格式，例如上面说的 gzip、deflate 等，同样也可以用“,”列出多个，服务器可以选择其中一种来压缩数据，实际使用的压缩格式放在响应头字段 Content-Encoding 里。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Content-Encoding: gzip</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果请求报文里没有 Accept-Encoding 字段，就表示客户端不支持压缩数据；如果响应报文里没有 Content-Encoding 字段，就表示响应数据没有被压缩。</p>
</li>
</ul>
<h3 id="语言类型与编码"><a href="#语言类型与编码" class="headerlink" title="语言类型与编码"></a>语言类型与编码</h3><ul>
<li><p>Accept-Language 字段标记了客户端可理解的自然语言，也允许用“,”做分隔符列出多个类型，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Accept-Language: zh-CN, zh, en</span><br><span class="line">这个请求头会告诉服务器：“最好给我 zh-CN 的汉语文字，如果没有就用其他的汉语方言，如果还没有就给英文”。</span><br></pre></td></tr></table></figure>
</li>
<li><p>相应的，服务器应该在响应报文里用头字段 Content-Language 告诉客户端实体数据使用的实际语言类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Content-Language: zh-CN</span><br></pre></td></tr></table></figure>
</li>
<li><p>字符集在 HTTP 里使用的请求头字段是 Accept-Charset，但响应头里却没有对应的 Content-Charset，而是在 Content-Type 字段的数据类型后面用“charset=xxx”来表示，这点需要特别注意。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Accept-Charset: gbk, utf-8</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="内容协商的质量值"><a href="#内容协商的质量值" class="headerlink" title="内容协商的质量值"></a>内容协商的质量值</h3><ul>
<li>在 HTTP 协议里用 Accept、Accept-Encoding、Accept-Language 等请求头字段进行内容协商的时候，还可以用一种特殊的“q”参数表示权重来设定优先级，这里的“q”是“quality factor”的意思。</li>
<li>权重的最大值是 1，最小值是 0.01，默认值是 1，如果值是 0 就表示拒绝。具体的形式是在数据类型或语言代码后面加一个“;”，然后是“q=value”。这里要提醒的是“;”的用法，在大多数编程语言里“;”的断句语气要强于“,”，而在 HTTP 的内容协商里却恰好反了过来，“;”的意义是小于“,”的。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Accept: text/html,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line"></span><br><span class="line">它表示浏览器最希望使用的是 HTML 文件，权重是 1，其次是 XML 文件，权重是 0.9，最后是任意数据类型，权重是 0.8。服务器收到请求头后，就会计算权重，再根据自己的实际情况优先输出 HTML 或者 XML。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="内容协商的结果"><a href="#内容协商的结果" class="headerlink" title="内容协商的结果"></a>内容协商的结果</h3><ul>
<li>内容协商的过程是不透明的，每个 Web 服务器使用的算法都不一样。但有的时候，服务器会在响应头里多加一个 Vary 字段，记录服务器在内容协商时参考的请求头字段，给出一点信息，例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Vary: Accept-Encoding,User-Agent,Accept</span><br><span class="line">这个 Vary 字段表示服务器依据了 Accept-Encoding、User-Agent 和 Accept 这三个头字段，然后决定了发回的响应报文。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="HTTP传输大文件的方法"><a href="#HTTP传输大文件的方法" class="headerlink" title="HTTP传输大文件的方法"></a>HTTP传输大文件的方法</h2><h3 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a>数据压缩</h3><ul>
<li>通常浏览器在发送请求时都会带着“Accept-Encoding”头字段，里面是浏览器支持的压缩格式列表，例如 gzip、deflate、br 等，这样服务器就可以从中选择一种压缩算法，放进“Content-Encoding”响应头里，再把原数据压缩后发给浏览器。</li>
<li>gzip 等压缩算法通常只对文本文件有较好的压缩率，而图片、音频视频等多媒体数据本身就已经是高度压缩的，再用 gzip 处理也不会变小（甚至还有可能会增大一点），所以它就失效了。</li>
<li>不过数据压缩在处理文本的时候效果还是很好的，所以各大网站的服务器都会使用这个手段作为“保底”。例如，在 Nginx 里就会使用“gzip on”指令，启用对“text/html”的压缩。<h3 id="分块传输"><a href="#分块传输" class="headerlink" title="分块传输"></a>分块传输</h3></li>
<li>压缩是把大文件整体变小，我们可以反过来思考，如果大文件整体不能变小，那就把它“拆开”，分解成多个小块，把这些小块分批发给浏览器，浏览器收到后再组装复原。</li>
<li>这种“化整为零”的思路在 HTTP 协议里就是“chunked”分块传输编码，在响应报文里用头字段“Transfer-Encoding: chunked”来表示，意思是报文里的 body 部分不是一次性发过来的，而是分成了许多的块（chunk）逐个发送。</li>
<li>分块传输也可以用于“流式数据”，例如由数据库动态生成的表单页面，这种情况下 body 数据的长度是未知的，无法在头字段“Content-Length”里给出确切的长度，所以也只能用 chunked 方式分块发送。</li>
<li>“Transfer-Encoding: chunked”和“Content-Length”这两个字段是互斥的，也就是说响应报文里这两个字段不能同时出现，一个响应报文的传输要么是长度已知，要么是长度未知（chunked），这一点你一定要记住。</li>
<li>下面我们来看一下分块传输的编码规则，其实也很简单，同样采用了明文的方式，很类似响应头。</li>
</ul>
<ol>
<li>每个分块包含两个部分，长度头和数据块；</li>
<li>长度头是以 CRLF（回车换行，即\r\n）结尾的一行明文，用 16 进制数字表示长度；</li>
<li>数据块紧跟在长度头后，最后也用 CRLF 结尾，但数据不包含 CRLF；</li>
<li>最后用一个长度为 0 的块表示结束，即“0\r\n\r\n”。<h3 id="范围请求"><a href="#范围请求" class="headerlink" title="范围请求"></a>范围请求</h3></li>
</ol>
<ul>
<li>比如，你在看当下正热播的某穿越剧，想跳过片头，直接看正片，或者有段剧情很无聊，想拖动进度条快进几分钟，这实际上是想获取一个大文件其中的片段数据，而分块传输并没有这个能力。</li>
<li>HTTP 协议为了满足这样的需求，提出了“范围请求”（range requests）的概念，允许客户端在请求头里使用专用字段来表示只获取文件的一部分，相当于是客户端的“化整为零”。</li>
<li>范围请求不是 Web 服务器必备的功能，可以实现也可以不实现，所以服务器必须在响应头里使用字段“Accept-Ranges: bytes”明确告知客户端：“我是支持范围请求的”。</li>
<li>请求头 Range 是 HTTP 范围请求的专用字段，格式是“bytes=x-y”，其中的 x 和 y 是以字节为单位的数据范围。要注意 x、y 表示的是“偏移量”，范围必须从 0 计数，例如前 10 个字节表示为“0-9”，第二个 10 字节表示为“10-19”，而“0-10”实际上是前 11 个字节。</li>
<li>服务器收到 Range 字段后，需要做四件事。</li>
</ul>
<ol>
<li>第一，它必须检查范围是否合法，比如文件只有 100 个字节，但请求“200-300”，这就是范围越界了。服务器就会返回状态码 416，意思是“你的范围请求有误，我无法处理，请再检查一下”。</li>
<li>第二，如果范围正确，服务器就可以根据 Range 头计算偏移量，读取文件的片段了，返回状态码“206 Partial Content”，和 200 的意思差不多，但表示 body 只是原数据的一部分。</li>
<li>第三，服务器要添加一个响应头字段 Content-Range，告诉片段的实际偏移量和资源的总大小，格式是“bytes x-y/length”，与 Range 头区别在没有“=”，范围后多了总长度。例如，对于“0-10”的范围请求，值就是“bytes 0-10/100”。</li>
<li>最后剩下的就是发送数据了，直接把片段用 TCP 发给客户端，一个范围请求就算是处理完了。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">GET /16-2 HTTP/1.1</span><br><span class="line">Host: www.diamonds.com</span><br><span class="line">Range: bytes=0-31</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HTTP/1.1 206 Partial Content</span><br><span class="line">Content-Length: 32</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Content-Range: bytes 0-31/96</span><br><span class="line"></span><br><span class="line">// this is a plain text json doc</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>有了范围请求之后，HTTP 处理大文件就更加轻松了，看视频时可以根据时间点计算出文件的 Range，不用下载整个文件，直接精确获取片段所在的数据内容。</li>
<li>不仅看视频的拖拽进度需要范围请求，常用的下载工具里的多段下载、断点续传也是基于它实现的，要点是：</li>
</ul>
<ol>
<li>先发个 HEAD，看服务器是否支持范围请求，同时获取文件的大小；</li>
<li>开 N 个线程，每个线程使用 Range 字段划分出各自负责下载的片段，发请求传输数据；</li>
<li>下载意外中断也不怕，不必重头再来一遍，只要根据上次的下载记录，用 Range 请求剩下的那一部分就可以了。</li>
</ol>
<h3 id="多段数据"><a href="#多段数据" class="headerlink" title="多段数据"></a>多段数据</h3><ul>
<li>范围请求一次只获取一个片段，其实它还支持在 Range 头里使用多个“x-y”，一次性获取多个片段数据。</li>
<li>这种情况需要使用一种特殊的 MIME 类型：“multipart/byteranges”，表示报文的 body 是由多段字节序列组成的，并且还要用一个参数“boundary=xxx”给出段之间的分隔标记。</li>
<li>每一个分段必须以“- -boundary”开始（前面加两个“-”），之后要用“Content-Type”和“Content-Range”标记这段数据的类型和所在范围，然后就像普通的响应头一样以回车换行结束，再加上分段数据，最后用一个“- -boundary- -”（前后各有两个“-”）表示所有的分段结束。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">GET /16-2 HTTP/1.1</span><br><span class="line">Host: www.diamonds.com</span><br><span class="line">Range: bytes=0-9, 20-29</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HTTP/1.1 206 Partial Content</span><br><span class="line">Content-Type: multipart/byteranges; boundary=00000000001</span><br><span class="line">Content-Length: 189</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--00000000001</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Range: bytes 0-9/96</span><br><span class="line"></span><br><span class="line">// this is</span><br><span class="line">--00000000001</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Range: bytes 20-29/96</span><br><span class="line"></span><br><span class="line">ext json d</span><br><span class="line">--00000000001--</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="HTTP的连接管理"><a href="#HTTP的连接管理" class="headerlink" title="HTTP的连接管理"></a>HTTP的连接管理</h2><h3 id="短连接"><a href="#短连接" class="headerlink" title="短连接"></a>短连接</h3><ul>
<li>短连接的缺点相当严重，因为在 TCP 协议里，建立连接和关闭连接都是非常“昂贵”的操作。TCP 建立连接要有“三次握手”，发送 3 个数据包，需要 1 个 RTT；关闭连接是“四次挥手”，4 个数据包需要 2 个 RTT。</li>
<li>而 HTTP 的一次简单“请求 - 响应”通常只需要 4 个包，如果不算服务器内部的处理时间，最多是 2 个 RTT。这么算下来，浪费的时间就是“3÷5=60%”，有三分之二的时间被浪费掉了，传输效率低得惊人。<h3 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h3></li>
<li>针对短连接暴露出的缺点，HTTP 协议就提出了“长连接”的通信方式，也叫“持久连接”（persistent connections）、“连接保活”（keep alive）、“连接复用”（connection reuse）。</li>
<li>其实解决办法也很简单，用的就是“成本均摊”的思路，既然 TCP 的连接和关闭非常耗时间，那么就把这个时间成本由原来的一个“请求 - 应答”均摊到多个“请求 - 应答”上</li>
<li>这样虽然不能改善 TCP 的连接效率，但基于“分母效应”，每个“请求 - 应答”的无效时间就会降低不少，整体传输效率也就提高了。</li>
<li>在短连接里发送了三次 HTTP“请求 - 应答”，每次都会浪费 60% 的 RTT 时间。而在长连接的情况下，同样发送三次请求，因为只在第一次时建立连接，在最后一次时关闭连接，所以浪费率就是“3÷9≈33%”，降低了差不多一半的时间损耗。显然，如果在这个长连接上发送的请求越多，分母就越大，利用率也就越高。<h3 id="连接相关的头字段"><a href="#连接相关的头字段" class="headerlink" title="连接相关的头字段"></a>连接相关的头字段</h3></li>
<li>由于长连接对性能的改善效果非常显著，所以在 HTTP/1.1 中的连接都会默认启用长连接。不需要用什么特殊的头字段指定，只要向服务器发送了第一次请求，后续的请求都会重复利用第一次打开的 TCP 连接，也就是长连接，在这个连接上收发数据。</li>
<li>当然，我们也可以在请求头里明确地要求使用长连接机制，使用的字段是 Connection，值是“keep-alive”。</li>
<li>因为 TCP 连接长时间不关闭，服务器必须在内存里保存它的状态，这就占用了服务器的资源。如果有大量的空闲长连接只连不发，就会很快耗尽服务器的资源，导致服务器无法为真正有需要的用户提供服务。</li>
<li>在客户端，可以在请求头里加上“Connection: close”字段，告诉服务器：“这次通信后就关闭连接”。服务器看到这个字段，就知道客户端要主动关闭连接，于是在响应报文里也加上这个字段，发送之后就调用 Socket API 关闭 TCP 连接。</li>
<li>服务器端通常不会主动关闭连接，但也可以使用一些策略。拿 Nginx 来举例，它有两种方式：</li>
</ul>
<ol>
<li>使用“keepalive_timeout”指令，设置长连接的超时时间，如果在一段时间内连接上没有任何数据收发就主动断开连接，避免空闲连接占用系统资源。</li>
<li>使用“keepalive_requests”指令，设置长连接上可发送的最大请求次数。比如设置成 1000，那么当 Nginx 在这个连接上处理了 1000 个请求后，也会主动断开连接。</li>
</ol>
<ul>
<li>另外，客户端和服务器都可以在报文里附加通用头字段“Keep-Alive: timeout=value”，限定长连接的超时时间。但这个字段的约束力并不强，通信的双方可能并不会遵守，所以不太常见。<h3 id="队头阻塞"><a href="#队头阻塞" class="headerlink" title="队头阻塞"></a>队头阻塞</h3></li>
<li>因为 HTTP 规定报文必须是“一发一收”，这就形成了一个先进先出的“串行”队列。队列里的请求没有轻重缓急的优先级，只有入队的先后顺序，排在最前面的请求被最优先处理。</li>
<li>如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本。<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3></li>
<li>在 HTTP 里就是“并发连接”（concurrent connections），也就是同时对一个域名发起多个长连接，用数量来解决质量的问题。但这种方式也存在缺陷。如果每个客户端都想自己快，建立很多个连接，用户数×并发数就会是个天文数字。服务器的资源根本就扛不住，或者被服务器认为是恶意攻击，反而会造成“拒绝服务”。</li>
<li>所以，HTTP 协议建议客户端使用并发，但不能“滥用”并发。RFC2616 里明确限制每个客户端最多并发 2 个连接。不过实践证明这个数字实在是太小了，众多浏览器都“无视”标准，把这个上限提高到了 6~8。后来修订的 RFC7230 也就“顺水推舟”，取消了这个“2”的限制。</li>
<li>“域名分片”（domain sharding）技术，还是用数量来解决质量的思路。HTTP 协议和浏览器不是限制并发连接数量吗？好，那我就多开几个域名，比如 shard1.diamonds.com、shard2.diamonds.com，而这些域名都指向同一台服务器 <a href="http://www.diamonds.com，这样实际长连接的数量就又上去了，真是“美滋滋”。不过实在是有点“上有政策，下有对策”的味道。" target="_blank" rel="noopener">www.diamonds.com，这样实际长连接的数量就又上去了，真是“美滋滋”。不过实在是有点“上有政策，下有对策”的味道。</a><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3></li>
<li>早期的 HTTP 协议使用短连接，收到响应后就立即关闭连接，效率很低；</li>
<li>HTTP/1.1 默认启用长连接，在一个连接上收发多个请求响应，提高了传输效率；</li>
<li>服务器会发送“Connection: keep-alive”字段表示启用了长连接；</li>
<li>报文头里如果有“Connection: close”就意味着长连接即将关闭；</li>
<li>过多的长连接会占用服务器资源，所以服务器会用一些策略有选择地关闭长连接；</li>
<li>“队头阻塞”问题会导致性能下降，可以用“并发连接”和“域名分片”技术缓解。</li>
</ul>
<h2 id="HTTP的重定向和跳转"><a href="#HTTP的重定向和跳转" class="headerlink" title="HTTP的重定向和跳转"></a>HTTP的重定向和跳转</h2><ul>
<li>在 Nginx 的主页上点了一下“download”链接，会发生什么呢？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">http://nginx.org/en/download.html</span><br><span class="line"></span><br><span class="line">浏览器首先要解析链接文字里的 URI。</span><br><span class="line">再用这个 URI 发起一个新的 HTTP 请求，获取响应报文后就会切换显示内容，渲染出新 URI 指向的页面。</span><br><span class="line">这样的跳转动作是由浏览器的使用者主动发起的，可以称为“主动跳转”</span><br><span class="line"></span><br><span class="line">但还有一类跳转是由服务器来发起的，浏览器使用者无法控制，相对地就可以称为“被动跳转”，这在 HTTP 协议里有个专门的名词，叫做“重定向”（Redirection）。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="重定向的过程"><a href="#重定向的过程" class="headerlink" title="重定向的过程"></a>重定向的过程</h3><ul>
<li>301 是“永久重定向”，302 是“临时重定向”，浏览器收到这两个状态码就会跳转到新的 URI。</li>
<li>“Location”字段属于响应字段，必须出现在响应报文里。但只有配合 301/302 状态码才有意义，它标记了服务器要求重定向的 URI，这里就是要求浏览器跳转到“index.html”。</li>
<li>浏览器收到 301/302 报文，会检查响应头里有没有“Location”。如果有，就从字段值里提取出 URI，发出新的 HTTP 请求，相当于自动替我们点击了这个链接。</li>
<li>在“Location”里的 URI 既可以使用绝对 URI，也可以使用相对 URI。所谓“绝对 URI”，就是完整形式的 URI，包括 scheme、host:port、path 等。所谓“相对 URI”，就是省略了 scheme 和 host:port，只有 path 和 query 部分，是不完整的，但可以从请求上下文里计算得到。<h3 id="重定向状态码"><a href="#重定向状态码" class="headerlink" title="重定向状态码"></a>重定向状态码</h3></li>
<li>301 俗称“永久重定向”（Moved Permanently），意思是原 URI 已经“永久”性地不存在了，今后的所有请求都必须改用新的 URI。</li>
<li>浏览器看到 301，就知道原来的 URI“过时”了，就会做适当的优化。比如历史记录、更新书签，下次可能就会直接用新的 URI 访问，省去了再次跳转的成本。搜索引擎的爬虫看到 301，也会更新索引库，不再使用老的 URI。</li>
<li>302 俗称“临时重定向”（“Moved Temporarily”），意思是原 URI 处于“临时维护”状态，新的 URI 是起“顶包”作用的“临时工”。</li>
<li>浏览器或者爬虫看到 302，会认为原来的 URI 仍然有效，但暂时不可用，所以只会执行简单的跳转页面，不记录新的 URI，也不会有其他的多余动作，下次访问还是用原 URI。</li>
<li>303 See Other：类似 302，但要求重定向后的请求改为 GET 方法，访问一个结果页面，避免 POST/PUT 重复操作；</li>
<li>307 Temporary Redirect：类似 302，但重定向后请求里的方法和实体不允许变动，含义比 302 更明确；</li>
<li>308 Permanent Redirect：类似 307，不允许重定向后的请求变动，但它是 301“永久重定向”的含义。</li>
<li>不过这303/307/308三个状态码的接受程度较低，有的浏览器和服务器可能不支持，开发时应当慎重，测试确认浏览器的实际效果后才能使用。</li>
</ul>
<h3 id="重定向的相关问题"><a href="#重定向的相关问题" class="headerlink" title="重定向的相关问题"></a>重定向的相关问题</h3><ul>
<li>第一个问题是“性能损耗”。很明显，重定向的机制决定了一个跳转会有两次请求 - 应答，比正常的访问多了一次。虽然 301/302 报文很小，但大量的跳转对服务器的影响也是不可忽视的。站内重定向还好说，可以长连接复用，站外重定向就要开两个连接，如果网络连接质量差，那成本可就高多了，会严重影响用户的体验。</li>
<li>第二个问题是“循环跳转”。如果重定向的策略设置欠考虑，可能会出现“A=&gt;B=&gt;C=&gt;A”的无限循环，不停地在这个链路里转圈圈，后果可想而知。</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>重定向是服务器发起的跳转，要求客户端改用新的 URI 重新发送请求，通常会自动进行，用户是无感知的；</li>
<li>301/302 是最常用的重定向状态码，分别是“永久重定向”和“临时重定向”；</li>
<li>响应头字段 Location 指示了要跳转的 URI，可以用绝对或相对的形式；</li>
<li>重定向可以把一个 URI 指向另一个 URI，也可以把多个 URI 指向同一个 URI，用途很多；</li>
<li>使用重定向时需要当心性能损耗，还要避免出现循环跳转。</li>
</ul>
<h2 id="HTTP的Cookie机制"><a href="#HTTP的Cookie机制" class="headerlink" title="HTTP的Cookie机制"></a>HTTP的Cookie机制</h2><ul>
<li>HTTP 是“无状态”的，这既是优点也是缺点。优点是服务器没有状态差异，可以很容易地组成集群，而缺点就是无法支持需要记录状态的事务操作。</li>
<li>HTTP 协议是可扩展的，后来发明的 Cookie 技术，给 HTTP 增加了“记忆能力”。<h3 id="什么是-Cookie？"><a href="#什么是-Cookie？" class="headerlink" title="什么是 Cookie？"></a>什么是 Cookie？</h3></li>
<li>相当于是服务器给每个客户端都贴上一张小纸条，上面写了一些只有服务器才能理解的数据，需要的时候客户端把这些信息发给服务器，服务器看到 Cookie，就能够认出对方是谁了。<h3 id="Cookie-的工作过程"><a href="#Cookie-的工作过程" class="headerlink" title="Cookie 的工作过程"></a>Cookie 的工作过程</h3></li>
<li>这要用到两个字段：响应头字段 Set-Cookie 和请求头字段 Cookie。</li>
<li>当用户通过浏览器第一次访问服务器的时候，服务器肯定是不知道他的身份的。所以，就要创建一个独特的身份标识数据，格式是“key=value”，然后放进 Set-Cookie 字段里，随着响应报文一同发给浏览器。</li>
<li>浏览器收到响应报文，看到里面有 Set-Cookie，知道这是服务器给的身份标识，于是就保存起来，下次再请求的时候就自动把这个值放进 Cookie 字段里发给服务器。</li>
<li>服务器有时会在响应头里添加多个 Set-Cookie，存储多个“key=value”。但浏览器这边发送时不需要用多个 Cookie 字段，只要在一行里用“;”隔开就行。</li>
<li>Cookie 是由浏览器负责存储的，而不是操作系统。所以，它是“浏览器绑定”的，只能在本浏览器内生效。<h3 id="Cookie-的属性"><a href="#Cookie-的属性" class="headerlink" title="Cookie 的属性"></a>Cookie 的属性</h3></li>
<li>Cookie 就是服务器委托浏览器存储在客户端里的一些数据，而这些数据通常都会记录用户的关键识别信息。所以，就需要在“key=value”外再用一些手段来保护，防止外泄或窃取，这些手段就是 Cookie 的属性。</li>
<li>首先，我们应该设置 Cookie 的生存周期，也就是它的有效期，让它只能在一段时间内可用，就像是食品的“保鲜期”，一旦超过这个期限浏览器就认为是 Cookie 失效，在存储里删除，也不会发送给服务器。</li>
<li>Cookie 的有效期可以使用 Expires 和 Max-Age 两个属性来设置。</li>
<li>“Expires”俗称“过期时间”，用的是绝对时间点，可以理解为“截止日期”（deadline）。“Max-Age”用的是相对时间，单位是秒，浏览器用收到报文的时间点再加上 Max-Age，就可以得到失效的绝对时间。</li>
<li>Expires 和 Max-Age 可以同时出现，两者的失效时间可以一致，也可以不一致，但浏览器会优先采用 Max-Age 计算失效期。</li>
<li>设置 Cookie 的作用域，让浏览器仅发送给特定的服务器和 URI，避免被其他网站盗用。作用域的设置比较简单，“Domain”和“Path”指定了 Cookie 所属的域名和路径，浏览器在发送 Cookie 前会从 URI 中提取出 host 和 path 部分，对比 Cookie 的属性。如果不满足条件，就不会在请求头里发送 Cookie。</li>
<li>使用这两个属性可以为不同的域名和路径分别设置各自的 Cookie，比如“/19-1”用一个 Cookie，“/19-2”再用另外一个 Cookie，两者互不干扰。不过现实中为了省事，通常 Path 就用一个“/”或者直接省略，表示域名下的任意路径都允许使用 Cookie，让服务器自己去挑。<h3 id="Cookie-的安全性"><a href="#Cookie-的安全性" class="headerlink" title="Cookie 的安全性"></a>Cookie 的安全性</h3></li>
<li>属性“HttpOnly”会告诉浏览器，此 Cookie 只能通过浏览器 HTTP 协议传输，禁止其他方式访问，浏览器的 JS 引擎就会禁用 document.cookie 等一切相关的 API，脚本攻击也就无从谈起了。</li>
<li>另一个属性“SameSite”可以防范“跨站请求伪造”（XSRF）攻击，设置成“SameSite=Strict”可以严格限定 Cookie 不能随着跳转链接跨站发送，而“SameSite=Lax”则略宽松一点，允许 GET/HEAD 等安全方法，但禁止 POST 跨站发送。</li>
<li>还有一个属性叫“Secure”，表示这个 Cookie 仅能用 HTTPS 协议加密传输，明文的 HTTP 协议会禁止发送。但 Cookie 本身不是加密的，浏览器里还是以明文的形式存在。</li>
</ul>
<h2 id="HTTP的缓存控制"><a href="#HTTP的缓存控制" class="headerlink" title="HTTP的缓存控制"></a>HTTP的缓存控制</h2><ul>
<li>缓存（Cache）是计算机领域里的一个重要概念，是优化系统性能的利器。</li>
<li>由于链路漫长，网络时延不可控，浏览器使用 HTTP 获取资源的成本较高。所以，非常有必要把“来之不易”的数据缓存起来，下次再请求的时候尽可能地复用。这样，就可以避免多次请求 - 应答的通信成本，节约网络带宽，也可以加快响应速度。<h3 id="服务器的缓存控制"><a href="#服务器的缓存控制" class="headerlink" title="服务器的缓存控制"></a>服务器的缓存控制</h3></li>
<li>服务器标记资源有效期使用的头字段是“Cache-Control”，里面的值“max-age=30”就是资源的有效时间，相当于告诉浏览器，“这个页面只能缓存 30 秒，之后就算是过期，不能用。”</li>
<li>这里的 max-age 是“生存时间”（又叫“新鲜度”“缓存寿命”，类似 TTL，Time-To-Live），时间的计算起点是响应报文的创建时刻（即 Date 字段，也就是离开服务器的时刻），而不是客户端收到报文的时刻，也就是说包含了在链路传输过程中所有节点所停留的时间。比如，服务器设定“max-age=5”，但因为网络质量很糟糕，等浏览器收到响应报文已经过去了 4 秒，那么这个资源在客户端就最多能够再存 1 秒钟，之后就会失效。</li>
<li>no-store：不允许缓存，用于某些变化非常频繁的数据，例如秒杀页面；</li>
<li>no-cache：它的字面含义容易与 no-store 搞混，实际的意思并不是不允许缓存，而是可以缓存，但在使用之前必须要去服务器验证是否过期，是否有最新的版本；<h3 id="客户端的缓存控制"><a href="#客户端的缓存控制" class="headerlink" title="客户端的缓存控制"></a>客户端的缓存控制</h3></li>
<li>当你点“刷新”按钮的时候，浏览器会在请求头里加一个“Cache-Control: max-age=0”。因为 max-age 是“生存时间”，max-age=0 的意思就是“我要一个最最新鲜的西瓜”，而本地缓存里的数据至少保存了几秒钟，所以浏览器就不会使用缓存，而是向服务器发请求。服务器看到 max-age=0，也就会用一个最新生成的报文回应浏览器。</li>
<li>Ctrl+F5 的“强制刷新”又是什么样的呢？它其实是发了一个“Cache-Control: no-cache”，含义和“max-age=0”基本一样，就看后台的服务器怎么理解，通常两者的效果是相同的。</li>
</ul>
<h3 id="条件请求"><a href="#条件请求" class="headerlink" title="条件请求"></a>条件请求</h3><ul>
<li>HTTP 协议定义了一系列“If”开头的“条件请求”字段，专门用来检查验证资源是否过期，把两个请求才能完成的工作合并在一个请求里做。而且，验证的责任也交给服务器，浏览器只需“坐享其成”。</li>
<li>条件请求一共有 5 个头字段，我们最常用的是“if-Modified-Since”和“If-None-Match”这两个。需要第一次的响应报文预先提供“Last-modified”和“ETag”，然后第二次请求时就可以带上缓存里的原值，验证资源是否是最新的。</li>
<li>ETag 是“实体标签”（Entity Tag）的缩写，是资源的一个唯一标识，主要是用来解决修改时间无法准确区分文件变化的问题。比如，一个文件在一秒内修改了多次，但因为修改时间是秒级，所以这一秒内的新版本无法区分。再比如，一个文件定期更新，但有时会是同样的内容，实际上没有变化，用修改时间就会误以为发生了变化，传送给浏览器就会浪费带宽。</li>
<li>使用 ETag 就可以精确地识别资源的变动情况，让浏览器能够更有效地利用缓存。ETag 还有“强”“弱”之分。强 ETag 要求资源在字节级别必须完全相符，弱 ETag 在值前有个“W/”标记，只要求资源在语义上没有变化，但内部可能会有部分发生了改变（例如 HTML 里的标签顺序调整，或者多了几个空格）。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">还是拿生鲜速递做比喻最容易理解：</span><br><span class="line">你打电话给超市，“我这个西瓜是 3 天前买的，还有最新的吗？”。超市看了一下库存，说：“没有啊，我这里都是 3 天前的。”于是你就知道了，再让超市送货也没用，还是吃冰箱里的西瓜吧。这就是“if-Modified-Since”和“Last-modified”。</span><br><span class="line">但你还是想要最新的，就又打电话：“有不是沙瓤的西瓜吗？”，超市告诉你都是沙瓤的（Match），于是你还是只能吃冰箱里的沙瓤西瓜。这就是“If-None-Match”和“弱 ETag”。</span><br><span class="line">第三次打电话，你说“有不是 8 斤的沙瓤西瓜吗？”，这回超市给了你满意的答复：“有个 10 斤的沙瓤西瓜”。于是，你就扔掉了冰箱里的存货，让超市重新送了一个新的大西瓜。这就是“If-None-Match”和“强 ETag”。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="HTTP的代理服务"><a href="#HTTP的代理服务" class="headerlink" title="HTTP的代理服务"></a>HTTP的代理服务</h2><ul>
<li>引入 HTTP 代理后，原来简单的双方通信就变复杂了一些，加入了一个或者多个中间人，但整体上来看，还是一个有顺序关系的链条，而且链条里相邻的两个角色仍然是简单的一对一通信，不会出现越级的情况。<h3 id="代理服务"><a href="#代理服务" class="headerlink" title="代理服务"></a>代理服务</h3></li>
<li>所谓的“代理服务”就是指服务本身不生产内容，而是处于中间位置转发上下游的请求和响应，具有双重身份：面向下游的用户时，表现为服务器，代表源服务器响应客户端的请求；而面向上游的源服务器时，又表现为客户端，代表客户端发送请求。<h3 id="代理的作用"><a href="#代理的作用" class="headerlink" title="代理的作用"></a>代理的作用</h3></li>
<li>你也许听过这样一句至理名言：“计算机科学领域里的任何问题，都可以通过引入一个中间层来解决”（在这句话后面还可以再加上一句“如果一个中间层解决不了问题，那就再加一个中间层”）。TCP/IP 协议栈是这样，而代理也是这样。</li>
<li>由于代理处在 HTTP 通信过程的中间位置，相应地就对上屏蔽了真实客户端，对下屏蔽了真实服务器，简单的说就是“欺上瞒下”。在这个中间层的“小天地”里就可以做很多的事情，为 HTTP 协议增加更多的灵活性，实现客户端和服务器的“双赢”。</li>
<li>代理最基本的一个功能是负载均衡。因为在面向客户端时屏蔽了源服务器，客户端看到的只是代理服务器，源服务器究竟有多少台、是哪些 IP 地址都不知道。于是代理服务器就可以掌握请求分发的“大权”，决定由后面的哪台服务器来响应请求。</li>
<li>代理中常用的负载均衡算法你应该也有所耳闻吧，比如轮询、一致性哈希等等，这些算法的目标都是尽量把外部的流量合理地分散到多台源服务器，提高系统的整体资源利用率和性能。</li>
<li>在负载均衡的同时，代理服务还可以执行更多的功能，比如：</li>
</ul>
<ol>
<li>健康检查：使用“心跳”等机制监控后端服务器，发现有故障就及时“踢出”集群，保证服务高可用；</li>
<li>安全防护：保护被代理的后端服务器，限制 IP 地址或流量，抵御网络攻击和过载；</li>
<li>加密卸载：对外网使用 SSL/TLS 加密通信认证，而在安全的内网不加密，消除加解密成本；</li>
<li>数据过滤：拦截上下行的数据，任意指定策略修改请求或者响应；</li>
<li>内容缓存：暂存、复用服务器响应<h3 id="代理相关头字段"><a href="#代理相关头字段" class="headerlink" title="代理相关头字段"></a>代理相关头字段</h3></li>
</ol>
<ul>
<li>首先，代理服务器需要用字段“Via”标明代理的身份。</li>
<li>Via 是一个通用字段，请求头或响应头里都可以出现。每当报文经过一个代理节点，代理服务器就会把自身的信息追加到字段的末尾，就像是经手人盖了一个章。</li>
<li>如果通信链路中有很多中间代理，就会在 Via 里形成一个链表，这样就可以知道报文究竟走过了多少个环节才到达了目的地。</li>
<li>服务器的 IP 地址应该是保密的，关系到企业的内网安全，所以一般不会让客户端知道。不过反过来，通常服务器需要知道客户端的真实 IP 地址，方便做访问控制、用户画像、统计分析。</li>
<li>“X-Forwarded-For”的字面意思是“为谁而转发”，形式上和“Via”差不多，也是每经过一个代理节点就会在字段里追加一个信息。但“Via”追加的是代理主机名（或者域名），而“X-Forwarded-For”追加的是请求方的 IP 地址。所以，在字段里最左边的 IP 地址就是客户端的地址。</li>
<li>“X-Real-IP”是另一种获取客户端真实 IP 的手段，它的作用很简单，就是记录客户端 IP 地址，没有中间的代理信息，相当于是“X-Forwarded-For”的简化版。如果客户端和源服务器之间只有一个代理，那么这两个字段的值就是相同的。<h3 id="代理协议"><a href="#代理协议" class="headerlink" title="代理协议"></a>代理协议</h3></li>
<li>通过“X-Forwarded-For”操作代理信息必须要解析 HTTP 报文头，这对于代理来说成本比较高，原本只需要简单地转发消息就好，而现在却必须要费力解析数据再修改数据，会降低代理的转发性能。</li>
<li>“X-Forwarded-For”等头必须要修改原始报文，而有些情况下是不允许甚至不可能的（比如使用 HTTPS 通信被加密）。</li>
<li>所以就出现了一个专门的“代理协议”（The PROXY protocol），它由知名的代理软件 HAProxy 所定义，也是一个“事实标准”，被广泛采用（注意并不是 RFC）。</li>
<li>“代理协议”有 v1 和 v2 两个版本，v1 和 HTTP 差不多，也是明文，而 v2 是二进制格式。</li>
<li>v1版本在 HTTP 报文前增加了一行 ASCII 码文本，相当于又多了一个头。这一行文本其实非常简单，开头必须是“PROXY”五个大写字母，然后是“TCP4”或者“TCP6”，表示客户端的 IP 地址类型，再后面是请求方地址、应答方地址、请求方端口号、应答方端口号，最后用一个回车换行（\r\n）结束。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">PROXY TCP4 1.1.1.1 2.2.2.2 55555 80\r\n</span><br><span class="line">GET / HTTP/1.1\r\n</span><br><span class="line">Host: www.xxx.com\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="HTTP的缓存代理"><a href="#HTTP的缓存代理" class="headerlink" title="HTTP的缓存代理"></a>HTTP的缓存代理</h2><ul>
<li>HTTP 传输链路上，不只是客户端有缓存，服务器上的缓存也是非常有价值的，可以让请求不必走完整个后续处理流程，“就近”获得响应结果。</li>
<li>特别是对于那些“读多写少”的数据，例如突发热点新闻、爆款商品的详情页，一秒钟内可能有成千上万次的请求。即使仅仅缓存数秒钟，也能够把巨大的访问流量挡在外面，让 RPS（request per second）降低好几个数量级，减轻应用服务器的并发压力，对性能的改善是非常显著的。</li>
<li>HTTP 的服务器缓存功能主要由代理服务器来实现（即缓存代理），而源服务器系统内部虽然也经常有各种缓存（如 Memcache、Redis、Varnish 等），但与 HTTP 没有太多关系<h3 id="缓存代理服务"><a href="#缓存代理服务" class="headerlink" title="缓存代理服务"></a>缓存代理服务</h3></li>
<li>在 HTTP 的缓存体系中，缓存代理的身份十分特殊，它“既是客户端，又是服务器”，同时也“既不是客户端，又不是服务器”。</li>
<li>说它“即是客户端又是服务器”，是因为它面向源服务器时是客户端，在面向客户端时又是服务器，所以它即可以用客户端的缓存控制策略也可以用服务器端的缓存控制策略</li>
<li>但缓存代理也“即不是客户端又不是服务器”，因为它只是一个数据的“中转站”，并不是真正的数据消费者和生产者，所以还需要有一些新的“Cache-Control”属性来对它做特别的约束。<h3 id="源服务器的缓存控制"><a href="#源服务器的缓存控制" class="headerlink" title="源服务器的缓存控制"></a>源服务器的缓存控制</h3></li>
<li>4 种服务器端的“Cache-Control”属性：max-age、no-store、no-cache 和 must-revalidate,这 4 种缓存属性可以约束客户端，也可以约束代理。</li>
<li>但客户端和代理是不一样的，客户端的缓存只是用户自己使用，而代理的缓存可能会为非常多的客户端提供服务。所以，需要对它的缓存再多一些限制条件。</li>
<li><p>首先，我们要区分客户端上的缓存和代理上的缓存，可以使用两个新属性“private”和“public”。“private”表示缓存只能在客户端保存，是用户“私有”的，不能放在代理上与别人共享。而“public”的意思就是缓存完全开放，谁都可以存，谁都可以用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比如你登录论坛，返回的响应报文里用“Set-Cookie”添加了论坛 ID，这就属于私人数据，不能存在代理上。不然，别人访问代理获取了被缓存的响应就麻烦了。</span><br></pre></td></tr></table></figure>
</li>
<li><p>其次，缓存失效后的重新验证也要区分开（即使用条件请求“Last-modified”和“ETag”），“must-revalidate”是只要过期就必须回源服务器验证，而新的“proxy-revalidate”只要求代理的缓存过期后必须验证，客户端不必回源，只验证到代理这个环节就行了。</p>
</li>
<li>再次，缓存的生存时间可以使用新的“s-maxage”（s 是 share 的意思，注意 maxage 中间没有“-”），只限定在代理上能够存多久，而客户端仍然使用“max-age”</li>
<li><p>还有一个代理专用的属性“no-transform”。代理有时候会对缓存下来的数据做一些优化，比如把图片生成 png、webp 等几种格式，方便今后的请求处理，而“no-transform”就会禁止这样做，不许“偷偷摸摸搞小动作”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这些新的缓存控制属性比较复杂，还是用“便利店冷柜”来举例好理解一些。</span><br><span class="line">水果上贴着标签“private, max-age=5”。这就是说水果不能放进冷柜，必须直接给顾客，保鲜期 5 天，过期了还得去超市重新进货。</span><br><span class="line">冻鱼上贴着标签“public, max-age=5, s-maxage=10”。这个的意思就是可以在冰柜里存 10 天，但顾客那里只能存 5 天，过期了可以来便利店取，只要在 10 天之内就不必再找超市。</span><br><span class="line">排骨上贴着标签“max-age=30, proxy-revalidate, no-transform”。因为缓存默认是 public 的，那么它在便利店和顾客的冰箱里就都可以存 30 天，过期后便利店必须去超市进新货，而且不能擅自把“大排”改成“小排”。</span><br></pre></td></tr></table></figure>
</li>
<li><p>源服务器在设置完“Cache-Control”后必须要为报文加上“Last-modified”或“ETag”字段。否则，客户端和代理后面就无法使用条件请求来验证缓存是否有效，也就不会有 304 缓存重定向。</p>
</li>
</ul>
<h3 id="客户端的缓存控制-1"><a href="#客户端的缓存控制-1" class="headerlink" title="客户端的缓存控制"></a>客户端的缓存控制</h3><ul>
<li>max-age、no-store、no-cache 这三个属性它们也是同样作用于代理和源服务器。</li>
<li>关于缓存的生存时间，多了两个新属性“max-stale”和“min-fresh”。</li>
<li><p>“max-stale”的意思是如果代理上的缓存过期了也可以接受，但不能过期太多，超过 x 秒也会不要。“min-fresh”的意思是缓存必须有效，而且必须在 x 秒后依然有效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">比如，草莓上贴着标签“max-age=5”，现在已经在冰柜里存了 7 天。如果有请求“max-stale=2”，意思是过期两天也能接受，所以刚好能卖出去。</span><br><span class="line">但要是“min-fresh=1”，这是绝对不允许过期的，就不会买走。这时如果有另外一个菠萝是“max-age=10”，那么“7+1&lt;10”，在一天之后还是新鲜的，所以就能卖出去。</span><br></pre></td></tr></table></figure>
</li>
<li><p>有的时候客户端还会发出一个特别的“only-if-cached”属性，表示只接受代理缓存的数据，不接受源服务器的响应。如果代理上没有缓存或者缓存过期，就应该给客户端返回一个 504（Gateway Timeout）。</p>
</li>
</ul>
<h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><ul>
<li>第一个是“Vary”字段，它是内容协商的结果，相当于报文的一个版本标记。同一个请求，经过内容协商后可能会有不同的字符集、编码、浏览器等版本。比如，“Vary: Accept-Encoding”“Vary: User-Agent”，缓存代理必须要存储这些不同的版本。当再收到相同的请求时，代理就读取缓存里的“Vary”，对比请求头里相应的“ Accept-Encoding”“User-Agent”等字段，如果和上一个请求的完全匹配，比如都是“gzip”“Chrome”，就表示版本一致，可以返回缓存的数据。</li>
<li>另一个问题是“Purge”，也就是“缓存清理”，它对于代理也是非常重要的功能，例如：</li>
</ul>
<ol>
<li>过期的数据应该及时淘汰，避免占用空间；</li>
<li>源站的资源有更新，需要删除旧版本，主动换成最新版（即刷新）；</li>
<li>有时候会缓存了一些本不该存储的信息，例如网络谣言或者危险链接，必须尽快把它们删除。<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3></li>
</ol>
<ul>
<li>计算机领域里最常用的性能优化手段是“时空转换”，也就是“时间换空间”或者“空间换时间”，HTTP 缓存属于后者；</li>
<li>缓存代理是增加了缓存功能的代理服务，缓存源服务器的数据，分发给下游的客户端；</li>
<li>“Cache-Control”字段也可以控制缓存代理，常用的有“private”“s-maxage”“no-transform”等，同样必须配合“Last-modified”“ETag”等字段才能使用；</li>
<li>缓存代理有时候也会带来负面影响，缓存不良数据，需要及时刷新或删除。</li>
</ul>
<h2 id="HTTPS是什么？SSL-TLS又是什么？"><a href="#HTTPS是什么？SSL-TLS又是什么？" class="headerlink" title="HTTPS是什么？SSL/TLS又是什么？"></a>HTTPS是什么？SSL/TLS又是什么？</h2><ul>
<li>为什么要有 HTTPS？简单的回答是“因为 HTTP 不安全”。由于 HTTP 天生“明文”的特点，整个传输过程完全透明，任何人都能够在链路中截获、修改或者伪造请求 / 响应报文，数据不具有可信性。</li>
<li>“代理服务”。它作为 HTTP 通信的中间人，在数据上下行的时候可以添加或删除部分头字段，也可以使用黑白名单过滤 body 里的关键字，甚至直接发送虚假的请求、响应，而浏览器和源服务器都没有办法判断报文的真伪。<h3 id="什么是安全？"><a href="#什么是安全？" class="headerlink" title="什么是安全？"></a>什么是安全？</h3></li>
<li>通常认为，如果通信过程具备了四个特性，就可以认为是“安全”的，这四个特性是：机密性、完整性，身份认证和不可否认。</li>
</ul>
<ol>
<li>机密性（Secrecy/Confidentiality）是指对数据的“保密”，只能由可信的人访问，对其他人是不可见的“秘密”，简单来说就是不能让不相关的人看到不该看的东西。</li>
<li>完整性（Integrity，也叫一致性）是指数据在传输过程中没有被篡改，不多也不少，“完完整整”地保持着原状。</li>
<li>身份认证（Authentication）是指确认对方的真实身份，也就是“证明你真的是你”，保证消息只能发送给可信的人。</li>
<li>不可否认（Non-repudiation/Undeniable），也叫不可抵赖，意思是不能否认已经发生过的行为，不能“说话不算数”“耍赖皮”。<h3 id="什么是-HTTPS？"><a href="#什么是-HTTPS？" class="headerlink" title="什么是 HTTPS？"></a>什么是 HTTPS？</h3></li>
</ol>
<ul>
<li>默认端口号 443，HTTPS 与 HTTP 最大的区别，它能够鉴别危险的网站，并且尽最大可能保证你的上网安全，防御黑客对信息的窃听、篡改或者“钓鱼”、伪造。</li>
<li>它把 HTTP 下层的传输协议由 TCP/IP 换成了 SSL/TLS，由“HTTP over TCP/IP”变成了“HTTP over SSL/TLS”，让 HTTP 运行在了安全的 SSL/TLS 协议上，收发报文不再使用 Socket API，而是调用专门的安全接口。<h3 id="SSL-TLS"><a href="#SSL-TLS" class="headerlink" title="SSL/TLS"></a>SSL/TLS</h3></li>
<li>SSL 即安全套接层（Secure Sockets Layer），在 OSI 模型中处于第 5 层（会话层），由网景公司于 1994 年发明，有 v2 和 v3 两个版本，而 v1 因为有严重的缺陷从未公开过。</li>
<li>SSL 发展到 v3 时已经证明了它自身是一个非常好的安全通信协议，于是互联网工程组 IETF 在 1999 年把它改名为 TLS（传输层安全，Transport Layer Security），正式标准化，版本号从 1.0 重新算起，所以 TLS1.0 实际上就是 SSLv3.1。到今天 TLS 已经发展出了三个版本，分别是 2006 年的 1.1、2008 年的 1.2 和去年（2018）的 1.3，每个新版本都紧跟密码学的发展和互联网的现状，持续强化安全和性能，已经成为了信息安全领域中的权威标准。目前应用的最广泛的 TLS 是 1.2，而之前的协议（TLS1.1/1.0、SSLv3/v2）都已经被认为是不安全的，各大浏览器即将在 2020 年左右停止支持，所以接下来的讲解都针对的是 TLS1.2。</li>
<li>TLS 由记录协议、握手协议、警告协议、变更密码规范协议、扩展协议等几个子协议组成，综合使用了对称加密、非对称加密、身份认证等许多密码学前沿技术。</li>
<li>浏览器和服务器在使用 TLS 建立连接时需要选择一组恰当的加密算法来实现安全通信，这些算法的组合被称为“密码套件”（cipher suite，也叫加密套件）。</li>
<li>TLS 的密码套件命名非常规范，格式很固定。基本的形式是“密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法”<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">“ECDHE-RSA-AES256-GCM-SHA384”</span><br><span class="line"></span><br><span class="line">“握手时使用 ECDHE 算法进行密钥交换，用 RSA 签名和身份认证，握手后的通信使用 AES 对称算法，密钥长度 256 位，分组模式是 GCM，摘要算法 SHA384 用于消息认证和产生随机数。”</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="OpenSSL"><a href="#OpenSSL" class="headerlink" title="OpenSSL"></a>OpenSSL</h3><ul>
<li>它是一个著名的开源密码学程序库和工具包，几乎支持所有公开的加密算法和协议，已经成为了事实上的标准，许多应用软件都会使用它作为底层库来实现 TLS 功能，包括常用的 Web 服务器 Apache、Nginx 等。</li>
</ul>
<h2 id="对称加密与非对称加密"><a href="#对称加密与非对称加密" class="headerlink" title="对称加密与非对称加密"></a>对称加密与非对称加密</h2><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><ul>
<li><p>加密和解密时使用的密钥都是同一个，是“对称”的。只要保证了密钥的安全，那整个通信过程就可以说具有了机密性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">举个例子，你想要登录某网站，只要事先和它约定好使用一个对称密钥，通信过程中传输的全是用密钥加密后的密文，只有你和网站才能解密。黑客即使能够窃听，看到的也只是乱码，因为没有密钥无法解出明文，所以就实现了机密性。</span><br></pre></td></tr></table></figure>
</li>
<li><p>TLS 里有非常多的对称加密算法可供选择，比如 RC4、DES、3DES、AES、ChaCha20 等，但前三种算法都被认为是不安全的，通常都禁止使用，目前常用的只有 AES 和 ChaCha20。</p>
<h3 id="加密分组模式"><a href="#加密分组模式" class="headerlink" title="加密分组模式"></a>加密分组模式</h3></li>
<li>对称算法还有一个“分组模式”的概念，它可以让算法用固定长度的密钥加密任意长度的明文，把小秘密（即密钥）转化为大秘密（即密文）。</li>
<li>最新的分组模式被称为 AEAD（Authenticated Encryption with Associated Data），在加密的同时增加了认证的功能，常用的是 GCM、CCM 和 Poly1305。把上面这些组合起来，就可以得到 TLS 密码套件中定义的对称加密算法。<h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3></li>
<li>它有两个密钥，一个叫“公钥”（public key），一个叫“私钥”（private key）。两个密钥是不同的，“不对称”，公钥可以公开给任何人使用，而私钥必须严格保密。</li>
<li>因为在对称加密算法中只要持有密钥就可以解密。如果你和网站约定的密钥在传递途中被黑客窃取，那他就可以在之后随意解密收发的数据，通信过程也就没有机密性可言了。</li>
<li>公钥和私钥有个特别的“单向”性，虽然都可以用来加密解密，但公钥加密后只能用私钥解密，反过来，私钥加密后也只能用公钥解密。<h3 id="混合加密"><a href="#混合加密" class="headerlink" title="混合加密"></a>混合加密</h3></li>
<li>很遗憾，虽然非对称加密没有“密钥交换”的问题，但因为它们都是基于复杂的数学难题，运算速度很慢，即使是 ECC 也要比 AES 差上好几个数量级。如果仅用非对称加密，虽然保证了安全，但通信速度有如乌龟、蜗牛，实用性就变成了零。</li>
<li>在通信刚开始的时候使用非对称算法，比如 RSA、ECDHE，首先解决密钥交换的问题。</li>
<li>然后用随机数产生对称算法使用的“会话密钥”（session key），再用公钥加密。因为会话密钥很短，通常只有 16 字节或 32 字节，所以慢一点也无所谓。</li>
</ul>
<h2 id="数字签名与证书"><a href="#数字签名与证书" class="headerlink" title="数字签名与证书"></a>数字签名与证书</h2><ul>
<li>黑客虽然拿不到会话密钥，无法破解密文，但可以通过窃听收集到足够多的密文，再尝试着修改、重组后发给网站。因为没有完整性保证，服务器只能“照单全收”，然后他就可以通过服务器的响应获取进一步的线索，最终就会破解出明文。</li>
<li>黑客也可以伪造身份发布公钥。如果你拿到了假的公钥，混合加密就完全失效了。你以为自己是在和“某宝”通信，实际上网线的另一端却是黑客，银行卡号、密码等敏感信息就在“安全”的通信过程中被窃取了。</li>
<li>所以，在机密性的基础上还必须加上完整性、身份认证等特性，才能实现真正的安全。<h3 id="摘要算法"><a href="#摘要算法" class="headerlink" title="摘要算法"></a>摘要算法</h3></li>
<li>实现完整性的手段主要是摘要算法（Digest Algorithm），也就是常说的散列函数、哈希函数（Hash Function）。</li>
<li>你可以把摘要算法近似地理解成一种特殊的压缩算法，它能够把任意长度的数据“压缩”成固定长度、而且独一无二的“摘要”字符串，就好像是给这段数据生成了一个数字“指纹”。</li>
<li>换一个角度，也可以把摘要算法理解成特殊的“单向”加密算法，它只有算法，没有密钥，加密后的数据无法解密，不能从摘要逆推出原文。</li>
<li>摘要算法实际上是把数据从一个“大空间”映射到了“小空间”，所以就存在“冲突”（collision，也叫碰撞）的可能性，就如同现实中的指纹一样，可能会有两份不同的原文对应相同的摘要。好的摘要算法必须能够“抵抗冲突”，让这种可能性尽量地小。</li>
<li>你一定在日常工作中听过、或者用过 MD5（Message-Digest 5）、SHA-1（Secure Hash Algorithm 1），它们就是最常用的两个摘要算法，能够生成 16 字节和 20 字节长度的数字摘要。但这两个算法的安全强度比较低，不够安全，在 TLS 里已经被禁止使用了。<h3 id="完整性"><a href="#完整性" class="headerlink" title="完整性"></a>完整性</h3></li>
<li>摘要算法保证了“数字摘要”和原文是完全等价的。所以，我们只要在原文后附上它的摘要，就能够保证数据的完整性。</li>
<li>不过摘要算法不具有机密性，如果明文传输，那么黑客可以修改消息后把摘要也一起改了，网站还是鉴别不出完整性。</li>
<li>所以，真正的完整性必须要建立在机密性之上，在混合加密系统里用会话密钥加密消息和摘要，这样黑客无法得知明文，也就没有办法动手脚了。<h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3></li>
<li>加密算法结合摘要算法，我们的通信过程可以说是比较安全了。但这里还有漏洞，就是通信的两个端点（endpoint）。</li>
<li>就像一开始所说的，黑客可以伪装成网站来窃取信息。而反过来，他也可以伪装成你，向网站发送支付、转账等消息，网站没有办法确认你的身份，钱可能就这么被偷走了。</li>
<li>现实生活中，解决身份认证的手段是签名和印章，只要在纸上写下签名或者盖个章，就能够证明这份文件确实是由本人而不是其他人发出的。</li>
<li>使用私钥再加上摘要算法，就能够实现“数字签名”，同时实现“身份认证”和“不可否认”。<h3 id="数字证书和-CA"><a href="#数字证书和-CA" class="headerlink" title="数字证书和 CA"></a>数字证书和 CA</h3></li>
<li>CA（Certificate Authority，证书认证机构）。它就像网络世界里的公安局、教育部、公证中心，具有极高的可信度，由它来给各个公钥签名，用自身的信誉来保证公钥无法伪造，是可信的。</li>
<li>CA 对公钥的签名认证也是有格式的，不是简单地把公钥绑定在持有者身份上就完事了，还要包含序列号、用途、颁发者、有效时间等等，把这些打成一个包再签名，完整地证明公钥关联的各种信息，形成“数字证书”（Certificate）。</li>
<li>有了这个证书体系，操作系统和浏览器都内置了各大 CA 的根证书，上网的时候只要服务器发过来它的证书，就可以验证证书里的签名，顺着证书链（Certificate Chain）一层层地验证，直到找到根证书，就能够确定证书是可信的，从而里面的公钥也是可信的。</li>
</ul>
<h3 id="证书体系的弱点"><a href="#证书体系的弱点" class="headerlink" title="证书体系的弱点"></a>证书体系的弱点</h3><ul>
<li>如果 CA 失误或者被欺骗，签发了错误的证书，虽然证书是真的，可它代表的网站却是假的。</li>
<li>还有一种更危险的情况，CA 被黑客攻陷，或者 CA 有恶意，因为它（即根证书）是信任的源头，整个信任链里的所有证书也就都不可信了。</li>
<li>针对第一种，开发出了 CRL（证书吊销列表，Certificate revocation list）和 OCSP（在线证书状态协议，Online Certificate Status Protocol），及时废止有问题的证书。</li>
<li>对于第二种，因为涉及的证书太多，就只能操作系统或者浏览器从根上“下狠手”了，撤销对 CA 的信任，列入“黑名单”，这样它颁发的所有证书就都会被认为是不安全的。</li>
</ul>
<h2 id="TLS1-2连接过程解析"><a href="#TLS1-2连接过程解析" class="headerlink" title="TLS1.2连接过程解析"></a>TLS1.2连接过程解析</h2><h3 id="HTTPS-建立连接"><a href="#HTTPS-建立连接" class="headerlink" title="HTTPS 建立连接"></a>HTTPS 建立连接</h3><ul>
<li>当你在浏览器地址栏里键入“https”开头的 URI，再按下回车，会发生什么呢？</li>
</ul>
<ol>
<li>浏览器首先要从 URI 里提取出协议名和域名。因为协议名是“https”，所以浏览器就知道了端口号是默认的 443，它再用 DNS 解析域名，得到目标的 IP 地址，然后就可以使用三次握手与网站建立 TCP 连接了。</li>
<li>在 HTTP 协议里，建立连接后，浏览器会立即发送请求报文。但现在是 HTTPS 协议，它需要再用另外一个“握手”过程，在 TCP 上建立安全连接，之后才是收发 HTTP 报文。这个“握手”过程与 TCP 有些类似，是 HTTPS 和 TLS 协议里最重要、最核心的部分。<h3 id="TLS-协议的组成"><a href="#TLS-协议的组成" class="headerlink" title="TLS 协议的组成"></a>TLS 协议的组成</h3></li>
</ol>
<ul>
<li>TLS 包含几个子协议，你也可以理解为它是由几个不同职责的模块组成，比较常用的有记录协议、警报协议、握手协议、变更密码规范协议等。</li>
</ul>
<ol>
<li>记录协议（Record Protocol）规定了 TLS 收发数据的基本单位：记录（record）。它有点像是 TCP 里的 segment，所有的其他子协议都需要通过记录协议发出。但多个记录数据可以在一个 TCP 包里一次性发出，也并不需要像 TCP 那样返回 ACK。</li>
<li>警报协议（Alert Protocol）的职责是向对方发出警报信息，有点像是 HTTP 协议里的状态码。比如，protocol_version 就是不支持旧版本，bad_certificate 就是证书有问题，收到警报后另一方可以选择继续，也可以立即终止连接。</li>
<li>握手协议（Handshake Protocol）是 TLS 里最复杂的子协议，要比 TCP 的 SYN/ACK 复杂的多，浏览器和服务器会在握手过程中协商 TLS 版本号、随机数、密码套件等信息，然后交换证书和密钥参数，最终双方协商得到会话密钥，用于后续的混合加密系统。</li>
<li>变更密码规范协议（Change Cipher Spec Protocol），它非常简单，就是一个“通知”，告诉对方，后续的数据都将使用加密保护。那么反过来，在它之前，数据都是明文的。<h3 id="ECDHE-握手过程"><a href="#ECDHE-握手过程" class="headerlink" title="ECDHE 握手过程"></a>ECDHE 握手过程</h3></li>
</ol>
<ul>
<li>在 TCP 建立连接之后，浏览器会首先发一个“Client Hello”消息，也就是跟服务器“打招呼”。里面有客户端的版本号、支持的密码套件，还有一个随机数（Client Random），用于后续生成会话密钥。这个的意思就是：“我这边有这些这些信息，你看看哪些是能用的，关键的随机数可得留着。”</li>
<li>作为“礼尚往来”，服务器收到“Client Hello”后，会返回一个“Server Hello”消息。把版本号对一下，也给出一个随机数（Server Random），然后从客户端的列表里选一个作为本次通信使用的密码套件，在这里它选择了“TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384”。这个的意思就是：“版本号对上了，可以加密，你的密码套件挺多，我选一个最合适的吧，用椭圆曲线加 RSA、AES、SHA384。我也给你一个随机数，你也得留着。”</li>
<li>然后，服务器为了证明自己的身份，就把证书也发给了客户端（Server Certificate）。</li>
<li>接下来是一个关键的操作，因为服务器选择了 ECDHE 算法，所以它会在证书后发送“Server Key Exchange”消息，里面是椭圆曲线的公钥（Server Params），用来实现密钥交换算法，再加上自己的私钥签名认证。这相当于说：“刚才我选的密码套件有点复杂，所以再给你个算法的参数，和刚才的随机数一样有用，别丢了。为了防止别人冒充，我又盖了个章。”</li>
<li>之后是“Server Hello Done”消息，服务器说：“我的信息就是这些，打招呼完毕。”</li>
<li>这样第一个消息往返就结束了（两个 TCP 包），结果是客户端和服务器通过明文共享了三个信息：Client Random、Server Random 和 Server Params。</li>
<li>客户端这时也拿到了服务器的证书，那这个证书是不是真实有效的呢？开始走证书链逐级验证，确认证书的真实性，再用证书公钥验证签名，就确认了服务器的身份：“刚才跟我打招呼的不是骗子，可以接着往下走。”</li>
<li>然后，客户端按照密码套件的要求，也生成一个椭圆曲线的公钥（Client Params），用“Client Key Exchange”消息发给服务器。</li>
<li>现在客户端和服务器手里都拿到了密钥交换算法的两个参数（Client Params、Server Params），就用 ECDHE 算法一阵算，算出了一个新的东西，叫“Pre-Master”，其实也是一个随机数。</li>
<li>现在客户端和服务器手里有了三个随机数：Client Random、Server Random 和 Pre-Master。用这三个作为原始材料，就可以生成用于加密会话的主密钥，叫“Master Secret”。而黑客因为拿不到“Pre-Master”，所以也就得不到主密钥。</li>
<li>为什么非得这么麻烦，非要三个随机数呢？这就必须说 TLS 的设计者考虑得非常周到了，他们不信任客户端或服务器伪随机数的可靠性，为了保证真正的“完全随机”“不可预测”，把三个不可靠的随机数混合起来，那么“随机”的程度就非常高了，足够让黑客难以猜测。</li>
<li>主密钥有 48 字节，但它也不是最终用于通信的会话密钥，还会再用 PRF （这里的“PRF”就是伪随机数函数，它基于密码套件里的最后一个参数，比如这次的 SHA384，通过摘要算法来再一次强化“Master Secret”的随机性）扩展出更多的密钥，比如客户端发送用的会话密钥（client_write_key）、服务器发送用的会话密钥（server_write_key）等等，避免只用一个密钥带来的安全隐患。</li>
<li>有了主密钥和派生的会话密钥，握手就快结束了。客户端发一个“Change Cipher Spec”，然后再发一个“Finished”消息，把之前所有发送的数据做个摘要，再加密一下，让服务器做个验证。意思就是告诉服务器：“后面都改用对称算法加密通信了啊，用的就是打招呼时说的 AES，加密对不对还得你测一下。”</li>
<li>服务器也是同样的操作，发“Change Cipher Spec”和“Finished”消息，双方都验证加密解密 OK，握手正式结束，后面就收发被加密的 HTTP 请求和响应了。<h3 id="RSA-握手过程"><a href="#RSA-握手过程" class="headerlink" title="RSA 握手过程"></a>RSA 握手过程</h3></li>
<li>第一个，使用 ECDHE 实现密钥交换，而不是 RSA，所以会在服务器端发出“Server Key Exchange”消息。</li>
<li>第二个，因为使用了 ECDHE，客户端可以不用等到服务器发回“Finished”确认握手完毕，立即就发出 HTTP 报文，省去了一个消息往返的时间浪费。这个叫“TLS False Start”，意思就是“抢跑”，和“TCP Fast Open”有点像，都是不等连接完全建立就提前发应用数据，提高传输的效率。</li>
<li>RSA 握手过程大体的流程没有变，只是“Pre-Master”不再需要用算法生成，而是客户端直接生成随机数，然后用服务器的公钥加密，通过“Client Key Exchange”消息发给服务器。服务器再用私钥解密，这样双方也实现了共享三个随机数，就可以生成主密钥。<h3 id="双向认证"><a href="#双向认证" class="headerlink" title="双向认证"></a>双向认证</h3></li>
<li>但为了防止账号、密码被盗，有的时候（比如网上银行）还会使用 U 盾给用户颁发客户端证书，实现“双向认证”，这样会更加安全。</li>
<li>双向认证的流程也没有太多变化，只是在“Server Hello Done”之后，“Client Key Exchange”之前，客户端要发送“Client Certificate”消息，服务器收到后也把证书链走一遍，验证客户端的身份。</li>
</ul>
<h2 id="TLS1-3特性解析"><a href="#TLS1-3特性解析" class="headerlink" title="TLS1.3特性解析"></a>TLS1.3特性解析</h2><h3 id="强化安全"><a href="#强化安全" class="headerlink" title="强化安全"></a>强化安全</h3><ul>
<li>TLS1.2 在十来年的应用中获得了许多宝贵的经验，陆续发现了很多的漏洞和加密算法的弱点，所以 TLS1.3 就在协议里修补了这些不安全因素。</li>
</ul>
<ol>
<li>伪随机数函数由 PRF 升级为 HKDF（HMAC-based Extract-and-Expand Key Derivation Function）；</li>
<li>明确禁止在记录协议里使用压缩；</li>
<li>废除了 RC4、DES 对称加密算法；</li>
<li>废除了 ECB、CBC 等传统分组模式；</li>
<li>废除了 MD5、SHA1、SHA-224 摘要算法；</li>
<li>废除了 RSA、DH 密钥交换算法和许多命名曲线。</li>
</ol>
<ul>
<li>经过这一番“减肥瘦身”之后，TLS1.3 里只保留了 AES、ChaCha20 对称加密算法，分组模式只能用 AEAD 的 GCM、CCM 和 Poly1305，摘要算法只能用 SHA256、SHA384，密钥交换算法只有 ECDHE 和 DHE，椭圆曲线也被“砍”到只剩 P-256 和 x25519 等 5 种。现在的 TLS1.3 里只有 5 个套件，无论是客户端还是服务器都不会再犯“选择困难症”了。</li>
<li>浏览器默认会使用 ECDHE 而不是 RSA 做密钥交换，这是因为它不具有“前向安全”（Forward Secrecy）。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">假设有这么一个很有耐心的黑客，一直在长期收集混合加密系统收发的所有报文。</span><br><span class="line">如果加密系统使用服务器证书里的 RSA 做密钥交换，一旦私钥泄露或被破解（使用社会工程学或者巨型计算机），那么黑客就能够使用私钥解密出之前所有报文的“Pre-Master”，再算出会话密钥，破解所有密文。</span><br><span class="line">这就是所谓的“今日截获，明日破解”。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">而 ECDHE 算法在每次握手时都会生成一对临时的公钥和私钥，每次通信的密钥对都是不同的，也就是“一次一密”，即使黑客花大力气破解了这一次的会话密钥，也只是这次通信被攻击，之前的历史消息不会受到影响，仍然是安全的。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="提升性能"><a href="#提升性能" class="headerlink" title="提升性能"></a>提升性能</h3><ul>
<li>HTTPS 建立连接时除了要做 TCP 握手，还要做 TLS 握手，在 1.2 中会多花两个消息往返（2-RTT），可能导致几十毫秒甚至上百毫秒的延迟，在移动网络中延迟还会更严重</li>
<li>TLS1.3 压缩了以前的“Hello”协商过程，删除了“Key Exchange”消息，把握手时间减少到了“1-RTT”，效率提高了一倍。<h3 id="握手分析"><a href="#握手分析" class="headerlink" title="握手分析"></a>握手分析</h3></li>
<li>在 TCP 建立连接之后，浏览器首先还是发一个“Client Hello”。注意“Client Hello”里的扩展，“supported_versions”表示这是 TLS1.3，“supported_groups”是支持的曲线，“key_share”是曲线对应的参数。这就好像是说：“还是照老规矩打招呼，这边有这些这些信息。但我猜你可能会升级，所以再多给你一些东西，也许后面用的上，咱们有话尽量一口气说完。”</li>
<li>服务器收到“Client Hello”同样返回“Server Hello”消息，还是要给出一个随机数（Server Random）和选定密码套件。“supported_versions”里确认使用的是 TLS1.3，然后在“key_share”扩展带上曲线和对应的公钥参数。</li>
<li>这时只交换了两条消息，客户端和服务器就拿到了四个共享信息：Client Random 和 Server Random、Client Params 和 Server Params，两边就可以各自用 ECDHE 算出“Pre-Master”，再用 HKDF 生成主密钥“Master Secret”，效率比 TLS1.2 提高了一大截。</li>
<li>在算出主密钥后，服务器立刻发出“Change Cipher Spec”消息，比 TLS1.2 提早进入加密通信，后面的证书等就都是加密的了，减少了握手时的明文信息泄露。</li>
<li>这里 TLS1.3 还有一个安全强化措施，多了个“Certificate Verify”消息，用服务器的私钥把前面的曲线、套件、参数等握手数据加了签名，作用和“Finished”消息差不多。但由于是私钥签名，所以强化了身份认证和和防窜改。</li>
<li>这两个“Hello”消息之后，客户端验证服务器证书，再发“Finished”消息，就正式完成了握手，开始收发 HTTP 报文。</li>
</ul>
<h2 id="HTTPS的优化"><a href="#HTTPS的优化" class="headerlink" title="HTTPS的优化"></a>HTTPS的优化</h2><ul>
<li>HTTPS 连接大致上可以划分为两个部分，第一个是建立连接时的非对称加密握手，第二个是握手后的对称加密报文传输。</li>
<li>由于目前流行的 AES、ChaCha20 性能都很好，还有硬件优化，报文传输的性能损耗可以说是非常地小，小到几乎可以忽略不计了。所以，通常所说的“HTTPS 连接慢”指的就是刚开始建立连接的那段时间。</li>
<li>在 TCP 建连之后，正式数据传输之前，HTTPS 比 HTTP 增加了一个 TLS 握手的步骤，这个步骤最长可以花费两个消息往返，也就是 2-RTT。而且在握手消息的网络耗时之外，还会有其他的一些“隐形”消耗，比如：</li>
</ul>
<ol>
<li>产生用于密钥交换的临时公私钥对（ECDHE）</li>
<li>验证证书时访问 CA 获取 CRL 或者 OCSP；</li>
<li>非对称加密解密处理“Pre-Master”。</li>
</ol>
<ul>
<li>在最差的情况下，也就是不做任何的优化措施，HTTPS 建立连接可能会比 HTTP 慢上几百毫秒甚至几秒，这其中既有网络耗时，也有计算耗时，就会让人产生“打开一个 HTTPS 网站好慢啊”的感觉。不过刚才说的情况早就是“过去时”了，现在已经有了很多行之有效的 HTTPS 优化手段，运用得好可以把连接的额外耗时降低到几十毫秒甚至是“零”。<h3 id="硬件优化"><a href="#硬件优化" class="headerlink" title="硬件优化"></a>硬件优化</h3></li>
<li>HTTPS 连接是计算密集型，而不是 I/O 密集型。所以，如果你花大价钱去买网卡、带宽、SSD 存储就是“南辕北辙”了，起不到优化的效果。</li>
<li>首先，你可以选择更快的 CPU，最好还内建 AES 优化，这样即可以加速握手，也可以加速传输。</li>
<li>其次，你可以选择“SSL 加速卡”，加解密时调用它的 API，让专门的硬件来做非对称加解密，分担 CPU 的计算压力。不过“SSL 加速卡”也有一些缺点，比如升级慢、支持算法有限，不能灵活定制解决方案等。</li>
<li>所以，就出现了第三种硬件加速方式：“SSL 加速服务器”，用专门的服务器集群来彻底“卸载”TLS 握手时的加密解密计算，性能自然要比单纯的“加速卡”要强大的多。<h3 id="软件优化"><a href="#软件优化" class="headerlink" title="软件优化"></a>软件优化</h3></li>
<li>软件方面的优化还可以再分成两部分：一个是软件升级，一个是协议优化。</li>
<li>软件升级实施起来比较简单，就是把现在正在使用的软件尽量升级到最新版本，比如把 Linux 内核由 2.x 升级到 4.x，把 Nginx 由 1.6 升级到 1.16，把 OpenSSL 由 1.0.1 升级到 1.1.0/1.1.1。</li>
<li>但对于很多大中型公司来说，硬件升级或软件升级都是个棘手的问题，有成千上万台各种型号的机器遍布各个机房，逐一升级不仅需要大量人手，而且有较高的风险，可能会影响正常的线上服务。<h3 id="协议优化"><a href="#协议优化" class="headerlink" title="协议优化"></a>协议优化</h3></li>
<li>如果有可能，应当尽量采用 TLS1.3，它大幅度简化了握手的过程，完全握手只要 1-RTT，而且更加安全。</li>
<li>如果暂时不能升级到 1.3，只能用 1.2，那么握手时使用的密钥交换协议应当尽量选用椭圆曲线的 ECDHE 算法。它不仅运算速度快，安全性高，还支持“False Start”，能够把握手的消息往返由 2-RTT 减少到 1-RTT，达到与 TLS1.3 类似的效果。</li>
<li>另外，椭圆曲线也要选择高性能的曲线，最好是 x25519，次优选择是 P-256。对称加密算法方面，也可以选用“AES_128_GCM”，它能比“AES_256_GCM”略快一点点。</li>
<li>在 Nginx 里可以用“ssl_ciphers”“ssl_ecdh_curve”等指令配置服务器使用的密码套件和椭圆曲线，把优先使用的放在前面，例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ssl_ciphers   TLS13-AES-256-GCM-SHA384:TLS13-CHACHA20-POLY1305-SHA256:EECDH+CHACHA20；</span><br><span class="line">ssl_ecdh_curve              X25519:P-256;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="证书优化"><a href="#证书优化" class="headerlink" title="证书优化"></a>证书优化</h3><ul>
<li>这里就有两个优化点，一个是证书传输，一个是证书验证。</li>
<li>服务器的证书可以选择椭圆曲线（ECDSA）证书而不是 RSA 证书，因为 224 位的 ECC 相当于 2048 位的 RSA，所以椭圆曲线证书的“个头”要比 RSA 小很多，即能够节约带宽也能减少客户端的运算量，可谓“一举两得”。</li>
<li>客户端的证书验证其实是个很复杂的操作，除了要公钥解密验证多个证书签名外，因为证书还有可能会被撤销失效，客户端有时还会再去访问 CA，下载 CRL 或者 OCSP 数据，这又会产生 DNS 查询、建立连接、收发数据等一系列网络通信，增加好几个 RTT。</li>
<li>CRL（Certificate revocation list，证书吊销列表）由 CA 定期发布，里面是所有被撤销信任的证书序号，查询这个列表就可以知道证书是否有效。但 CRL 因为是“定期”发布，就有“时间窗口”的安全隐患，而且随着吊销证书的增多，列表会越来越大，一个 CRL 经常会上 MB。想象一下，每次需要预先下载几 M 的“无用数据”才能连接网站，实用性实在是太低了。</li>
<li>所以，现在 CRL 基本上不用了，取而代之的是 OCSP（在线证书状态协议，Online Certificate Status Protocol），向 CA 发送查询请求，让 CA 返回证书的有效状态。</li>
<li>但 OCSP 也要多出一次网络请求的消耗，而且还依赖于 CA 服务器，如果 CA 服务器很忙，那响应延迟也是等不起的。于是又出来了一个“补丁”，叫“OCSP Stapling”（OCSP 装订），它可以让服务器预先访问 CA 获取 OCSP 响应，然后在握手时随着证书一起发给客户端，免去了客户端连接 CA 服务器查询的时间。<h3 id="会话复用"><a href="#会话复用" class="headerlink" title="会话复用"></a>会话复用</h3></li>
<li>HTTPS 建立连接的过程：先是 TCP 三次握手，然后是 TLS 一次握手。这后一次握手的重点是算出主密钥“Master Secret”，而主密钥每次连接都要重新计算，未免有点太浪费了，如果能够把“辛辛苦苦”算出来的主密钥缓存一下“重用”，不就可以免去了握手和计算的成本了吗？这种做法就叫“会话复用”（TLS session resumption），和 HTTP Cache 一样，也是提高 HTTPS 性能的“大杀器”，被浏览器和服务器广泛应用。</li>
<li>会话复用分两种，第一种叫“Session ID”，就是客户端和服务器首次连接后各自保存一个会话的 ID 号，内存里存储主密钥和其他相关的信息。当客户端再次连接时发一个 ID 过来，服务器就在内存里找，找到就直接用主密钥恢复会话状态，跳过证书验证和密钥交换，只用一个消息往返就可以建立安全通信。<h3 id="会话票证"><a href="#会话票证" class="headerlink" title="会话票证"></a>会话票证</h3></li>
<li>“Session ID”是最早出现的会话复用技术，也是应用最广的，但它也有缺点，服务器必须保存每一个客户端的会话数据，对于拥有百万、千万级别用户的网站来说存储量就成了大问题，加重了服务器的负担。</li>
<li>于是，又出现了第二种“Session Ticket”方案。它有点类似 HTTP 的 Cookie，存储的责任由服务器转移到了客户端，服务器加密会话信息，用“New Session Ticket”消息发给客户端，让客户端保存。重连的时候，客户端使用扩展“session_ticket”发送“Ticket”而不是“Session ID”，服务器解密后验证有效期，就可以恢复会话，开始加密通信。不过“Session Ticket”方案需要使用一个固定的密钥文件（ticket_key）来加密 Ticket，为了防止密钥被破解，保证“前向安全”，密钥文件需要定期轮换，比如设置为一小时或者一天。<h3 id="预共享密钥"><a href="#预共享密钥" class="headerlink" title="预共享密钥"></a>预共享密钥</h3></li>
<li>“False Start”“Session ID”“Session Ticket”等方式只能实现 1-RTT，而 TLS1.3 更进一步实现了“0-RTT”，原理和“Session Ticket”差不多，但在发送 Ticket 的同时会带上应用数据（Early Data），免去了 1.2 里的服务器确认步骤，这种方式叫“Pre-shared Key”，简称为“PSK”。</li>
<li>但“PSK”也不是完美的，它为了追求效率而牺牲了一点安全性，容易受到“重放攻击”（Replay attack）的威胁。黑客可以截获“PSK”的数据，像复读机那样反复向服务器发送。</li>
<li>解决的办法是只允许安全的 GET/HEAD 方法，在消息里加入时间戳、“nonce”验证，或者“一次性票证”限制重放。</li>
</ul>
<h2 id="我应该迁移到HTTPS吗？"><a href="#我应该迁移到HTTPS吗？" class="headerlink" title="我应该迁移到HTTPS吗？"></a>我应该迁移到HTTPS吗？</h2><ul>
<li>从 HTTP 迁移到 HTTPS 是“大势所趋”，能做就应该尽早做；<h3 id="重定向跳转"><a href="#重定向跳转" class="headerlink" title="重定向跳转"></a>重定向跳转</h3></li>
<li><p>把不安全的 HTTP 网址用 301 或 302“重定向”到新的 HTTPS 网站，这在 Nginx 里也很容易做到，使用“return”或“rewrite”都可以。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">return 301 https://$host$request_uri;             #永久重定向</span><br><span class="line">rewrite ^  https://$host$request_uri permanent;   #永久重定向</span><br><span class="line">但这种方式有两个问题。一个是重定向增加了网络成本，多出了一次请求；</span><br><span class="line">另一个是存在安全隐患，重定向的响应可能会被“中间人”窜改，实现“会话劫持”，跳转到恶意网站</span><br></pre></td></tr></table></figure>
</li>
<li><p>不过有一种叫“HSTS”（HTTP 严格传输安全，HTTP Strict Transport Security）的技术可以消除这种安全隐患。HTTPS 服务器需要在发出的响应头里添加一个“Strict-Transport-Security”的字段，再设定一个有效期，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Strict-Transport-Security: max-age=15768000; includeSubDomains</span><br><span class="line">这相当于告诉浏览器：我这个网站必须严格使用 HTTPS 协议，在半年之内（182.5 天）都不允许用 HTTP，你以后就自己做转换吧，不要再来麻烦我了。</span><br><span class="line">有了“HSTS”的指示，以后浏览器再访问同样的域名的时候就会自动把 URI 里的“http”改成“https”，直接访问安全的 HTTPS 网站。这样“中间人”就失去了攻击的机会，而且对于客户端来说也免去了一次跳转，加快了连接速度。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="HTTP-2特性概览"><a href="#HTTP-2特性概览" class="headerlink" title="HTTP/2特性概览"></a>HTTP/2特性概览</h2><ul>
<li>HTTPS，通过引入 SSL/TLS 在安全上达到了“极致”，但在性能提升方面却是乏善可陈，只优化了握手加密的环节，对于整体的数据传输没有提出更好的改进方案，还只能依赖于“长连接”这种“落后”的技术</li>
<li>“秦失其鹿，天下共逐之”，Google 率先发明了 SPDY 协议，并应用于自家的浏览器 Chrome，打响了 HTTP 性能优化的“第一枪”。随后互联网标准化组织 IETF 以 SPDY 为基础，综合其他多方的意见，终于推出了 HTTP/1 的继任者，也就是今天的主角“HTTP/2”，在性能方面有了一个大的飞跃。</li>
</ul>
<h3 id="为什么不是-HTTP-2-0"><a href="#为什么不是-HTTP-2-0" class="headerlink" title="为什么不是 HTTP/2.0"></a>为什么不是 HTTP/2.0</h3><ul>
<li>以前的“1.0”“1.1”造成了很多的混乱和误解，让人在实际的使用中难以区分差异，所以就决定 HTTP 协议不再使用小版本号（minor version），只使用大版本号（major version），从今往后 HTTP 协议不会出现 HTTP/2.0、2.1，只会有“HTTP/2”“HTTP/3”……<h3 id="兼容-HTTP-1"><a href="#兼容-HTTP-1" class="headerlink" title="兼容 HTTP/1"></a>兼容 HTTP/1</h3></li>
<li>由于 HTTPS 已经在安全方面做的非常好了，所以 HTTP/2 的唯一目标就是改进性能。</li>
<li>但它不仅背负着众多的期待，同时还背负着 HTTP/1 庞大的历史包袱，所以协议的修改必须小心谨慎，兼容性是首要考虑的目标，否则就会破坏互联网上无数现有的资产，这方面 TLS 已经有了先例（为了兼容 TLS1.2 不得不进行“伪装”）。</li>
<li>因为必须要保持功能上的兼容，所以 HTTP/2 把 HTTP 分解成了“语义”和“语法”两个部分，“语义”层不做改动，与 HTTP/1 完全一致（即 RFC7231）。比如请求方法、URI、状态码、头字段等概念都保留不变，这样就消除了再学习的成本，基于 HTTP 的上层应用也不需要做任何修改，可以无缝转换到 HTTP/2。</li>
<li>与 HTTPS 不同，HTTP/2 没有在 URI 里引入新的协议名，仍然用“http”表示明文协议，用“https”表示加密协议。</li>
<li>在“语义”保持稳定之后，HTTP/2 在“语法”层做了“天翻地覆”的改造，完全变更了 HTTP 报文的传输格式。</li>
</ul>
<h3 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h3><ul>
<li>首先，HTTP/2 对报文的头部做了一个“大手术”。</li>
<li>HTTP/1 里可以用头字段“Content-Encoding”指定 Body 的编码方式，比如用 gzip 压缩来节约带宽，但报文的另一个组成部分——Header 却被无视了，没有针对它的优化手段。</li>
<li>由于报文 Header 一般会携带“User Agent”“Cookie”“Accept”“Server”等许多固定的头字段，多达几百字节甚至上千字节，但 Body 却经常只有几十字节（比如 GET 请求、204/301/304 响应），成了不折不扣的“大头儿子”。</li>
<li>更要命的是，成千上万的请求响应报文里有很多字段值都是重复的，非常浪费，“长尾效应”导致大量带宽消耗在了这些冗余度极高的数据上。</li>
<li>HTTP/2 并没有使用传统的压缩算法，而是开发了专门的“HPACK”算法，在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，还釆用哈夫曼编码来压缩整数和字符串，可以达到 50%~90% 的高压缩率。<h3 id="二进制格式"><a href="#二进制格式" class="headerlink" title="二进制格式"></a>二进制格式</h3></li>
<li>HTTP/2不再使用肉眼可见的 ASCII 码，而是向下层的 TCP/IP 协议“靠拢”，全面采用二进制格式。虽然对人不友好，但却大大方便了计算机的解析。原来使用纯文本的时候容易出现多义性，比如大小写、空白字符、回车换行、多字少字等等，程序在处理时必须用复杂的状态机，效率低，还麻烦。</li>
<li>二进制里只有“0”和“1”，可以严格规定字段大小、顺序、标志位等格式，“对就是对，错就是错”，解析起来没有歧义，实现简单，而且体积小、速度快，做到“内部提效”。</li>
<li>它把 TCP 协议的部分特性挪到了应用层，把原来的“Header+Body”的消息“打散”为数个小片的二进制“帧”（Frame），用“HEADERS”帧存放头数据、“DATA”帧存放实体数据。</li>
<li>这种做法有点像是“Chunked”分块编码的方式，也是“化整为零”的思路，但 HTTP/2 数据分帧后“Header+Body”的报文结构就完全消失了，协议看到的只是一个个的“碎片”。<h3 id="虚拟的“流”"><a href="#虚拟的“流”" class="headerlink" title="虚拟的“流”"></a>虚拟的“流”</h3></li>
<li>HTTP/2 为此定义了一个“流”（Stream）的概念，它是二进制帧的双向传输序列，同一个消息往返的帧会分配一个唯一的流 ID。你可以把它想象成是一个虚拟的“数据流”，在里面流动的是一串有先后顺序的数据帧，这些数据帧按照次序组装起来就是 HTTP/1 里的请求报文和响应报文。</li>
<li>因为“流”是虚拟的，实际上并不存在，所以 HTTP/2 就可以在一个 TCP 连接上用“流”同时发送多个“碎片化”的消息，这就是常说的“多路复用”（ Multiplexing）——多个往返通信都复用一个连接来处理。</li>
<li>在“流”的层面上看，消息是一些有序的“帧”序列，而在“连接”的层面上看，消息却是乱序收发的“帧”。多个请求 / 响应之间没有了顺序关系，不需要排队等待，也就不会再出现“队头阻塞”问题，降低了延迟，大幅度提高了连接的利用率。</li>
<li>为了更好地利用连接，加大吞吐量，HTTP/2 还添加了一些控制帧来管理虚拟的“流”，实现了优先级和流量控制，这些特性也和 TCP 协议非常相似。</li>
<li>HTTP/2 还在一定程度上改变了传统的“请求 - 应答”工作模式，服务器不再是完全被动地响应请求，也可以新建“流”主动向客户端发送消息。比如，在浏览器刚请求 HTML 的时候就提前把可能会用到的 JS、CSS 文件发给客户端，减少等待的延迟，这被称为“服务器推送”（Server Push，也叫 Cache Push）。</li>
</ul>
<h3 id="强化安全-1"><a href="#强化安全-1" class="headerlink" title="强化安全"></a>强化安全</h3><ul>
<li>出于兼容的考虑，HTTP/2 延续了 HTTP/1 的“明文”特点，可以像以前一样使用明文传输数据，不强制使用加密通信，不过格式还是二进制，只是不需要解密。</li>
<li>但由于 HTTPS 已经是大势所趋，而且主流的浏览器 Chrome、Firefox 等都公开宣布只支持加密的 HTTP/2，所以“事实上”的 HTTP/2 是加密的。也就是说，互联网上通常所能见到的 HTTP/2 都是使用“https”协议名，跑在 TLS 上面。</li>
<li>为了区分“加密”和“明文”这两个不同的版本，HTTP/2 协议定义了两个字符串标识符：“h2”表示加密的 HTTP/2，“h2c”表示明文的 HTTP/2，多出的那个字母“c”的意思是“clear text”。</li>
</ul>
<h3 id="协议栈"><a href="#协议栈" class="headerlink" title="协议栈"></a>协议栈</h3><ul>
<li>http/1: http/tcp/ip/mac</li>
<li>https: http/tls/tcp/ip/mac</li>
<li>http/2: http/hpack+stream/tls 1.2+/tcp/ip/mac</li>
</ul>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li>HTTP 协议取消了小版本号，所以 HTTP/2 的正式名字不是 2.0；</li>
<li>HTTP/2 在“语义”上兼容 HTTP/1，保留了请求方法、URI 等传统概念；</li>
<li>HTTP/2 使用“HPACK”算法压缩头部信息，消除冗余数据节约带宽；</li>
<li>HTTP/2 的消息不再是“Header+Body”的形式，而是分散为多个二进制“帧”；</li>
<li>HTTP/2 使用虚拟的“流”传输消息，解决了困扰多年的“队头阻塞”问题，同时实现了“多路复用”，提高连接的利用率；</li>
<li>HTTP/2 也增强了安全性，要求至少是 TLS1.2，而且禁用了很多不安全的密码套件。</li>
</ul>
<h2 id="HTTP-2内核剖析"><a href="#HTTP-2内核剖析" class="headerlink" title="HTTP/2内核剖析"></a>HTTP/2内核剖析</h2><h3 id="连接前言"><a href="#连接前言" class="headerlink" title="连接前言"></a>连接前言</h3><ul>
<li>由于 HTTP/2“事实上”是基于 TLS，所以在正式收发数据之前，会有 TCP 握手和 TLS 握手，</li>
<li>TLS 握手成功之后，客户端必须要发送一个“连接前言”（connection preface），用来确认建立 HTTP/2 连接。这个“连接前言”是标准的 HTTP/1 请求报文，使用纯文本的 ASCII 码格式，请求方法是特别注册的一个关键字“PRI”，全文只有 24 个字节：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n</span><br><span class="line">只要服务器收到这个“有魔力的字符串”，就知道客户端在 TLS 上想要的是 HTTP/2 协议，而不是其他别的协议，后面就会都使用 HTTP/2 的数据格式。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="头部压缩-1"><a href="#头部压缩-1" class="headerlink" title="头部压缩"></a>头部压缩</h3><ul>
<li>因为语义上它与 HTTP/1 兼容，所以报文还是由“Header+Body”构成的，但在请求发送前，必须要用“HPACK”算法来压缩头部数据。</li>
<li>“HPACK”算法是专门为压缩 HTTP 头部定制的算法，与 gzip、zlib 等压缩算法不同，它是一个“有状态”的算法，需要客户端和服务器各自维护一份“索引表”，也可以说是“字典”（这有点类似 brotli），压缩和解压缩就是查表和更新表的操作。</li>
<li>为了方便管理和压缩，HTTP/2 废除了原有的起始行概念，把起始行里面的请求方法、URI、状态码等统一转换成了头字段的形式，并且给这些“不是头字段的头字段”起了个特别的名字——“伪头字段”（pseudo-header fields）。而起始行里的版本号和错误原因短语因为没什么大用，顺便也给废除了。为了与“真头字段”区分开来，这些“伪头字段”会在名字前加一个“:”，比如“:authority” “:method” “:status”，分别表示的是域名、请求方法和状态码。</li>
<li><p>现在 HTTP 报文头就简单了，全都是“Key-Value”形式的字段，于是 HTTP/2 就为一些最常用的头字段定义了一个只读的“静态表”（Static Table）。动态表”（Dynamic Table）添加在静态表后面，结构相同，但会在编码解码的时候随时更新。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">比如说，第一次发送请求时的“user-agent”字段长是一百多个字节，用哈夫曼压缩编码发送之后，客户端和服务器都更新自己的动态表，添加一个新的索引号“65”。</span><br><span class="line">那么下一次发送的时候就不用再重复发那么多字节了，只要用一个字节发送编号就好。</span><br></pre></td></tr></table></figure>
</li>
<li><p>随着在 HTTP/2 连接上发送的报文越来越多，两边的“字典”也会越来越丰富，最终每次的头部字段都会变成一两个字节的代码，原来上千字节的头用几十个字节就可以表示了，压缩效果比 gzip 要好得多。</p>
<h3 id="二进制帧"><a href="#二进制帧" class="headerlink" title="二进制帧"></a>二进制帧</h3></li>
<li>头部数据压缩之后，HTTP/2 就要把报文拆成二进制的帧准备发送。</li>
<li>HTTP/2 的帧结构有点类似 TCP 的段或者 TLS 里的记录，但报头很小，只有 9 字节，非常地节省（可以对比一下 TCP 头，它最少是 20 个字节）。</li>
<li>帧开头是 3 个字节的长度（但不包括头的 9 个字节），默认上限是 2^14，最大是 2^24，也就是说 HTTP/2 的帧通常不超过 16K，最大是 16M。</li>
<li>长度后面的一个字节是帧类型，大致可以分成数据帧和控制帧两类，HEADERS 帧和 DATA 帧属于数据帧，存放的是 HTTP 报文，而 SETTINGS、PING、PRIORITY 等则是用来管理流的控制帧。</li>
<li>报文头里最后 4 个字节是流标识符，也就是帧所属的“流”，接收方使用它就可以从乱序的帧里识别出具有相同流 ID 的帧序列，按顺序组装起来就实现了虚拟的“流”。<h3 id="流与多路复用"><a href="#流与多路复用" class="headerlink" title="流与多路复用"></a>流与多路复用</h3></li>
<li>流是二进制帧的双向传输序列。要搞明白流，关键是要理解帧头里的流 ID。</li>
<li>在 HTTP/2 连接上，虽然帧是乱序收发的，但只要它们都拥有相同的流 ID，就都属于一个流，而且在这个流里帧不是无序的，而是有着严格的先后顺序。</li>
<li>HTTP/2 的流有哪些特点呢？</li>
</ul>
<ol>
<li>流是可并发的，一个 HTTP/2 连接上可以同时发出多个流传输数据，也就是并发多请求，实现“多路复用”；</li>
<li>客户端和服务器都可以创建流，双方互不干扰；</li>
<li>流是双向的，一个流里面客户端和服务器都可以发送或接收数据帧，也就是一个“请求 - 应答”来回；</li>
<li>流之间没有固定关系，彼此独立，但流内部的帧是有严格顺序的；</li>
<li>流可以设置优先级，让服务器优先处理，比如先传 HTML/CSS，后传图片，优化用户体验；</li>
<li>流 ID 不能重用，只能顺序递增，客户端发起的 ID 是奇数，服务器端发起的 ID 是偶数；</li>
<li>在流上发送“RST_STREAM”帧可以随时终止流，取消接收或发送；</li>
<li>第 0 号流比较特殊，不能关闭，也不能发送数据帧，只能发送控制帧，用于流量控制。</li>
</ol>
<ul>
<li>HTTP/2 在一个连接上使用多个流收发数据，那么它本身默认就会是长连接，所以永远不需要“Connection”头字段（keepalive 或 close）。</li>
<li>下载大文件的时候想取消接收，在 HTTP/1 里只能断开 TCP 连接重新“三次握手”，成本很高，而在 HTTP/2 里就可以简单地发送一个“RST_STREAM”中断流，而长连接会继续保持。</li>
<li>因为客户端和服务器两端都可以创建流，而流 ID 有奇数偶数和上限的区分，所以大多数的流 ID 都会是奇数，而且客户端在一个连接里最多只能发出 2^30，也就是 10 亿个请求。ID 用完了该怎么办呢？这个时候可以再发一个控制帧“GOAWAY”，真正关闭 TCP 连接。<h3 id="流状态转换"><a href="#流状态转换" class="headerlink" title="流状态转换"></a>流状态转换</h3></li>
<li>HTTP/2 借鉴了 TCP，根据帧的标志位实现流状态转换。当然，这些状态也是虚拟的，只是为了辅助理解。</li>
<li>最开始的时候流都是“空闲”（idle）状态，也就是“不存在”，可以理解成是待分配的“号段资源”。</li>
<li>当客户端发送 HEADERS 帧后，有了流 ID，流就进入了“打开”状态，两端都可以收发数据，然后客户端发送一个带“END_STREAM”标志位的帧，流就进入了“半关闭”状态。这个“半关闭”状态很重要，意味着客户端的请求数据已经发送完了，需要接受响应数据，而服务器端也知道请求数据接收完毕，之后就要内部处理，再发送响应数据。</li>
<li>响应数据发完了之后，也要带上“END_STREAM”标志位，表示数据发送完毕，这样流两端就都进入了“关闭”状态，流就结束了。</li>
<li>流 ID 不能重用，所以流的生命周期就是 HTTP/1 里的一次完整的“请求 - 应答”，流关闭就是一次通信结束。下一次再发请求就要开一个新流（而不是新连接），流 ID 不断增加，直到到达上限，发送“GOAWAY”帧开一个新的 TCP 连接，流 ID 就又可以重头计数。</li>
<li>因为流可以并发，所以 HTTP/2 就可以实现无阻塞的多路复用。</li>
</ul>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><ul>
<li>HTTP/2 必须先发送一个“连接前言”字符串，然后才能建立正式连接；</li>
<li>HTTP/2 废除了起始行，统一使用头字段，在两端维护字段“Key-Value”的索引表，使用“HPACK”算法压缩头部；</li>
<li>HTTP/2 把报文切分为多种类型的二进制帧，报头里最重要的字段是流标识符，标记帧属于哪个流；</li>
<li>流是 HTTP/2 虚拟的概念，是帧的双向传输序列，相当于 HTTP/1 里的一次“请求 - 应答”；</li>
<li>在一个 HTTP/2 连接上可以并发多个流，也就是多个“请求 - 响应”报文，这就是“多路复用”。</li>
</ul>
<h2 id="HTTP-3展望"><a href="#HTTP-3展望" class="headerlink" title="HTTP/3展望"></a>HTTP/3展望</h2><ul>
<li>HTTP/2 做出的许多努力，比如头部压缩、二进制分帧、虚拟的“流”与多路复用，性能方面比 HTTP/1 有了很大的提升，“基本上”解决了“队头阻塞”这个“老大难”问题。<h3 id="HTTP-2-的“队头阻塞”"><a href="#HTTP-2-的“队头阻塞”" class="headerlink" title="HTTP/2 的“队头阻塞”"></a>HTTP/2 的“队头阻塞”</h3></li>
<li>HTTP/2 虽然使用“帧”“流”“多路复用”，没有了“队头阻塞”，但这些手段都是在应用层里，而在下层，也就是 TCP 协议里，还是会发生“队头阻塞”。</li>
<li>在 HTTP/2 把多个“请求 - 响应”分解成流，交给 TCP 后，TCP 会再拆成更小的包依次发送（其实在 TCP 里应该叫 segment，也就是“段”）。</li>
<li><p>在网络良好的情况下，包可以很快送达目的地。但如果网络质量比较差，像手机上网的时候，就有可能会丢包。而 TCP 为了保证可靠传输，有个特别的“丢包重传”机制，丢失的包必须要等待重新传输确认，其他的包即使已经收到了，也只能放在缓冲区里，上层的应用拿不出来，只能“干着急”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">客户端用 TCP 发送了三个包，但服务器所在的操作系统只收到了后两个包，第一个包丢了。那么内核里的 TCP 协议栈就只能把已经收到的包暂存起来，“停下”等着客户端重传那个丢失的包，这样就又出现了“队头阻塞”。</span><br><span class="line">由于这种“队头阻塞”是 TCP 协议固有的，所以 HTTP/2 即使设计出再多的“花样”也无法解决。</span><br></pre></td></tr></table></figure>
</li>
<li><p>Google 在推 SPDY 的时候就已经意识到了这个问题，于是就又发明了一个新的“QUIC”协议，让 HTTP 跑在 QUIC 上而不是 TCP 上。而这个“HTTP over QUIC”就是 HTTP 协议的下一个大版本，HTTP/3。它在 HTTP/2 的基础上又实现了质的飞跃，真正“完美”地解决了“队头阻塞”问题。</p>
</li>
</ul>
<h3 id="QUIC-协议"><a href="#QUIC-协议" class="headerlink" title="QUIC 协议"></a>QUIC 协议</h3><ul>
<li>http/2:http/qpack+stream/quic+tls 1.3+/udp/ip/mac</li>
<li>HTTP/3 有一个关键的改变，那就是它把下层的 TCP“抽掉”了，换成了 UDP。因为 UDP 是无序的，包之间没有依赖关系，所以就从根本上解决了“队头阻塞”。</li>
<li>UDP 是一个简单、不可靠的传输协议，只是对 IP 协议的一层很薄的包装，和 TCP 相比，它实际应用的较少。不过正是因为它简单，不需要建连和断连，通信成本低，也就非常灵活、高效，“可塑性”很强。</li>
<li>所以，QUIC 就选定了 UDP，在它之上把 TCP 的那一套连接管理、拥塞窗口、流量控制等“搬”了过来，“去其糟粕，取其精华”，打造出了一个全新的可靠传输协议，可以认为是“新时代的 TCP”。<h3 id="QUIC-的特点"><a href="#QUIC-的特点" class="headerlink" title="QUIC 的特点"></a>QUIC 的特点</h3></li>
<li>QUIC 基于 UDP，而 UDP 是“无连接”的，根本就不需要“握手”和“挥手”，所以天生就要比 TCP 快。</li>
<li>就像 TCP 在 IP 的基础上实现了可靠传输一样，QUIC 也基于 UDP 实现了可靠传输，保证数据一定能够抵达目的地。它还引入了类似 HTTP/2 的“流”和“多路复用”，单个“流”是有序的，可能会因为丢包而阻塞，但其他“流”不会受到影响。</li>
<li>但 QUIC 并不是建立在 TLS 之上，而是内部“包含”了 TLS。它使用自己的帧“接管”了 TLS 里的“记录”，握手消息、警报消息都不使用 TLS 记录，直接封装成 QUIC 的帧发送，省掉了一次开销。<h3 id="QUIC-内部细节"><a href="#QUIC-内部细节" class="headerlink" title="QUIC 内部细节"></a>QUIC 内部细节</h3></li>
<li>QUIC 的基本数据传输单位是包（packet）和帧（frame），一个包由多个帧组成，包面向的是“连接”，帧面向的是“流”。</li>
<li><p>QUIC 使用不透明的“连接 ID”来标记通信的两个端点，客户端和服务器可以自行选择一组 ID 来标记自己，这样就解除了 TCP 里连接对“IP 地址 + 端口”（即常说的四元组）的强绑定，支持“连接迁移”（Connection Migration）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比如你下班回家，手机会自动由 4G 切换到 WiFi。这时 IP 地址会发生变化，TCP 就必须重新建立连接。而 QUIC 连接里的两端连接 ID 不会变，所以连接在“逻辑上”没有中断，它就可以在新的 IP 地址上继续使用之前的连接，消除重连的成本，实现连接的无缝迁移。</span><br></pre></td></tr></table></figure>
</li>
<li><p>HTTP/2 里的流都是双向的，而 QUIC 则分为双向流和单向流。</p>
</li>
</ul>
<h3 id="HTTP-3-协议"><a href="#HTTP-3-协议" class="headerlink" title="HTTP/3 协议"></a>HTTP/3 协议</h3><ul>
<li>因为 QUIC 本身就已经支持了加密、流和多路复用，所以 HTTP/3 的工作减轻了很多，把流控制都交给 QUIC 去做。调用的不再是 TLS 的安全接口，也不是 Socket API，而是专门的 QUIC 函数。不过这个“QUIC 函数”还没有形成标准，必须要绑定到某一个具体的实现库。</li>
<li>HTTP/3 里仍然使用流来发送“请求 - 响应”，但它自身不需要像 HTTP/2 那样再去定义流，而是直接使用 QUIC 的流，相当于做了一个“概念映射”。</li>
<li>HTTP/3 里的“双向流”可以完全对应到 HTTP/2 的流，而“单向流”在 HTTP/3 里用来实现控制和推送，近似地对应 HTTP/2 的 0 号流。</li>
<li>头部压缩算法在 HTTP/3 里升级成了“QPACK”，使用方式上也做了改变。虽然也分成静态表和动态表，但在流上发送 HEADERS 帧时不能更新字段，只能引用，索引表的更新需要在专门的单向流上发送指令来管理，解决了 HPACK 的“队头阻塞”问题。</li>
<li>另外，QPACK 的字典也做了优化，静态表由之前的 61 个增加到了 98 个，而且序号从 0 开始，也就是说“:authority”的编号是 0。</li>
</ul>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><ul>
<li>HTTP/3 基于 QUIC 协议，完全解决了“队头阻塞”问题，弱网环境下的表现会优于 HTTP/2；</li>
<li>QUIC 是一个新的传输层协议，建立在 UDP 之上，实现了可靠传输；</li>
<li>QUIC 内含了 TLS1.3，只能加密通信，支持 0-RTT 快速建连；</li>
<li>QUIC 的连接使用“不透明”的连接 ID，不绑定在“IP 地址 + 端口”上，支持“连接迁移”；</li>
<li>QUIC 的流与 HTTP/2 的流很相似，但分为双向流和单向流；</li>
<li>HTTP/3 没有指定默认端口号，需要用 HTTP/2 的扩展帧“Alt-Svc”来发现。</li>
</ul>
<h2 id="我应该迁移到HTTP-2吗？"><a href="#我应该迁移到HTTP-2吗？" class="headerlink" title="我应该迁移到HTTP/2吗？"></a>我应该迁移到HTTP/2吗？</h2><ul>
<li>HTTP/2 完全兼容 HTTP/1，是“更安全的 HTTP、更快的 HTTPS”，头部压缩、多路复用等技术可以充分利用带宽，降低延迟，从而大幅度提高上网体验；</li>
<li>TCP 协议存在“队头阻塞”，所以 HTTP/2 在弱网或者移动网络下的性能表现会不如 HTTP/1；</li>
<li>迁移到 HTTP/2 肯定会有性能提升，但高流量网站效果会更显著；</li>
<li>如果已经升级到了 HTTPS，那么再升级到 HTTP/2 会很简单；</li>
<li>TLS 协议提供“ALPN”扩展，让客户端和服务器协商使用的应用层协议，“发现”HTTP/2 服务。</li>
</ul>
<h2 id="Nginx：高性能的Web服务器"><a href="#Nginx：高性能的Web服务器" class="headerlink" title="Nginx：高性能的Web服务器"></a>Nginx：高性能的Web服务器</h2><ul>
<li>作为一个 Web 服务器，Nginx 的功能非常完善，完美支持 HTTP/1、HTTPS 和 HTTP/2，而且还在不断进步。当前的主线版本已经发展到了 1.17，正在进行 HTTP/3 的研发，或许一年之后就能在 Nginx 上跑 HTTP/3 了。<h3 id="进程池"><a href="#进程池" class="headerlink" title="进程池"></a>进程池</h3></li>
<li>Nginx 作为“轻量级”的服务器，它的 CPU、内存占用都非常少，同样的资源配置下就能够为更多的用户提供服务，其奥秘在于它独特的工作模式。</li>
<li>在 Nginx 之前，Web 服务器对每一个请求使用单独的进程或者线程处理。这就存在创建进程或线程的成本，还会有进程、线程“上下文切换”的额外开销。如果请求数量很多，CPU 就会在多个进程、线程之间切换时“疲于奔命”，平白地浪费了计算时间。</li>
<li>Nginx 则完全不同，“一反惯例”地没有使用多线程，而是使用了“进程池 + 单线程”的工作模式。</li>
<li>Nginx 在启动的时候会预先创建好固定数量的 worker 进程，在之后的运行过程中不会再 fork 出新进程，这就是进程池，而且可以自动把进程“绑定”到独立的 CPU 上，这样就完全消除了进程创建和切换的成本，能够充分利用多核 CPU 的计算能力。</li>
<li>在进程池之上，还有一个“master”进程，专门用来管理进程池。它的作用有点像是 supervisor（一个用 Python 编写的进程管理工具），用来监控进程，自动恢复发生异常的 worker，保持进程池的稳定和服务能力。<h3 id="I-O-多路复用"><a href="#I-O-多路复用" class="headerlink" title="I/O 多路复用"></a>I/O 多路复用</h3></li>
<li>使用多线程能够很容易实现并发处理,但多线程也有一些缺点，除了刚才说到的“上下文切换”成本，还有编程模型复杂、数据竞争、同步等问题，写出正确、快速的多线程程序并不是一件容易的事情。</li>
<li>所以 Nginx 就选择了单线程的方式，带来的好处就是开发简单，没有互斥锁的成本，减少系统消耗。</li>
<li>Web 服务器从根本上来说是“I/O 密集型”而不是“CPU 密集型”，处理能力的关键在于网络收发而不是 CPU 计算（这里暂时不考虑 HTTPS 的加解密），而网络 I/O 会因为各式各样的原因不得不等待，比如数据还没到达、对端没有响应、缓冲区满发不出去等等。</li>
<li>对于一般的单线程来说 CPU 就会“停下来”，造成浪费。而多线程的解决思路有点类似“并发连接”，虽然有的线程可能阻塞，但由于多个线程并行，总体上看阻塞的情况就不会太严重了。Nginx 里使用的 epoll，就好像是 HTTP/2 里的“多路复用”技术，它把多个 HTTP 请求处理打散成碎片，都“复用”到一个单线程里，不按照先来后到的顺序处理，而是只当连接上真正可读、可写的时候才处理，如果可能发生阻塞就立刻切换出去，处理其他的请求。通过这种方式，Nginx 就完全消除了 I/O 阻塞，把 CPU 利用得“满满当当”，又因为网络收发并不会消耗太多 CPU 计算能力，也不需要切换进程、线程，所以整体的 CPU 负载是相当低的。</li>
<li>epoll 还有一个特点，大量的连接管理工作都是在操作系统内核里做的，这就减轻了应用程序的负担，所以 Nginx 可以为每个连接只分配很小的内存维护状态，即使有几万、几十万的并发连接也只会消耗几百 M 内存，而其他的 Web 服务器这个时候早就“Memory not enough”了。<h3 id="多阶段处理"><a href="#多阶段处理" class="headerlink" title="多阶段处理"></a>多阶段处理</h3></li>
<li>Nginx 的 HTTP 处理有四大类模块：</li>
</ul>
<ol>
<li>handler 模块：直接处理 HTTP 请求；</li>
<li>filter 模块：不直接处理请求，而是加工过滤响应报文；</li>
<li>upstream 模块：实现反向代理功能，转发请求到其他服务器；</li>
<li>balance 模块：实现反向代理时的负载均衡算法。</li>
</ol>
<ul>
<li>charset 模块实现了字符集编码转换;chunked 模块实现了响应数据的分块传输；range 模块实现了范围请求，只返回数据的一部分；rewrite 模块实现了重定向和跳转，还可以使用内置变量自定义跳转的 URI；not_modified 模块检查头字段“if-Modified-Since”和“If-None-Match”，处理条件请求；ssl 模块实现了 SSL/TLS 协议支持，读取磁盘上的证书和私钥，实现 TLS 握手和 SNI、ALPN 等扩展功能；http_v2 模块实现了完整的 HTTP/2 协议。</li>
</ul>
<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><ul>
<li>Nginx 是一个高性能的 Web 服务器，它非常的轻量级，消耗的 CPU、内存很少；</li>
<li>Nginx 采用“master/workers”进程池架构，不使用多线程，消除了进程、线程切换的成本</li>
<li>Nginx 基于 epoll 实现了“I/O 多路复用”，不会阻塞，所以性能很高；</li>
<li>Nginx 使用了“职责链”模式，多个模块分工合作，自由组合，以流水线的方式处理 HTTP 请求。</li>
</ul>
<h2 id="OpenResty：更灵活的Web服务器"><a href="#OpenResty：更灵活的Web服务器" class="headerlink" title="OpenResty：更灵活的Web服务器"></a>OpenResty：更灵活的Web服务器</h2><ul>
<li>“一个人很难超越时代，而时代却可以轻易超越所有人”，Nginx 当初设计时针对的应用场景已经发生了变化，它的一些缺点也就暴露出来了。</li>
<li>Nginx 的服务管理思路延续了当时的流行做法，使用磁盘上的静态配置文件，所以每次修改后必须重启才能生效。这在业务频繁变动的时候是非常致命的（例如流行的微服务架构），特别是对于拥有成千上万台服务器的网站来说，仅仅增加或者删除一行配置就要分发、重启所有的机器，对运维是一个非常大的挑战，要耗费很多的时间和精力，成本很高，很不灵活，难以“随需应变”。</li>
<li>OpenResty 并不是一个全新的 Web 服务器，而是基于 Nginx，它利用了 Nginx 模块化、可扩展的特性，开发了一系列的增强模块，并把它们打包整合，形成了一个“一站式”的 Web 开发平台。</li>
<li>虽然 OpenResty 的核心是 Nginx，但它又超越了 Nginx，关键就在于其中的 ngx_lua 模块，把小巧灵活的 Lua 语言嵌入了 Nginx，可以用脚本的方式操作 Nginx 内部的进程、多路复用、阶段式处理等各种构件。<h3 id="动态的-Lua"><a href="#动态的-Lua" class="headerlink" title="动态的 Lua"></a>动态的 Lua</h3></li>
<li>OpenResty 里的一个关键模块是 ngx_lua，它为 Nginx 引入了脚本语言 Lua。</li>
<li>Lua 的设计目标是嵌入到其他应用程序里运行，为其他编程语言带来“脚本化”能力，所以它的“个头”比较小，功能集有限，不追求“大而全”，而是“小而美”，大多数时间都“隐匿”在其他应用程序的后面，是“无名英雄”。你或许玩过或者听说过《魔兽世界》《愤怒的小鸟》吧，它们就在内部嵌入了 Lua，使用 Lua 来调用底层接口，充当“胶水语言”（glue language），编写游戏逻辑脚本，提高开发效率。</li>
<li>作为脚本语言，Lua 还有一个重要的“代码热加载”特性，不需要重启进程，就能够从磁盘、Redis 或者任何其他地方加载数据，随时替换内存里的代码片段。这就带来了“动态配置”，让 OpenResty 能够永不停机，在微秒、毫秒级别实现配置和业务逻辑的实时更新，比起 Nginx 秒级的重启是一个极大的进步。<h3 id="高效率的-Lua"><a href="#高效率的-Lua" class="headerlink" title="高效率的 Lua"></a>高效率的 Lua</h3></li>
<li>OpenResty 能够高效运行的一大“秘技”是它的“同步非阻塞”编程范式，如果你要开发 OpenResty 应用就必须时刻铭记于心。“同步非阻塞”本质上还是一种“多路复用”</li>
<li>epoll 是操作系统级别的“多路复用”，运行在内核空间。而 OpenResty 的“同步非阻塞”则是基于 Lua 内建的“协程”，是应用程序级别的“多路复用”，运行在用户空间，所以它的资源消耗要更少。</li>
</ul>
<h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><ul>
<li>Nginx 依赖于磁盘上的静态配置文件，修改后必须重启才能生效，缺乏灵活性；</li>
<li>OpenResty 基于 Nginx，打包了很多有用的模块和库，是一个高性能的 Web 开发平台；</li>
<li>OpenResty 的工作语言是 Lua，它小巧灵活，执行效率高，支持“代码热加载”；</li>
<li>OpenResty 的核心编程范式是“同步非阻塞”，使用协程，不需要异步回调函数；</li>
<li>OpenResty 也使用“阶段式处理”的工作模式，但因为在阶段里执行的都是 Lua 代码，所以非常灵活，配合 Redis 等外部数据库能够实现各种动态配置。</li>
</ul>
<h2 id="WAF：保护我们的网络服务"><a href="#WAF：保护我们的网络服务" class="headerlink" title="WAF：保护我们的网络服务"></a>WAF：保护我们的网络服务</h2><h3 id="Web-服务遇到的威胁"><a href="#Web-服务遇到的威胁" class="headerlink" title="Web 服务遇到的威胁"></a>Web 服务遇到的威胁</h3><ul>
<li><p>第一种叫“DDoS”攻击（distributed denial-of-service attack），有时候也叫“洪水攻击”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">黑客会控制许多“僵尸”计算机，向目标服务器发起大量无效请求。</span><br><span class="line">因为服务器无法区分正常用户和黑客，只能“照单全收”，这样就挤占了正常用户所应有的资源。</span><br><span class="line">如果黑客的攻击强度很大，就会像“洪水”一样对网站的服务能力造成冲击，耗尽带宽、CPU 和内存，导致网站完全无法提供正常服务。</span><br></pre></td></tr></table></figure>
</li>
<li><p>“SQL 注入”（SQL injection）应该算是最著名的一种“代码注入”攻击了，它利用了服务器字符串拼接形成 SQL 语句的漏洞，构造出非正常的 SQL 语句，获取数据库内部的敏感信息。</p>
</li>
<li>另一种“HTTP 头注入”攻击的方式也是类似的原理，它在“Host”“User-Agent”“X-Forwarded-For”等字段里加入了恶意数据或代码，服务端程序如果解析不当，就会执行预设的恶意代码。</li>
<li>利用 Cookie 的攻击手段，“跨站脚本”（XSS）攻击，它属于“JS 代码注入”，利用 JavaScript 脚本获取未设防的 Cookie。</li>
</ul>
<h3 id="网络应用防火墙"><a href="#网络应用防火墙" class="headerlink" title="网络应用防火墙"></a>网络应用防火墙</h3><ul>
<li>传统“防火墙”工作在三层或者四层，隔离了外网和内网，使用预设的规则，只允许某些特定 IP 地址和端口号的数据包通过，拒绝不符合条件的数据流入或流出内网，实质上是一种网络数据过滤设备。</li>
<li>WAF 也是一种“防火墙”，但它工作在七层，看到的不仅是 IP 地址和端口号，还能看到整个 HTTP 报文，所以就能够对报文内容做更深入细致的审核，使用更复杂的条件、规则来过滤数据。说白了，WAF 就是一种“HTTP 入侵检测和防御系统”。</li>
<li>通常一款产品能够称为 WAF，要具备下面的一些功能：</li>
</ul>
<ol>
<li>IP 黑名单和白名单，拒绝黑名单上地址的访问，或者只允许白名单上的用户访问；</li>
<li>URI 黑名单和白名单，与 IP 黑白名单类似，允许或禁止对某些 URI 的访问；</li>
<li>防护 DDoS 攻击，对特定的 IP 地址限连限速；</li>
<li>过滤请求报文，防御“代码注入”攻击；</li>
<li>过滤响应报文，防御敏感信息外泄；</li>
<li>审计日志，记录所有检测到的入侵操作。</li>
</ol>
<ul>
<li>在网络安全领域必须时刻记得“木桶效应”（也叫“短板效应”）。网站的整体安全不在于你加固的最强的那个方向，而是在于你可能都没有意识到的“短板”。黑客往往会“避重就轻”，只要发现了网站的一个弱点，就可以“一点突破”，其他方面的安全措施也就都成了“无用功”。</li>
</ul>
<h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><ul>
<li>Web 服务通常都运行在公网上，容易受到“DDoS”、“代码注入”等各种黑客攻击，影响正常的服务，所以必须要采取措施加以保护；</li>
<li>WAF 是一种“HTTP 入侵检测和防御系统”，工作在七层，为 Web 服务提供全面的防护；</li>
<li>ModSecurity 是一个开源的、生产级的 WAF 产品，核心组成部分是“规则引擎”和“规则集”，两者的关系有点像杀毒引擎和病毒特征库；</li>
<li>WAF 实质上是模式匹配与数据过滤，所以会消耗 CPU，增加一些计算成本，降低服务能力，使用时需要在安全与性能之间找到一个“平衡点”。</li>
</ul>
<h2 id="CDN：加速我们的网络服务"><a href="#CDN：加速我们的网络服务" class="headerlink" title="CDN：加速我们的网络服务"></a>CDN：加速我们的网络服务</h2><h3 id="什么是-CDN？"><a href="#什么是-CDN？" class="headerlink" title="什么是 CDN？"></a>什么是 CDN？</h3><ul>
<li>CDN 有三个关键词：“内容”“分发”和“网络”。CDN 的最核心原则是“就近访问”，如果用户能够在本地几十公里的距离之内获取到数据，那么时延就基本上变成 0 了。</li>
<li>缓存代理”技术。使用“推”或者“拉”的手段，把源站的内容逐级缓存到网络的每一个节点上。</li>
<li>用户在上网的时候就不直接访问源站，而是访问离他“最近的”一个 CDN 节点，术语叫“边缘节点”（edge node），其实就是缓存了源站内容的代理服务器，这样一来就省去了“长途跋涉”的时间成本，实现了“网络加速”。</li>
<li>套用一句广告词来形容 CDN 吧，我觉得非常恰当：“我们不生产内容，我们只是内容的搬运工。”CDN，正是把“数据传输”这件看似简单的事情“做大做强”“做专做精”，就像专门的快递公司一样，在互联网世界里实现了它的价值。<h3 id="CDN-的负载均衡"><a href="#CDN-的负载均衡" class="headerlink" title="CDN 的负载均衡"></a>CDN 的负载均衡</h3></li>
<li>它有两个关键组成部分：全局负载均衡和缓存系统，对应的是 DNS和缓存代理技术。</li>
<li>全局负载均衡（Global Sever Load Balance）一般简称为 GSLB，它是 CDN 的“大脑”，主要的职责是当用户接入网络的时候在 CDN 专网中挑选出一个“最佳”节点提供服务，解决的是用户如何找到“最近的”边缘节点，对整个 CDN 网络进行“负载均衡”。GSLB 最常见的实现方式是“DNS 负载均衡”</li>
<li>CDN 的全局负载均衡系统，“智能调度”，主要的依据有这么几个：</li>
</ul>
<ol>
<li>看用户的 IP 地址，查表得知地理位置，找相对最近的边缘节点；</li>
<li>看用户所在的运营商网络，找相同网络的边缘节点；</li>
<li>检查边缘节点的负载情况，找负载较轻的节点；</li>
<li>其他，比如节点的“健康状况”、服务能力、带宽、响应时间等。</li>
</ol>
<h3 id="CDN-的缓存代理"><a href="#CDN-的缓存代理" class="headerlink" title="CDN 的缓存代理"></a>CDN 的缓存代理</h3><ul>
<li>缓存系统是 CDN 的另一个关键组成部分，相当于 CDN 的“心脏”。如果缓存系统的服务能力不够，不能很好地满足用户的需求，那 GSLB 调度算法再优秀也没有用。</li>
<li>两个 CDN 的关键概念：“命中”和“回源”。“命中”就是指用户访问的资源恰好在缓存系统里，可以直接返回给用户；“回源”则正相反，缓存里没有，必须用代理的方式回源站取。</li>
<li>相应地，也就有了两个衡量 CDN 服务质量的指标：“命中率”和“回源率”。命中率就是命中次数与所有访问次数之比，回源率是回源次数与所有访问次数之比。显然，好的 CDN 应该是命中率越高越好，回源率越低越好。现在的商业 CDN 命中率都在 90% 以上，相当于把源站的服务能力放大了 10 倍以上。</li>
</ul>
<h2 id="WebSocket：沙盒里的TCP"><a href="#WebSocket：沙盒里的TCP" class="headerlink" title="WebSocket：沙盒里的TCP"></a>WebSocket：沙盒里的TCP</h2><ul>
<li>“WebSocket”是一种基于 TCP 的轻量级网络通信协议，在地位上是与 HTTP“平级”的。</li>
</ul>
<h3 id="为什么要有-WebSocket"><a href="#为什么要有-WebSocket" class="headerlink" title="为什么要有 WebSocket"></a>为什么要有 WebSocket</h3><ul>
<li>WebSocket 与 HTTP/2 一样，都是为了解决 HTTP 某方面的缺陷而诞生的。HTTP/2 针对的是“队头阻塞”，而 WebSocket 针对的是“请求 - 应答”通信模式。</li>
<li>“请求 - 应答”是一种“半双工”的通信模式，虽然可以双向收发数据，但同一时刻只能一个方向上有动作，传输效率低。更关键的一点，它是一种“被动”通信模式，服务器只能“被动”响应客户端的请求，无法主动向客户端发送数据。</li>
<li>虽然后来的 HTTP/2、HTTP/3 新增了 Stream、Server Push 等特性，但“请求 - 应答”依然是主要的工作方式。这就导致 HTTP 难以应用在动态页面、即时消息、网络游戏等要求“实时通信”的领域。<h3 id="WebSocket-的特点"><a href="#WebSocket-的特点" class="headerlink" title="WebSocket 的特点"></a>WebSocket 的特点</h3></li>
<li>WebSocket 是一个真正“全双工”的通信协议，与 TCP 一样，客户端和服务器都可以随时向对方发送数据，而不用像 HTTP“你拍一，我拍一”那么“客套”。</li>
<li>WebSocket 采用了二进制帧结构，语法、语义与 HTTP 完全不兼容，但因为它的主要运行环境是浏览器，为了便于推广和应用，就不得不“搭便车”，在使用习惯上尽量向 HTTP 靠拢，这就是它名字里“Web”的含义。</li>
<li>服务发现方面，WebSocket 没有使用 TCP 的“IP 地址 + 端口号”，而是延用了 HTTP 的 URI 格式，但开头的协议名不是“http”，引入的是两个新的名字：“ws”和“wss”，分别表示明文和加密的 WebSocket 协议。</li>
<li>WebSocket 的默认端口也选择了 80 和 443，因为现在互联网上的防火墙屏蔽了绝大多数的端口，只对 HTTP 的 80、443 端口“放行”，所以 WebSocket 就可以“伪装”成 HTTP 协议，比较容易地“穿透”防火墙，与服务器建立连接。<h3 id="WebSocket-的帧结构"><a href="#WebSocket-的帧结构" class="headerlink" title="WebSocket 的帧结构"></a>WebSocket 的帧结构</h3></li>
<li>不过 WebSocket 和 HTTP/2 的关注点不同，WebSocket 更侧重于“实时通信”，而 HTTP/2 更侧重于提高传输效率，所以两者的帧结构也有很大的区别。</li>
<li>WebSocket 虽然有“帧”，但却没有像 HTTP/2 那样定义“流”，也就不存在“多路复用”“优先级”等复杂的特性，而它自身就是“全双工”的，也就不需要“服务器推送”。所以综合起来，WebSocket 的帧学习起来会简单一些。<h3 id="WebSocket-的握手"><a href="#WebSocket-的握手" class="headerlink" title="WebSocket 的握手"></a>WebSocket 的握手</h3></li>
<li>和 TCP、TLS 一样，WebSocket 也要有一个握手过程，然后才能正式收发数据。</li>
<li>WebSocket 的握手是一个标准的 HTTP GET 请求，但要带上两个协议升级的专用头字段：“Connection: Upgrade”，表示要求协议“升级”；“Upgrade: websocket”，表示要“升级”成 WebSocket 协议。</li>
<li>另外，为了防止普通的 HTTP 消息被“意外”识别成 WebSocket，握手消息还增加了两个额外的认证用头字段（所谓的“挑战”，Challenge）：Sec-WebSocket-Key：一个 Base64 编码的 16 字节随机数，作为简单的认证密钥；Sec-WebSocket-Version：协议的版本号，当前必须是 13。</li>
<li>服务器收到 HTTP 请求报文，看到上面的四个字段，就知道这不是一个普通的 GET 请求，而是 WebSocket 的升级请求，于是就不走普通的 HTTP 处理流程，而是构造一个特殊的“101 Switching Protocols”响应报文，通知客户端，接下来就不用 HTTP 了，全改用 WebSocket 协议通信。（有点像 TLS 的“Change Cipher Spec”）</li>
<li>WebSocket 的握手响应报文也是有特殊格式的，要用字段“Sec-WebSocket-Accept”验证客户端请求报文，同样也是为了防止误连接。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">encode_base64(</span><br><span class="line">  sha1( </span><br><span class="line">    Sec-WebSocket-Key + &apos;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&apos; ))</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h3><ul>
<li>HTTP 的“请求 - 应答”模式不适合开发“实时通信”应用，效率低，难以实现动态页面，所以出现了 WebSocket；</li>
<li>WebSocket 是一个“全双工”的通信协议，相当于对 TCP 做了一层“薄薄的包装”，让它运行在浏览器环境里；</li>
<li>WebSocket 使用兼容 HTTP 的 URI 来发现服务，但定义了新的协议名“ws”和“wss”，端口号也沿用了 80 和 443；</li>
<li>WebSocket 使用二进制帧，结构比较简单，特殊的地方是有个“掩码”操作，客户端发数据必须掩码，服务器则不用；</li>
<li>WebSocket 利用 HTTP 协议实现连接握手，发送 GET 请求要求“协议升级”，握手过程中有个非常简单的认证机制，目的是防止误连接。</li>
</ul>
<h2 id="HTTP性能优化面面观（上）"><a href="#HTTP性能优化面面观（上）" class="headerlink" title="HTTP性能优化面面观（上）"></a>HTTP性能优化面面观（上）</h2><h3 id="HTTP-服务器"><a href="#HTTP-服务器" class="headerlink" title="HTTP 服务器"></a>HTTP 服务器</h3><ul>
<li>衡量服务器性能的主要指标有三个：吞吐量（requests per second）、并发数（concurrency）和响应时间（time per request）。除了上面的三个基本性能指标，服务器还要考虑 CPU、内存、硬盘和网卡等系统资源的占用程度，利用率过高或者过低都可能有问题。</li>
</ul>
<ol>
<li>吞吐量就是我们常说的 RPS，每秒的请求次数，也有叫 TPS、QPS，它是服务器最基本的性能指标，RPS 越高就说明服务器的性能越好。</li>
<li>并发数反映的是服务器的负载能力，也就是服务器能够同时支持的客户端数量，当然也是越多越好，能够服务更多的用户。</li>
<li>响应时间反映的是服务器的处理能力，也就是快慢程度，响应时间越短，单位时间内服务器就能够给越多的用户提供服务，提高吞吐量和并发数。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">在 Linux 上，最常用的性能测试工具可能就是 ab（Apache Bench）了，比如，下面的命令指定了并发数 100，总共发送 10000 个请求：</span><br><span class="line"></span><br><span class="line">ab -c 100 -n 10000 &apos;http://www.xxx.com&apos;</span><br><span class="line"></span><br><span class="line">系统资源监控方面，Linux 自带的工具也非常多，常用的有 uptime、top、vmstat、netstat、sar 等等，可能你比我还要熟悉，我就列几个简单的例子吧：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">top             #查看CPU和内存占用情况</span><br><span class="line">vmstat  2       #每2秒检查一次系统状态</span><br><span class="line">sar -n DEV 2    #看所有网卡的流量，定时2秒检查</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="HTTP-客户端"><a href="#HTTP-客户端" class="headerlink" title="HTTP 客户端"></a>HTTP 客户端</h3><ul>
<li>客户端是信息的消费者，一切数据都要通过网络从服务器获取，所以它最基本的性能指标就是“延迟”（latency）。所谓的“延迟”其实就是“等待”，等待数据到达客户端时所花费的时间。但因为 HTTP 的传输链路很复杂，所以延迟的原因也就多种多样。</li>
</ul>
<ol>
<li>首先，我们必须谨记有一个“不可逾越”的障碍——光速，因为地理距离而导致的延迟是无法克服的，访问数千公里外的网站显然会有更大的延迟。</li>
<li>其次，第二个因素是带宽，它又包括接入互联网时的电缆、WiFi、4G 和运营商内部网络、运营商之间网络的各种带宽，每一处都有可能成为数据传输的瓶颈，降低传输速度，增加延迟。</li>
<li>第三个因素是 DNS 查询，如果域名在本地没有缓存，就必须向 DNS 系统发起查询，引发一连串的网络通信成本，而在获取 IP 地址之前客户端只能等待，无法访问网站。</li>
<li>第四个因素是 TCP 握手，你应该对它比较熟悉了吧，必须要经过 SYN、SYN/ACK、ACK 三个包之后才能建立连接，它带来的延迟由光速和带宽共同决定。</li>
<li>建立 TCP 连接之后，就是正常的数据收发了，后面还有解析 HTML、执行 JavaScript、排版渲染等等，这些也会耗费一些时间。不过它们已经不属于 HTTP 了，所以不在今天的讨论范围之内。</li>
</ol>
<ul>
<li>因为有“队头阻塞”，浏览器对每个域名最多开 6 个并发连接（HTTP/1.1），当页面里链接很多的时候就必须排队等待（Queued、Queueing）</li>
<li>浏览器要预先分配资源，调度连接</li>
<li>连接前必须要解析域名</li>
<li>与网站服务器建立连接的成本很高</li>
<li>实际发送数据非常快</li>
<li>之后就是等待服务器的响应，专有名词叫 TTFB（Time To First Byte），也就是“首字节响应时间”，里面包括了服务器的处理时间和网络传输时间</li>
<li>接收数据也是非常快的</li>
</ul>
<h3 id="HTTP-传输链路"><a href="#HTTP-传输链路" class="headerlink" title="HTTP 传输链路"></a>HTTP 传输链路</h3><ul>
<li>“第一公里”是指网站的出口，也就是服务器接入互联网的传输线路，它的带宽直接决定了网站对外的服务能力，也就是吞吐量等指标。显然，优化性能应该在这“第一公里”加大投入，尽量购买大带宽，接入更多的运营商网络。</li>
<li>“中间一公里”就是由许多小网络组成的实际的互联网，其实它远不止“一公里”，而是非常非常庞大和复杂的网络，地理距离、网络互通都严重影响了传输速度。好在这里面有一个 HTTP 的“好帮手”——CDN，它可以帮助网站跨越“千山万水”，让这段距离看起来真的就好像只有“一公里”。</li>
<li>“最后一公里”是用户访问互联网的入口，对于固网用户就是光纤、网线，对于移动用户就是 WiFi、基站。以前它是客户端性能的主要瓶颈，延迟大带宽小，但随着近几年 4G 和高速宽带的普及，“最后一公里”的情况已经好了很多，不再是制约性能的主要因素了。</li>
</ul>
<h3 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h3><ul>
<li>性能优化是一个复杂的概念，在 HTTP 里可以分解为服务器性能优化、客户端性能优化和传输链路优化；</li>
<li>服务器有三个主要的性能指标：吞吐量、并发数和响应时间，此外还需要考虑资源利用率；</li>
<li>客户端的基本性能指标是延迟，影响因素有地理距离、带宽、DNS 查询、TCP 握手等；</li>
<li>从服务器到客户端的传输链路可以分为三个部分，我们能够优化的是前两个部分，也就是“第一公里”和“中间一公里”；</li>
<li>有很多工具可以测量这些指标，服务器端有 ab、top、sar 等，客户端可以使用测试网站，浏览器的开发者工具。</li>
</ul>
<h2 id="HTTP性能优化面面观（下）"><a href="#HTTP性能优化面面观（下）" class="headerlink" title="HTTP性能优化面面观（下）"></a>HTTP性能优化面面观（下）</h2><ul>
<li>总的来说，任何计算机系统的优化都可以分成这么几类：硬件软件、内部外部、花钱不花钱。</li>
<li>投资购买现成的硬件最简单的优化方式，比如换上更强的 CPU、更快的网卡、更大的带宽、更多的服务器，效果也会“立竿见影”，直接提升网站的服务能力，也就实现了 HTTP 优化。</li>
<li>另外，花钱购买外部的软件或者服务也是一种行之有效的优化方式，最“物有所值”的应该算是 CDN 了。CDN 专注于网络内容交付，帮助网站解决“中间一公里”的问题，还有很多其他非常专业的优化功能。把网站交给 CDN 运营，就好像是“让网站坐上了喷气飞机”，能够直达用户，几乎不需要费什么力气就能够达成很好的优化效果。</li>
<li>不过这些“花钱”的手段实在是太没有“技术含量”了，属于“懒人”（无贬义）的做法。<h3 id="开源"><a href="#开源" class="headerlink" title="开源"></a>开源</h3></li>
<li>这个“开源”可不是 Open Source，而是指抓“源头”，开发网站服务器自身的潜力，在现有条件不变的情况下尽量挖掘出更多的服务能力。</li>
<li>首先，我们应该选用高性能的 Web 服务器，最佳选择当然就是 Nginx/OpenResty 了，尽量不要选择基于 Java、Python、Ruby 的其他服务器，它们用来做后面的业务逻辑服务器更好。利用 Nginx 强大的反向代理能力实现“动静分离”，动态页面交给 Tomcat、Django、Rails，图片、样式表等静态资源交给 Nginx。</li>
<li>Nginx 或者 OpenResty 自身也有很多配置参数可以用来进一步调优，举几个例子，比如说禁用负载均衡锁、增大连接池，绑定 CPU 等等，相关的资料有很多。</li>
<li>对于 HTTP 协议一定要启用长连接。TCP 和 SSL 建立新连接的成本是非常高的，有可能会占到客户端总延迟的一半以上。长连接虽然不能优化连接握手，但可以把成本“均摊”到多次请求里，这样只有第一次请求会有延迟，之后的请求就不会有连接延迟，总体的延迟也就降低了。</li>
<li>在现代操作系统上都已经支持 TCP 的新特性“TCP Fast Open”（Win10、iOS9、Linux 4.1），它的效果类似 TLS 的“False Start”，可以在初次握手的时候就传输数据，也就是 0-RTT，所以我们应该尽可能在操作系统和 Nginx 里开启这个特性，减少外网和内网里的握手延迟。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">下面给出一个简短的 Nginx 配置示例，启用了长连接等优化参数，实现了动静分离。</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen 80 deferred reuseport backlog=4096 fastopen=1024; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  keepalive_timeout  60;</span><br><span class="line">  keepalive_requests 10000;</span><br><span class="line">  </span><br><span class="line">  location ~* \.(png)$ &#123;</span><br><span class="line">    root /var/images/png/;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  location ~* \.(php)$ &#123;</span><br><span class="line">    proxy_pass http://php_back_end;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><ul>
<li>“节流”是指减少客户端和服务器之间收发的数据量，在有限的带宽里传输更多的内容。</li>
<li>“节流”最基本的做法就是使用 HTTP 协议内置的“数据压缩”编码，不仅可以选择标准的 gzip，还可以积极尝试新的压缩算法 br，它有更好的压缩效果。</li>
<li>不过在数据压缩的时候应当注意选择适当的压缩率，不要追求最高压缩比，否则会耗费服务器的计算资源，增加响应时间，降低服务能力，反而会“得不偿失”。</li>
<li>HTML/CSS/JavaScript 属于纯文本，就可以采用特殊的“压缩”，去掉源码里多余的空格、换行、注释等元素。这样“压缩”之后的文本虽然看起来很混乱，对“人类”不友好，但计算机仍然能够毫无障碍地阅读，不影响浏览器上的运行效果。</li>
<li>图片在 HTTP 传输里占有非常高的比例，虽然它本身已经被压缩过了，不能被 gzip、br 处理，但仍然有优化的空间。比如说，去除图片里的拍摄时间、地点、机型等元数据，适当降低分辨率，缩小尺寸。图片的格式也很关键，尽量选择高压缩率的格式，有损格式应该用 JPEG，无损格式应该用 Webp 格式。</li>
<li>对于小文本或者小图片，还有一种叫做“资源合并”（Concatenation）的优化方式，就是把许多小资源合并成一个大资源，用一个请求全下载到客户端，然后客户端再用 JavaScript、CSS 切分后使用，好处是节省了请求次数，但缺点是处理比较麻烦。</li>
<li>刚才说的几种数据压缩针对的都是 HTTP 报文里的 body，在 HTTP/1 里没有办法可以压缩 header，但我们也可以采取一些手段来减少 header 的大小，不必要的字段就尽量不发（例如 Server、X-Powered-By）。</li>
<li>网站经常会使用 Cookie 来记录用户的数据，浏览器访问网站时每次都会带上 Cookie，冗余度很高。所以应当少使用 Cookie，减少 Cookie 记录的数据量，总使用 domain 和 path 属性限定 Cookie 的作用域，尽可能减少 Cookie 的传输。如果客户端是现代浏览器，还可以使用 HTML5 里定义的 Web Local Storage，避免使用 Cookie。</li>
<li>DNS 解析域名会耗费不少的时间，如果网站拥有多个域名，那么域名解析获取 IP 地址就是一个不小的成本，所以应当适当“收缩”域名，限制在两三个左右，减少解析完整域名所需的时间，让客户端尽快从系统缓存里获取解析结果。</li>
<li>重定向引发的客户端延迟也很高，它不仅增加了一次请求往返，还有可能导致新域名的 DNS 解析，是 HTTP 前端性能优化的“大忌”。除非必要，应当尽量不使用重定向，或者使用 Web 服务器的“内部重定向”。<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3></li>
<li>它不仅是 HTTP，也是任何计算机系统性能优化的“法宝”，把它和上面的“开源”“节流”搭配起来应用于传输链路，就能够让 HTTP 的性能再上一个台阶。</li>
<li>利用好缓存功能的关键是理解它的工作原理，为每个资源都添加 ETag 和 Last-modified 字段，再用 Cache-Control、Expires 设置好缓存控制属性。</li>
<li>其中最基本的是 max-age 有效期，标记资源可缓存的时间。对于图片、CSS 等静态资源可以设置较长的时间，比如一天或者一个月，对于动态资源，除非是实时性非常高，也可以设置一个较短的时间，比如 1 秒或者 5 秒。</li>
<li>这样一旦资源到达客户端，就会被缓存起来，在有效期内都不会再向服务器发送请求，也就是：“没有请求的请求，才是最快的请求。”</li>
</ul>
<h3 id="HTTP-2-1"><a href="#HTTP-2-1" class="headerlink" title="HTTP/2"></a>HTTP/2</h3><ul>
<li>HTTP 性能优化还有一个选择，那就是把协议由 HTTP/1 升级到 HTTP/2。</li>
<li>你已经知道了 HTTP/2 的很多优点，它消除了应用层的队头阻塞，拥有头部压缩、二进制帧、多路复用、流量控制、服务器推送等许多新特性，大幅度提升了 HTTP 的传输效率。</li>
<li>对于 HTTP/2 来说，一个域名使用一个 TCP 连接才能够获得最佳性能，如果开多个域名，就会浪费带宽和服务器资源，也会降低 HTTP/2 的效率，所以“域名收缩”在 HTTP/2 里是必须要做的。</li>
<li>“资源合并”在 HTTP/1 里减少了多次请求的成本，但在 HTTP/2 里因为有头部压缩和多路复用，传输小文件的成本很低，所以合并就失去了意义。而且“资源合并”还有一个缺点，就是降低了缓存的可用性，只要一个小文件更新，整个缓存就完全失效，必须重新下载。</li>
<li>所以在现在的大带宽和 CDN 应用场景下，应当尽量少用资源合并（JavaScript、CSS 图片合并，数据内嵌），让资源的粒度尽可能地小，才能更好地发挥缓存的作用。</li>
</ul>
<h3 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h3><ul>
<li>花钱购买硬件、软件或者服务可以直接提升网站的服务能力，其中最有价值的是 CDN；</li>
<li>不花钱也可以优化 HTTP，三个关键词是“开源”“节流”和“缓存”；</li>
<li>后端应该选用高性能的 Web 服务器，开启长连接，提升 TCP 的传输效率；</li>
<li>前端应该启用 gzip、br 压缩，减小文本、图片的体积，尽量少传不必要的头字段；</li>
<li>缓存是无论何时都不能忘记的性能优化利器，应该总使用 Etag 或 Last-modified 字段标记资源；</li>
<li>升级到 HTTP/2 能够直接获得许多方面的性能提升，但要留意一些 HTTP/1 的“反模式”。</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/学习/">学习</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/学习/">学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网站/">网站</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/资源/">资源</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-algorithm" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2021/03/29/algorithm/" class="article-date">
      <time datetime="2021-03-28T16:00:00.000Z" itemprop="datePublished">2021-03-29</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/29/algorithm/">算法</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>/*<em>
 </em>假设有任意多张面额为 2 元、3 元、7 元的货币，现要用它们凑出 100 元，求总共有多少种可能性。<br> */<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function test1() &#123;</span><br><span class="line">  let count = 0;</span><br><span class="line">  for (let i = 0; i &lt;= 100 / 7; i++) &#123;</span><br><span class="line">    //这里针对j可以优化一波</span><br><span class="line">    for (let j = 0; j &lt;= 100 / 3; j++) &#123;</span><br><span class="line">      if (100 - i * 7 - j * 3 &gt;= 0 &amp;&amp; (100 - i * 7 - j * 3) % 2 == 0) &#123;</span><br><span class="line">        count += 1;</span><br><span class="line">        console.log(</span><br><span class="line">          `$&#123;count&#125;:7元:$&#123;i&#125;张,3元:$&#123;j&#125;张,2元:$&#123;(100 - i * 7 - j * 3) / 2&#125;张`</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(`一共有$&#123;count&#125;种可能性`);</span><br><span class="line">&#125;</span><br><span class="line">//test1();</span><br></pre></td></tr></table></figure></p>
<p>/**</p>
<ul>
<li>查找出一个数组中，出现次数最多的那个元素的数值。</li>
<li>例如，输入数组 a = [1,2,3,4,5,5,6 ] 中，查找出现次数最多的数值。</li>
<li>从数组中可以看出，只有 5 出现了 2 次，其余都是 1 次。显然 5 出现的次数最多，则输出 5。<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function test2(arr) &#123;</span><br><span class="line">  //记录数组元素出现次数  采用map数据结构，查找的时间复杂度是o(1)</span><br><span class="line">  let res = new Map();</span><br><span class="line">  //出现最多次数</span><br><span class="line">  let max = -1;</span><br><span class="line">  for (let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">    if (res.has(arr[i])) &#123;</span><br><span class="line">      res.set(arr[i], res.get(arr[i]) + 1);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      res.set(arr[i], 1);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  //获取出现次数的最大值</span><br><span class="line">  max = Math.max.apply(null, [...res.values()]);</span><br><span class="line">  for (let [key, value] of res) &#123;</span><br><span class="line">    if (value === max) console.log(`$&#123;key&#125;出现的次数最多，出现了$&#123;value&#125;次`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//test2([1, 2, 3, 4, 5, 5, 6]);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</li>
<li>有效字符串需满足：左括号必须与相同类型的右括号匹配，左括号必须以正确的顺序匹配。</li>
<li>例如，{ [ ( ) ( ) ] } 是合法的，而 { ( [ ) ] } 是非法的。</li>
<li>思路：</li>
<li>从左到右顺序遍历字符串。</li>
<li>当出现左括号时，压栈。</li>
<li>当出现右括号时，出栈。</li>
<li>并且判断当前右括号，和被出栈的左括号是否是互相匹配的一对。</li>
<li>如果不是，则字符串非法。当遍历完成之后，如果栈为空。则合法。<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function test3(data) &#123;</span><br><span class="line">  //左括号</span><br><span class="line">  const typesLeft = [&quot;(&quot;, &quot;[&quot;, &quot;&#123;&quot;];</span><br><span class="line">  //右括号</span><br><span class="line">  const typesRight = [&quot;)&quot;, &quot;]&quot;, &quot;&#125;&quot;];</span><br><span class="line">  //括号</span><br><span class="line">  const types = [&quot;()&quot;, &quot;[]&quot;, &quot;&#123;&#125;&quot;];</span><br><span class="line"></span><br><span class="line">  //存储 模拟栈</span><br><span class="line">  const store = [];</span><br><span class="line"></span><br><span class="line">  for (let type of data) &#123;</span><br><span class="line">      //匹配到左括号时，进行入栈操作</span><br><span class="line">    if (typesLeft.includes(type)) &#123;</span><br><span class="line">      store.push(type);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      //匹配到右括号时，进行出栈操作，检验当前括号是否合法</span><br><span class="line">      const left = store.pop();</span><br><span class="line">      if (!types.includes(`$&#123;left&#125;$&#123;type&#125;`)) &#123;</span><br><span class="line">        console.log(&quot;非法字符串&quot;);</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//test3([&apos;(&apos;,&apos;&#123;&apos;,&apos;&#125;&apos;,&apos;&#125;&apos;,&apos;)&apos;])</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>约瑟夫环是一个数学的应用问题，具体为，已知 n 个人（以编号 1，2，3…n 分别表示）围坐在一张圆桌周围。</li>
<li>从编号为 k 的人开始报数，数到 m 的那个人出列；</li>
<li>他的下一个人又从 1 开始报数，数到 m 的那个人又出列；</li>
<li>依此规律重复下去，直到圆桌周围的人全部出列。</li>
<li>这个问题的输入变量就是 n 和 m，即 n 个人和数到 m 的出列的人。输出的结果，就是 n 个人出列的顺序。</li>
<li>这个问题，用队列的方法实现是个不错的选择。它的结果就是出列的顺序，恰好满足队列对处理顺序敏感的前提。因此，求解方式也是基于队列的先进先出原则。</li>
<li>解法如下：</li>
<li>先把所有人都放入循环队列中。注意这个循环队列的长度要大于或者等于 n。</li>
<li>从第一个人开始依次出队列，出队列一次则计数变量 i 自增。如果 i 比 m 小，则还需要再入队列。</li>
<li>直到i等于 m 的人出队列时，就不用再让这个人进队列了。而是放入一个用来记录出队列顺序的数组中。</li>
<li>直到数完 n 个人为止。当队列为空时，则表示队列中的 n 个人都出队列了，这时结束队列循环，输出数组内记录的元素。<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">//n个人，从编号为k的人开始报数，</span><br><span class="line">function test4(persons, k, m) &#123;</span><br><span class="line">  //退出的人</span><br><span class="line">  const exitPersons = [];</span><br><span class="line">  //计数器</span><br><span class="line">  let count = 1;</span><br><span class="line"></span><br><span class="line">  //第一次</span><br><span class="line">  for (let &#123; name, num &#125; of persons) &#123;</span><br><span class="line">    if (num &lt; k) &#123;</span><br><span class="line">      persons.shift();</span><br><span class="line">      persons.push(&#123;</span><br><span class="line">        name,</span><br><span class="line">        num,</span><br><span class="line">      &#125;);</span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br><span class="line">    break;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //还有人时</span><br><span class="line">  while (persons.length) &#123;</span><br><span class="line">    const person = persons.shift();</span><br><span class="line">    if (count &lt; m) &#123;</span><br><span class="line">      persons.push(person);</span><br><span class="line">      count++;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      //找到目标后，重置计数器</span><br><span class="line">      count = 1;</span><br><span class="line">      exitPersons.push(person);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  //console.log(exitPersons);</span><br><span class="line">&#125;</span><br><span class="line">// test4(</span><br><span class="line">//   [</span><br><span class="line">//     &#123; name: &quot;赵一&quot;, num: 1 &#125;,</span><br><span class="line">//     &#123; name: &quot;钱二&quot;, num: 2 &#125;,</span><br><span class="line">//     &#123; name: &quot;孙三&quot;, num: 3 &#125;,</span><br><span class="line">//     &#123; name: &quot;李四&quot;, num: 4 &#125;,</span><br><span class="line">//     &#123; name: &quot;周五&quot;, num: 5 &#125;,</span><br><span class="line">//     &#123; name: &quot;吴六&quot;, num: 6 &#125;,</span><br><span class="line">//     &#123; name: &quot;郑七&quot;, num: 7 &#125;,</span><br><span class="line">//     &#123; name: &quot;王八&quot;, num: 8 &#125;,</span><br><span class="line">//   ],</span><br><span class="line">//   2,</span><br><span class="line">//   4</span><br><span class="line">// );</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>10</li>
<li>/  \</li>
<li>8   12</li>
<li>/ \  / \</li>
<li>6   9 11 13</li>
<li>给定一棵树，按照层次顺序遍历并打印这棵树。<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">const root = &#123;</span><br><span class="line">  value: 10,</span><br><span class="line">  left: &#123; value: 8, left: &#123; value: 6 &#125;, right: &#123; value: 9 &#125; &#125;,</span><br><span class="line">  right: &#123; value: 12, left: &#123; value: 11 &#125;, right: &#123; value: 13 &#125; &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">function test5(root) &#123;</span><br><span class="line">  //模拟队列</span><br><span class="line">  const queue = [];</span><br><span class="line">  //根节点入队列</span><br><span class="line">  queue.push(root);</span><br><span class="line">  while (queue.length) &#123;</span><br><span class="line">    //当前节点</span><br><span class="line">    const current = queue.shift();</span><br><span class="line">    console.log(current.value);</span><br><span class="line">    //左节点</span><br><span class="line">    if (current.left) &#123;</span><br><span class="line">      queue.push(current.left);</span><br><span class="line">    &#125;</span><br><span class="line">    //右节点</span><br><span class="line">    if (current.right) &#123;</span><br><span class="line">      queue.push(current.right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//test5(root);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>10</li>
<li>/  \</li>
<li>8   12</li>
<li>/ \  / \</li>
<li>6   9 11 13</li>
<li>二叉树的三种遍历方式<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//前序</span><br><span class="line">function test6(node) &#123;</span><br><span class="line">  if (!node) return;</span><br><span class="line">  console.log(node.value);</span><br><span class="line">  test6(node.left);</span><br><span class="line">  test6(node.right);</span><br><span class="line">&#125;</span><br><span class="line">//test6(root)</span><br><span class="line">//中序</span><br><span class="line">function test7(node) &#123;</span><br><span class="line">  if (!node) return;</span><br><span class="line">  test7(node.left);</span><br><span class="line">  console.log(node.value);</span><br><span class="line">  test7(node.right);</span><br><span class="line">&#125;</span><br><span class="line">//test7(root)</span><br><span class="line">//后序</span><br><span class="line">function test8(node) &#123;</span><br><span class="line">  if (!node) return;</span><br><span class="line">  test8(node.left);</span><br><span class="line">  test8(node.right);</span><br><span class="line">  console.log(node.value);</span><br><span class="line">&#125;</span><br><span class="line">//test8(root)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>给定一个整数数组 arr 和一个目标值 target，请你在该数组中找出加和等于目标值的那两个整数，并返回它们的在数组中下标。</li>
<li>你可以假设，原数组中没有重复元素，而且有且只有一组答案。但是，数组中的元素只能使用一次。例如，arr = [1, 2, 3, 4, 5, 6]，target = 4。因为，arr[0] + arr[2] = 1 + 3 = 4 = target，则输出 0，2。<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function test9(data, target) &#123;</span><br><span class="line">  for (const item of data) &#123;</span><br><span class="line">    if (data.includes(target - item) &amp;&amp; target - item !== item)</span><br><span class="line">      console.log(`$&#123;target&#125;=$&#123;item&#125;+$&#123;target - item&#125;`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//test9([1,2,3,4,5,6],4)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>汉诺塔问题(递归)</li>
<li>从左到右有 x、y、z 三根柱子，其中 x 柱子上面有从小叠到大的 n 个圆盘。现要求将 x 柱子上的圆盘移到 z 柱子上去。要求是，每次只能移动一个盘子，且大盘子不能被放在小盘子上面。求移动的步骤。</li>
<li><hr>
</li>
<li>我们的原问题是，把从小到大的 n 个盘子，从 x 移动到 z。</li>
<li>我们可以将这个大问题拆解为以下 3 个小问题：</li>
<li>把从小到大的 n-1 个盘子，从 x 移动到 y；</li>
<li>接着把最大的一个盘子，从 x 移动到 z；</li>
<li>再把从小到大的 n-1 个盘子，从 y 移动到 z。</li>
<li><hr>
</li>
<li>经过仔细分析可见，汉诺塔问题是完全可以用递归实现的。我们定义汉诺塔的递归函数为 hanio()。这个函数的输入参数包括了：</li>
<li>3 根柱子的标记 x、y、z；</li>
<li>待移动的盘子数量 n。</li>
<li><hr>
</li>
<li>具体代码如下所示，在代码中，hanio(n, x, y, z)，代表了把 n 个盘子由 x 移动到 z。根据分析，我们知道递归体包含 3 个步骤：</li>
<li>把从小到大的 n-1 个盘子从 x 移动到 y，那么代码就是 hanio(n-1, x, z, y)；</li>
<li>再把最大的一个盘子从 x 移动到 z，那么直接完成一次移动的动作就可以了；</li>
<li>再把从小到大的 n-1 个盘子从 y 移动到 z，那么代码就是 hanio(n-1, y, x, z)。对于终止条件则需要判断 n 的大小。如果 n 等于 1，那么同样直接移动就可以了。<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function test10(n, x, y, z) &#123;</span><br><span class="line">  if (n &lt; 1) return console.log(&quot;汉诺塔层数不能小于1&quot;);</span><br><span class="line">  if (n === 1) return console.log(`移动$&#123;x&#125;到$&#123;z&#125;`);</span><br><span class="line">  test10(n - 1, x, z, y);</span><br><span class="line">  console.log(`移动$&#123;x&#125;到$&#123;z&#125;`);</span><br><span class="line">  test10(n - 1, y, x, z);</span><br><span class="line">&#125;</span><br><span class="line">//test10(3, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>斐波那契数列。(递归)</li>
<li>斐波那契数列是：0，1，1，2，3，5，8，13，21，34，55，89，144……。</li>
<li>你会发现，这个数列中元素的性质是，某个数等于它前面两个数的和；</li>
<li>也就是 a[n+2] = a[n+1] + a[n]。至于起始两个元素，则分别为 0 和 1。</li>
<li>在这个数列中的数字，就被称为斐波那契数。</li>
<li><hr>
</li>
<li>写一个函数，输入 x，输出斐波那契数列中第 x 位的元素。</li>
<li>例如，输入 4，输出 2；输入 9，输出 21。</li>
<li>要求：需要用递归的方式来实现。<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const target = 9;</span><br><span class="line">const data = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144];</span><br><span class="line">function test11(data, x) &#123;</span><br><span class="line">  if (x === 1) return 0;</span><br><span class="line">  if (x === 2) return 1;</span><br><span class="line">  if (x &gt; 2) data[x] = test11(data, x - 1) + test11(data, x - 2);</span><br><span class="line">  //输出结果</span><br><span class="line">  if (x === target) console.log(data[x]);</span><br><span class="line">  return data[x];</span><br><span class="line">&#125;</span><br><span class="line">//test11(data, target);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>/*<em>
 </em>二分 (基于有序)<br> */<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function test12(data, target) &#123;</span><br><span class="line">  //低</span><br><span class="line">  let low = 0;</span><br><span class="line">  //高</span><br><span class="line">  let high = data.length - 1;</span><br><span class="line">  //中</span><br><span class="line">  let middle = 0;</span><br><span class="line">  //计数器</span><br><span class="line">  let count = 1;</span><br><span class="line">  while (low &lt;= high) &#123;</span><br><span class="line">    middle = Math.floor((low + high) / 2);</span><br><span class="line">    if (target === data[middle]) &#123;</span><br><span class="line">      console.log(`找了$&#123;count&#125;次`);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (target &gt; data[middle]) &#123;</span><br><span class="line">      low = middle + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (target &lt; data[middle]) &#123;</span><br><span class="line">      high = middle - 1;</span><br><span class="line">    &#125;</span><br><span class="line">    count++;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(&quot;没有找到&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//test12([2, 4, 6, 7], 4);</span><br></pre></td></tr></table></figure></p>
<p>/*<em>
 </em>在一个有序数组中，查找出第一个大于 9 的数字，假设一定存在。<br> <em>例如，arr = { -1, 3, 3, 7, 10, 14, 14 }; 则返回 10。
 </em>查找的目标数字具备这样的性质：<br> <em>第一，它比 9 大；
 </em>第二，它前面的数字（除非它是第一个数字），比 9 小。<br> <em>因此，当我们作出向左走或向右走的决策时，必须满足这两个条件。
 </em>/<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function test13(data, target) &#123;</span><br><span class="line">  let low = 0;</span><br><span class="line">  let high = data.length - 1;</span><br><span class="line">  let middle = 0;</span><br><span class="line">  while (low &lt;= high) &#123;</span><br><span class="line">    middle = Math.floor((low + high) / 2);</span><br><span class="line">    if (target &gt;= data[middle]) &#123;</span><br><span class="line">      if (target &lt; data[middle + 1]) return data[middle + 1];</span><br><span class="line">      low = middle + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (target &lt; data[middle]) &#123;</span><br><span class="line">      if (target &gt; data[middle - 1]) return data[middle];</span><br><span class="line">      high = middle - 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//console.log(test13([-1, 3, 3, 7, 10, 14, 14], 9));</span><br></pre></td></tr></table></figure></p>
<p>/**</p>
<ul>
<li>冒泡排序<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function test14(data) &#123;</span><br><span class="line">  for (let i = 0; i &lt; data.length; i++) &#123;</span><br><span class="line">    //j &lt; data.length - i 每一轮都会筛选出一个最值，减少没有必要的比较次数</span><br><span class="line">    for (let j = 0; j &lt; data.length - i; j++) &#123;</span><br><span class="line">      //交换位置</span><br><span class="line">      if (data[j] &gt; data[j + 1]) &#123;</span><br><span class="line">        data[j + 1] = data[j] + data[j + 1];</span><br><span class="line">        data[j] = data[j + 1] - data[j];</span><br><span class="line">        data[j + 1] = data[j + 1] - data[j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(data);</span><br><span class="line">&#125;</span><br><span class="line">//test14([-1, 3, -3, 7, 10, 14, 14]);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>插入排序</li>
<li>选取未排序的元素，插入到已排序区间的合适位置，直到未排序区间为空。</li>
<li>插入排序顾名思义，就是从左到右维护一个已经排好序的序列。直到所有的待排数据全都完成插入的动作。<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">function test15(data) &#123;</span><br><span class="line">  for (let i = 1; i &lt; data.length; i++) &#123;</span><br><span class="line">    //记录当前遍历的元素</span><br><span class="line">    let current = data[i];</span><br><span class="line">    for (let j = i - 1; j &gt;= 0; j--) &#123;</span><br><span class="line">      if (data[j] &gt; current) &#123;</span><br><span class="line">        data[j + 1] = data[j] + data[j + 1];</span><br><span class="line">        data[j] = data[j + 1] - data[j];</span><br><span class="line">        data[j + 1] = data[j + 1] - data[j];</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//test15([-1, 3, -3, 7, 10, 14, 14]);</span><br><span class="line">function test16(data) &#123;</span><br><span class="line">  for (let i = 1; i &lt; data.length; i++) &#123;</span><br><span class="line">    //记录当前遍历的元素</span><br><span class="line">    let current = data[i];</span><br><span class="line">    let j = i - 1;</span><br><span class="line">    for (; j &gt;= 0; j--) &#123;</span><br><span class="line">      if (data[j] &gt; current) &#123;</span><br><span class="line">        data[j + 1] = data[j];</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    data[j + 1] = current;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//test16([-1, 3, -3, 7, 10, 14, 14]);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>归并排序</li>
<li>归并排序的原理就是分治法。</li>
<li>它首先将数组不断地二分，直到最后每个部分只包含 1 个数据。</li>
<li>然后再对每个部分分别进行排序，最后将排序好的相邻的两部分合并在一起，这样整个数组就有序了。<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">function test17(data) &#123;</span><br><span class="line">  //临时数组</span><br><span class="line">  let temp = [];</span><br><span class="line">  //开始下标</span><br><span class="line">  let start = 0;</span><br><span class="line">  //结束下标</span><br><span class="line">  let end = data.length - 1;</span><br><span class="line"></span><br><span class="line">  //拆分</span><br><span class="line">  function split(data, temp, start, end) &#123;</span><br><span class="line">    if (start &lt; end) &#123;</span><br><span class="line">      //中间下标</span><br><span class="line">      let mid = Math.floor((start + end) / 2);</span><br><span class="line"></span><br><span class="line">      //对左边进行拆分</span><br><span class="line">      split(data, temp, start, mid);</span><br><span class="line">      //对右边进行拆分</span><br><span class="line">      split(data, temp, mid + 1, end);</span><br><span class="line">      //合并左右部分</span><br><span class="line">      merge(data, temp, start, mid, end);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //合并</span><br><span class="line">  function merge(data, temp, start, mid, end) &#123;</span><br><span class="line">    //左边开始下标</span><br><span class="line">    let leftStart = start;</span><br><span class="line">    //右边开始下标</span><br><span class="line">    let rightStart = mid + 1;</span><br><span class="line">    //临时数组开始下标</span><br><span class="line">    let left = start;</span><br><span class="line"></span><br><span class="line">    //左边部分和右边部分都未走完时</span><br><span class="line">    while (leftStart &lt;= mid &amp;&amp; rightStart &lt;= end) &#123;</span><br><span class="line">      if (data[leftStart] &gt; data[rightStart]) &#123;</span><br><span class="line">        temp[left++] = data[rightStart++];</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        temp[left++] = data[leftStart++];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //左边部分未走完时</span><br><span class="line">    while (leftStart &lt;= mid) &#123;</span><br><span class="line">      temp[left++] = data[leftStart++];</span><br><span class="line">    &#125;</span><br><span class="line">    //右边部分未走完时</span><br><span class="line">    while (rightStart &lt;= end) &#123;</span><br><span class="line">      temp[left++] = data[rightStart++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //每次合并完更新原数据</span><br><span class="line">    for (let i = 0; i &lt; temp.length; i++) &#123;</span><br><span class="line">      data[i] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  split(data, temp, start, end);</span><br><span class="line">  console.log(data);</span><br><span class="line">&#125;</span><br><span class="line">//test17([-1, -3, -3, 7, 10, 14, 14]);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>快速排序</li>
<li>快速排序法的原理也是分治法。</li>
<li>它的每轮迭代，会选取数组中任意一个数据作为分区点，将小于它的元素放在它的左侧，大于它的放在它的右侧。</li>
<li>再利用分治思想，继续分别对左右两侧进行同样的操作，直至每个区间缩小为 1，则完成排序。<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">function test18(data, start, end) &#123;</span><br><span class="line">  if (start &gt;= end) return;</span><br><span class="line"></span><br><span class="line">  //取数据第一个值作为参考值</span><br><span class="line">  let temp = data[start];</span><br><span class="line">  //左指针</span><br><span class="line">  let left = start;</span><br><span class="line">  //右指针</span><br><span class="line">  let right = end;</span><br><span class="line">  while (left &lt; right) &#123;</span><br><span class="line">    //从右</span><br><span class="line">    while (temp &lt;= data[right] &amp;&amp; left &lt; right) &#123;</span><br><span class="line">      right--;</span><br><span class="line">    &#125;</span><br><span class="line">    //从左</span><br><span class="line">    while (temp &gt;= data[left] &amp;&amp; left &lt; right) &#123;</span><br><span class="line">      left++;</span><br><span class="line">    &#125;</span><br><span class="line">    //此时的left和right位置元素交换位置</span><br><span class="line">    /**</span><br><span class="line">     * 1.可以使用变量交换两个元素</span><br><span class="line">     * 2.这里的交换方法针对left和right相同情况时做了一层判断</span><br><span class="line">     */</span><br><span class="line">    if (left !== right) &#123;</span><br><span class="line">      data[right] = data[left] + data[right];</span><br><span class="line">      data[left] = data[right] - data[left];</span><br><span class="line">      data[right] = data[right] - data[left];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  //参考值与此时的结束位置元素交换位置  (判断情况与上面类似)</span><br><span class="line">  if (start !== left) &#123;</span><br><span class="line">    data[start] = data[left] + data[start];</span><br><span class="line">    data[left] = data[start] - data[left];</span><br><span class="line">    data[start] = data[start] - data[left];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  test18(data, start, left - 1);</span><br><span class="line">  test18(data, left + 1, end);</span><br><span class="line">  console.log(data);</span><br><span class="line">&#125;</span><br><span class="line">//test18([-1, -3, -3, 7, 10, 14, 14], 0, 6);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>假设有且仅有 1 个最大公共子串。</li>
<li>比如，输入 a = “13452439”， b = “123456”。由于字符串 “345” 同时在 a 和 b 中出现，且是同时出现在 a 和 b 中的最长子串。因此输出 “345”。<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function test19(strA, strB) &#123;</span><br><span class="line">  //记录字符串a的下标</span><br><span class="line">  let indexB = -1;</span><br><span class="line">  //记录字符串b的下标</span><br><span class="line">  let indexA = -1;</span><br><span class="line">  let map = new Map();</span><br><span class="line">  for (let i = 0; i &lt; strA.length; i++) &#123;</span><br><span class="line">    indexA = i;</span><br><span class="line">    indexB = strB.indexOf(strA[i]);</span><br><span class="line">    //strA[i]是否存在strB中</span><br><span class="line">    if (indexB !== -1) &#123;</span><br><span class="line">      let str = strA[i];</span><br><span class="line">      map.set(str, str.length);</span><br><span class="line">      for (let j = indexB + 1; j &lt; strB.length; j++) &#123;</span><br><span class="line">        if (strA[++indexA] === strB[j]) &#123;</span><br><span class="line">          str += strB[j];</span><br><span class="line">          map.set(str, str.length);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  for (const [key, value] of map) &#123;</span><br><span class="line">    if (value === Math.max.apply(null, [...map.values()])) &#123;</span><br><span class="line">      console.log(`最大公共字符串为：$&#123;key&#125;`);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//test19(&quot;13145612439&quot;, &quot;1234562&quot;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>两个有序数组查找合并之后的中位数。给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出这两个正序数组合在一起之后的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</li>
<li>你可以假设 nums1 和 nums2 不会同时为空，所有的数字全都不相等。还可以再假设，如果数字个数为偶数个，中位数就是中间偏左的那个元素。</li>
<li>例如：nums1 = [1, 3, 5, 7, 9]</li>
<li>nums2 = [2, 4, 8, 12]</li>
<li>输出 5。<br>*/</li>
</ul>
<p>/**</p>
<ul>
<li>小明从小就喜欢数学，喜欢在笔记里记录很多表达式。他觉得现在的表达式写法很麻烦，为了提高运算符优先级，不得不添加很多括号。如果不小心漏了一个右括号的话，就差之毫厘，谬之千里了。</li>
<li>因此他改用前缀表达式，例如把 (2 + 3) <em> 4写成</em> + 2 3 4，这样就能避免使用括号了。这样的表达式虽然书写简单，但计算却不够直观。请你写一个程序帮他计算这些前缀表达式。</li>
<li>在这个题目中，输入就是前缀表达式，输出就是计算的结果。你可以假设除法为整除，即“5/3=1”。例如，输入字符串为 + 2 3，输出 5；输入字符串为 <em> + 2 2 3，输出为 12；输入字符串为 </em> 2 + 2 3，输出为 10。</li>
<li>我们给出一些提示。假设输入字符串为 <em> 2 + 2 3，即 2</em>(2+3)。第一个字符为运算符号 *，它将对两个数字进行乘法。如果后面紧接着的字符不全是数字字符，那就需要暂存下来，先计算后面的算式。一旦后面的计算完成，就需要接着从后往前去继续计算。</li>
<li>因为从后往前是一种逆序动作，我们能够很自然地想到可以用栈的数据结构进行存储。你可以尝试利用栈，去解决这个问题。<br>*/</li>
</ul>
<p>/**</p>
<ul>
<li>给定一个方格棋盘，从左上角出发到右下角有多少种方法</li>
<li>在一个方格棋盘里，左上角是起点，右下角是终点。每次只能向右或向下，移向相邻的格子。同时，棋盘中有若干个格子是陷阱，不可经过，必须绕开行走。</li>
<li>要求用动态规划的方法，求出从起点到终点总共有多少种不同的路径。例如，输入二维矩阵 m 代表棋盘，其中，1 表示格子可达，-1 表示陷阱。输出可行的路径数量为 2。<br>*/</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/学习/">学习</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/学习/">学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网站/">网站</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/资源/">资源</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-vue" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2021/03/25/vue/" class="article-date">
      <time datetime="2021-03-24T16:00:00.000Z" itemprop="datePublished">2021-03-25</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/25/vue/">vue进阶</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="Vue初始化"><a href="#Vue初始化" class="headerlink" title="Vue初始化"></a>Vue初始化</h2><h3 id="Vue-prototype-mount"><a href="#Vue-prototype-mount" class="headerlink" title="Vue.prototype.$mount"></a>Vue.prototype.$mount</h3><ol>
<li>文件路径：vue/src/platforms/web/entry-runtime-with-compiler.js </li>
<li>new Vue()时，会调用Vue构造函数，Vue构造函数里面会调用Vue._init方法，Vue._init方法里面会调用Vue.$mount方法<br>3.注册Vue.compile方法，传递一个HTML字符串返回render函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">//处理el</span><br><span class="line">export function query (el: string | Element): Element &#123;</span><br><span class="line">  //如果是字符串时，通过选择器获取dom</span><br><span class="line">  if (typeof el === &apos;string&apos;) &#123;</span><br><span class="line">    const selected = document.querySelector(el)</span><br><span class="line">	//如果没有找到对应dom，会返回一个div</span><br><span class="line">    if (!selected) &#123;</span><br><span class="line">      process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; warn(</span><br><span class="line">        &apos;Cannot find element: &apos; + el</span><br><span class="line">      )</span><br><span class="line">      return document.createElement(&apos;div&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    return selected</span><br><span class="line">  &#125; </span><br><span class="line">  //不是字符串时直接返回</span><br><span class="line">  else &#123;</span><br><span class="line">    return el</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//获取outerHtml</span><br><span class="line">function getOuterHTML (el: Element): string &#123;</span><br><span class="line">  if (el.outerHTML) &#123;</span><br><span class="line">    return el.outerHTML</span><br><span class="line">  &#125; </span><br><span class="line">  //获取不到outerHtml时</span><br><span class="line">  else &#123;</span><br><span class="line">    const container = document.createElement(&apos;div&apos;)</span><br><span class="line">    container.appendChild(el.cloneNode(true))</span><br><span class="line">    return container.innerHTML</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Vue.prototype.$mount = function (el?: string | Element,hydrating?: boolean): Component &#123;</span><br><span class="line"></span><br><span class="line">  //先对el进行处理</span><br><span class="line">  el = el &amp;&amp; query(el);</span><br><span class="line"> //如果el是body或html时，在开发环境会有警告</span><br><span class="line">  if (el === document.body || el === document.documentElement) &#123;</span><br><span class="line">    process.env.NODE_ENV !== &quot;production&quot; &amp;&amp;</span><br><span class="line">      warn(</span><br><span class="line">        `Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`</span><br><span class="line">      );</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line"> //获取options选项</span><br><span class="line">  const options = this.$options;</span><br><span class="line"> //如果没有传render函数</span><br><span class="line">  if (!options.render) &#123;</span><br><span class="line">    //获取模板字符串</span><br><span class="line">    let template = options.template;</span><br><span class="line">    //对模板字符串进行处理</span><br><span class="line">    if (template) &#123;</span><br><span class="line"></span><br><span class="line">      if (typeof template === &quot;string&quot;) &#123;</span><br><span class="line">        if (template.charAt(0) === &quot;#&quot;) &#123;</span><br><span class="line">          template = idToTemplate(template);</span><br><span class="line">          /* istanbul ignore if */</span><br><span class="line">          if (process.env.NODE_ENV !== &quot;production&quot; &amp;&amp; !template) &#123;</span><br><span class="line">            warn(</span><br><span class="line">              `Template element not found or is empty: $&#123;options.template&#125;`,</span><br><span class="line">              this</span><br><span class="line">            );</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else if (template.nodeType) &#123;</span><br><span class="line">        template = template.innerHTML;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        if (process.env.NODE_ENV !== &quot;production&quot;) &#123;</span><br><span class="line">          warn(&quot;invalid template option:&quot; + template, this);</span><br><span class="line">        &#125;</span><br><span class="line">        return this;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    //没有模板时，获取el的outerHtml作为模板</span><br><span class="line">    else if (el) &#123;</span><br><span class="line">      template = getOuterHTML(el);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //将模板生成渲染函数</span><br><span class="line">    if (template) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //进行挂载</span><br><span class="line">  return mount.call(this, el, hydrating);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="vue初始化过程"><a href="#vue初始化过程" class="headerlink" title="vue初始化过程"></a>vue初始化过程</h3><ol>
<li><p>注册一些跟平台相关的全局的指令和组件    vue/src/platforms/web/runtime/index.js </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// install platform runtime directives &amp; components</span><br><span class="line">extend(Vue.options.directives, platformDirectives)   v-model v-show</span><br><span class="line">extend(Vue.options.components, platformComponents)   v-transition-group  v-transition</span><br><span class="line"></span><br><span class="line">// install platform patch function</span><br><span class="line">Vue.prototype.__patch__ = inBrowser ? patch : noop   将虚拟Dom转换成真是DOM</span><br><span class="line"></span><br><span class="line">// public mount method           挂载，将dom渲染到页面上面</span><br><span class="line">Vue.prototype.$mount = function (</span><br><span class="line">  el?: string | Element,</span><br><span class="line">  hydrating?: boolean</span><br><span class="line">): Component &#123;</span><br><span class="line">  el = el &amp;&amp; inBrowser ? query(el) : undefined</span><br><span class="line">  return mountComponent(this, el, hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化全局Api       vue/src/core/index.js /</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &apos;./instance/index&apos;</span><br><span class="line">import &#123; initGlobalAPI &#125; from &apos;./global-api/index&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">initGlobalAPI(Vue)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Vue.version = &apos;__VERSION__&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>initGlobalAPI 初始化vue的静态方法  文件路径 vue/src/core/global-api/index.js /</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">export function initGlobalAPI (Vue: GlobalAPI) &#123;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    //vue.config全局配置对象</span><br><span class="line">    Object.defineProperty(Vue, &apos;config&apos;, configDef)</span><br><span class="line">  </span><br><span class="line">    Vue.util = &#123;</span><br><span class="line">      warn,</span><br><span class="line">      extend,</span><br><span class="line">      mergeOptions,</span><br><span class="line">      defineReactive</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">   //静态方法 set/delete/nextTick</span><br><span class="line">    Vue.set = set</span><br><span class="line">    Vue.delete = del</span><br><span class="line">    Vue.nextTick = nextTick</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    //让一个对象可响应</span><br><span class="line">    Vue.observable = &lt;T&gt;(obj: T): T =&gt; &#123;</span><br><span class="line">      observe(obj)</span><br><span class="line">      return obj</span><br><span class="line">    &#125;</span><br><span class="line">    //components/filters/directives/初始化</span><br><span class="line">    Vue.options = Object.create(null)</span><br><span class="line">    ASSET_TYPES.forEach(type =&gt; &#123;</span><br><span class="line">      Vue.options[type + &apos;s&apos;] = Object.create(null)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    Vue.options._base = Vue</span><br><span class="line">  </span><br><span class="line">    //keep-alive组件注册  浅拷贝</span><br><span class="line">    extend(Vue.options.components, builtInComponents)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">   </span><br><span class="line">    initUse(Vue)  //Vue.use  用来注册插件</span><br><span class="line">    initMixin(Vue)  /Vue.mixin  //实现混入</span><br><span class="line">    initExtend(Vue)  /Vue.extend  // 基于传入的options返回一个组件的构造函数</span><br><span class="line">    initAssetRegisters(Vue) /Vue.directive/Vue.component/Vue.filter初始化</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>vue构造函数   vue/src/core/instance/index.js /</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import &#123; initMixin &#125; from &apos;./init&apos;</span><br><span class="line">import &#123; stateMixin &#125; from &apos;./state&apos;</span><br><span class="line">import &#123; renderMixin &#125; from &apos;./render&apos;</span><br><span class="line">import &#123; eventsMixin &#125; from &apos;./events&apos;</span><br><span class="line">import &#123; lifecycleMixin &#125; from &apos;./lifecycle&apos;</span><br><span class="line">import &#123; warn &#125; from &apos;../util/index&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//不使用class是为了后续方便在vue.prototype上混入实例成员</span><br><span class="line">function Vue (options) &#123;</span><br><span class="line"></span><br><span class="line">  //开发环境必须使用new关键字调用Vue构造函数</span><br><span class="line">  if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp;</span><br><span class="line">    !(this instanceof Vue)</span><br><span class="line">  ) &#123;</span><br><span class="line">    warn(&apos;Vue is a constructor and should be called with the `new` keyword&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">  //初始化options</span><br><span class="line">  this._init(options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">initMixin(Vue)   //注册Vue.prototype._init方法</span><br><span class="line">stateMixin(Vue)    //注册vue实例相关方法 $data/$props/$set/$delete/$watch实例方法</span><br><span class="line">eventsMixin(Vue)    //注册事件相关方法   $on/$once/$off/$emit</span><br><span class="line">lifecycleMixin(Vue)  //注册生命周期相关方法  _update/$forceUpdate/$destory</span><br><span class="line">renderMixin(Vue)    //$nextTick/_render</span><br><span class="line"></span><br><span class="line">export default Vue</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="静态成员初始化"><a href="#静态成员初始化" class="headerlink" title="静态成员初始化"></a>静态成员初始化</h4><ol>
<li><p>Vue.use        vue/src/core/global-api/use.js </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">export function initUse (Vue: GlobalAPI) &#123;</span><br><span class="line">   //参数为函数或对象</span><br><span class="line">  Vue.use = function (plugin: Function | Object) &#123;</span><br><span class="line">   //已经安装的插件</span><br><span class="line">    const installedPlugins = (this._installedPlugins || (this._installedPlugins = []))</span><br><span class="line">	//已经安装过的插件不会再次安装</span><br><span class="line">    if (installedPlugins.indexOf(plugin) &gt; -1) &#123;</span><br><span class="line">      return this</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // additional parameters   把参数的第一个元素去除，第一个元素是插件</span><br><span class="line">    const args = toArray(arguments, 1)</span><br><span class="line">    args.unshift(this)   //args数组第一项插入this(Vue)</span><br><span class="line">	//参数为对象时，有一个install方法，调用install方法</span><br><span class="line">    if (typeof plugin.install === &apos;function&apos;) &#123;</span><br><span class="line">      plugin.install.apply(plugin, args)</span><br><span class="line">    &#125; </span><br><span class="line">	//参数为函数时,直接调用</span><br><span class="line">	else if (typeof plugin === &apos;function&apos;) &#123;</span><br><span class="line">      plugin.apply(null, args)</span><br><span class="line">    &#125;</span><br><span class="line">    installedPlugins.push(plugin)</span><br><span class="line">    return this</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Vue.mixin        vue/src/core/global-api/mixin.js </p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mergeOptions &#125; from &apos;../util/index&apos;</span><br><span class="line"></span><br><span class="line">export function initMixin (Vue: GlobalAPI) &#123;</span><br><span class="line">  将选项对象与Vue全局options对象进行合并</span><br><span class="line">  Vue.mixin = function (mixin: Object) &#123;</span><br><span class="line">    this.options = mergeOptions(this.options, mixin)</span><br><span class="line">    return this</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><p>Vue.extend   vue/src/core/global-api/extend.js </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"> Vue.extend = function (extendOptions: Object): Function &#123;</span><br><span class="line">    extendOptions = extendOptions || &#123;&#125;</span><br><span class="line">	</span><br><span class="line">	//Vue构造函数</span><br><span class="line">    const Super = this</span><br><span class="line">    const SuperId = Super.cid</span><br><span class="line">    const cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = &#123;&#125;)</span><br><span class="line">    if (cachedCtors[SuperId]) &#123;</span><br><span class="line">      return cachedCtors[SuperId]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const name = extendOptions.name || Super.options.name</span><br><span class="line">    if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; name) &#123;</span><br><span class="line">      validateComponentName(name)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //定义构造函数 调用_init初始化方法</span><br><span class="line">    const Sub = function VueComponent (options) &#123;</span><br><span class="line">      this._init(options)</span><br><span class="line">    &#125;</span><br><span class="line">	//继承Vue</span><br><span class="line">    Sub.prototype = Object.create(Super.prototype)</span><br><span class="line">    Sub.prototype.constructor = Sub</span><br><span class="line">    Sub.cid = cid++</span><br><span class="line">	</span><br><span class="line">	//合并options</span><br><span class="line">    Sub.options = mergeOptions(</span><br><span class="line">      Super.options,</span><br><span class="line">      extendOptions</span><br><span class="line">    )</span><br><span class="line">    Sub[&apos;super&apos;] = Super</span><br><span class="line"></span><br><span class="line">    // For props and computed properties, we define the proxy getters on</span><br><span class="line">    // the Vue instances at extension time, on the extended prototype. This</span><br><span class="line">    // avoids Object.defineProperty calls for each instance created.</span><br><span class="line">    if (Sub.options.props) &#123;</span><br><span class="line">      initProps(Sub)</span><br><span class="line">    &#125;</span><br><span class="line">    if (Sub.options.computed) &#123;</span><br><span class="line">      initComputed(Sub)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // allow further extension/mixin/plugin usage</span><br><span class="line">    Sub.extend = Super.extend</span><br><span class="line">    Sub.mixin = Super.mixin</span><br><span class="line">    Sub.use = Super.use</span><br><span class="line"></span><br><span class="line">    // create asset registers, so extended classes</span><br><span class="line">    // can have their private assets too.</span><br><span class="line">    ASSET_TYPES.forEach(function (type) &#123;</span><br><span class="line">      Sub[type] = Super[type]</span><br><span class="line">    &#125;)</span><br><span class="line">    // enable recursive self-lookup</span><br><span class="line">    if (name) &#123;</span><br><span class="line">      Sub.options.components[name] = Sub</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // keep a reference to the super options at extension time.</span><br><span class="line">    // later at instantiation we can check if Super&apos;s options have</span><br><span class="line">    // been updated.</span><br><span class="line">    Sub.superOptions = Super.options</span><br><span class="line">    Sub.extendOptions = extendOptions</span><br><span class="line">    Sub.sealedOptions = extend(&#123;&#125;, Sub.options)</span><br><span class="line"></span><br><span class="line">    // cache constructor</span><br><span class="line">    cachedCtors[SuperId] = Sub</span><br><span class="line">    return Sub</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Vue.directive/Vue.component/Vue.filter/   vue/src/core/global-api/assets.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ASSET_TYPES.forEach(type =&gt; &#123;</span><br><span class="line">    Vue[type] = function (</span><br><span class="line">      id: string,</span><br><span class="line">      definition: Function | Object</span><br><span class="line">    ): Function | Object | void &#123;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	  //没有传定义时</span><br><span class="line">      if (!definition) &#123;</span><br><span class="line">        return this.options[type + &apos;s&apos;][id]</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        /* istanbul ignore if */</span><br><span class="line">        if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; type === &apos;component&apos;) &#123;</span><br><span class="line">          validateComponentName(id)</span><br><span class="line">        &#125;  </span><br><span class="line">		//isPlainObject:&apos;[object Object]&apos;</span><br><span class="line">        if (type === &apos;component&apos; &amp;&amp; isPlainObject(definition)) &#123;</span><br><span class="line">          definition.name = definition.name || id</span><br><span class="line">          definition = this.options._base.extend(definition)</span><br><span class="line">        &#125;</span><br><span class="line">        if (type === &apos;directive&apos; &amp;&amp; typeof definition === &apos;function&apos;) &#123;</span><br><span class="line">          definition = &#123; bind: definition, update: definition &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">		//全局注册</span><br><span class="line">        this.options[type + &apos;s&apos;][id] = definition</span><br><span class="line">        return definition</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="实例成员初始化"><a href="#实例成员初始化" class="headerlink" title="实例成员初始化"></a>实例成员初始化</h4><ol>
<li><p>ininMixin  给Vue实例增加_init方法    vue/src/core/instance/init.js </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype._init = function (options?: Object) &#123;</span><br><span class="line">   const vm: Component = this</span><br><span class="line">   // a uid</span><br><span class="line">   vm._uid = uid++</span><br><span class="line"></span><br><span class="line">   let startTag, endTag</span><br><span class="line">   /* istanbul ignore if */</span><br><span class="line">   if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">     startTag = `vue-perf-start:$&#123;vm._uid&#125;`</span><br><span class="line">     endTag = `vue-perf-end:$&#123;vm._uid&#125;`</span><br><span class="line">     mark(startTag)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // a flag to avoid this being observed</span><br><span class="line">   vm._isVue = true</span><br><span class="line">   // merge options</span><br><span class="line">   if (options &amp;&amp; options._isComponent) &#123;</span><br><span class="line">     // optimize internal component instantiation</span><br><span class="line">     // since dynamic options merging is pretty slow, and none of the</span><br><span class="line">     // internal component options needs special treatment.</span><br><span class="line">     initInternalComponent(vm, options)</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">     vm.$options = mergeOptions(</span><br><span class="line">       resolveConstructorOptions(vm.constructor),</span><br><span class="line">       options || &#123;&#125;,</span><br><span class="line">       vm</span><br><span class="line">     )</span><br><span class="line">   &#125;</span><br><span class="line">   /* istanbul ignore else */</span><br><span class="line">   if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">     initProxy(vm)</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">     vm._renderProxy = vm</span><br><span class="line">   &#125;</span><br><span class="line">   // expose real self</span><br><span class="line">   vm._self = vm</span><br><span class="line">   initLifecycle(vm)</span><br><span class="line">   initEvents(vm)</span><br><span class="line">   initRender(vm)</span><br><span class="line">   callHook(vm, &apos;beforeCreate&apos;)</span><br><span class="line">   initInjections(vm) // resolve injections before data/props</span><br><span class="line">   initState(vm)</span><br><span class="line">   initProvide(vm) // resolve provide after data/props</span><br><span class="line">   callHook(vm, &apos;created&apos;)</span><br><span class="line"></span><br><span class="line">   /* istanbul ignore if */</span><br><span class="line">   if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">     vm._name = formatComponentName(vm, false)</span><br><span class="line">     mark(endTag)</span><br><span class="line">     measure(`vue $&#123;vm._name&#125; init`, startTag, endTag)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (vm.$options.el) &#123;</span><br><span class="line">     vm.$mount(vm.$options.el)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>stateMixin  $data/$props/$set/$delete/$watch    vue/src/core/instance/state.js /</p>
</li>
<li>eventsMixin  $on/$off/$once/$emit/    vue/src/core/instance/events.js /</li>
<li>lifecycleMixin  $forceUpdate/$destroy/_update    vue/src/core/instance/lifecycle.js /</li>
<li>renderMixin  $nextTick/_render   vue/src/core/instance/render.js /</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/学习/">学习</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/学习/">学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网站/">网站</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/资源/">资源</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-core" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2021/03/25/core/" class="article-date">
      <time datetime="2021-03-24T16:00:00.000Z" itemprop="datePublished">2021-03-25</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/25/core/">核心进阶</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ol>
<li>基础类型存储在栈内存，被引用或拷贝时，会创建一个完全相等的变量；<blockquote>
<p><code>Undefined</code> <code>Null</code> <code>String</code> <code>Number</code> <code>Boolean</code> <code>Symbol</code> <code>BigInt</code></p>
</blockquote>
</li>
<li>引用类型存储在堆内存，存储的是地址，多个引用指向同一个地址，这里会涉及一个“共享”的概念。<blockquote>
<p><code>Object</code><br><code>Array</code> <code>Date</code> <code>RegExp</code> <code>Function</code> <code>Math</code></p>
</blockquote>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">let a = &#123;</span><br><span class="line">  name: &quot;Julia&quot;,</span><br><span class="line"></span><br><span class="line">  age: 20,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function change(o) &#123;</span><br><span class="line">  o.age = 24;</span><br><span class="line">  //关键   变量o改变内存指向 跟a已经没有关系</span><br><span class="line">  o = &#123;</span><br><span class="line">    name: &quot;Kath&quot;,</span><br><span class="line">    age: 30,</span><br><span class="line">  &#125;;</span><br><span class="line">  return o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let b = change(a);</span><br><span class="line"></span><br><span class="line">console.log(b.age); // 第一个console   30</span><br><span class="line"></span><br><span class="line">console.log(a.age); // 第二个console   24</span><br></pre></td></tr></table></figure>
<h2 id="数据类型检测"><a href="#数据类型检测" class="headerlink" title="数据类型检测"></a>数据类型检测</h2><ol>
<li>typeof<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">typeof 1 // &apos;number&apos;</span><br><span class="line"></span><br><span class="line">typeof &apos;1&apos; // &apos;string&apos;</span><br><span class="line"></span><br><span class="line">typeof undefined // &apos;undefined&apos;</span><br><span class="line"></span><br><span class="line">typeof true // &apos;boolean&apos;</span><br><span class="line"></span><br><span class="line">typeof Symbol() // &apos;symbol&apos;</span><br><span class="line"></span><br><span class="line">typeof null // &apos;object&apos;       !!!!!!!!!!!!!!!!</span><br><span class="line"></span><br><span class="line">typeof [] // &apos;object&apos;</span><br><span class="line"></span><br><span class="line">typeof &#123;&#125; // &apos;object&apos;</span><br><span class="line"></span><br><span class="line">typeof console // &apos;object&apos;</span><br><span class="line"></span><br><span class="line">typeof console.log // &apos;function&apos;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>虽然 typeof null 会输出 object，但这只是 JS 存在的一个悠久 Bug，不代表 null 就是引用数据类型，并且 null 本身也不是对象。因此，null 在 typeof 之后返回的是有问题的结果，不能作为判断 null 的方法。如果你需要在 if 语句中判断是否为 null，直接通过 ‘===null’来判断就好。</li>
<li>引用数据类型 Object，用 typeof 来判断的话，除了 function 会判断为 OK 以外，其余都是 ‘object’，是无法判断出来的。</li>
</ul>
<ol start="2">
<li>instanceof<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">let Car = function() &#123;&#125;</span><br><span class="line"></span><br><span class="line">let benz = new Car()</span><br><span class="line"></span><br><span class="line">benz instanceof Car // true</span><br><span class="line"></span><br><span class="line">let car = new String(&apos;Mercedes Benz&apos;)</span><br><span class="line"></span><br><span class="line">car instanceof String // true</span><br><span class="line"></span><br><span class="line">let str = &apos;Covid-19&apos;</span><br><span class="line"></span><br><span class="line">str instanceof String // false</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------------------------------</span><br><span class="line"></span><br><span class="line">function myInstanceof(left, right) &#123;</span><br><span class="line"></span><br><span class="line">  // 这里先用typeof来判断基础数据类型，如果是，直接返回false</span><br><span class="line"></span><br><span class="line">  if(typeof left !== &apos;object&apos; || left === null) return false;</span><br><span class="line"></span><br><span class="line">  // getPrototypeOf是Object对象自带的API，能够拿到参数的原型对象</span><br><span class="line"></span><br><span class="line">  let proto = Object.getPrototypeOf(left);</span><br><span class="line"></span><br><span class="line">  while(true) &#123;                  //循环往下寻找，直到找到相同的原型对象</span><br><span class="line"></span><br><span class="line">    if(proto === null) return false;</span><br><span class="line"></span><br><span class="line">    if(proto === right.prototype) return true;//找到相同原型对象，返回true</span><br><span class="line"></span><br><span class="line">    proto = Object.getPrototypeof(proto);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 验证一下自己实现的myInstanceof是否OK</span><br><span class="line"></span><br><span class="line">console.log(myInstanceof(new Number(123), Number));    // true</span><br><span class="line"></span><br><span class="line">console.log(myInstanceof(123, Number));                // false</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>instanceof 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型；</li>
<li>而 typeof 也存在弊端，它虽然可以判断基础数据类型（null 除外），但是引用数据类型中，除了 function 类型以外，其他的也无法判断。</li>
</ul>
<ol start="3">
<li>Object.prototype.toString<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString(&#123;&#125;)       // &quot;[object Object]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(&#123;&#125;)  // 同上结果，加上call也ok</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(1)    // &quot;[object Number]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(&apos;1&apos;)  // &quot;[object String]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(true)  // &quot;[object Boolean]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(function()&#123;&#125;)  // &quot;[object Function]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(null)   //&quot;[object Null]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(undefined) //&quot;[object Undefined]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(/123/g)    //&quot;[object RegExp]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(new Date()) //&quot;[object Date]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call([])       //&quot;[object Array]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(document)  //&quot;[object HTMLDocument]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(window)   //&quot;[object Window]&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function getType(obj)&#123;</span><br><span class="line">  let type  = typeof obj;</span><br><span class="line">  if (type !== &quot;object&quot;) &#123;    // 先进行typeof判断，如果是基础数据类型，直接返回</span><br><span class="line">    return type;</span><br><span class="line">  &#125;</span><br><span class="line">  // 对于typeof返回结果是object的，再进行如下的判断，正则返回结果</span><br><span class="line">  return Object.prototype.toString.call(obj).replace(/^\[object (\S+)\]$/, &apos;$1&apos;);  // 注意正则中间有个空格</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><ol>
<li>强制类型转换 Number()、parseInt()、parseFloat()、toString()、String()、Boolean()<blockquote>
<p>Number() 方法的强制转换规则<br>如果是布尔值，true 和 false 分别被转换为 1 和 0；<br>如果是数字，返回自身；<br>如果是 null，返回 0；<br>如果是 undefined，返回 NaN；<br>如果是字符串，遵循以下规则：如果字符串中只包含数字（或者是 0X / 0x 开头的十六进制数字字符串，允许包含正负号），则将其转换为十进制；如果字符串中包含有效的浮点格式，将其转换为浮点数值；如果是空字符串，将其转换为 0；如果不是以上格式的字符串，均返回 NaN；<br>如果是 Symbol，抛出错误；<br>如果是对象，并且部署了 [Symbol.toPrimitive] ，那么调用此方法，否则调用对象的 valueOf() 方法，然后依据前面的规则转换返回的值；如果转换的结果是 NaN ，则调用对象的 toString() 方法，再次依照前面的顺序转换返回对应的值</p>
</blockquote>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Number(true);        // 1</span><br><span class="line"></span><br><span class="line">Number(false);       // 0</span><br><span class="line"></span><br><span class="line">Number(&apos;0111&apos;);      //111</span><br><span class="line"></span><br><span class="line">Number(null);        //0</span><br><span class="line"></span><br><span class="line">Number(&apos;&apos;);          //0</span><br><span class="line"></span><br><span class="line">Number(&apos;1a&apos;);        //NaN</span><br><span class="line"></span><br><span class="line">Number(-0X11);       //-17</span><br><span class="line"></span><br><span class="line">Number(&apos;0X11&apos;)       //17</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Boolean() 方法的强制转换规则<br>除了 undefined、 null、 false、 ‘’、 0（包括 +0，-0）、 NaN 转换出来是 false，其他都是 true。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Boolean(0)          //false</span><br><span class="line"></span><br><span class="line">Boolean(null)       //false</span><br><span class="line"></span><br><span class="line">Boolean(undefined)  //false</span><br><span class="line"></span><br><span class="line">Boolean(NaN)        //false</span><br><span class="line"></span><br><span class="line">Boolean(1)          //true</span><br><span class="line"></span><br><span class="line">Boolean(13)         //true</span><br><span class="line"></span><br><span class="line">Boolean(&apos;12&apos;)       //true</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>‘==’ 的隐式类型转换规则</li>
</ol>
<ul>
<li>如果类型相同，无须进行类型转换；</li>
<li>如果其中一个操作值是 null 或者 undefined，那么另一个操作符必须为 null 或者 undefined，才会返回 true，否则都返回 false；</li>
<li>如果其中一个是 Symbol 类型，那么返回 false；</li>
<li>两个操作值如果为 string 和 number 类型，那么就会将字符串转换为 number；</li>
<li>如果一个操作值是 boolean，那么转换成 number；</li>
<li>如果一个操作值为 object 且另一方为 string、number 或者 symbol，就会把 object 转为原始类型再进行判断（调用 object 的 valueOf/toString 方法进行转换）。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">null == undefined       // true  规则2</span><br><span class="line"></span><br><span class="line">null == 0               // false 规则2</span><br><span class="line"></span><br><span class="line">&apos;&apos; == null              // false 规则2</span><br><span class="line"></span><br><span class="line">&apos;&apos; == 0                 // true  规则4 字符串转隐式转换成Number之后再对比</span><br><span class="line"></span><br><span class="line">&apos;123&apos; == 123            // true  规则4 字符串转隐式转换成Number之后再对比</span><br><span class="line"></span><br><span class="line">0 == false              // true  e规则 布尔型隐式转换成Number之后再对比</span><br><span class="line"></span><br><span class="line">1 == true               // true  e规则 布尔型隐式转换成Number之后再对比</span><br><span class="line"></span><br><span class="line">var a = &#123;</span><br><span class="line"></span><br><span class="line">  value: 0,</span><br><span class="line"></span><br><span class="line">  valueOf: function() &#123;</span><br><span class="line"></span><br><span class="line">    this.value++;</span><br><span class="line"></span><br><span class="line">    return this.value;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 注意这里a又可以等于1、2、3</span><br><span class="line"></span><br><span class="line">console.log(a == 1 &amp;&amp; a == 2 &amp;&amp; a ==3);  //true f规则 Object隐式转换</span><br><span class="line"></span><br><span class="line">// 注：但是执行过3遍之后，再重新执行a==3或之前的数字就是false，因为value已经加上去了，这里需要注意一下</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="3">
<li>‘+’ 的隐式类型转换规则</li>
</ol>
<ul>
<li>如果其中有一个是字符串，另外一个是 undefined、null 或布尔型，则调用 toString() 方法进行字符串拼接；如果是纯对象、数组、正则等，则默认调用对象的转换方法会存在优先级，然后再进行拼接。</li>
<li>如果其中有一个是数字，另外一个是 undefined、null、布尔型或数字，则会将其转换成数字进行加法运算，对象的情况还是参考上一条规则。</li>
<li>如果其中一个是字符串、一个是数字，则按照字符串规则进行拼接</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1 + 2        // 3  常规情况</span><br><span class="line"></span><br><span class="line">&apos;1&apos; + &apos;2&apos;    // &apos;12&apos; 常规情况</span><br><span class="line"></span><br><span class="line">// 下面看一下特殊情况</span><br><span class="line"></span><br><span class="line">&apos;1&apos; + undefined   // &quot;1undefined&quot; 规则1，undefined转换字符串</span><br><span class="line"></span><br><span class="line">&apos;1&apos; + null        // &quot;1null&quot; 规则1，null转换字符串</span><br><span class="line"></span><br><span class="line">&apos;1&apos; + true        // &quot;1true&quot; 规则1，true转换字符串</span><br><span class="line"></span><br><span class="line">&apos;1&apos; + 1n          // &apos;11&apos; 比较特殊字符串和BigInt相加，BigInt转换为字符串</span><br><span class="line"></span><br><span class="line">1 + undefined     // NaN  规则2，undefined转换数字相加NaN</span><br><span class="line"></span><br><span class="line">1 + null          // 1    规则2，null转换为0</span><br><span class="line"></span><br><span class="line">1 + true          // 2    规则2，true转换为1，二者相加为2</span><br><span class="line"></span><br><span class="line">1 + 1n            // 错误  不能把BigInt和Number类型直接混合相加</span><br><span class="line"></span><br><span class="line">&apos;1&apos; + 3           // &apos;13&apos; 规则3，字符串拼接</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>Object 的转换规则</li>
</ol>
<ul>
<li>如果部署了 Symbol.toPrimitive 方法，优先调用再返回；</li>
<li>调用 valueOf()，如果转换为基础类型，则返回；</li>
<li>调用 toString()，如果转换为基础类型，则返回；</li>
<li>如果都没有返回基础类型，会报错。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line"></span><br><span class="line">  value: 1,</span><br><span class="line"></span><br><span class="line">  valueOf() &#123;</span><br><span class="line"></span><br><span class="line">    return 2;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line"></span><br><span class="line">    return &apos;3&apos;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  [Symbol.toPrimitive]() &#123;</span><br><span class="line"></span><br><span class="line">    return 4</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(obj + 1); // 输出5</span><br><span class="line"></span><br><span class="line">// 因为有Symbol.toPrimitive，就优先执行这个；如果Symbol.toPrimitive这段代码删掉，则执行valueOf打印结果为3；如果valueOf也去掉，则调用toString返回&apos;31&apos;(字符串拼接)</span><br><span class="line"></span><br><span class="line">// 再看两个特殊的case：</span><br><span class="line"></span><br><span class="line">10 + &#123;&#125;</span><br><span class="line"></span><br><span class="line">// &quot;10[object Object]&quot;，注意：&#123;&#125;会默认调用valueOf是&#123;&#125;，不是基础类型继续转换，调用toString，返回结果&quot;[object Object]&quot;，于是和10进行&apos;+&apos;运算，按照字符串拼接规则来，参考&apos;+&apos;的规则C</span><br><span class="line"></span><br><span class="line">[1,2,undefined,4,5] + 10</span><br><span class="line"></span><br><span class="line">// &quot;1,2,,4,510&quot;，注意[1,2,undefined,4,5]会默认先调用valueOf结果还是这个数组，不是基础数据类型继续转换，也还是调用toString，返回&quot;1,2,,4,5&quot;，然后再和10进行运算，还是按照字符串拼接规则，参考&apos;+&apos;的第3条规则</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h2><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><ol>
<li>Object.assign<br><em>注意点</em></li>
</ol>
<ul>
<li>它不会拷贝对象的继承属性；</li>
<li>它不会拷贝对象的不可枚举的属性；</li>
<li>可以拷贝 Symbol 类型的属性。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">let obj1 = &#123; a:&#123; b:1 &#125;, sym:Symbol(1)&#125;; </span><br><span class="line"></span><br><span class="line">Object.defineProperty(obj1, &apos;innumerable&apos; ,&#123;</span><br><span class="line"></span><br><span class="line">    value:&apos;不可枚举属性&apos;,</span><br><span class="line"></span><br><span class="line">    enumerable:false</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">let obj2 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Object.assign(obj2,obj1)</span><br><span class="line"></span><br><span class="line">obj1.a.b = 2;</span><br><span class="line"></span><br><span class="line">console.log(&apos;obj1&apos;,obj1);</span><br><span class="line"></span><br><span class="line">console.log(&apos;obj2&apos;,obj2);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="2">
<li>扩展运算符<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/* 对象的拷贝 */</span><br><span class="line"></span><br><span class="line">let obj = &#123;a:1,b:&#123;c:1&#125;&#125;</span><br><span class="line"></span><br><span class="line">let obj2 = &#123;...obj&#125;</span><br><span class="line"></span><br><span class="line">obj.a = 2</span><br><span class="line"></span><br><span class="line">console.log(obj)  //&#123;a:2,b:&#123;c:1&#125;&#125; console.log(obj2); //&#123;a:1,b:&#123;c:1&#125;&#125;</span><br><span class="line"></span><br><span class="line">obj.b.c = 2</span><br><span class="line"></span><br><span class="line">console.log(obj)  //&#123;a:2,b:&#123;c:2&#125;&#125; console.log(obj2); //&#123;a:1,b:&#123;c:2&#125;&#125;</span><br><span class="line"></span><br><span class="line">/* 数组的拷贝 */</span><br><span class="line"></span><br><span class="line">let arr = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">let newArr = [...arr]; //跟arr.slice()是一样的效果</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>扩展运算符 和 object.assign 有同样的缺陷，也就是实现的浅拷贝的功能差不多，但是如果属性都是基本类型的值，使用扩展运算符进行浅拷贝会更加方便。</li>
</ul>
<ol start="3">
<li>concat 拷贝数组<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">let newArr = arr.concat();</span><br><span class="line"></span><br><span class="line">newArr[1] = 100;</span><br><span class="line"></span><br><span class="line">console.log(arr);  // [ 1, 2, 3 ]</span><br><span class="line"></span><br><span class="line">console.log(newArr); // [ 1, 100, 3 ]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>concat 只能用于数组的浅拷贝，使用场景比较局限。</li>
</ul>
<ol start="4">
<li>slice 拷贝数组</li>
</ol>
<ul>
<li>slice 方法也比较有局限性，因为它仅仅针对数组类型。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, 2, &#123;val: 4&#125;];</span><br><span class="line"></span><br><span class="line">let newArr = arr.slice();</span><br><span class="line"></span><br><span class="line">newArr[2].val = 1000;</span><br><span class="line"></span><br><span class="line">console.log(arr);  //[ 1, 2, &#123; val: 1000 &#125; ]</span><br></pre></td></tr></table></figure>
<ul>
<li>浅拷贝只能拷贝一层对象。如果存在对象的嵌套，那么浅拷贝将无能为力。因此深拷贝就是为了解决这个问题而生的，它能解决多层对象嵌套问题，彻底实现拷贝。</li>
</ul>
<ol start="5">
<li>浅拷贝</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">const shallowClone = (target) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  if (typeof target === &apos;object&apos; &amp;&amp; target !== null) &#123;</span><br><span class="line"></span><br><span class="line">    const cloneTarget = Array.isArray(target) ? []: &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    for (let prop in target) &#123;</span><br><span class="line"></span><br><span class="line">      //是否是自有属性</span><br><span class="line">      if (target.hasOwnProperty(prop)) &#123;</span><br><span class="line"></span><br><span class="line">          cloneTarget[prop] = target[prop];</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return cloneTarget;</span><br><span class="line"></span><br><span class="line">  &#125; else &#123;</span><br><span class="line"></span><br><span class="line">    return target;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><ol>
<li>JSON.stringify()<br><em>弊端</em></li>
</ol>
<ul>
<li>拷贝的对象的值中如果有函数、undefined、symbol 这几种类型，经过 JSON.stringify 序列化之后的字符串中这个键值对会消失；</li>
<li>拷贝 Date 引用类型会变成字符串；</li>
<li>无法拷贝不可枚举的属性；</li>
<li>无法拷贝对象的原型链；</li>
<li>拷贝 RegExp 引用类型会变成空对象；</li>
<li>对象中含有 NaN、Infinity 以及 -Infinity，JSON 序列化的结果会变成 null；</li>
<li>无法拷贝对象的循环应用，即对象成环 (obj[key] = obj)。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">function Obj() &#123; </span><br><span class="line"></span><br><span class="line">  this.func = function () &#123; alert(1) &#125;; </span><br><span class="line"></span><br><span class="line">  this.obj = &#123;a:1&#125;;</span><br><span class="line"></span><br><span class="line">  this.arr = [1,2,3];</span><br><span class="line"></span><br><span class="line">  this.und = undefined; </span><br><span class="line"></span><br><span class="line">  this.reg = /123/; </span><br><span class="line"></span><br><span class="line">  this.date = new Date(0); </span><br><span class="line"></span><br><span class="line">  this.NaN = NaN;</span><br><span class="line"></span><br><span class="line">  this.infinity = Infinity;</span><br><span class="line"></span><br><span class="line">  this.sym = Symbol(1);</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">let obj1 = new Obj();</span><br><span class="line"></span><br><span class="line">Object.defineProperty(obj1,&apos;innumerable&apos;,&#123; </span><br><span class="line"></span><br><span class="line">  enumerable:false,</span><br><span class="line"></span><br><span class="line">  value:&apos;innumerable&apos;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&apos;obj1&apos;,obj1);</span><br><span class="line"></span><br><span class="line">let str = JSON.stringify(obj1);</span><br><span class="line"></span><br><span class="line">let obj2 = JSON.parse(str);</span><br><span class="line"></span><br><span class="line">console.log(&apos;obj2&apos;,obj2);</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 JSON.stringify 方法实现深拷贝对象，虽然到目前为止还有很多无法实现的功能，但是这种方法足以满足日常的开发需求，并且是最简单和快捷的。</li>
</ul>
<ol start="2">
<li>手写递归实现<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">let obj1 = &#123;</span><br><span class="line"></span><br><span class="line">  a:&#123;</span><br><span class="line"></span><br><span class="line">    b:1</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function deepClone(obj) &#123; </span><br><span class="line"></span><br><span class="line">  let cloneObj = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  for(let key in obj) &#123;                 //遍历</span><br><span class="line"></span><br><span class="line">    if(typeof obj[key] ===&apos;object&apos;) &#123; </span><br><span class="line"></span><br><span class="line">      cloneObj[key] = deepClone(obj[key])  //是对象就再次调用该函数递归</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">      cloneObj[key] = obj[key]  //基本类型的话直接复制值</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return cloneObj</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let obj2 = deepClone(obj1);</span><br><span class="line"></span><br><span class="line">obj1.a.b = 2;</span><br><span class="line"></span><br><span class="line">console.log(obj2);   //  &#123;a:&#123;b:1&#125;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><em>弊端</em></p>
<ul>
<li>这个深拷贝函数并不能复制不可枚举的属性以及 Symbol 类型；</li>
<li>这种方法只是针对普通的引用类型的值做递归复制，而对于 Array、Date、RegExp、Error、Function 这样的引用类型并不能正确地拷贝；</li>
<li>对象的属性里面成环，即循环引用没有解决。</li>
</ul>
<ol start="3">
<li>改进后递归实现<br><em>注意点</em></li>
</ol>
<ul>
<li>针对能够遍历对象的不可枚举属性以及 Symbol 类型，我们可以使用 Reflect.ownKeys 方法；</li>
<li>当参数为 Date、RegExp 类型，则直接生成一个新的实例返回；</li>
<li>利用 Object 的 getOwnPropertyDescriptors 方法可以获得对象的所有属性，以及对应的特性，顺便结合 Object 的 create 方法创建一个新对象，并继承传入原对象的原型链；</li>
<li>利用 WeakMap 类型作为 Hash 表，因为 WeakMap 是弱引用类型，可以有效防止内存泄漏（你可以关注一下 Map 和 weakMap 的关键区别，这里要用 weakMap），作为检测循环引用很有帮助，如果存在循环，则引用直接返回 WeakMap 存储的值。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">const isComplexDataType = obj =&gt; (typeof obj === &apos;object&apos; || typeof obj === &apos;function&apos;) &amp;&amp; (obj !== null)</span><br><span class="line"></span><br><span class="line">const deepClone = function (obj, hash = new WeakMap()) &#123;</span><br><span class="line"></span><br><span class="line">  if (obj.constructor === Date) </span><br><span class="line"></span><br><span class="line">  return new Date(obj)       // 日期对象直接返回一个新的日期对象</span><br><span class="line"></span><br><span class="line">  if (obj.constructor === RegExp)</span><br><span class="line"></span><br><span class="line">  return new RegExp(obj)     //正则对象直接返回一个新的正则对象</span><br><span class="line"></span><br><span class="line">  //如果循环引用了就用 weakMap 来解决</span><br><span class="line"></span><br><span class="line">  if (hash.has(obj)) return hash.get(obj)</span><br><span class="line"></span><br><span class="line">  let allDesc = Object.getOwnPropertyDescriptors(obj)</span><br><span class="line"></span><br><span class="line">  //遍历传入参数所有键的特性</span><br><span class="line"></span><br><span class="line">  let cloneObj = Object.create(Object.getPrototypeOf(obj), allDesc)</span><br><span class="line"></span><br><span class="line">  //继承原型链</span><br><span class="line"></span><br><span class="line">  hash.set(obj, cloneObj)</span><br><span class="line"></span><br><span class="line">  for (let key of Reflect.ownKeys(obj)) &#123; </span><br><span class="line"></span><br><span class="line">    cloneObj[key] = (isComplexDataType(obj[key]) &amp;&amp; typeof obj[key] !== &apos;function&apos;) ? deepClone(obj[key], hash) : obj[key]</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return cloneObj</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 下面是验证代码</span><br><span class="line"></span><br><span class="line">let obj = &#123;</span><br><span class="line"></span><br><span class="line">  num: 0,</span><br><span class="line"></span><br><span class="line">  str: &apos;&apos;,</span><br><span class="line"></span><br><span class="line">  boolean: true,</span><br><span class="line"></span><br><span class="line">  unf: undefined,</span><br><span class="line"></span><br><span class="line">  nul: null,</span><br><span class="line"></span><br><span class="line">  obj: &#123; name: &apos;我是一个对象&apos;, id: 1 &#125;,</span><br><span class="line"></span><br><span class="line">  arr: [0, 1, 2],</span><br><span class="line"></span><br><span class="line">  func: function () &#123; console.log(&apos;我是一个函数&apos;) &#125;,</span><br><span class="line"></span><br><span class="line">  date: new Date(0),</span><br><span class="line"></span><br><span class="line">  reg: new RegExp(&apos;/我是一个正则/ig&apos;),</span><br><span class="line"></span><br><span class="line">  [Symbol(&apos;1&apos;)]: 1,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.defineProperty(obj, &apos;innumerable&apos;, &#123;</span><br><span class="line"></span><br><span class="line">  enumerable: false, value: &apos;不可枚举属性&apos; &#125;</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">obj = Object.create(obj, Object.getOwnPropertyDescriptors(obj))</span><br><span class="line"></span><br><span class="line">obj.loop = obj    // 设置loop成循环引用的属性</span><br><span class="line"></span><br><span class="line">let cloneObj = deepClone(obj)</span><br><span class="line"></span><br><span class="line">cloneObj.arr.push(4)</span><br><span class="line"></span><br><span class="line">console.log(&apos;obj&apos;, obj)</span><br><span class="line"></span><br><span class="line">console.log(&apos;cloneObj&apos;, cloneObj)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ol>
<li>原型链继承<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function Parent1() &#123;</span><br><span class="line"></span><br><span class="line">  this.name = &apos;parent1&apos;;</span><br><span class="line"></span><br><span class="line">  this.play = [1, 2, 3]</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child1() &#123;</span><br><span class="line"></span><br><span class="line">  this.type = &apos;child2&apos;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child1.prototype = new Parent1();</span><br><span class="line">let c1=new Child1()</span><br><span class="line">let c2=new Child1()</span><br><span class="line">console.log(c1.__proto__===c2.__proto__); //true</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>两个实例使用的是同一个原型对象。它们的内存空间是共享的，当一个发生变化的时候，另外一个也随之进行了变化，这就是使用原型链继承方式的一个缺点。</p>
<ol start="2">
<li>构造函数继承（借助 call）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">function Parent1()&#123;</span><br><span class="line"></span><br><span class="line">  this.name = &apos;parent1&apos;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Parent1.prototype.getName = function () &#123;</span><br><span class="line"></span><br><span class="line">  return this.name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function Child1()&#123;</span><br><span class="line"></span><br><span class="line">  Parent1.call(this);</span><br><span class="line"></span><br><span class="line">  this.type = &apos;child1&apos;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let child = new Child1();</span><br><span class="line"></span><br><span class="line">console.log(child);  // 没问题</span><br><span class="line"></span><br><span class="line">console.log(child.getName());  // 会报错</span><br></pre></td></tr></table></figure>
<p>构造函数实现继承的优缺点，它使父类的引用属性不会被共享，优化了第一种继承方式的弊端；<br>但是随之而来的缺点也比较明显——只能继承父类的实例属性和方法，不能继承原型属性或者方法。</p>
<ol start="3">
<li><p>组合继承（前两种组合）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">function Parent3 () &#123;</span><br><span class="line"></span><br><span class="line">  this.name = &apos;parent3&apos;;</span><br><span class="line"></span><br><span class="line">  this.play = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Parent3.prototype.getName = function () &#123;</span><br><span class="line"></span><br><span class="line">  return this.name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child3() &#123;</span><br><span class="line"></span><br><span class="line">  // 第二次调用 Parent3()</span><br><span class="line"></span><br><span class="line">  Parent3.call(this);</span><br><span class="line"></span><br><span class="line">  this.type = &apos;child3&apos;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 第一次调用 Parent3()</span><br><span class="line"></span><br><span class="line">Child3.prototype = new Parent3();</span><br><span class="line"></span><br><span class="line">// 手动挂上构造器，指向自己的构造函数</span><br><span class="line"></span><br><span class="line">Child3.prototype.constructor = Child3;</span><br><span class="line"></span><br><span class="line">var s3 = new Child3();</span><br><span class="line"></span><br><span class="line">var s4 = new Child3();</span><br><span class="line"></span><br><span class="line">s3.play.push(4);</span><br><span class="line"></span><br><span class="line">console.log(s3.play, s4.play);  // 不互相影响</span><br><span class="line"></span><br><span class="line">console.log(s3.getName()); // 正常输出&apos;parent3&apos;</span><br><span class="line"></span><br><span class="line">console.log(s4.getName()); // 正常输出&apos;parent3&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>原型式继承</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">let parent4 = &#123;</span><br><span class="line"></span><br><span class="line">  name: &quot;parent4&quot;,</span><br><span class="line"></span><br><span class="line">  friends: [&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;],</span><br><span class="line"></span><br><span class="line">  getName: function() &#123;</span><br><span class="line"></span><br><span class="line">    return this.name;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let person4 = Object.create(parent4);</span><br><span class="line"></span><br><span class="line">person4.name = &quot;tom&quot;;</span><br><span class="line"></span><br><span class="line">person4.friends.push(&quot;jerry&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let person5 = Object.create(parent4);</span><br><span class="line"></span><br><span class="line">person5.friends.push(&quot;lucy&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">console.log(person4.name);</span><br><span class="line"></span><br><span class="line">console.log(person4.name === person4.getName());</span><br><span class="line"></span><br><span class="line">console.log(person5.name);</span><br><span class="line"></span><br><span class="line">console.log(person4.friends);</span><br><span class="line"></span><br><span class="line">console.log(person5.friends);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>最后两个输出结果是一样的，关于引用数据类型“共享”的问题，其实 Object.create 方法是可以为一些对象实现浅拷贝的。<br>关于这种继承方式的缺点也很明显，多个实例的引用类型属性指向相同的内存，存在篡改的可能。</p>
<ol start="5">
<li>寄生式继承</li>
</ol>
<ul>
<li><p>使用原型式继承可以获得一份目标对象的浅拷贝，然后利用这个浅拷贝的能力再进行增强，添加一些方法，这样的继承方式就叫作寄生式继承。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"> let parent5 = &#123;</span><br><span class="line"></span><br><span class="line">  name: &quot;parent5&quot;,</span><br><span class="line"></span><br><span class="line">  friends: [&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;],</span><br><span class="line"></span><br><span class="line">  getName: function() &#123;</span><br><span class="line"></span><br><span class="line">    return this.name;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function clone(original) &#123;</span><br><span class="line"></span><br><span class="line">  let clone = Object.create(original);</span><br><span class="line"></span><br><span class="line">  clone.getFriends = function() &#123;</span><br><span class="line"></span><br><span class="line">    return this.friends;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return clone;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let person5 = clone(parent5);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">console.log(person5.getName());</span><br><span class="line"></span><br><span class="line">console.log(person5.getFriends());</span><br></pre></td></tr></table></figure>
</li>
<li><p>虽然其优缺点和原型式继承一样，但是对于普通对象的继承方式来说，寄生式继承相比于原型式继承，还是在父类基础上添加了更多的方法。</p>
</li>
</ul>
<ol start="6">
<li>寄生组合式继承</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">function clone (parent, child) &#123;</span><br><span class="line"></span><br><span class="line">  // 这里改用 Object.create 就可以减少组合继承中多进行一次构造的过程</span><br><span class="line"></span><br><span class="line">  child.prototype = Object.create(parent.prototype);</span><br><span class="line"></span><br><span class="line">  child.prototype.constructor = child;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function Parent6() &#123;</span><br><span class="line"></span><br><span class="line">  this.name = &apos;parent6&apos;;</span><br><span class="line"></span><br><span class="line">  this.play = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> Parent6.prototype.getName = function () &#123;</span><br><span class="line"></span><br><span class="line">  return this.name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child6() &#123;</span><br><span class="line"></span><br><span class="line">  Parent6.call(this);</span><br><span class="line"></span><br><span class="line">  this.friends = &apos;child5&apos;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">clone(Parent6, Child6);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Child6.prototype.getFriends = function () &#123;</span><br><span class="line"></span><br><span class="line">  return this.friends;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let person6 = new Child6();</span><br><span class="line"></span><br><span class="line">console.log(person6);</span><br><span class="line"></span><br><span class="line">console.log(person6.getName());</span><br><span class="line"></span><br><span class="line">console.log(person6.getFriends());</span><br></pre></td></tr></table></figure>
<ul>
<li>这种寄生组合式继承方式，基本可以解决前几种继承方式的缺点，较好地实现了继承想要的结果，同时也减少了构造次数，减少了性能的开销</li>
</ul>
<ol start="7">
<li>ES6 的 extends 关键字实现逻辑<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line"></span><br><span class="line">  constructor(name) &#123;</span><br><span class="line"></span><br><span class="line">    this.name = name</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 原型方法</span><br><span class="line"></span><br><span class="line">  // 即 Person.prototype.getName = function() &#123; &#125;</span><br><span class="line"></span><br><span class="line">  // 下面可以简写为 getName() &#123;...&#125;</span><br><span class="line"></span><br><span class="line">  getName = function () &#123;</span><br><span class="line"></span><br><span class="line">    console.log(&apos;Person:&apos;, this.name)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Gamer extends Person &#123;</span><br><span class="line"></span><br><span class="line">  constructor(name, age) &#123;</span><br><span class="line"></span><br><span class="line">    // 子类中存在构造函数，则需要在使用“this”之前首先调用 super()。</span><br><span class="line"></span><br><span class="line">    super(name)</span><br><span class="line"></span><br><span class="line">    this.age = age</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const asuna = new Gamer(&apos;Asuna&apos;, 20)</span><br><span class="line"></span><br><span class="line">asuna.getName() // 成功访问到父类的方法</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>利用 babel 这个编译工具，将 ES6 的代码编译成 ES5</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">function _possibleConstructorReturn (self, call) &#123; </span><br><span class="line"></span><br><span class="line">		// ...</span><br><span class="line"></span><br><span class="line">		return call &amp;&amp; (typeof call === &apos;object&apos; || typeof call === &apos;function&apos;) ? call : self; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _inherits (subClass, superClass) &#123; </span><br><span class="line"></span><br><span class="line">    // 这里可以看到</span><br><span class="line"></span><br><span class="line">	subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, &#123; </span><br><span class="line"></span><br><span class="line">		constructor: &#123; </span><br><span class="line"></span><br><span class="line">			value: subClass, </span><br><span class="line"></span><br><span class="line">			enumerable: false, </span><br><span class="line"></span><br><span class="line">			writable: true, </span><br><span class="line"></span><br><span class="line">			configurable: true </span><br><span class="line"></span><br><span class="line">		&#125; </span><br><span class="line"></span><br><span class="line">	&#125;); </span><br><span class="line"></span><br><span class="line">	if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var Parent = function Parent () &#123;</span><br><span class="line"></span><br><span class="line">	// 验证是否是 Parent 构造出来的 this</span><br><span class="line"></span><br><span class="line">	_classCallCheck(this, Parent);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var Child = (function (_Parent) &#123;</span><br><span class="line"></span><br><span class="line">	_inherits(Child, _Parent);</span><br><span class="line"></span><br><span class="line">	function Child () &#123;</span><br><span class="line"></span><br><span class="line">		_classCallCheck(this, Child);</span><br><span class="line"></span><br><span class="line">		return _possibleConstructorReturn(this, (Child.__proto__ || Object.getPrototypeOf(Child)).apply(this, arguments));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	return Child;</span><br><span class="line"></span><br><span class="line">&#125;(Parent));</span><br></pre></td></tr></table></figure>
<p>从上面编译完成的源码中可以看到，它采用的也是寄生组合继承方式，因此也证明了这种方式是较优的解决继承的方式。</p>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><ul>
<li>不管是什么样的计算机程序语言，运行在对应的代码引擎上，对应的使用内存过程大致逻辑是一样的，可以分为这三个步骤：</li>
</ul>
<ol>
<li>分配你所需要的系统内存空间；</li>
<li>使用分配到的内存进行读或者写等操作；</li>
<li>不需要使用内存时，将其空间释放或者归还。</li>
</ol>
<ul>
<li><p>在 JavaScript 中，当我们创建变量（对象，字符串等）的时候，系统会自动给对象分配对应的内存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var a = 123; // 给数值变量分配栈内存</span><br><span class="line"></span><br><span class="line">var etf = &quot;ARK&quot;; // 给字符串分配栈内存</span><br><span class="line"></span><br><span class="line">// 给对象及其包含的值分配堆内存</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line"></span><br><span class="line">  name: &apos;tom&apos;,</span><br><span class="line"></span><br><span class="line">  age: 13</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">// 给数组及其包含的值分配内存（就像对象一样）</span><br><span class="line"></span><br><span class="line">var a = [1, null, &quot;PSAC&quot;]; </span><br><span class="line"></span><br><span class="line">// 给函数（可调用的对象）分配内存</span><br><span class="line"></span><br><span class="line">function sum(a, b)&#123;</span><br><span class="line"></span><br><span class="line">  return a + b;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>栈内存中的基本类型，可以通过操作系统直接处理；<br>而堆内存中的引用类型，正是由于可以经常变化，大小不固定，因此需要 JavaScript 的引擎通过垃圾回收机制来处理。</p>
<h3 id="chrome内存回收机制"><a href="#chrome内存回收机制" class="headerlink" title="chrome内存回收机制"></a>chrome内存回收机制</h3></li>
<li>在 Chrome 浏览器中，JavaScript 的 V8 引擎被限制了内存的使用，根据不同的操作系统（操作系统有 64 位和 32 位的）内存大小会不同，大的可以到 1.4G 的空间，小的只能到 0.7G 的空间。</li>
<li>为什么要去限制内存使用呢？<br>大致是两个原因：V8 最开始是为浏览器而设计的引擎，早些年由于 Web 应用都比较简单，其实并未考虑占据过多的内存空间；<br>另外又由于被 V8 的垃圾回收机制所限制，比如清理大量的内存时会耗费很多时间，这样会引起 JavaScript 执行的线程被挂起，会影响当前执行的页面应用的性能。<h4 id="新生代内存回收"><a href="#新生代内存回收" class="headerlink" title="新生代内存回收"></a>新生代内存回收</h4></li>
<li>新生代的内存回收的空间，在 64 位操作系统下分配为 32MB，正是因为新生代中的变量存活时间短，不太容易产生太大的内存压力，因此不够大也是可以理解的。</li>
<li>系统会将分配给新生代的内存空间分为两部分：正在使用的内存空间[1]，闲置的内存空间[2]<br>当浏览器开始进行内存的垃圾回收时，JavaScript 的 V8 引擎会将[1]的对象检查一遍。如果引擎检测是存活对象，那么会复制到[2]去；如果不是存活的对象，则直接进行系统回收。当所有[1]的对象没有了的时候，等再有新生代的对象产生时，[1][2]对调，这样来循环处理。</li>
<li><code>算法 Scavenge</code>，它主要就是解决内存碎片<h4 id="老生代内存回收"><a href="#老生代内存回收" class="headerlink" title="老生代内存回收"></a>老生代内存回收</h4></li>
<li>新生代中的变量如果经过回收之后依然一直存在，那么就会被放入到老生代内存中。</li>
<li>只要是已经经历过一次 Scavenge 算法回收的，就可以晋升为老生代内存的对象</li>
<li>对于内存空间比较大的，就不适合用 Scavenge 算法了。</li>
<li>老生代内存中的垃圾回收,采用了 <code>Mark-Sweep（标记清除）</code> 和 <code>Mark-Compact（标记整理）</code>的策略</li>
</ul>
<ol>
<li>标记清除（Mark-Sweep）<br>分为两个阶段：标记阶段和清除阶段。<br>首先它会遍历堆上的所有的对象，分别对它们打上标记；然后在代码执行过程结束之后，对使用过的变量取消标记。<br>那么没取消标记的就是没有使用过的变量，因此在清除阶段，就会把还有标记的进行整体清除，从而释放内存空间。</li>
</ol>
<p>通过标记清除之后，还是会出现内存碎片的问题。标记整理策略（Mark-Compact）用来解决内存碎片的问题。</p>
<ol start="2">
<li>标记整理（Mark-Compact）<br>标记整理添加了活动对象整理阶段，处理过程中会将所有的活动对象往一端靠拢，整体移动完成后，直接清理掉边界外的内存。<br>Scavenge 算法比较适合内存较小的情况处理；而对于老生代内存较大、变量较多的时候，还是需要采用“标记-清除”结合“标记-整理”这样的方式处理内存问题，并尽量避免内存碎片的产生。<h3 id="内存泄漏与优化"><a href="#内存泄漏与优化" class="headerlink" title="内存泄漏与优化"></a>内存泄漏与优化</h3></li>
</ol>
<ul>
<li>内存泄漏的场景：</li>
</ul>
<ol>
<li>过多的缓存未释放；</li>
<li>闭包太多未释放；</li>
<li>定时器或者回调太多未释放；</li>
<li>太多无效的 DOM 未释放；</li>
<li>全局变量太多未被发现。</li>
</ol>
<h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><h3 id="时间、空间复杂度"><a href="#时间、空间复杂度" class="headerlink" title="时间、空间复杂度"></a>时间、空间复杂度</h3><p>通常，复杂度的计算方法遵循以下几个原则：</p>
<ol>
<li>首先，复杂度与具体的常系数无关，例如 O(n) 和 O(2n) 表示的是同样的复杂度。<br>我们详细分析下，O(2n) 等于 O(n+n)，也等于 O(n) + O(n)。<br>也就是说，一段 O(n) 复杂度的代码只是先后执行两遍 O(n)，其复杂度是一致的。</li>
<li>其次，多项式级的复杂度相加的时候，选择高者作为结果，例如 O(n²)+O(n) 和 O(n²) 表示的是同样的复杂度。<br>具体分析一下就是，O(n²)+O(n) = O(n²+n)。随着 n 越来越大，二阶多项式的变化率是要比一阶多项式更大的。<br>因此，只需要通过更大变化率的二阶多项式来表征复杂度就可以了。</li>
<li>值得一提的是，O(1) 也是表示一个特殊复杂度，含义为某个任务通过有限可数的资源即可完成。<br>此处有限可数的具体意义是，与输入数据量 n 无关。</li>
<li>一个顺序结构的代码，时间复杂度是 O(1)。</li>
<li>二分查找，或者更通用地说是采用分而治之的二分策略，时间复杂度都是 O(logn)。这个我们会在后续课程讲到。</li>
<li>一个简单的 for 循环，时间复杂度是 O(n)。</li>
<li>两个顺序执行的 for 循环，时间复杂度是 O(n)+O(n)=O(2n)，其实也是 O(n)。</li>
<li>两个嵌套的 for 循环，时间复杂度是 O(n²)。</li>
<li>程序优化的最核心的思路，简单梳理如下：<br>第一步，暴力解法。在没有任何时间、空间约束下，完成代码任务的开发。<br>第二步，无效操作处理。将代码中的无效计算、无效存储剔除，降低时间或空间复杂度。<br>第三步，时空转换。设计合理数据结构，完成时间复杂度向空间复杂度的转移。<h3 id="增删查"><a href="#增删查" class="headerlink" title="增删查"></a>增删查</h3></li>
<li>链表和数组一样，都是 O(n) 空间复杂度的复杂数据结构。但其区别之一就是，数组有 index 的索引，而链表没有。<br>① 有了 index 的索引，所以我们就可以直接进行查找操作来，这里的时间复杂度为 O(1)。<br>② 链表因为没有索引，只能“一个接一个”地按照位置条件查找，在这种情况下时间复杂度就是 O (n)。</li>
<li>数据处理的基本操作只有 3 个，分别是增、删、查。其中，增和删又可以细分为在数据结构中间的增和删，以及在数据结构最后的增和删。<br>区别就在于原数据的位置是否发生改变。查找又可以细分为按照位置条件的查找和按照数据数值特征的查找。<br>几乎所有的数据处理，都是这些基本操作的组合和叠加。<h3 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h3></li>
</ol>
<ul>
<li>最常用的是链式表达，通常也叫作线性链表或者链表。</li>
</ul>
<ol>
<li>虽然链表在新增和删除数据上有优势，但仔细思考就会发现，这个优势并不实用。这主要是因为，在新增数据时，通常会伴随一个查找的动作。例如，在第五个结点后，新增一个新的数据结点，那么执行的操作就包含两个步骤：<br>①第一步，查找第五个结点；<br>②第二步，再新增一个数据结点。整体的复杂度就是 O(n) + O(1)，也就是O(n)。</li>
<li>线性表真正的价值在于，它对数据的存储方式是按照顺序的存储。<br>如果数据的元素个数不确定，且需要经常进行数据的新增和删除时，那么链表会比较合适。<br>如果数据元素大小确定，删除插入的操作并不多，那么数组可能更适合些。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">例 1，链表的翻转。给定一个链表，输出翻转后的链表。例如，输入1 -&gt;2 -&gt; 3 -&gt; 4 -&gt;5，输出 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1。</span><br><span class="line">我们来仔细看一下这个问题的难点在哪里，这里有两种情况：</span><br><span class="line">如果是数组的翻转，这会非常容易。原因在于，数组在连续的空间进行存储，可以直接求解出数组的长度。而且，数组可以通过索引值去查找元素，然后对相应的数据进行交换操作而完成翻转。</span><br><span class="line">但对于某个单向链表，它的指针结构造成了它的数据通路有去无回，一旦修改了某个指针，后面的数据就会造成失联的状态。为了解决这个问题，我们需要构造三个指针 prev、curr 和 next，对当前结点、以及它之前和之后的结点进行缓存，再完成翻转动作。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">例 2，给定一个奇数个元素的链表，查找出这个链表中间位置的结点的数值。</span><br><span class="line">这个问题也是利用了链表的长度无法直接获取的不足做文章，解决办法如下：</span><br><span class="line">一个暴力的办法是，先通过一次遍历去计算链表的长度，这样我们就知道了链表中间位置是第几个。接着再通过一次遍历去查找这个位置的数值。</span><br><span class="line">除此之外，还有一个巧妙的办法，就是利用快慢指针进行处理。其中快指针每次循环向后跳转两次，而慢指针每次向后跳转一次。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">例 3，判断链表是否有环。</span><br><span class="line">假设链表有环，这个环里面就像是一个跑步赛道的操场一样。经过多次循环之后，快指针和慢指针都会进入到这个赛道中，就好像两个跑步选手在比赛。</span><br><span class="line">快指针每次走两格，而慢指针每次走一格，相对而言，快指针每次循环会多走一步。</span><br><span class="line">这就意味着：如果链表存在环，快指针和慢指针一定会在环内相遇，即 fast == slow 的情况一定会发生。</span><br><span class="line">反之，则最终会完成循环，二者从未相遇。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><h4 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h4><ol>
<li>栈的顺序存储可以借助数组来实现。一般来说，会把数组的首元素存在栈底，最后一个元素放在栈顶。<br>然后定义一个 top 指针来指示栈顶元素在数组中的位置。假设栈中只有一个数据元素，则 top = 0。<br>一般以 top 是否为 -1 来判定是否为空栈。<br>当定义了栈的最大容量为 StackSize 时，则栈顶 top 必须小于 StackSize。</li>
<li>对于查找操作，栈没有额外的改变，跟线性表一样，它也需要遍历整个栈来完成基于某些条件的数值查找。</li>
<li>删除数据元素，即出栈操作，只需要 top - 1 就可以了。<h4 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h4></li>
<li>关于链式栈，就是用链表的方式对栈的表示。</li>
<li>在链式栈中进行删除操作时，只能在栈顶进行操作。因此，将栈顶的 top 指针指向栈顶元素的 next 指针即可完成删除。</li>
<li>对于链式栈来说，新增删除数据元素没有任何循环操作，其时间复杂度均为 O(1)。</li>
</ol>
<ul>
<li>不管是顺序栈还是链栈，数据的新增、删除、查找与线性表的操作原理极为相似，时间复杂度完全一样，都依赖当前位置的指针来进行数据对象的操作。区别仅仅在于新增和删除的对象，只能是栈顶的数据结点。<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3>队列也存在这两种存储方式，即顺序队列和链式队列：</li>
</ul>
<ol>
<li>顺序队列，依赖数组来实现，其中的数据在内存中也是顺序存储。</li>
<li>而链式队列，则依赖链表来实现，其中的数据依赖每个结点的指针互联，在内存中并不是顺序存储。链式队列，实际上就是只能尾进头出的线性表的单链表。</li>
<li>队列从队头（front）删除元素，从队尾（rear）插入元素。</li>
<li>队列新增数据的操作，就是利用 rear 指针在队尾新增一个数据元素。这个过程不会影响其他数据，时间复杂度为 O(1)</li>
<li>队列删除数据的操作与栈不同。队列元素出口在队列头部，即下标为 0 的位置。当利用 front 指针删除一个数据时，队列中剩余的元素都需要向前移动一个位置，以保证队列头部下标为 0 的位置不为空，此时时间复杂度就变成 O(n) <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">采用顺序存储的队列时，我们可以通过移动指针的方式来删除数据，这样就不需要移动剩余的数据了。</span><br><span class="line">但是，这样的操作，也可能会产生数组越界的问题。</span><br><span class="line">两个简单粗暴的解决方法就是：</span><br><span class="line">1. 不惜消耗 O(n) 的时间复杂度去移动数据；</span><br><span class="line">2. 或者开辟足够大的内存空间确保数组不会越界。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h4><ol>
<li>循环队列进行新增数据元素操作时，首先判断队列是否为满。<br>如果不满，则可以将新元素赋值给队尾，然后让 rear 指针向后移动一个位置。<br>如果已经排到队列最后的位置，则 rea r指针重新指向头部。</li>
<li>循环队列进行删除操作时，即出队列操作，需要判断队列是否为空，然后将队头元素赋值给返回值，front 指针向后移一个位置。<br>如果已经排到队列最后的位置，就把 front 指针重新指向到头部。<br>这个过程就好像钟表的指针转到了表盘的尾部 12 点的位置后，又重新回到了表盘头部 1 点钟的位置。<br>这样就能在不开辟大量存储空间的前提下，不采用 O(n) 的操作，也能通过移动数据来完成频繁的新增和删除数据。</li>
<li>此时，又会产生新的问题，即当队列为空时，有 front 指针和 rear 指针相等。<br>而现在的队列是满的，同样有 front 指针和 rear 指针相等。<br>那么怎样判断队列到底是空还是满呢？常用的方法是，设置一个标志变量 flag 来区别队列是空还是满。<h4 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h4></li>
<li>链式队列就是一个单链表，同时增加了 front 指针和 rear 指针。<br>链式队列和单链表一样，通常会增加一个头结点，并另 front 指针指向头结点。<br>头结点不存储数据，只是用来辅助标识。</li>
<li>特别值得一提的是，如果这个链表除去头结点外只剩一个元素，那么删除仅剩的一个元素后，rear 指针就变成野指针了。<br>这时候，需要让 rear 指针指向头结点。也许你前面会对头结点存在的意义产生怀疑，似乎没有它也不影响增删的操作。</li>
<li>那么为何队列还特被强调要有头结点呢？<br>这主要是为了防止删除最后一个有效数据结点后， front 指针和 rear 指针变成野指针，导致队列没有意义了。<br>有了头结点后，哪怕队列为空，头结点依然存在，能让 front 指针和 rear 指针依然有意义。</li>
</ol>
<ul>
<li>空间性能方面，循环队列必须有一个固定的长度，因此存在存储元素数量和空间的浪费问题，而链式队列不存在这种问题，所以在空间上，链式队列更为灵活一些。</li>
<li>通常情况下，在可以确定队列长度最大值时，建议使用循环队列。无法确定队列长度时，应考虑使用链式队列。队列具有先进先出的特点，很像现实中人们排队买票的场景。在面对数据处理顺序非常敏感的问题时，队列一定是个不错的技术选型。<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3></li>
<li>树是由结点和边组成的，不存在环的一种数据结构。</li>
<li>没有父结点，则可以称为根结点</li>
<li>没有子结点，则称为叶子结点</li>
<li>树中结点的最大层次数，就是这棵树的树深（称为深度，也称为高度）</li>
<li>树数据的查找操作和链表一样，都需要遍历每一个数据去判断，所以时间复杂度是 O(n)。</li>
<li>对于查找操作，如果是普通二叉树，则查找的时间复杂度和遍历一样，都是 O(n)。如果是二叉查找树，则可以在 O(logn) 的时间复杂度内完成查找动作。<h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4></li>
<li>在二叉树中，每个结点最多有两个分支，即每个结点最多有两个子结点，分别称作左子结点和右子结点。</li>
<li>满二叉树，定义为除了叶子结点外，所有结点都有 2 个子结点。</li>
<li>完全二叉树，定义为除了最后一层以外，其他层的结点个数都达到最大，并且最后一层的叶子结点都靠左排列。之所以称为完全二叉树，是从存储空间利用效率的视角来看的。对于一棵完全二叉树而言，仅仅浪费了下标为 0 的存储位置。而如果是一棵非完全二叉树，则会浪费大量的存储空间。</li>
<li>存储二叉树有两种办法，一种是基于指针的链式存储法，另一种是基于数组的顺序存储法。</li>
<li>根据基于数组的顺序存储法，我们可以发现如果结点 X 的下标为 i，那么 X 的左子结点总是存放在 2 <em> i 的位置，X 的右子结点总是存放在 2 </em> i + 1 的位置。<h5 id="二叉查找树（二叉搜索树）"><a href="#二叉查找树（二叉搜索树）" class="headerlink" title="二叉查找树（二叉搜索树）"></a>二叉查找树（二叉搜索树）</h5></li>
<li>在二叉查找树中的任意一个结点，其左子树中的每个结点的值，都要小于这个结点的值。</li>
<li>在二叉查找树中的任意一个结点，其右子树中每个结点的值，都要大于这个结点的值。</li>
<li>在二叉查找树中，会尽可能规避两个结点数值相等的情况。</li>
<li>对二叉查找树进行中序遍历，就可以输出一个从小到大的有序数据队列。</li>
<li>在利用二叉查找树执行查找操作时，我们可以进行以下判断：</li>
</ul>
<ol>
<li>首先判断根结点是否等于要查找的数据，如果是就返回。</li>
<li>如果根结点大于要查找的数据，就在左子树中递归执行查找动作，直到叶子结点。</li>
<li>如果根结点小于要查找的数据，就在右子树中递归执行查找动作，直到叶子结点。</li>
<li>这样的“二分查找”所消耗的时间复杂度就可以降低为 O(logn)。</li>
</ol>
<ul>
<li>二叉查找树插入数据的时间复杂度是 O(logn)。但这并不意味着它比普通二叉树要复杂。原因在于这里的时间复杂度更多是消耗在了遍历数据去找到查找位置上，真正执行插入动作的时间复杂度仍然是 O(1)。</li>
<li>二叉查找树的删除操作会比较复杂，这是因为删除完某个结点后的树，仍然要满足二叉查找树的性质。</li>
</ul>
<ol>
<li>情况一，如果要删除的结点是某个叶子结点，则直接删除，将其父结点指针指向 null 即可。</li>
<li>情况二，如果要删除的结点只有一个子结点，只需要将其父结点指向的子结点的指针换成其子结点的指针即可。</li>
<li>情况三，如果要删除的结点有两个子结点，则有两种可行的操作方式。①找到这个结点的左子树中最大的结点，替换要删除的结点。②找到这个结点的右子树中最小的结点，替换要删除的结点。<h5 id="Trie-树，或字典树"><a href="#Trie-树，或字典树" class="headerlink" title="Trie 树，或字典树"></a>Trie 树，或字典树</h5></li>
</ol>
<ul>
<li>根结点不包含字符</li>
<li>除根结点外每一个结点都只包含一个字符；</li>
<li>从根结点到某一叶子结点，路径上经过的字符连接起来，即为集合中的某个字符串。<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3></li>
<li>哈希表的设计采用了函数映射的思想，将记录的存储位置与记录的关键字关联起来。这样的设计方式，能够快速定位到想要查找的记录，而且不需要与表中存在的记录的关键字比较后再来进行查找。</li>
<li>如果有一种方法，可以实现“地址 = f (关键字)”的映射关系，那么就可以快速完成基于数据的数值的查找了。这就是哈希表的核心思想</li>
<li>Hash 函数设计的好坏会直接影响到对哈希表的操作效率。</li>
<li>哈希冲突，是需要在设计哈希函数时进行规避的</li>
<li>常用的设计哈希函数的方法：</li>
</ul>
<ol>
<li>直接定制法<br>哈希函数为关键字到地址的线性函数。如，H (key) = a*key + b。 这里，a 和 b 是设置好的常数。</li>
<li>数字分析法<br>假设关键字集合中的每个关键字 key 都是由 s 位数字组成（k1,k2,…,Ks），并从中提取分布均匀的若干位组成哈希地址。上面张一、张二、张三、张四的手机号信息存储，就是使用的这种方法。</li>
<li>平方取中法<br>如果关键字的每一位都有某些数字重复出现，并且频率很高，我们就可以先求关键字的平方值，通过平方扩大差异，然后取中间几位作为最终存储地址。</li>
<li>折叠法<br>如果关键字的位数很多，可以将关键字分割为几个等长的部分，取它们的叠加和的值（舍去进位）作为哈希地址。</li>
<li>除留余数法<br>预先设置一个数 p，然后对关键字进行取余运算。即地址为 key mod p。</li>
</ol>
<ul>
<li>解决哈希冲突</li>
</ul>
<ol>
<li>开放定址法<br>即当一个关键字和另一个关键字发生冲突时，使用某种探测技术在哈希表中形成一个探测序列，然后沿着这个探测序列依次查找下去。当碰到一个空的单元时，则插入其中。<br>常用的探测方法是线性探测法。<br>比如有一组关键字 {12，13，25，23}，采用的哈希函数为 key mod 11。<br>当插入 12，13，25 时可以直接插入，地址分别为 1、2、3。而当插入 23 时，哈希地址为 23 mod 11 = 1。然而，地址 1 已经被占用，因此沿着地址 1 依次往下探测，直到探测到地址 4，发现为空，则将 23 插入其中。</li>
<li>链地址法<br>将哈希地址相同的记录存储在一张线性链表中。</li>
</ol>
<ul>
<li>哈希表相对于其他数据结构有很多的优势。它可以提供非常快速的插入-删除-查找操作，无论多少数据，插入和删除值需要接近常量的时间。在查找方面，哈希表的速度比树还要快，基本可以瞬间查找到想要的元素。</li>
<li>哈希表也有一些不足。哈希表中的数据是没有顺序概念的，所以不能以一种固定的方式（比如从小到大）来遍历其中的元素。在数据处理顺序敏感的问题时，选择哈希表并不是个好的处理方法。同时，哈希表中的 key 是不允许重复的，在重复性非常高的数据中，哈希表也不是个好的选择。<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3></li>
<li>递归的核心思想是把规模大的问题转化为规模小的相似的子问题来解决。</li>
<li>当一个问题同时满足以下 2 个条件时，就可以使用递归的方法求解：</li>
</ul>
<ol>
<li>可以拆解为除了数据规模以外，求解思路完全相同的子问题；</li>
<li>存在终止条件。<h3 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h3></li>
</ol>
<ul>
<li>分治法的核心思想就是“分而治之”。</li>
<li>利用分而治之的思想，就可以把一个大规模、高难度的问题，分解为若干个小规模、低难度的小问题。随后，开发者将面对多个简单的问题，并很快地找到答案各个击破。在把这些简单问题解决好之后，我们通过把这些小问题的答案合并，就得到了原问题的答案。</li>
<li>二分查找，则是利用分治法去解决查找问题。通常二分查找需要一个前提，那就是输入的数列是有序的。</li>
<li>二分查找的时间复杂度是 O(logn)，这也是分治法普遍具备的特性。当你面对某个代码题，而且约束了时间复杂度是 O(logn) 或者是 O(nlogn) 时，可以想一下分治法是否可行。</li>
<li>二分查找的循环次数并不确定。一般是达到某个条件就跳出循环。因此，编码的时候，多数会采用 while 循环加 break 跳出的代码结构。</li>
<li>二分查找处理的原问题必须是有序的。因此，当你在一个有序数据环境中处理问题时，可以考虑分治法。相反，如果原问题中的数据并不是有序的，则使用分治法的可能性就会很低了。<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3></li>
<li>衡量一个排序算法的优劣，我们主要会从以下 3 个角度进行分析：</li>
</ul>
<ol>
<li>时间复杂度，具体包括，最好时间复杂度、最坏时间复杂度以及平均时间复杂度。</li>
<li>空间复杂度，如果空间复杂度为 1，也叫作原地排序。</li>
<li>稳定性，排序的稳定性是指相等的数据对象，在排序之后，顺序是否能保证不变。</li>
<li>排序最暴力的方法，时间复杂度是 O(n*n)。这恰如冒泡排序和插入排序。</li>
<li>当我们利用算法思维去解决问题时，就会想到尝试分治法。此时，利用归并排序就能让时间复杂度降低到 O(nlogn)。然而，归并排序需要额外开辟临时空间。一方面是为了保证稳定性，另一方面则是在归并时，由于在数组中插入元素导致了数据挪移的问题。</li>
<li>为了规避因此而带来的时间损耗，此时我们采用快速排序。通过交换操作，可以解决插入元素导致的数据挪移问题，而且降低了不必要的空间开销。但是由于其动态二分的交换数据，导致了由此得出的排序结果并不稳定。</li>
<li>如果对数据规模比较小的数据进行排序，可以选择时间复杂度为 O(n<em>n) 的排序算法。因为当数据规模小的时候，时间复杂度 O(nlogn) 和 O(n</em>n) 的区别很小，它们之间仅仅相差几十毫秒，因此对实际的性能影响并不大。</li>
<li>但对数据规模比较大的数据进行排序，就需要选择时间复杂度为 O(nlogn) 的排序算法了。归并排序的空间复杂度为 O(n)，也就意味着当排序 100M 的数据，就需要 200M 的空间，所以对空间资源消耗会很多。快速排序在平均时间复杂度为 O(nlogn)，但是如果分区点选择不好的话，最坏的时间复杂度也有可能逼近 O(n*n)。而且快速排序不具备稳定性，这也需要看你所面对的问题是否有稳定性的需求。<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4></li>
</ol>
<ul>
<li>冒泡排序最好时间复杂度是 O(n)，也就是当输入数组刚好是顺序的时候，只需要挨个比较一遍就行了，不需要做交换操作，所以时间复杂度为 O(n)。</li>
<li>冒泡排序最坏时间复杂度会比较惨，是 O(n<em>n)。也就是说当数组刚好是完全逆序的时候，每轮排序都需要挨个比较 n 次，并且重复 n 次，所以时间复杂度为 O(n</em>n)。</li>
<li>很显然，当输入数组杂乱无章时，它的平均时间复杂度也是 O(n*n)。</li>
<li>冒泡排序不需要额外的空间，所以空间复杂度是 O(1)。冒泡排序过程中，当元素相同时不做交换，所以冒泡排序是稳定的排序算法。<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4></li>
<li>选取未排序的元素，插入到已排序区间的合适位置，直到未排序区间为空。插入排序顾名思义，就是从左到右维护一个已经排好序的序列。直到所有的待排数据全都完成插入的动作。</li>
<li>插入排序最好时间复杂度是 O(n)，即当数组刚好是完全顺序时，每次只用比较一次就能找到正确的位置。这个过程重复 n 次，就可以清空未排序区间。</li>
<li>插入排序最坏时间复杂度则需要 O(n<em>n)。即当数组刚好是完全逆序时，每次都要比较 n 次才能找到正确位置。这个过程重复 n 次，就可以清空未排序区间，所以最坏时间复杂度为 O(n</em>n)。</li>
<li>插入排序的平均时间复杂度是 O(n<em>n)。这是因为往数组中插入一个元素的平均时间复杂度为 O(n)，而插入排序可以理解为重复 n 次的数组插入操作，所以平均时间复杂度为 O(n</em>n)。</li>
<li>插入排序不需要开辟额外的空间，所以空间复杂度是 O(1)。<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4></li>
<li>归并排序法的原理是分治法。</li>
<li>对于归并排序，它采用了二分的迭代方式，复杂度是 logn。</li>
<li>每次的迭代，需要对两个有序数组进行合并，这样的动作在 O(n) 的时间复杂度下就可以完成。因此，归并排序的复杂度就是二者的乘积 O(nlogn)。同时，它的执行频次与输入序列无关，因此，归并排序最好、最坏、平均时间复杂度都是 O(nlogn)。</li>
<li>空间复杂度方面，由于每次合并的操作都需要开辟基于数组的临时内存空间，所以空间复杂度为 O(n)。归并排序合并的时候，相同元素的前后顺序不变，所以归并是稳定的排序算法。<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4></li>
<li>快速排序法的原理也是分治法。</li>
<li>的每轮迭代，会选取数组中任意一个数据作为分区点，将小于它的元素放在它的左侧，大于它的放在它的右侧。再利用分治思想，继续分别对左右两侧进行同样的操作，直至每个区间缩小为 1，则完成排序。</li>
<li>在快排的最好时间的复杂度下，如果每次选取分区点时，都能选中中位数，把数组等分成两个，那么此时的时间复杂度和归并一样，都是 O(n*logn)。</li>
<li>而在最坏的时间复杂度下，也就是如果每次分区都选中了最小值或最大值，得到不均等的两组。那么就需要 n 次的分区操作，每次分区平均扫描 n / 2 个元素，此时时间复杂度就退化为 O(n*n) 了。</li>
<li>快速排序法在大部分情况下，统计上是很难选到极端情况的。因此它平均的时间复杂度是 O(n*logn)。</li>
<li>快速排序法的空间方面，使用了交换法，因此空间复杂度为 O(1)。</li>
<li>很显然，快速排序的分区过程涉及交换操作，所以快排是不稳定的排序算法。<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3></li>
<li>从数学的视角来看，动态规划是一种运筹学方法，是在多轮决策过程中的最优方法。</li>
<li>从分治法的视角来看，每个子问题必须相互独立。但在多轮决策中，这个假设显然不成立。这也是动态规划方法产生的原因之一。</li>
<li>动态规划有一个重要概念叫作状态。</li>
<li>一般而言，具有如下几个特征的问题，可以采用动态规划求解：</li>
</ul>
<ol>
<li>最优子结构。它的含义是，原问题的最优解所包括的子问题的解也是最优的。例如，某个策略使得 A 到 G 是最优的。假设它途径了 Fi，那么它从 A 到 Fi 也一定是最优的。</li>
<li>无后效性。某阶段的决策，无法影响先前的状态。可以理解为今天的动作改变不了历史。</li>
<li>有重叠子问题。也就是，子问题之间不独立。这个性质是动态规划区别于分治法的条件。如果原问题不满足这个特征，也是可以用动态规划求解的，无非就是杀鸡用了宰牛刀。<h2 id="new-apply-call-bind"><a href="#new-apply-call-bind" class="headerlink" title="new/apply/call/bind"></a>new/apply/call/bind</h2><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3></li>
</ol>
<ul>
<li>new 关键词的主要作用就是执行一个构造函数、返回一个实例对象，在 new 的过程中，根据构造函数的情况，来确定是否可以接受参数的传递。</li>
<li>new 在这个生成实例的过程中,大致分为以下几个步骤:</li>
</ul>
<ol>
<li>创建一个新对象；</li>
<li>将构造函数的作用域赋给新对象（this 指向新对象）；</li>
<li>执行构造函数中的代码（为这个新对象添加属性）；</li>
<li>返回新对象。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//如果不用 new 这个关键词，会发生什么样的变化呢？</span><br><span class="line">function Person()&#123;</span><br><span class="line"></span><br><span class="line">  this.name = &apos;Jack&apos;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p = Person();</span><br><span class="line"></span><br><span class="line">console.log(p) // undefined</span><br><span class="line"></span><br><span class="line">console.log(name) // Jack</span><br><span class="line"></span><br><span class="line">console.log(p.name) // &apos;name&apos; of undefined</span><br><span class="line"></span><br><span class="line">//当构造函数中有 return 一个对象的操作，结果又会是什么样子呢？</span><br><span class="line">function Person()&#123;</span><br><span class="line"></span><br><span class="line">   this.name = &apos;Jack&apos;; </span><br><span class="line"></span><br><span class="line">   return &#123;age: 18&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p = new Person(); </span><br><span class="line"></span><br><span class="line">console.log(p)  // &#123;age: 18&#125;</span><br><span class="line"></span><br><span class="line">console.log(p.name) // undefined</span><br><span class="line"></span><br><span class="line">console.log(p.age) // 18</span><br></pre></td></tr></table></figure>
<ul>
<li><p>构造函数必须是返回一个对象，如果返回的不是对象，那么还是会按照 new 的实现步骤，返回新生成的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line"></span><br><span class="line">   this.name = &apos;Jack&apos;; </span><br><span class="line"></span><br><span class="line">   return &apos;tom&apos;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p = new Person(); </span><br><span class="line"></span><br><span class="line">console.log(p)  // &#123;name: &apos;Jack&apos;&#125;</span><br><span class="line"></span><br><span class="line">console.log(p.name) // Jack</span><br></pre></td></tr></table></figure>
</li>
<li><p>new 关键词执行之后总是会返回一个对象，要么是实例对象，要么是 return 语句指定的对象。</p>
<h3 id="call-apply-bind"><a href="#call-apply-bind" class="headerlink" title="call/apply/bind"></a>call/apply/bind</h3></li>
<li><p>call、apply 和 bind 是挂在 Function 对象上的三个方法，调用这三个方法的必须是一个函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func.call(thisArg, param1, param2, ...)</span><br><span class="line"></span><br><span class="line">func.apply(thisArg, [param1,param2,...])</span><br><span class="line"></span><br><span class="line">func.bind(thisArg, param1, param2, ...)</span><br></pre></td></tr></table></figure>
</li>
<li><p>bind 虽然改变了 func 的 this 指向，但不是马上执行，而这两个（call、apply）是在改变了函数的 this 指向之后立马执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">let a = &#123;</span><br><span class="line"></span><br><span class="line">  name: &apos;jack&apos;,</span><br><span class="line"></span><br><span class="line">  getName: function(msg) &#123;</span><br><span class="line"></span><br><span class="line">    return msg + this.name;</span><br><span class="line"></span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let b = &#123;</span><br><span class="line"></span><br><span class="line">  name: &apos;lily&apos;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(a.getName(&apos;hello~&apos;));  // hello~jack</span><br><span class="line"></span><br><span class="line">console.log(a.getName.call(b, &apos;hi~&apos;));  // hi~lily</span><br><span class="line"></span><br><span class="line">console.log(a.getName.apply(b, [&apos;hi~&apos;]))  // hi~lily</span><br><span class="line"></span><br><span class="line">let name = a.getName.bind(b, &apos;hello~&apos;);</span><br><span class="line"></span><br><span class="line">console.log(name());  // hello~lily</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="手写实现"><a href="#手写实现" class="headerlink" title="手写实现"></a>手写实现</h3><h4 id="new-1"><a href="#new-1" class="headerlink" title="new"></a>new</h4><ul>
<li>new 被调用后大致做了哪几件事情。</li>
</ul>
<ol>
<li>让实例可以访问到私有属性；</li>
<li>让实例可以访问构造函数原型（constructor.prototype）所在原型链上的属性；</li>
<li>构造函数返回的最后结果是引用数据类型。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function _new(ctor, ...args) &#123;</span><br><span class="line"></span><br><span class="line">    if(typeof ctor !== &apos;function&apos;) &#123;</span><br><span class="line"></span><br><span class="line">      throw &apos;ctor must be a function&apos;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let obj = new Object();</span><br><span class="line"></span><br><span class="line">    obj.__proto__ = Object.create(ctor.prototype);</span><br><span class="line"></span><br><span class="line">    //关键  this指向</span><br><span class="line">    let res = ctor.apply(obj,  [...args]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    let isObject = typeof res === &apos;object&apos; &amp;&amp; res !== null;</span><br><span class="line"></span><br><span class="line">    let isFunction = typeof res === &apos;function&apos;;</span><br><span class="line"></span><br><span class="line">    return isObject || isFunction ? res : obj;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="call-apply"><a href="#call-apply" class="headerlink" title="call/apply"></a>call/apply</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.call = function (context, ...args) &#123;</span><br><span class="line"></span><br><span class="line">  var context = context || window;</span><br><span class="line">  //当前this指向Function.prototype上面的方法</span><br><span class="line">  context.fn = this;</span><br><span class="line"></span><br><span class="line">  var result = eval(&apos;context.fn(...args)&apos;);</span><br><span class="line"></span><br><span class="line">  delete context.fn</span><br><span class="line"></span><br><span class="line">  return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Function.prototype.apply = function (context, args) &#123;</span><br><span class="line"></span><br><span class="line">  let context = context || window;</span><br><span class="line">  //当前this指向Function.prototype上面的方法</span><br><span class="line">  context.fn = this;</span><br><span class="line"></span><br><span class="line">  let result = eval(&apos;context.fn(...args)&apos;);</span><br><span class="line"></span><br><span class="line">  delete context.fn</span><br><span class="line"></span><br><span class="line">  return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind = function (context, ...args) &#123;</span><br><span class="line"></span><br><span class="line">    if (typeof this !== &quot;function&quot;) &#123;</span><br><span class="line"></span><br><span class="line">      throw new Error(&quot;this must be a function&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var self = this;</span><br><span class="line"></span><br><span class="line">    var fbound = function () &#123;</span><br><span class="line"></span><br><span class="line">        self.apply(this instanceof fbound ? this : context, args.concat(Array.prototype.slice.call(arguments)));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(this.prototype) &#123;</span><br><span class="line"></span><br><span class="line">      fbound.prototype = Object.create(this.prototype);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return fbound;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//new (Math.max.bind(this))();</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>方法特征</th>
<th>call</th>
<th>apply</th>
<th>bind</th>
</tr>
</thead>
<tbody>
<tr>
<td>方法参数</td>
<td>多个</td>
<td>单个数组</td>
<td>多个</td>
</tr>
<tr>
<td>方法功能</td>
<td>函数调用改变this</td>
<td>函数调用改变this</td>
<td>函数调用改变this</td>
</tr>
<tr>
<td>返回结果</td>
<td>直接执行</td>
<td>直接执行</td>
<td>返回待执行函数</td>
</tr>
<tr>
<td>底层实现</td>
<td>通过eval</td>
<td>通过eval</td>
<td>间接调用apply</td>
</tr>
</tbody>
</table>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><ul>
<li>红宝书闭包的定义：闭包是指有权访问另外一个函数作用域中的变量的函数。MDN：一个函数和对其周围状态的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。</li>
<li>作用域链，即当前函数一般都会存在上层函数的作用域的引用，那么他们就形成了一条作用域链。 </li>
<li><p>闭包产生的本质就是：当前环境中存在指向父级作用域的引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">function fun1() &#123;</span><br><span class="line"></span><br><span class="line">  var a = 2</span><br><span class="line"></span><br><span class="line">  function fun2() &#123;</span><br><span class="line"></span><br><span class="line">    console.log(a);  //2</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return fun2;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var result = fun1();</span><br><span class="line"></span><br><span class="line">result();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">是不是只有返回函数才算是产生了闭包呢？其实也不是，回到闭包的本质，我们只需要让父级作用域的引用存在即可，因此还可以这么改代码，如下所示。</span><br><span class="line"></span><br><span class="line">var fun3;</span><br><span class="line"></span><br><span class="line">function fun1() &#123;</span><br><span class="line"></span><br><span class="line">  var a = 2</span><br><span class="line"></span><br><span class="line">  fun3 = function() &#123;</span><br><span class="line"></span><br><span class="line">    console.log(a);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun1();</span><br><span class="line"></span><br><span class="line">fun3();</span><br></pre></td></tr></table></figure>
</li>
<li><p>闭包的表现形式</p>
</li>
</ul>
<ol>
<li>返回一个函数</li>
<li><p>在定时器、事件监听、Ajax 请求、Web Workers 或者任何异步中，只要使用了回调函数，实际上就是在使用闭包。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 定时器</span><br><span class="line"></span><br><span class="line">setTimeout(function handler()&#123;</span><br><span class="line"></span><br><span class="line">  console.log(&apos;1&apos;);</span><br><span class="line"></span><br><span class="line">&#125;，1000);</span><br><span class="line"></span><br><span class="line">// 事件监听</span><br><span class="line"></span><br><span class="line">$(&apos;#app&apos;).click(function()&#123;</span><br><span class="line"></span><br><span class="line">  console.log(&apos;Event Listener&apos;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>作为函数参数传递的形式</p>
</li>
<li>IIFE（立即执行函数），创建了闭包，保存了全局作用域（window）和当前函数的作用域，因此可以输出全局的变量<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a = 2;</span><br><span class="line"></span><br><span class="line">(function IIFE()&#123;</span><br><span class="line"></span><br><span class="line">  console.log(a);  // 输出2</span><br><span class="line"></span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">IIFE 这个函数会稍微有些特殊，算是一种自执行匿名函数，这个匿名函数拥有独立的作用域。这不仅可以避免了外界访问此 IIFE 中的变量，而且又不会污染全局作用域，</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>如何解决循环输出问题？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">for(var i = 1; i &lt;= 5; i ++)&#123;</span><br><span class="line"></span><br><span class="line">  setTimeout(function() &#123;</span><br><span class="line"></span><br><span class="line">    console.log(i)</span><br><span class="line"></span><br><span class="line">  &#125;, 0)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">1.setTimeout 为宏任务，由于 JS 中单线程 eventLoop 机制，在主线程同步任务执行完后才去执行宏任务，因此循环结束后 setTimeout 中的回调才依次执行。</span><br><span class="line">2.因为 setTimeout 函数也是一种闭包，往上找它的父级作用域链就是 window，变量 i 为 window 上的全局变量，开始执行 setTimeout 之前变量 i 已经就是 6 了，因此最后输出的连续就都是 6。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li><p>利用 IIFE</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">for(var i = 1;i &lt;= 5;i++)&#123;</span><br><span class="line"></span><br><span class="line">  (function(j)&#123;</span><br><span class="line"></span><br><span class="line">    setTimeout(function timer()&#123;</span><br><span class="line"></span><br><span class="line">      console.log(j)</span><br><span class="line"></span><br><span class="line">    &#125;, 0)</span><br><span class="line"></span><br><span class="line">  &#125;)(i)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 ES6 中的 let</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for(let i = 1; i &lt;= 5; i++)&#123;</span><br><span class="line"></span><br><span class="line">  setTimeout(function() &#123;</span><br><span class="line"></span><br><span class="line">    console.log(i);</span><br><span class="line"></span><br><span class="line">  &#125;,0)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">ES6 中新增的 let 定义变量的方式，使得 ES6 之后 JS 发生革命性的变化，让 JS 有了块级作用域，代码的作用域以块级为单位进行执行。</span><br></pre></td></tr></table></figure>
</li>
<li><p>定时器传入第三个参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for(var i=1;i&lt;=5;i++)&#123;</span><br><span class="line"></span><br><span class="line">  setTimeout(function(j) &#123;</span><br><span class="line"></span><br><span class="line">    console.log(j)</span><br><span class="line"></span><br><span class="line">  &#125;, 0, i)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>由于闭包会使一些变量一直保存在内存中不会自动释放，所以如果大量使用的话就会消耗大量内存，从而影响网页性能。<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><h3 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse"></a>JSON.parse</h3></li>
<li><code>JSON.parse(text[, reviver])</code>第一个参数是需要解析处理的 JSON 字符串，第二个参数是可选参数提供可选的 reviver 函数，用在返回之前对所得到的对象执行变换操作。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const json = &apos;&#123;&quot;result&quot;:true, &quot;count&quot;:2&#125;&apos;;</span><br><span class="line"></span><br><span class="line">const obj = JSON.parse(json);</span><br><span class="line"></span><br><span class="line">console.log(obj.count);</span><br><span class="line"></span><br><span class="line">// 2</span><br><span class="line"></span><br><span class="line">console.log(obj.result);</span><br><span class="line"></span><br><span class="line">// true</span><br><span class="line"></span><br><span class="line">/* 带第二个参数的情况 */</span><br><span class="line"></span><br><span class="line">JSON.parse(&apos;&#123;&quot;p&quot;: 5&#125;&apos;, function (k, v) &#123;</span><br><span class="line"></span><br><span class="line">    if(k === &apos;&apos;) return v;     // 如果k不是空，</span><br><span class="line"></span><br><span class="line">    return v * 2;              // 就将属性值变为原来的2倍返回</span><br><span class="line"></span><br><span class="line">&#125;);                            // &#123; p: 10 &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify"></a>JSON.stringify</h3><ul>
<li><p>JSON.stringify 方法是将一个 JavaScript 对象或值转换为 JSON 字符串，默认该方法其实有三个参数：第一个参数是必选，后面两个是可选参数非必选。第一个参数传入的是要转换的对象；第二个是一个 replacer 函数，比如指定的 replacer 是数组，则可选择性地仅处理包含数组指定的属性；第三个参数用来控制结果字符串里面的间距，后面两个参数整体用得比较少。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">JSON.stringify(&#123; x: 1, y: 2 &#125;);</span><br><span class="line"></span><br><span class="line">// &quot;&#123;&quot;x&quot;:1,&quot;y&quot;:2&#125;&quot;</span><br><span class="line"></span><br><span class="line">JSON.stringify(&#123; x: [10, undefined, function()&#123;&#125;, Symbol(&apos;&apos;)] &#125;)</span><br><span class="line"></span><br><span class="line">// &quot;&#123;&quot;x&quot;:[10,null,null,null]&#125;&quot;</span><br><span class="line"></span><br><span class="line">/* 第二个参数的例子 */</span><br><span class="line"></span><br><span class="line">function replacer(key, value) &#123;</span><br><span class="line"></span><br><span class="line">  if (typeof value === &quot;string&quot;) &#123;</span><br><span class="line"></span><br><span class="line">    return undefined;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return value;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var foo = &#123;foundation: &quot;Mozilla&quot;, model: &quot;box&quot;, week: 4, transport: &quot;car&quot;, month: 7&#125;;</span><br><span class="line"></span><br><span class="line">var jsonString = JSON.stringify(foo, replacer);</span><br><span class="line"></span><br><span class="line">console.log(jsonString);</span><br><span class="line"></span><br><span class="line">// &quot;&#123;&quot;week&quot;:4,&quot;month&quot;:7&#125;&quot;</span><br><span class="line"></span><br><span class="line">/* 第三个参数的例子 */</span><br><span class="line"></span><br><span class="line">JSON.stringify(&#123; a: 2 &#125;, null, &quot; &quot;);</span><br><span class="line"></span><br><span class="line">/* &quot;&#123;</span><br><span class="line"></span><br><span class="line"> &quot;a&quot;: 2</span><br><span class="line"></span><br><span class="line">&#125;&quot;*/</span><br><span class="line"></span><br><span class="line">JSON.stringify(&#123; a: 2 &#125;, null, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">// &quot;&#123;&quot;a&quot;:2&#125;&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">从上面的代码中可以看到，增加第二个参数 replacer 带来的变化：通过替换方法把对象中的属性为字符串的过滤掉，在 stringify 之后返回的仅为数字的属性变成字符串之后的结果；</span><br><span class="line">当第三个参数传入的是多个空格的时候，则会增加结果字符串里面的间距数量，从最后一段代码中可以看到结果。</span><br></pre></td></tr></table></figure>
</li>
<li><p>手动实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line">function jsonStringify(data) &#123;</span><br><span class="line"></span><br><span class="line">  let type = typeof data;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  if(type !== &apos;object&apos;) &#123;</span><br><span class="line"></span><br><span class="line">    let result = data;</span><br><span class="line"></span><br><span class="line">    //data 可能是基础数据类型的情况在这里处理</span><br><span class="line"></span><br><span class="line">    if (Number.isNaN(data) || data === Infinity) &#123;</span><br><span class="line"></span><br><span class="line">       //NaN 和 Infinity 序列化返回 &quot;null&quot;</span><br><span class="line"></span><br><span class="line">       result = &quot;null&quot;;</span><br><span class="line"></span><br><span class="line">    &#125; else if (type === &apos;function&apos; || type === &apos;undefined&apos; || type === &apos;symbol&apos;) &#123;</span><br><span class="line"></span><br><span class="line">      // 由于 function 序列化返回 undefined，因此和 undefined、symbol 一起处理</span><br><span class="line"></span><br><span class="line">       return undefined;</span><br><span class="line"></span><br><span class="line">    &#125; else if (type === &apos;string&apos;) &#123;</span><br><span class="line"></span><br><span class="line">       result = &apos;&quot;&apos; + data + &apos;&quot;&apos;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return String(result);</span><br><span class="line"></span><br><span class="line">  &#125; else if (type === &apos;object&apos;) &#123;</span><br><span class="line"></span><br><span class="line">     if (data === null) &#123;</span><br><span class="line"></span><br><span class="line">        return &quot;null&quot;  // 第01讲有讲过 typeof null 为&apos;object&apos;的特殊情况</span><br><span class="line"></span><br><span class="line">     &#125; else if (data.toJSON &amp;&amp; typeof data.toJSON === &apos;function&apos;) &#123;</span><br><span class="line"></span><br><span class="line">        return jsonStringify(data.toJSON());</span><br><span class="line"></span><br><span class="line">     &#125; else if (data instanceof Array) &#123;</span><br><span class="line"></span><br><span class="line">        let result = [];</span><br><span class="line"></span><br><span class="line">        //如果是数组，那么数组里面的每一项类型又有可能是多样的</span><br><span class="line"></span><br><span class="line">        data.forEach((item, index) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">        if (typeof item === &apos;undefined&apos; || typeof item === &apos;function&apos; || typeof item === &apos;symbol&apos;) &#123;</span><br><span class="line"></span><br><span class="line">               result[index] = &quot;null&quot;;</span><br><span class="line"></span><br><span class="line">           &#125; else &#123;</span><br><span class="line"></span><br><span class="line">               result[index] = jsonStringify(item);</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">         &#125;);</span><br><span class="line"></span><br><span class="line">         result = &quot;[&quot; + result + &quot;]&quot;;</span><br><span class="line"></span><br><span class="line">         return result.replace(/&apos;/g, &apos;&quot;&apos;);</span><br><span class="line"></span><br><span class="line">      &#125; else &#123;</span><br><span class="line"></span><br><span class="line">         // 处理普通对象</span><br><span class="line"></span><br><span class="line">         let result = [];</span><br><span class="line"></span><br><span class="line">         Object.keys(data).forEach((item, index) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">            if (typeof item !== &apos;symbol&apos;) &#123;</span><br><span class="line"></span><br><span class="line">              //key 如果是 symbol 对象，忽略</span><br><span class="line"></span><br><span class="line">              if (data[item] !== undefined &amp;&amp; typeof data[item] !== &apos;function&apos; &amp;&amp; typeof data[item] !== &apos;symbol&apos;) &#123;</span><br><span class="line"></span><br><span class="line">                //键值如果是 undefined、function、symbol 为属性值，忽略</span><br><span class="line"></span><br><span class="line">                result.push(&apos;&quot;&apos; + item + &apos;&quot;&apos; + &quot;:&quot; + jsonStringify(data[item]));</span><br><span class="line"></span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">         &#125;);</span><br><span class="line"></span><br><span class="line">         return (&quot;&#123;&quot; + result + &quot;&#125;&quot;).replace(/&apos;/g, &apos;&quot;&apos;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">手工实现一个 JSON.stringify 方法的基本代码如上面所示，有几个问题还是需要注意一下：</span><br><span class="line">1.由于 function 返回 &apos;null&apos;， 并且 typeof function 能直接返回精确的判断，故在整体逻辑处理基础数据类型的时候，会随着 undefined，symbol 直接处理了；</span><br><span class="line">2.由于 typeof null 的时候返回&apos;object&apos;，故 null 的判断逻辑整体在处理引用数据类型的逻辑里面；</span><br><span class="line">3.关于引用数据类型中的数组，由于数组的每一项的数据类型又有很多的可能性，故在处理数组过程中又将 undefined，symbol，function 作为数组其中一项的情况做了特殊处理；</span><br><span class="line">4.同样在最后处理普通对象的时候，key （键值）也存在和数组一样的问题，故又需要再针对上面这几种情况（undefined，symbol，function）做特殊处理；</span><br><span class="line">5.最后在处理普通对象过程中，对于循环引用的问题暂未做检测，如果是有循环引用的情况，需要抛出 Error；</span><br><span class="line">6.根据官方给出的 JSON.stringify 的第二个以及第三个参数的实现，本段模拟实现的代码并未实现。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">上面实现的这个 jsonStringify 方法和真正的 JSON.stringify 想要得到的效果是否一样呢？请看下面的测试结果。</span><br><span class="line">let nl = null;</span><br><span class="line"></span><br><span class="line">console.log(jsonStringify(nl) === JSON.stringify(nl));</span><br><span class="line"></span><br><span class="line">// true</span><br><span class="line"></span><br><span class="line">let und = undefined;</span><br><span class="line"></span><br><span class="line">console.log(jsonStringify(undefined) === JSON.stringify(undefined));</span><br><span class="line"></span><br><span class="line">// true</span><br><span class="line"></span><br><span class="line">let boo = false;</span><br><span class="line"></span><br><span class="line">console.log(jsonStringify(boo) === JSON.stringify(boo));</span><br><span class="line"></span><br><span class="line">// true</span><br><span class="line"></span><br><span class="line">let nan = NaN;</span><br><span class="line"></span><br><span class="line">console.log(jsonStringify(nan) === JSON.stringify(nan));</span><br><span class="line"></span><br><span class="line">// true</span><br><span class="line"></span><br><span class="line">let inf = Infinity;</span><br><span class="line"></span><br><span class="line">console.log(jsonStringify(Infinity) === JSON.stringify(Infinity));</span><br><span class="line"></span><br><span class="line">// true</span><br><span class="line"></span><br><span class="line">let str = &quot;jack&quot;;</span><br><span class="line"></span><br><span class="line">console.log(jsonStringify(str) === JSON.stringify(str));</span><br><span class="line"></span><br><span class="line">// true</span><br><span class="line"></span><br><span class="line">let reg = new RegExp(&quot;\w&quot;);</span><br><span class="line"></span><br><span class="line">console.log(jsonStringify(reg) === JSON.stringify(reg));</span><br><span class="line"></span><br><span class="line">// true</span><br><span class="line"></span><br><span class="line">let date = new Date();</span><br><span class="line"></span><br><span class="line">console.log(jsonStringify(date) === JSON.stringify(date));</span><br><span class="line"></span><br><span class="line">// true</span><br><span class="line"></span><br><span class="line">let sym = Symbol(1);</span><br><span class="line"></span><br><span class="line">console.log(jsonStringify(sym) === JSON.stringify(sym));</span><br><span class="line"></span><br><span class="line">// true</span><br><span class="line"></span><br><span class="line">let array = [1,2,3];</span><br><span class="line"></span><br><span class="line">console.log(jsonStringify(array) === JSON.stringify(array));</span><br><span class="line"></span><br><span class="line">// true</span><br><span class="line"></span><br><span class="line">let obj = &#123;</span><br><span class="line"></span><br><span class="line">    name: &apos;jack&apos;,</span><br><span class="line"></span><br><span class="line">    age: 18,</span><br><span class="line"></span><br><span class="line">    attr: [&apos;coding&apos;, 123],</span><br><span class="line"></span><br><span class="line">    date: new Date(),</span><br><span class="line"></span><br><span class="line">    uni: Symbol(2),</span><br><span class="line"></span><br><span class="line">    sayHi: function() &#123;</span><br><span class="line"></span><br><span class="line">        console.log(&quot;hi&quot;)</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    info: &#123;</span><br><span class="line"></span><br><span class="line">        sister: &apos;lily&apos;,</span><br><span class="line"></span><br><span class="line">        age: 16,</span><br><span class="line"></span><br><span class="line">        intro: &#123;</span><br><span class="line"></span><br><span class="line">            money: undefined,</span><br><span class="line"></span><br><span class="line">            job: null</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(jsonStringify(obj) === JSON.stringify(obj));</span><br><span class="line"></span><br><span class="line">// true</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Eventloop"><a href="#Eventloop" class="headerlink" title="Eventloop"></a>Eventloop</h2><h3 id="浏览器的-Eventloop"><a href="#浏览器的-Eventloop" class="headerlink" title="浏览器的 Eventloop"></a>浏览器的 Eventloop</h3><ul>
<li>JavaScript 引擎</li>
</ul>
<ol>
<li>调用堆栈（call stack）负责跟踪所有要执行的代码。每当一个函数执行完成时，就会从堆栈中弹出（pop）该执行完成函数；如果有代码需要进去执行的话，就进行 push 操作，</li>
<li>事件队列（event queue）负责将新的 function 发送到队列中进行处理。它遵循 queue 的数据结构特性，先进先出，在该顺序下发送所有操作以进行执行。</li>
<li>每当调用事件队列（event queue）中的异步函数时，都会将其发送到浏览器 API。根据从调用堆栈收到的命令，API 开始自己的单线程操作。其中 setTimeout 方法就是一个比较典型的例子，在堆栈中处理 setTimeout 操作时，会将其发送到相应的 API，该 API 一直等到指定的时间将此操作送回进行处理。它将操作发送到哪里去呢？答案是事件队列（event queue）。这样，就有了一个循环系统，用于在 JavaScript 中运行异步操作。</li>
<li>JavaScript 语言本身是单线程的，而浏览器 API 充当单独的线程。事件循环（Eventloop）促进了这一过程，它会不断检查调用堆栈是否为空。如果为空，则从事件队列中添加新的函数进入调用栈（call stack）；如果不为空，则处理当前函数的调用。我们把整个过程串起来就是这样的一个循环执行流程</li>
</ol>
<ul>
<li>macrotasks(宏任务):<br><code>script(整体代码),setTimeout,setInterval,setImmediate,I/O,UI rendering,event listner</code></li>
<li>microtasks(微任务):<br><code>process.nextTick, Promises, Object.observe, MutationObserver</code></li>
<li>Eventloop 处理宏任务和微任务的逻辑</li>
</ul>
<ol>
<li>JavaScript 引擎首先从宏任务队列（macrotask queue）中取出第一个任务；</li>
<li>执行完毕后，再将微任务（microtask queue）中的所有任务取出，按照顺序分别全部执行（这里包括不仅指开始执行时队列里的微任务），如果在这一步过程中产生新的微任务，也需要执行；</li>
<li>然后再从宏任务队列中取下一个，执行完毕后，再次将 microtask queue 中的全部取出，循环往复，直到两个 queue 中的任务都取完。</li>
<li>总结起来就是：一次 Eventloop 循环会处理一个宏任务和所有这次循环中产生的微任务。</li>
</ol>
<ul>
<li>各种浏览器事件同时触发时，肯定有一个先来后到的排队问题。决定这些事件如何排队触发的机制，就是事件循环。这个排队行为以 JavaScript 开发者的角度来看，主要是分成两个队列：</li>
</ul>
<ol>
<li>一个是 JavaScript 外部的队列。外部的队列主要是浏览器协调的各类事件的队列，标准文件中称之为 Task Queue。下文中为了方便理解统一称为外部队列。</li>
<li>另一个是 JavaScript 内部的队列。这部分主要是 JavaScript 内部执行的任务队列，标准中称之为 Microtask Queue。下文中为了方便理解统一称为内部队列。</li>
</ol>
<ul>
<li>值得注意的是，虽然为了好理解我们管这个叫队列 (Queue)，但是本质上是有序集合 (Set)，因为传统的队列都是先进先出（FIFO）的，而这里的队列则不然，排到最前面但是没有满足条件也是不会执行的（比如外部队列里只有一个 setTimeout 的定时任务，但是时间还没有到，没有满足条件也不会把他出列来执行）。<h4 id="外部队列"><a href="#外部队列" class="headerlink" title="外部队列"></a>外部队列</h4></li>
<li>外部队列（Task Queue  关于 Task，常有人称它为 Marcotask (宏任务)，但 HTML 标准中没有这种说法。），顾名思义就是 JavaScript 外部的事件的队列，这里我们可以先列举一下浏览器中这些外部事件源（Task Source），他们主要有：</li>
</ul>
<ol>
<li>DOM 操作 (页面渲染)</li>
<li>用户交互 (鼠标、键盘)</li>
<li>网络请求 (Ajax 等)</li>
<li>History API 操作</li>
<li>定时器 (setTimeout 等)</li>
</ol>
<ul>
<li>HTML 标准中明确指出一个事件循环由一个或多个外部队列，而每一个外部事件源都有一个对应的外部队列。不同事件源的队列可以有不同的优先级（例如在网络事件和用户交互之间，浏览器可以优先处理鼠标行为，从而让用户感觉更加流程）。</li>
<li>scripts 执行也是一个事件，我们只要归类一下就会发现 JavaScript 的执行也是一个浏览器发起的外部事件。<h4 id="内部队列"><a href="#内部队列" class="headerlink" title="内部队列"></a>内部队列</h4></li>
<li>内部队列（Microtask Queue），即 JavaScript 语言内部的事件队列，在 HTML 标准中，并没有明确规定这个队列的事件源，通常认为有以下几种：</li>
</ul>
<ol>
<li>Promise 的成功 (.then) 与失败 (.catch)</li>
<li>MutationObserver</li>
<li>Object.observe (已废弃)<h3 id="Node-js-的-Eventloop"><a href="#Node-js-的-Eventloop" class="headerlink" title="Node.js 的 Eventloop"></a>Node.js 的 Eventloop</h3></li>
</ol>
<ul>
<li>当 Node.js 开始启动时，会初始化一个 Eventloop，处理输入的代码脚本，这些脚本会进行 API 异步调用，process.nextTick() 方法会开始处理事件循环。</li>
<li>整个流程分为六个阶段，当这六个阶段执行完一次之后，才可以算得上执行了一次 Eventloop 的循环过程</li>
</ul>
<ol>
<li>Timers 阶段：这个阶段执行 setTimeout 和 setInterval。</li>
<li>I/O callbacks 阶段：这个阶段主要执行系统级别的回调函数，比如 TCP 连接失败的回调。</li>
<li>idle，prepare 阶段：只是 Node.js 内部闲置、准备，可以忽略。</li>
<li>poll 阶段：poll 阶段是一个重要且复杂的阶段，几乎所有 I/O 相关的回调，都在这个阶段执行（除了setTimeout、setInterval、setImmediate 以及一些因为 exception 意外关闭产生的回调）</li>
<li>check 阶段：执行 setImmediate() 设定的 callbacks。</li>
<li>close callbacks 阶段：执行关闭请求的回调函数，比如 socket.on(‘close’, …)。</li>
</ol>
<ul>
<li>除了把 Eventloop 的宏任务细分到不同阶段外。node 还引入了一个新的任务队列 Process.nextTick()。可以认为，Process.nextTick() 会在上述各个阶段结束时，在进入下一个阶段之前立即执行（优先级甚至超过 microtask 队列）。</li>
<li>Node.js 和浏览器端宏任务队列的另一个很重要的不同点是，浏览器端任务队列每轮事件循环仅出队一个回调函数接着去执行微任务队列；而 Node.js 端只要轮到执行某个宏任务队列，则会执行完队列中所有的当前任务，但是当前轮次新添加到队尾的任务则会等到下一轮次才会执行。</li>
<li>HTML (浏览器端) 与 libuv (服务端) 面对的场景有很大的差异。首先能直观感受到的区别是：</li>
</ul>
<ol>
<li>事件循环的过程没有 HTML 渲染。只剩下了外部队列和内部队列这两个部分。</li>
<li>外部队列的事件源不同。Node.js 端没有了鼠标等外设但是新增了文件等 IO。</li>
<li>内部队列的事件仅剩下 Promise 的 then 和 catch。</li>
</ol>
<ul>
<li>至于内在的差异，有一个很重要的地方是 Node.js （libuv）在最初设计的时候是允许执行多次外部的事件再切换到内部队列的，而浏览器端一次事件循环只允许执行一次外部事件。</li>
<li>setImmediate 的引入是为了解决 setTimeout 的精度问题，由于 setTimeout 指定的延迟时间是毫秒（ms）但实际一次事件循环的时间可能是纳秒级的，所以在一次事件循环的多个外部队列中，找到某一个队列直接执行其中的 callback 可以得到比 setTimeout 更早执行的效果。我们继续以开始的场景构造一个例子，并在 Node.js 10.x 的版本上执行（存在一次事件循环执行多次外部事件）。这里 setTimeout 在 setImmediate 后面执行的原因是因为 ms 精度的问题，想要手动 fix 这个精度可以插入一段 const now = Date.now(); wihle (Date.now() &lt; now + 1) {} 即可看到 setTimeout 在 setImmediate 之前执行了。</li>
<li>我们可以推测出 Node.js 中的事件循环与浏览器类似，也是外部队列与内部队列的循环，而 setImmediate 在另外一个外部队列中。</li>
<li>其中主要有两点需要关注，一是外部列队在每次事件循环只执行了一个，另一个是 Node.js 的固定了多个外部队列的优先级。setImmediate 的外部队列没有执行完的时候，是不会执行 timeout 的外部队列的。</li>
<li>timer（setTimeout）是第一阶段的原因在 libuv 的文档中有描述 —— 为了减少时间相关的系统调用（System Call）。setImmediate 出现在 check 阶段是蹭了 libuv 中 poll 阶段之后的检查过程（这个过程放在 poll 中也很奇怪，放在 poll 之后感觉比较合适）。</li>
<li>idle, prepare 对应的是 libuv 中的两个叫做 idle 和 prepare 的句柄。由于 I/O 的 poll 过程可能阻塞住事件循环，所以这两个句柄主要是用来触发 poll （阻塞）之前需要触发的回调</li>
<li>由于 poll 可能 block 住事件循环，所以应当有一个外部队列专门用于执行 I/O 的 callback ，并且优先级在 poll 以及 prepare to poll 之前。</li>
<li>另外我们知道网络 IO 可能有非常多的请求同时进来，如果该阶段如果无限制的执行这些 callback，可能导致 Node.js 的进程卡死该阶段，其他外部队列的代码都没发执行了。所以当前外部队列在执行一定数量的 callback 之后会截断。由于截断的这个特性，这个专门执行 I/O callbacks 的外部队列也叫 pengding callbacks</li>
</ul>
<h3 id="EventLoop-对渲染的影响"><a href="#EventLoop-对渲染的影响" class="headerlink" title="EventLoop 对渲染的影响"></a>EventLoop 对渲染的影响</h3><ul>
<li>浏览器作为一个复杂的应用是多线程工作的，除了运行 JS 的线程外，还有渲染线程、定时器触发线程、HTTP 请求线程，等等。JS 线程可以读取并且修改 DOM，而渲染线程也需要读取 DOM，这是一个典型的多线程竞争临界资源的问题。所以浏览器就把这两个线程设计成互斥的，即同时只能有一个线程在执行。</li>
<li>requestAnimationFrame，这个 API 保证在下次浏览器渲染之前一定会被调用，实际上我们完全可以把它看成是一个高级版的 setInterval。它们都是在一段时间后执行回调，但是前者的间隔时间是由浏览器自己不断调整的，而后者只能由用户指定。这样的特性也决定了 requestAnimationFrame 更适合用来做针对每一帧来修改的动画效果。</li>
<li>当然 requestAnimationFrame 不是 Eventloop 里的宏任务，或者说它并不在 Eventloop 的生命周期里，只是浏览器又开放的一个在渲染之前发生的新的 hook。另外需要注意的是微任务的认知概念也需要更新，在执行 animation callback 时也有可能产生微任务（比如 promise 的 callback），会放到 animation queue 处理完后再执行。所以微任务并不是像之前说的那样在每一轮 Eventloop 后处理，而是在 JS 的函数调用栈清空后处理。</li>
<li>但是 requestIdlecallback 却是一个更好理解的概念。当宏任务队列中没有任务可以处理时，浏览器可能存在“空闲状态”。这段空闲时间可以被 requestIdlecallback 利用起来执行一些优先级不高、不必立即执行的任务,当然为了防止浏览器一直处于繁忙状态，导致 requestIdlecallback 可能永远无法执行回调，它还提供了一个额外的 timeout 参数，为这个任务设置一个截止时间。浏览器就可以根据这个截止时间规划这个任务的执行。</li>
</ul>
<h3 id="宏任务、微任务"><a href="#宏任务、微任务" class="headerlink" title="宏任务、微任务"></a>宏任务、微任务</h3><ul>
<li>宏任务和微任务的执行顺序基本是，在 EventLoop 中，每一次循环称为一次 tick，主要的任务顺序如下：</li>
</ul>
<ol>
<li>执行栈选择最先进入队列的宏任务，执行其同步代码直至结束；</li>
<li>检查是否有微任务，如果有则执行直到微任务队列为空；</li>
<li>如果是在浏览器端，那么基本要渲染页面了；</li>
<li>开始下一轮的循环（tick），执行宏任务中的一些异步代码，例如 setTimeout 等。</li>
</ol>
<ul>
<li>Call-Stack（调用栈）也就是执行栈，它是一个栈的结构，符合先进后出的机制，每次一个循环，先执行最先入队的宏任务，然后再执行微任务。不管微任务还是宏任务，它们只要按照顺序进入了执行栈，那么执行栈就还是按照先进后出的规则，一步一步执行。因此根据这个原则，最先进行调用栈的宏任务，一般情况下都是最后返回执行的结果。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">async function async1() &#123;</span><br><span class="line"></span><br><span class="line">  console.log(&quot;async1 start&quot;);</span><br><span class="line"></span><br><span class="line">  await async2();</span><br><span class="line"></span><br><span class="line">  console.log(&quot;async1 end&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function async2() &#123;</span><br><span class="line"></span><br><span class="line">  console.log(&quot;async2&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async1();</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  console.log(&quot;timeout&quot;);</span><br><span class="line"></span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">new Promise(function (resolve) &#123;</span><br><span class="line"></span><br><span class="line">  console.log(&quot;promise1&quot;);</span><br><span class="line"></span><br><span class="line">  resolve();</span><br><span class="line"></span><br><span class="line">&#125;).then(function () &#123;</span><br><span class="line"></span><br><span class="line">  console.log(&quot;promise2&quot;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&quot;script end&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">async1 start</span><br><span class="line">async2</span><br><span class="line">promise1</span><br><span class="line">script end</span><br><span class="line">async1 end</span><br><span class="line">promise2</span><br><span class="line">timeout</span><br></pre></td></tr></table></figure>
<h4 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h4><ul>
<li>如果在浏览器的环境下，宏任务主要分为下面这几个大类：</li>
</ul>
<ol>
<li>渲染事件（比如解析 DOM、计算布局、绘制）；</li>
<li>用户交互事件（比如鼠标点击、滚动页面、放大缩小等）；</li>
<li>setTimeout、setInterval 等；</li>
<li>网络请求完成、文件读写完成事件。</li>
</ol>
<ul>
<li>为了让这些任务在主线程上执行，页面进程引入了消息队列和事件循环机制，我们把这些消息队列中的任务称为宏任务。</li>
<li>宏任务基本上满足了日常的开发需求，而对于时间精度有要求的宏任务就不太能满足了，比如渲染事件、各种 I/O、用户交互的事件等，都随时有可能被添加到消息队列中，JS 代码不能准确掌控任务要添加到队列中的位置，控制不了任务在消息队列中的位置，所以很难控制开始执行任务的时间。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function callback2()&#123;</span><br><span class="line"></span><br><span class="line">    console.log(2)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function callback()&#123;</span><br><span class="line"></span><br><span class="line">    console.log(1)</span><br><span class="line"></span><br><span class="line">    setTimeout(callback2,0)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setTimeout(callback,0)</span><br><span class="line">在上面这段代码中，我的目的是想通过 setTimeout 来设置两个回调任务，并让它们按照前后顺序来执行，中间也不要再插入其他的任务。</span><br><span class="line">但是实际情况我们难以控制，比如在你调用 setTimeout 来设置回调任务的间隙，消息队列中就有可能被插入很多系统级的任务。</span><br><span class="line">如果中间被插入的任务执行时间过久的话，那么就会影响到后面任务的执行了。所以说宏任务的时间粒度比较大，执行的间隔是不能精确控制的。</span><br><span class="line">这就不适用于一些高实时性的需求了，比如后面要讲到的监听 DOM 变化。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h4><ul>
<li>微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。</li>
<li>当 JavaScript 执行一段脚本的时候，V8 会为其创建一个全局执行上下文，同时 V8 引擎也会在内部创建一个微任务队列。这个微任务队列就是用来存放微任务的，因为在当前宏任务执行的过程中，有时候会产生多个微任务，这时候就需要使用这个微任务队列来保存这些微任务了。不过这个微任务队列是给 V8 引擎内部使用的，所以你是无法通过 JavaScript 直接访问的。</li>
<li>在现代浏览器里面，产生微任务有两种方式</li>
</ul>
<ol>
<li>使用 MutationObserver 监控某个 DOM 节点，或者为这个节点添加、删除部分子节点，当 DOM 节点发生变化时，就会产生 DOM 变化记录的微任务。</li>
<li>使用 Promise，当调用 Promise.resolve() 或者 Promise.reject() 的时候，也会产生微任务</li>
</ol>
<ul>
<li>如果在执行微任务的过程中，产生了新的微任务，一样会将该微任务添加到微任务队列中，V8 引擎一直循环执行微任务队列中的任务，直到队列清空才算执行结束。也就是说在执行微任务过程中产生的新的微任务并不会推迟到下一个循环中执行，而是在当前的循环中继续执行，这点是需要注意的。</li>
<li>微任务和宏任务是绑定的，每个宏任务在执行时，会创建自己的微任务队列。</li>
<li>微任务的执行时长会影响当前宏任务的时长。比如一个宏任务在执行过程中，产生了 10 个微任务，执行每个微任务的时间是 10ms，那么执行这 10 个微任务的时间就是 100ms，也可以说这 10 个微任务让宏任务的执行时间延长了 100ms。</li>
<li>在一个宏任务中，分别创建一个用于回调的宏任务和微任务，无论什么情况下，微任务都早于宏任务执行。</li>
</ul>
<h4 id="MutationObserver"><a href="#MutationObserver" class="headerlink" title="MutationObserver"></a>MutationObserver</h4><ul>
<li>MutationObserver API 可以用来监视 DOM 的变化，包括属性的变更、节点的增加、内容的改变等。因为上面我们分析过，在两个任务之间，可能会被渲染进程插入其他的事件，从而影响到响应的实时性。这时候，微任务就可以上场了，在每次 DOM 节点发生变化的时候，渲染引擎将变化记录封装成微任务，并将微任务添加进当前的微任务队列中。这样当执行到检查点的时候，V8 引擎就会按照顺序执行微任务了。</li>
<li>MutationObserver 采用了“异步 + 微任务”的策略：</li>
</ul>
<ol>
<li>通过异步操作解决了同步操作的性能问题；</li>
<li>通过微任务解决了实时性的问题。</li>
</ol>
<h4 id="Process-nextTick"><a href="#Process-nextTick" class="headerlink" title="Process.nextTick"></a>Process.nextTick</h4><ul>
<li>Process.nextick 的运行逻辑：</li>
</ul>
<ol>
<li>Process.nextick 会将 callback 添加到“next tick queue”；</li>
<li>“next tick queue”会在当前 JavaScript stack 执行完成后，下一次 event loop 开始执行前按照 FIFO 出队；</li>
<li>如果递归调用 Process.nextick 可能会导致一个无限循环，需要去适时终止递归。</li>
</ol>
<ul>
<li>可能你已经注意到 Process.nextick 其实是微任务，同时也是异步 API 的一部分。但是从技术上来说 Process.nextick 并不是事件循环（eventloop）的一部分，相反地，“next tick queue”将会在当前操作完成之后立即被处理，而不管当前处于事件循环的哪个阶段。</li>
<li>如果任何时刻你在一个给定的阶段调用 Process.nextick，则所有被传入 Process.nextick 的回调将在事件循环继续往下执行前被执行。这可能会导致一些很糟的情形，因为它允许用户递归调用 Process.nextick 来挂起 I/O 进程的进行，这会导致事件循环永远无法到达轮询阶段。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">let bar;</span><br><span class="line"></span><br><span class="line">function someAsyncApiCall(callback) &#123; callback(); &#125;</span><br><span class="line"></span><br><span class="line">someAsyncApiCall(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  console.log(&apos;bar&apos;, bar);   // undefined</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">bar = 1;</span><br><span class="line"></span><br><span class="line">用户定义函数 someAsyncApiCall() 有一个异步签名，但实际上它是同步执行的。</span><br><span class="line">当它被调用时，提供给 someAsyncApiCall() 的回调函数会在执行 someAsyncApiCall() 本身的同一个事件循环阶段被执行，因为 someAsyncApiCall() 实际上并未执行任何异步操作。</span><br><span class="line">结果就是，即使回调函数尝试引用变量 bar，但此时在作用域中并没有改变量。因为程序还没运行到对 bar 赋值的部分。</span><br><span class="line"></span><br><span class="line">将回调放到 Process.nextick 中，程序依然可以执行完毕，且所有的变量、函数等都在执行回调之前被初始化，它还具有不会被事件循环打断的优点。以下是将上面的例子改用 Process.nextick 的代码：</span><br><span class="line"></span><br><span class="line">let bar;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">function someAsyncApiCall(callback) &#123;</span><br><span class="line"></span><br><span class="line">  process.nextTick(callback);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">someAsyncApiCall(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  console.log(&apos;bar&apos;, bar); // 1</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">bar = 1;</span><br><span class="line"></span><br><span class="line">-------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const EventEmitter = require(&apos;events&apos;);</span><br><span class="line"></span><br><span class="line">const util = require(&apos;util&apos;);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">function MyEmitter() &#123;</span><br><span class="line"></span><br><span class="line">EventEmitter.call(this);</span><br><span class="line"></span><br><span class="line">this.emit(&apos;event&apos;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">util.inherits(MyEmitter, EventEmitter);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">const myEmitter = new MyEmitter();</span><br><span class="line"></span><br><span class="line">myEmitter.on(&apos;event&apos;, () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">console.log(&apos;an event occurred!&apos;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">你无法在构造函数中立即触发一个事件，因为此时程序还未运行到将回调赋值给事件的那段代码。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">因此，在构造函数内部，你可以使用 Process.nextick 设置一个回调以在构造函数执行完毕后触发事件，下面的代码满足了我们的预期。</span><br><span class="line"></span><br><span class="line">const EventEmitter = require(&apos;events&apos;);</span><br><span class="line"></span><br><span class="line">const util = require(&apos;util&apos;);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">function MyEmitter() &#123;</span><br><span class="line"></span><br><span class="line">EventEmitter.call(this);</span><br><span class="line"></span><br><span class="line">process.nextTick(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  this.emit(&apos;event&apos;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">util.inherits(MyEmitter, EventEmitter);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">const myEmitter = new MyEmitter();</span><br><span class="line"></span><br><span class="line">  myEmitter.on(&apos;event&apos;, () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  console.log(&apos;an event occurred!&apos;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">通过上面的改造可以看出，使用 Process.nextick 就可以解决问题了，即使 event 事件还没进行绑定，但也可以让代码在前面进行触发，因为根据代码执行顺序，Process.nextick 是在每一次的事件循环最后执行的。</span><br><span class="line">因此这样写，代码也不会报错，同样又保持了代码的逻辑。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="Vue的nextick"><a href="#Vue的nextick" class="headerlink" title="Vue的nextick"></a>Vue的nextick</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"></span><br><span class="line">  &lt;div class=&quot;app&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div ref=&quot;msg&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div v-if=&quot;msg1&quot;&gt;Message got outside $nextTick: &#123;&#123;msg1&#125;&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div v-if=&quot;msg2&quot;&gt;Message got inside $nextTick: &#123;&#123;msg2&#125;&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;button @click=&quot;changeMsg&quot;&gt;</span><br><span class="line"></span><br><span class="line">      Change the Message</span><br><span class="line"></span><br><span class="line">    &lt;/button&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line"></span><br><span class="line">  el: &apos;.app&apos;,</span><br><span class="line"></span><br><span class="line">  data: &#123;</span><br><span class="line"></span><br><span class="line">    msg: &apos;Vue&apos;,</span><br><span class="line"></span><br><span class="line">    msg1: &apos;&apos;,</span><br><span class="line"></span><br><span class="line">    msg2: &apos;&apos;,</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line"></span><br><span class="line">    changeMsg() &#123;</span><br><span class="line"></span><br><span class="line">      this.msg = &quot;Hello world.&quot;</span><br><span class="line"></span><br><span class="line">      this.msg1 = this.$refs.msg.innerHTML</span><br><span class="line"></span><br><span class="line">      this.$nextTick(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">        this.msg2 = this.$refs.msg.innerHTML</span><br><span class="line"></span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">通过按钮点击之后，div 里面的 msg1 和 msg2 的变化情况。你会发现第一次点击按钮调用 changeMsg 方法时，其实 msg2 并没有变化，因为 msg2 的变化是在下一个 tick 才进行执行的。</span><br></pre></td></tr></table></figure>
<h2 id="JS-代码是如何被浏览器引擎编译、执行的？"><a href="#JS-代码是如何被浏览器引擎编译、执行的？" class="headerlink" title="JS 代码是如何被浏览器引擎编译、执行的？"></a>JS 代码是如何被浏览器引擎编译、执行的？</h2><h3 id="V8-引擎"><a href="#V8-引擎" class="headerlink" title="V8 引擎"></a>V8 引擎</h3><ul>
<li>编译型语言和解释型语言</li>
</ul>
<ol>
<li>编译型语言的特点是在代码运行前编译器直接将对应的代码转换成机器码，运行时不需要再重新翻译，直接可以使用编译后的结果。</li>
<li>解释型语言也是需要将代码转换成机器码，但是和编译型的区别在于运行时需要转换。比较显著的特点是，解释型语言的执行速度要慢于编译型语言，因为解释型语言每次执行都需要把源码转换一次才能执行。</li>
</ol>
<ul>
<li>V8是众多浏览器的 JS 引擎中性能表现最好的一个，并且它是 Chrome 的内核，Node.js 也是基于 V8 引擎研发的。</li>
<li>V8引擎执行 JS 代码要经过以下阶段</li>
</ul>
<ol>
<li>Parse 阶段：V8 引擎负责将 JS 代码转换成 AST（抽象语法树）；</li>
<li>Ignition 阶段：解释器将 AST 转换为字节码，解析执行字节码也会为下一个阶段优化编译提供需要的信息；</li>
<li>TurboFan 阶段：编译器利用上个阶段收集的信息，将字节码优化为可以执行的机器码；</li>
<li>Orinoco 阶段：垃圾回收阶段，将程序中不再使用的内存空间进行回收。<h3 id="生成-AST"><a href="#生成-AST" class="headerlink" title="生成 AST"></a>生成 AST</h3></li>
</ol>
<ul>
<li>Eslint 和 Babel 这两个工具都和 AST 脱不了干系。V8 引擎就是通过编译器（Parse）将源代码解析成 AST 的</li>
<li>AST 在实际工作中应用场景也比较多，大致有下面几个：</li>
</ul>
<ol>
<li>JS 反编译，语法解析；</li>
<li>Babel 编译 ES6 语法；</li>
<li>代码高亮；</li>
<li>关键字匹配；</li>
<li>代码压缩。</li>
</ol>
<ul>
<li>生成 AST 分为两个阶段，一是词法分析，二是语法分析</li>
</ul>
<ol>
<li>词法分析：这个阶段会将源代码拆成最小的、不可再分的词法单元，称为 token。比如这行代码 var a =1；通常会被分解成 var 、a、=、2、; 这五个词法单元。另外刚才代码中的空格在 JavaScript 中是直接忽略的。</li>
<li>语法分析：这个过程是将词法单元转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树，这个树被称为抽象语法树。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line">// 第一段代码</span><br><span class="line"></span><br><span class="line">var a = 1;</span><br><span class="line"></span><br><span class="line">// 第二段代码</span><br><span class="line"></span><br><span class="line">function sum (a,b) &#123;</span><br><span class="line"></span><br><span class="line">  return a + b;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第一段代码，编译后的结果：</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  &quot;type&quot;: &quot;Program&quot;,</span><br><span class="line"></span><br><span class="line">  &quot;start&quot;: 0,</span><br><span class="line"></span><br><span class="line">  &quot;end&quot;: 10,</span><br><span class="line"></span><br><span class="line">  &quot;body&quot;: [</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      &quot;type&quot;: &quot;VariableDeclaration&quot;,</span><br><span class="line"></span><br><span class="line">      &quot;start&quot;: 0,</span><br><span class="line"></span><br><span class="line">      &quot;end&quot;: 10,</span><br><span class="line"></span><br><span class="line">      &quot;declarations&quot;: [</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">          &quot;type&quot;: &quot;VariableDeclarator&quot;,</span><br><span class="line"></span><br><span class="line">          &quot;start&quot;: 4,</span><br><span class="line"></span><br><span class="line">          &quot;end&quot;: 9,</span><br><span class="line"></span><br><span class="line">          &quot;id&quot;: &#123;</span><br><span class="line"></span><br><span class="line">            &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line"></span><br><span class="line">            &quot;start&quot;: 4,</span><br><span class="line"></span><br><span class="line">            &quot;end&quot;: 5,</span><br><span class="line"></span><br><span class="line">            &quot;name&quot;: &quot;a&quot;</span><br><span class="line"></span><br><span class="line">          &#125;,</span><br><span class="line"></span><br><span class="line">          &quot;init&quot;: &#123;</span><br><span class="line"></span><br><span class="line">            &quot;type&quot;: &quot;Literal&quot;,</span><br><span class="line"></span><br><span class="line">            &quot;start&quot;: 8,</span><br><span class="line"></span><br><span class="line">            &quot;end&quot;: 9,</span><br><span class="line"></span><br><span class="line">            &quot;value&quot;: 1,</span><br><span class="line"></span><br><span class="line">            &quot;raw&quot;: &quot;1&quot;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      ],</span><br><span class="line"></span><br><span class="line">      &quot;kind&quot;: &quot;var&quot;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  &quot;sourceType&quot;: &quot;module&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">第二段代码，编译出来的结果：</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  &quot;type&quot;: &quot;Program&quot;,</span><br><span class="line"></span><br><span class="line">  &quot;start&quot;: 0,</span><br><span class="line"></span><br><span class="line">  &quot;end&quot;: 38,</span><br><span class="line"></span><br><span class="line">  &quot;body&quot;: [</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      &quot;type&quot;: &quot;FunctionDeclaration&quot;,</span><br><span class="line"></span><br><span class="line">      &quot;start&quot;: 0,</span><br><span class="line"></span><br><span class="line">      &quot;end&quot;: 38,</span><br><span class="line"></span><br><span class="line">      &quot;id&quot;: &#123;</span><br><span class="line"></span><br><span class="line">        &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line"></span><br><span class="line">        &quot;start&quot;: 9,</span><br><span class="line"></span><br><span class="line">        &quot;end&quot;: 12,</span><br><span class="line"></span><br><span class="line">        &quot;name&quot;: &quot;sum&quot;</span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &quot;expression&quot;: false,</span><br><span class="line"></span><br><span class="line">      &quot;generator&quot;: false,</span><br><span class="line"></span><br><span class="line">      &quot;async&quot;: false,</span><br><span class="line"></span><br><span class="line">      &quot;params&quot;: [</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">          &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line"></span><br><span class="line">          &quot;start&quot;: 14,</span><br><span class="line"></span><br><span class="line">          &quot;end&quot;: 15,</span><br><span class="line"></span><br><span class="line">          &quot;name&quot;: &quot;a&quot;</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">          &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line"></span><br><span class="line">          &quot;start&quot;: 16,</span><br><span class="line"></span><br><span class="line">          &quot;end&quot;: 17,</span><br><span class="line"></span><br><span class="line">          &quot;name&quot;: &quot;b&quot;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      ],</span><br><span class="line"></span><br><span class="line">      &quot;body&quot;: &#123;</span><br><span class="line"></span><br><span class="line">        &quot;type&quot;: &quot;BlockStatement&quot;,</span><br><span class="line"></span><br><span class="line">        &quot;start&quot;: 19,</span><br><span class="line"></span><br><span class="line">        &quot;end&quot;: 38,</span><br><span class="line"></span><br><span class="line">        &quot;body&quot;: [</span><br><span class="line"></span><br><span class="line">          &#123;</span><br><span class="line"></span><br><span class="line">            &quot;type&quot;: &quot;ReturnStatement&quot;,</span><br><span class="line"></span><br><span class="line">            &quot;start&quot;: 23,</span><br><span class="line"></span><br><span class="line">            &quot;end&quot;: 36,</span><br><span class="line"></span><br><span class="line">            &quot;argument&quot;: &#123;</span><br><span class="line"></span><br><span class="line">              &quot;type&quot;: &quot;BinaryExpression&quot;,</span><br><span class="line"></span><br><span class="line">              &quot;start&quot;: 30,</span><br><span class="line"></span><br><span class="line">              &quot;end&quot;: 35,</span><br><span class="line"></span><br><span class="line">              &quot;left&quot;: &#123;</span><br><span class="line"></span><br><span class="line">                &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line"></span><br><span class="line">                &quot;start&quot;: 30,</span><br><span class="line"></span><br><span class="line">                &quot;end&quot;: 31,</span><br><span class="line"></span><br><span class="line">                &quot;name&quot;: &quot;a&quot;</span><br><span class="line"></span><br><span class="line">              &#125;,</span><br><span class="line"></span><br><span class="line">              &quot;operator&quot;: &quot;+&quot;,</span><br><span class="line"></span><br><span class="line">              &quot;right&quot;: &#123;</span><br><span class="line"></span><br><span class="line">                &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line"></span><br><span class="line">                &quot;start&quot;: 34,</span><br><span class="line"></span><br><span class="line">                &quot;end&quot;: 35,</span><br><span class="line"></span><br><span class="line">                &quot;name&quot;: &quot;b&quot;</span><br><span class="line"></span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  &quot;sourceType&quot;: &quot;module&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">从上面编译出的结果可以看到，AST 只是源代码语法结构的一种抽象的表示形式，计算机也不会去直接去识别 JS 代码，转换成抽象语法树也只是识别这一过程中的第一步。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>现在浏览器还不支持 ES6 语法，需要将其转换成 ES5 语法，这个过程就要借助 Babel 来实现。将 ES6 源码解析成 AST，再将 ES6 语法的抽象语法树转成 ES5 的抽象语法树，最后利用它来生成 ES5 的源代码。另外 ESlint 的原理也大致相同，检测流程也是将源码转换成抽象语法树，再利用它来检测代码规范。<h3 id="生成字节码"><a href="#生成字节码" class="headerlink" title="生成字节码"></a>生成字节码</h3></li>
<li>之前的 V8 版本不会经过这个过程，最早只是通过 AST 直接转换成机器码，而后面几个版本中才对此进行了改进。如果将 AST 直接转换为机器码还是会有一些问题存在的，例如：</li>
</ul>
<ol>
<li>直接转换会带来内存占用过大的问题，因为将抽象语法树全部生成了机器码，而机器码相比字节码占用的内存多了很多；</li>
<li>某些 JavaScript 使用场景使用解释器更为合适，解析成字节码，有些代码没必要生成机器码，进而尽可能减少了占用内存过大的问题。</li>
</ol>
<ul>
<li>官方在 V8 的 v5.6 版本中还是将抽象语法树转换成字节码这一过程又加上了，重新加入了字节码的处理过程。再然后，V8 重新引进了 Ignition 解释器，将抽象语法树转换成字节码后，内存占用显著下降了，同时也可以使用 JIT 编译器做进一步的优化。</li>
<li>字节码是介于 AST 和机器码之间的一种代码，需要将其转换成机器码后才能执行，字节码可以理解为是机器码的一种抽象。Ignition 解释器除了可以快速生成没有优化的字节码外，还可以执行部分字节码。<h3 id="生成机器码"><a href="#生成机器码" class="headerlink" title="生成机器码"></a>生成机器码</h3></li>
<li>在 Ignition 解释器处理完之后，如果发现一段代码被重复执行多次的情况，生成的字节码以及分析数据会传给 TurboFan 编译器，它会根据分析数据的情况生成优化好的机器码。再执行这段代码之后，只需要直接执行编译后的机器码，这样性能就会更好。</li>
<li>TurboFan 编译器，它是 JIT 优化的编译器，因为 V8 引擎是多线程的，TurboFan 的编译线程和生成字节码不会在同一个线程上，这样可以和 Ignition 解释器相互配合着使用，不受另一方的影响。</li>
<li>由 Ignition 解释器收集的分析数据被 TurboFan 编译器使用，主要是通过一种推测优化的技术，生成已经优化的机器码来执行。</li>
</ul>
<h2 id="JavaScript引擎如何执行JavaScript代码"><a href="#JavaScript引擎如何执行JavaScript代码" class="headerlink" title="JavaScript引擎如何执行JavaScript代码"></a>JavaScript引擎如何执行JavaScript代码</h2><ul>
<li>JavaScript 代码是需要在 JavaScript 引擎中运行的。我们在说到 JavaScript 运行的时候，常常会提到执行环境、词法环境、作用域、执行上下文、闭包等内容。</li>
<li>JavaScript引擎执行JavaScript代码时会进行词法分析、语法分析、语义分析等处理，最终生成抽象语法树，根据抽象语法树生成机器码</li>
<li>在 V8 引擎中 JavaScript 代码的运行过程主要分成三个阶段：</li>
</ul>
<ol>
<li>语法分析阶段：对代码进行语法分析，检查是否有语法错误</li>
<li>编译阶段：会创建执行上下文，包括变量对象的创建、作用域链的建立、this指向的确立等。每进入一个不同的运行环境，V8引擎都会创建一个执行上下文。</li>
<li>执行阶段：将编译阶段的执行上下文压入调用栈，代码执行结束后，将其弹出调用栈</li>
</ol>
<ul>
<li>前面提到的执行环境、词法环境、作用域、执行上下文等内容都是在编译和执行阶段中产生的概念。<h3 id="执行上下文创建"><a href="#执行上下文创建" class="headerlink" title="执行上下文创建"></a>执行上下文创建</h3></li>
<li>全局环境和函数环境的创建过程如下</li>
</ul>
<ol>
<li>第一次载入JavaScript代码时会创建一个全局环境。全局环境位于最外层，直到应用程序结束后（浏览器、网页关闭等）才会被销毁。</li>
<li>每个函数有自己的运行环境，当函数被调用时，会进入该函数的运行环境。当该环境中的代码全部执行完毕后，该环境会被销毁。不同函数运行环境不一样，同一个函数多次被调用会创建不同的函数环境。</li>
</ol>
<ul>
<li>每进入一个不同的运行环境时，JavaScript 都会创建一个新的执行上下文，该过程包括：</li>
</ul>
<ol>
<li>建立作用域链（Scope Chain）；</li>
<li>创建变量对象（Variable Object，简称 VO）；</li>
<li>确定 this 的指向。<h3 id="创建变量对象"><a href="#创建变量对象" class="headerlink" title="创建变量对象"></a>创建变量对象</h3></li>
</ol>
<ul>
<li>每个执行上下文都会有一个关联的变量对象，该对象上会保存这个上下文中定义的所有变量和函数。</li>
<li>而在浏览器中，全局环境的变量对象是window对象，因此所有的全局变量和函数都是作为window对象的属性和方法创建的。相应的，在 Node 中全局环境的变量对象则是global对象。</li>
<li>创建变量对象将会创建arguments对象（仅函数环境下），同时会检查当前上下文的函数声明和变量声明。</li>
</ul>
<ol>
<li>对于变量声明：此时会给变量分配内存，并将其初始化为undefined（该过程只进行定义声明，执行阶段才执行赋值语句）。</li>
<li>对于函数声明：此时会在内存里创建函数对象，并且直接初始化为该函数对象。</li>
</ol>
<ul>
<li>变量声明和函数声明的处理过程，便是我们常说的变量提升和函数提升，其中函数声明提升会优先于变量声明提升。因为变量提升容易带来变量在预期外被覆盖掉的问题，同时还可能导致本应该被销毁的变量没有被销毁等情况。因此 ES6 中引入了let和const关键字，从而使 JavaScript 也拥有了块级作用域。</li>
<li>在 JavaScript 中，词法环境又分为词法环境（Lexical Environment）和变量环境（Variable Environment）两种，其中：</li>
</ul>
<ol>
<li>变量环境用来记录var/function等变量声明；</li>
<li>词法环境是用来记录let/const/class等变量声明。<h3 id="建立作用域链"><a href="#建立作用域链" class="headerlink" title="建立作用域链"></a>建立作用域链</h3></li>
</ol>
<ul>
<li>作用域就是词法环境，而词法环境由两个成员组成。</li>
</ul>
<ol>
<li>环境记录（Environment Record）：用于记录自身词法环境中的变量对象。</li>
<li>外部词法环境引用（Outer Lexical Environment）：记录外层词法环境的引用。</li>
</ol>
<ul>
<li>通过外部词法环境的引用，作用域可以层层拓展，建立起从里到外延伸的一条作用域链。当某个变量无法在自身词法环境记录中找到时，可以根据外部词法环境引用向外层进行寻找，直到最外层的词法环境中外部词法环境引用为null，这便是作用域链的变量查询。</li>
<li><p>通过外部词法环境的引用，作用域可以层层拓展，建立起从里到外延伸的一条作用域链。当某个变量无法在自身词法环境记录中找到时，可以根据外部词法环境引用向外层进行寻找，直到最外层的词法环境中外部词法环境引用为null，这便是作用域链的变量查询。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">function foo(a) &#123;</span><br><span class="line"></span><br><span class="line">  var b = 2;</span><br><span class="line"></span><br><span class="line">  function c() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  var d = function() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foo(1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在执行foo(1)时，首先进入定义期，此时：</span><br><span class="line">参数变量a的值为1</span><br><span class="line">变量b和d初始化为undefined</span><br><span class="line">函数c创建函数并初始化</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">AO = &#123;</span><br><span class="line"></span><br><span class="line">  arguments: &#123;</span><br><span class="line"></span><br><span class="line">    0: 1,</span><br><span class="line"></span><br><span class="line">    length: 1</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  a: 1,</span><br><span class="line"></span><br><span class="line">  b: undefined,</span><br><span class="line"></span><br><span class="line">  c: reference to function c()&#123;&#125;,</span><br><span class="line"></span><br><span class="line">  d: undefined</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">进入执行期之后，会执行赋值语句进行赋值，此时变量b和d会被赋值为 2 和函数表达式：</span><br><span class="line">AO = &#123;</span><br><span class="line"></span><br><span class="line">   arguments: &#123;</span><br><span class="line"></span><br><span class="line">    0: 1,</span><br><span class="line"></span><br><span class="line">    length: 1</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  a: 1,</span><br><span class="line"></span><br><span class="line">  b: 2,</span><br><span class="line"></span><br><span class="line">  c: reference to function c()&#123;&#125;,</span><br><span class="line"></span><br><span class="line">  d: reference to FunctionExpression &quot;d&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>一般来说，当函数执行结束之后，执行期上下文将被销毁（作用域链和活动对象均被销毁）。但有时候我们想要保留其中一些变量对象，不想被销毁，此时就会使用到闭包。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line"></span><br><span class="line">  var a = 1;</span><br><span class="line"></span><br><span class="line">  function bar() &#123;</span><br><span class="line"></span><br><span class="line">    return a;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return bar;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var b = foo();</span><br><span class="line"></span><br><span class="line">console.log(b()); // 1</span><br><span class="line"></span><br><span class="line">在这个例子中，当b()执行时，foo函数上下文包括作用域都已经被销毁了，为什么foo作用域下的a依然可以被访问到呢？</span><br><span class="line"></span><br><span class="line">这是因为bar函数引用了foo函数变量对象中的值，此时即使创建bar函数的foo函数执行上下文被销毁了，但它的变量对象依然会保留在 JavaScript 内存中，bar函数依然可以通过bar函数的作用域链找到它，并进行访问。这便是我们常说的闭包，即使创建它的上下文已经销毁，它仍然被保留在内存中。</span><br></pre></td></tr></table></figure>
</li>
<li><p>闭包使得我们可以从外部读取局部变量，在大多数项目中都会被使用到，常见的用途包括：</p>
</li>
</ul>
<ol>
<li>用于从外部读取其他函数内部变量的函数；</li>
<li>可以使用闭包来模拟私有方法；</li>
<li>让这些变量的值始终保持在内存中。<h3 id="确定-this-的指向"><a href="#确定-this-的指向" class="headerlink" title="确定 this 的指向"></a>确定 this 的指向</h3></li>
</ol>
<ul>
<li>根据 JavaScript 中函数的调用方式不同，this的指向分为以下情况。</li>
</ul>
<ol>
<li>在全局环境中，this指向全局对象（在浏览器中为window）</li>
<li>在函数内部，this的值取决于函数被调用的方式<br>函数作为对象的方法被调用，this指向调用这个方法的对象<br>函数用作构造函数时（使用new关键字），它的this被绑定到正在构造的新对象</li>
<li>在类的构造函数中，this是一个常规对象，类中所有非静态的方法都会被添加到this的原型中</li>
<li>在箭头函数中，this指向它被创建时的环境</li>
<li>使用apply、call、bind等方式调用：根据 API 不同，可切换函数执行的上下文环境，即this绑定的对象</li>
</ol>
<h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h2><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><ul>
<li>如果一定要解释 Promise 到底是什么，简单来说它就是一个容器，里面保存着某个未来才会结束的事件（通常是异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。</li>
<li>回调地狱有两个主要的问题：</li>
</ul>
<ol>
<li>多层嵌套的问题；</li>
<li>每种任务的处理结果存在两种可能性（成功或失败），那么需要在每种任务执行结束后分别处理这两种可能性。</li>
</ol>
<ul>
<li>Promise 的静态方法</li>
</ul>
<ol>
<li><p>all 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">此方法对于汇总多个 promise 的结果很有用，在 ES6 中可以将多个 Promise.all 异步请求并行操作，返回结果一般有下面两种情况。</span><br><span class="line">1.当所有结果成功返回时按照请求顺序返回成功。</span><br><span class="line">2.当其中有一个失败方法时，则进入失败方法</span><br><span class="line"></span><br><span class="line">//1.获取轮播数据列表</span><br><span class="line"></span><br><span class="line">function getBannerList()&#123;</span><br><span class="line"></span><br><span class="line">  return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">      setTimeout(function()&#123;</span><br><span class="line"></span><br><span class="line">        resolve(&apos;轮播数据&apos;)</span><br><span class="line"></span><br><span class="line">      &#125;,300) </span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//2.获取店铺列表</span><br><span class="line"></span><br><span class="line">function getStoreList()&#123;</span><br><span class="line"></span><br><span class="line">  return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line"></span><br><span class="line">      resolve(&apos;店铺数据&apos;)</span><br><span class="line"></span><br><span class="line">    &#125;,500)</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//3.获取分类列表</span><br><span class="line"></span><br><span class="line">function getCategoryList()&#123;</span><br><span class="line"></span><br><span class="line">  return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line"></span><br><span class="line">      resolve(&apos;分类数据&apos;)</span><br><span class="line"></span><br><span class="line">    &#125;,700)</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function initLoad()&#123; </span><br><span class="line"></span><br><span class="line">  Promise.all([getBannerList(),getStoreList(),getCategoryList()])</span><br><span class="line"></span><br><span class="line">  .then(res=&gt;&#123;</span><br><span class="line"></span><br><span class="line">    console.log(res) </span><br><span class="line"></span><br><span class="line">  &#125;).catch(err=&gt;&#123;</span><br><span class="line"></span><br><span class="line">    console.log(err)</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">initLoad()</span><br></pre></td></tr></table></figure>
</li>
<li><p>allSettled 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Promise.allSettled 的语法及参数跟 Promise.all 类似，唯一的不同在于，执行完之后不会失败，也就是说当 Promise.allSettled 全部处理完成后，我们可以拿到每个 Promise 的状态，而不管其是否处理成功。</span><br><span class="line"></span><br><span class="line">const resolved = Promise.resolve(2);</span><br><span class="line"></span><br><span class="line">const rejected = Promise.reject(-1);</span><br><span class="line"></span><br><span class="line">const allSettledPromise = Promise.allSettled([resolved, rejected]);</span><br><span class="line"></span><br><span class="line">allSettledPromise.then(function (results) &#123;</span><br><span class="line"></span><br><span class="line">  console.log(results);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 返回结果：</span><br><span class="line"></span><br><span class="line">// [</span><br><span class="line"></span><br><span class="line">//    &#123; status: &apos;fulfilled&apos;, value: 2 &#125;,</span><br><span class="line"></span><br><span class="line">//    &#123; status: &apos;rejected&apos;, reason: -1 &#125;</span><br><span class="line"></span><br><span class="line">// ]</span><br></pre></td></tr></table></figure>
</li>
<li><p>any 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">any 方法返回一个 Promise，只要参数 Promise 实例有一个变成 fulfilled 状态，最后 any 返回的实例就会变成 fulfilled 状态；如果所有参数 Promise 实例都变成 rejected 状态，包装实例就会变成 rejected 状态。</span><br><span class="line">const resolved = Promise.resolve(2);</span><br><span class="line"></span><br><span class="line">const rejected = Promise.reject(-1);</span><br><span class="line"></span><br><span class="line">const anyPromise = Promise.any([resolved, rejected]);</span><br><span class="line"></span><br><span class="line">anyPromise.then(function (results) &#123;</span><br><span class="line"></span><br><span class="line">  console.log(results);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 返回结果：</span><br><span class="line"></span><br><span class="line">// 2</span><br></pre></td></tr></table></figure>
</li>
<li><p>race 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"> race 方法返回一个 Promise，只要参数的 Promise 之中有一个实例率先改变状态，则 race 方法的返回状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给 race 方法的回调函数。</span><br><span class="line"> //请求某个图片资源</span><br><span class="line"></span><br><span class="line">function requestImg()&#123;</span><br><span class="line"></span><br><span class="line">  var p = new Promise(function(resolve, reject)&#123;</span><br><span class="line"></span><br><span class="line">    var img = new Image();</span><br><span class="line"></span><br><span class="line">    img.onload = function()&#123; resolve(img); &#125;</span><br><span class="line"></span><br><span class="line">    img.src = &apos;http://www.baidu.com/img/flexible/logo/pc/result.png&apos;;</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return p;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//延时函数，用于给请求计时</span><br><span class="line"></span><br><span class="line">function timeout()&#123;</span><br><span class="line"></span><br><span class="line">  var p = new Promise(function(resolve, reject)&#123;</span><br><span class="line"></span><br><span class="line">    setTimeout(function()&#123; reject(&apos;图片请求超时&apos;); &#125;, 5000);</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return p;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise.race([requestImg(), timeout()])</span><br><span class="line"></span><br><span class="line">.then(function(results)&#123;</span><br><span class="line"></span><br><span class="line">  console.log(results);</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">.catch(function(reason)&#123;</span><br><span class="line"></span><br><span class="line">  console.log(reason);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h3><ul>
<li>通俗来讲 Generator 是一个带星号的“函数”（它并不是真正的函数），可以配合 yield 关键字来暂停或者执行函数。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">function* gen() &#123;</span><br><span class="line"></span><br><span class="line">  console.log(&quot;enter&quot;);</span><br><span class="line"></span><br><span class="line">  let a = yield 1;</span><br><span class="line"></span><br><span class="line">  let b = yield (function () &#123;return 2&#125;)();</span><br><span class="line"></span><br><span class="line">  return 3;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var g = gen()           // 阻塞住，不会执行任何语句</span><br><span class="line"></span><br><span class="line">console.log(g.next())</span><br><span class="line"></span><br><span class="line">console.log(g.next())</span><br><span class="line"></span><br><span class="line">console.log(g.next())</span><br><span class="line"></span><br><span class="line">console.log(g.next()) </span><br><span class="line"></span><br><span class="line">// output:</span><br><span class="line"></span><br><span class="line">// &#123; value: 1, done: false &#125;</span><br><span class="line"></span><br><span class="line">// &#123; value: 2, done: false &#125;</span><br><span class="line"></span><br><span class="line">// &#123; value: 3, done: true &#125;</span><br><span class="line"></span><br><span class="line">// &#123; value: undefined, done: true &#125;</span><br><span class="line"></span><br><span class="line">Generator 的执行有这几个关键点</span><br><span class="line">1. 调用 gen() 后，程序会阻塞住，不会执行任何语句。</span><br><span class="line">2. 调用 g.next() 后，程序继续执行，直到遇到 yield 关键词时执行暂停。</span><br><span class="line">3. 一直执行 next 方法，最后返回一个对象，其存在两个属性：value 和 done。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function* gen1() &#123;</span><br><span class="line"></span><br><span class="line">    yield 1;</span><br><span class="line"></span><br><span class="line">    yield* gen2();</span><br><span class="line"></span><br><span class="line">    yield 4;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function* gen2() &#123;</span><br><span class="line"></span><br><span class="line">    yield 2;</span><br><span class="line"></span><br><span class="line">    yield 3;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var g = gen1();</span><br><span class="line"></span><br><span class="line">console.log(g.next())</span><br><span class="line"></span><br><span class="line">console.log(g.next())</span><br><span class="line"></span><br><span class="line">console.log(g.next())</span><br><span class="line"></span><br><span class="line">console.log(g.next())</span><br><span class="line"></span><br><span class="line">// output:</span><br><span class="line"></span><br><span class="line">// &#123; value: 1, done: false &#125;</span><br><span class="line"></span><br><span class="line">// &#123; value: 2, done: false &#125;</span><br><span class="line"></span><br><span class="line">// &#123; value: 3, done: false &#125;</span><br><span class="line"></span><br><span class="line">// &#123; value: 4, done: false &#125;</span><br><span class="line"></span><br><span class="line">// &#123;value: undefined, done: true&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="thunk-函数"><a href="#thunk-函数" class="headerlink" title="thunk 函数"></a>thunk 函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">let isString = (obj) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  return Object.prototype.toString.call(obj) === &apos;[object String]&apos;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let isFunction = (obj) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  return Object.prototype.toString.call(obj) === &apos;[object Function]&apos;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let isArray = (obj) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  return Object.prototype.toString.call(obj) === &apos;[object Array]&apos;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">可以看到，其中出现了非常多重复的数据类型判断逻辑，平常业务开发中类似的重复逻辑的场景也同样会有很多。我们将它们做一下封装，如下所示。</span><br><span class="line">let isType = (type) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  return (obj) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    return Object.prototype.toString.call(obj) === `[object $&#123;type&#125;]`;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let isString = isType(&apos;String&apos;);</span><br><span class="line"></span><br><span class="line">let isArray = isType(&apos;Array&apos;);</span><br><span class="line"></span><br><span class="line">isString(&quot;123&quot;);    // true</span><br><span class="line"></span><br><span class="line">isArray([1,2,3]);   // true</span><br><span class="line">像 isType 这样的函数我们称为 thunk 函数，它的基本思路都是接收一定的参数，会生产出定制化的函数，最后使用定制化的函数去完成想要实现的功能。</span><br></pre></td></tr></table></figure>
<h4 id="Generator-和-thunk-结合"><a href="#Generator-和-thunk-结合" class="headerlink" title="Generator 和 thunk 结合"></a>Generator 和 thunk 结合</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">const readFileThunk = (filename) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  return (callback) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    fs.readFile(filename, callback);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const gen = function* () &#123;</span><br><span class="line"></span><br><span class="line">  const data1 = yield readFileThunk(&apos;1.txt&apos;)</span><br><span class="line"></span><br><span class="line">  console.log(data1.toString())</span><br><span class="line"></span><br><span class="line">  const data2 = yield readFileThunk(&apos;2.txt&apos;)</span><br><span class="line"></span><br><span class="line">  console.log(data2.toString)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let g = gen();</span><br><span class="line"></span><br><span class="line">g.next().value((err, data1) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  g.next(data1).value((err, data2) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    g.next(data2);</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">上面第三段代码执行起来嵌套的情况还算简单，如果任务多起来，就会产生很多层的嵌套，可读性不强，</span><br><span class="line">function run(gen)&#123;</span><br><span class="line"></span><br><span class="line">  const next = (err, data) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    let res = gen.next(data);</span><br><span class="line"></span><br><span class="line">    if(res.done) return;</span><br><span class="line"></span><br><span class="line">    res.value(next);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  next();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(g);</span><br></pre></td></tr></table></figure>
<h4 id="Generator-和-Promise-结合"><a href="#Generator-和-Promise-结合" class="headerlink" title="Generator 和 Promise 结合"></a>Generator 和 Promise 结合</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">// 最后包装成 Promise 对象进行返回</span><br><span class="line"></span><br><span class="line">const readFilePromise = (filename) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    fs.readFile(filename, (err, data) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">      if(err) &#123;</span><br><span class="line"></span><br><span class="line">        reject(err);</span><br><span class="line"></span><br><span class="line">      &#125;else &#123;</span><br><span class="line"></span><br><span class="line">        resolve(data);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  &#125;).then(res =&gt; res);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> let g = gen();</span><br><span class="line"></span><br><span class="line">// 这块和上面 thunk 的方式一样</span><br><span class="line"></span><br><span class="line">const gen = function* () &#123;</span><br><span class="line"></span><br><span class="line">  const data1 = yield readFilePromise(&apos;1.txt&apos;)</span><br><span class="line"></span><br><span class="line">  console.log(data1.toString())</span><br><span class="line"></span><br><span class="line">  const data2 = yield readFilePromise(&apos;2.txt&apos;)</span><br><span class="line"></span><br><span class="line">  console.log(data2.toString)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 这块和上面 thunk 的方式一样</span><br><span class="line"></span><br><span class="line">function run(gen)&#123;</span><br><span class="line"></span><br><span class="line">  const next = (err, data) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    let res = gen.next(data);</span><br><span class="line"></span><br><span class="line">    if(res.done) return;</span><br><span class="line"></span><br><span class="line">    res.value.then(next);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  next();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(g);</span><br></pre></td></tr></table></figure>
<h4 id="co-函数库"><a href="#co-函数库" class="headerlink" title="co 函数库"></a>co 函数库</h4><ul>
<li>为什么 co 函数库可以自动执行 Generator 函数，它的处理原理是什么呢？</li>
</ul>
<ol>
<li>因为 Generator 函数就是一个异步操作的容器，它需要一种自动执行机制，co 函数接受 Generator 函数作为参数，并最后返回一个 Promise 对象。</li>
<li>在返回的 Promise 对象里面，co 先检查参数 gen 是否为 Generator 函数。如果是，就执行该函数；如果不是就返回，并将 Promise 对象的状态改为 resolved。</li>
<li>co 将 Generator 函数的内部指针对象的 next 方法，包装成 onFulfilled 函数。这主要是为了能够捕捉抛出的错误。</li>
<li>关键的是 next 函数，它会反复调用自身。<h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// readFilePromise 依旧返回 Promise 对象</span><br><span class="line"></span><br><span class="line">const readFilePromise = (filename) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    fs.readFile(filename, (err, data) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">      if(err) &#123;</span><br><span class="line"></span><br><span class="line">        reject(err);</span><br><span class="line"></span><br><span class="line">      &#125;else &#123;</span><br><span class="line"></span><br><span class="line">        resolve(data);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  &#125;).then(res =&gt; res);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 这里把 Generator的 * 换成 async，把 yield 换成 await</span><br><span class="line"></span><br><span class="line">const gen = async function() &#123;</span><br><span class="line"></span><br><span class="line">  const data1 = await readFilePromise(&apos;1.txt&apos;)</span><br><span class="line"></span><br><span class="line">  console.log(data1.toString())</span><br><span class="line"></span><br><span class="line">  const data2 = await readFilePromise(&apos;2.txt&apos;)</span><br><span class="line"></span><br><span class="line">  console.log(data2.toString)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>async 函数对 Generator 函数的改进，主要体现在以下三点<br>内置执行器：Generator 函数的执行必须靠执行器，因为不能一次性执行完成，所以之后才有了开源的 co 函数库。但是，async 函数和正常的函数一样执行，也不用 co 函数库，也不用使用 next 方法，而 async 函数自带执行器，会自动执行。<br>适用性更好：co 函数库有条件约束，yield 命令后面只能是 Thunk 函数或 Promise 对象，但是 async 函数的 await 关键词后面，可以不受约束。<br>可读性更好：async 和 await，比起使用 * 号和 yield，语义更清晰明了。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">async function func() &#123;</span><br><span class="line"></span><br><span class="line">  return 100;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(func());</span><br><span class="line"></span><br><span class="line">// Promise &#123;&lt;fulfilled&gt;: 100&#125;</span><br><span class="line">从执行的结果可以看出，async 函数 func 最后返回的结果直接是 Promise 对象，比较方便让开发者继续往后处理。而之前 Generator 并不会自动执行，需要通过 next 方法控制，最后返回的也并不是 Promise 对象，而是需要通过 co 函数库来实现最后返回 Promise 对象。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="EventEmitter"><a href="#EventEmitter" class="headerlink" title="EventEmitter"></a>EventEmitter</h3><ul>
<li>Node.js的events 模块对外提供了一个 EventEmitter 对象，用于对 Node.js 中的事件进行统一管理。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var events = require(&apos;events&apos;);</span><br><span class="line"></span><br><span class="line">var eventEmitter = new events.EventEmitter();</span><br><span class="line"></span><br><span class="line">eventEmitter.on(&apos;say&apos;,function(name)&#123;</span><br><span class="line"></span><br><span class="line">    console.log(&apos;Hello&apos;,name);</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">eventEmitter.emit(&apos;say&apos;,&apos;Jonh&apos;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="addListener-和-removeListener、on-和-off-方法对比"><a href="#addListener-和-removeListener、on-和-off-方法对比" class="headerlink" title="addListener 和 removeListener、on 和 off 方法对比"></a>addListener 和 removeListener、on 和 off 方法对比</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">addListener 方法的作用是为指定事件添加一个监听器，其实和 on 方法实现的功能是一样的，on 其实就是 addListener 方法的一个别名。</span><br><span class="line">二者实现的作用是一样的，同时 removeListener 方法的作用是为移除某个事件的监听器，同样 off 也是 removeListener 的别名。</span><br><span class="line">var events = require(&apos;events&apos;);</span><br><span class="line"></span><br><span class="line">var emitter = new events.EventEmitter();</span><br><span class="line"></span><br><span class="line">function hello1(name)&#123;</span><br><span class="line"></span><br><span class="line">  console.log(&quot;hello 1&quot;,name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function hello2(name)&#123;</span><br><span class="line"></span><br><span class="line">  console.log(&quot;hello 2&quot;,name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">emitter.addListener(&apos;say&apos;,hello1);</span><br><span class="line"></span><br><span class="line">emitter.addListener(&apos;say&apos;,hello2);</span><br><span class="line"></span><br><span class="line">emitter.emit(&apos;say&apos;,&apos;John&apos;);</span><br><span class="line"></span><br><span class="line">//输出hello 1 John </span><br><span class="line"></span><br><span class="line">//输出hello 2 John</span><br><span class="line"></span><br><span class="line">emitter.removeListener(&apos;say&apos;,hello1);</span><br><span class="line"></span><br><span class="line">emitter.emit(&apos;say&apos;,&apos;John&apos;);</span><br><span class="line"></span><br><span class="line">//相应的，监听say事件的hello1事件被移除</span><br><span class="line"></span><br><span class="line">//只输出hello 2 John</span><br></pre></td></tr></table></figure>
<h4 id="removeListener-和-removeAllListeners"><a href="#removeListener-和-removeAllListeners" class="headerlink" title="removeListener 和 removeAllListeners"></a>removeListener 和 removeAllListeners</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var events = require(&apos;events&apos;);</span><br><span class="line"></span><br><span class="line">var emitter = new events.EventEmitter();</span><br><span class="line"></span><br><span class="line">function hello1(name)&#123;</span><br><span class="line"></span><br><span class="line">  console.log(&quot;hello 1&quot;,name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function hello2(name)&#123;</span><br><span class="line"></span><br><span class="line">  console.log(&quot;hello 2&quot;,name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">emitter.addListener(&apos;say&apos;,hello1);</span><br><span class="line"></span><br><span class="line">emitter.addListener(&apos;say&apos;,hello2);</span><br><span class="line"></span><br><span class="line">emitter.removeAllListeners(&apos;say&apos;);</span><br><span class="line"></span><br><span class="line">emitter.emit(&apos;say&apos;,&apos;John&apos;);</span><br><span class="line"></span><br><span class="line">//removeAllListeners 移除了所有关于 say 事件的监听</span><br><span class="line"></span><br><span class="line">//因此没有任何输出</span><br></pre></td></tr></table></figure>
<h4 id="on-和-once-方法区别"><a href="#on-和-once-方法区别" class="headerlink" title="on 和 once 方法区别"></a>on 和 once 方法区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var events = require(&apos;events&apos;);</span><br><span class="line"></span><br><span class="line">var emitter = new events.EventEmitter();</span><br><span class="line"></span><br><span class="line">function hello(name)&#123;</span><br><span class="line"></span><br><span class="line">  console.log(&quot;hello&quot;,name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">emitter.on(&apos;say&apos;,hello);</span><br><span class="line"></span><br><span class="line">emitter.emit(&apos;say&apos;,&apos;John&apos;);</span><br><span class="line"></span><br><span class="line">emitter.emit(&apos;say&apos;,&apos;Lily&apos;);</span><br><span class="line"></span><br><span class="line">emitter.emit(&apos;say&apos;,&apos;Lucy&apos;);</span><br><span class="line"></span><br><span class="line">//会输出 hello John、hello Lily、hello Lucy，之后还要加也可以继续触发</span><br><span class="line"></span><br><span class="line">emitter.once(&apos;see&apos;,hello);</span><br><span class="line"></span><br><span class="line">emitter.emit(&apos;see&apos;,&apos;Tom&apos;);</span><br><span class="line"></span><br><span class="line">//只会输出一次 hello Tom</span><br></pre></td></tr></table></figure>
<h4 id="实现一个-EventEmitter"><a href="#实现一个-EventEmitter" class="headerlink" title="实现一个 EventEmitter"></a>实现一个 EventEmitter</h4><ul>
<li>自己封装一个能在浏览器中跑的EventEmitter，并应用在你的业务代码中还是能带来不少方便的，它可以帮你实现自定义事件的订阅和发布，从而提升业务开发的便利性。</li>
<li>EventEmitter 采用的正是发布-订阅模式。</li>
<li>发布-订阅模式在观察者模式的基础上，在目标和观察者之间增加了一个调度中心。</li>
<li>在 Vue 框架中不同组件之间的通讯里，有一种解决方案叫 EventBus。和 EventEmitter的思路类似，它的基本用途是将 EventBus 作为组件传递数据的桥梁，所有组件共用相同的事件中心，可以向该中心注册发送事件或接收事件，所有组件都可以收到通知，使用起来非常便利，其核心其实就是发布-订阅模式的落地实现。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function EventEmitter() &#123;</span><br><span class="line"></span><br><span class="line">    this.__events = &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventEmitter.VERSION = &apos;1.0.0&apos;;</span><br><span class="line"></span><br><span class="line">从上面的代码中可以看到，我们先初始化了一个内部的__events 的对象，用来存放自定义事件，以及自定义事件的回调函数。</span><br><span class="line"></span><br><span class="line">EventEmitter.prototype.on = function(eventName, listener)&#123;</span><br><span class="line"></span><br><span class="line">	  if (!eventName || !listener) return;</span><br><span class="line"></span><br><span class="line">      // 判断回调的 listener 是否为函数</span><br><span class="line"></span><br><span class="line">	  if (!isValidListener(listener)) &#123;</span><br><span class="line"></span><br><span class="line">	       throw new TypeError(&apos;listener must be a function&apos;);</span><br><span class="line"></span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	   var events = this.__events;</span><br><span class="line"></span><br><span class="line">	   var listeners = events[eventName] = events[eventName] || [];</span><br><span class="line"></span><br><span class="line">	   var listenerIsWrapped = typeof listener === &apos;object&apos;;</span><br><span class="line"></span><br><span class="line">       // 不重复添加事件，判断是否有一样的</span><br><span class="line"></span><br><span class="line">       if (indexOf(listeners, listener) === -1) &#123;</span><br><span class="line"></span><br><span class="line">           listeners.push(listenerIsWrapped ? listener : &#123;</span><br><span class="line"></span><br><span class="line">               listener: listener,</span><br><span class="line"></span><br><span class="line">               once: false</span><br><span class="line"></span><br><span class="line">           &#125;);</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">	   return this;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 判断是否是合法的 listener</span><br><span class="line"></span><br><span class="line"> function isValidListener(listener) &#123;</span><br><span class="line"></span><br><span class="line">     if (typeof listener === &apos;function&apos;) &#123;</span><br><span class="line"></span><br><span class="line">         return true;</span><br><span class="line"></span><br><span class="line">     &#125; else if (listener &amp;&amp; typeof listener === &apos;object&apos;) &#123;</span><br><span class="line"></span><br><span class="line">         return isValidListener(listener.listener);</span><br><span class="line"></span><br><span class="line">     &#125; else &#123;</span><br><span class="line"></span><br><span class="line">         return false;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 顾名思义，判断新增自定义事件是否存在</span><br><span class="line"></span><br><span class="line">function indexOf(array, item) &#123;</span><br><span class="line"></span><br><span class="line">     var result = -1</span><br><span class="line"></span><br><span class="line">     item = typeof item === &apos;object&apos; ? item.listener : item;</span><br><span class="line"></span><br><span class="line">     for (var i = 0, len = array.length; i &lt; len; i++) &#123;</span><br><span class="line"></span><br><span class="line">         if (array[i].listener === item) &#123;</span><br><span class="line"></span><br><span class="line">             result = i;</span><br><span class="line"></span><br><span class="line">             break;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">从上面的代码中可以看出，on 方法的核心思路就是，当调用订阅一个自定义事件的时候，只要该事件通过校验合法之后，就把该自定义事件 push 到 this.__events 这个对象中存储，等需要出发的时候，则直接从通过获取 __events 中对应事件的 listener 回调函数，而后直接执行该回调方法就能实现想要的效果。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EventEmitter.prototype.emit = function(eventName, args) &#123;</span><br><span class="line"></span><br><span class="line">     // 直接通过内部对象获取对应自定义事件的回调函数</span><br><span class="line"></span><br><span class="line">     var listeners = this.__events[eventName];</span><br><span class="line"></span><br><span class="line">     if (!listeners) return;</span><br><span class="line"></span><br><span class="line">     // 需要考虑多个 listener 的情况</span><br><span class="line"></span><br><span class="line">     for (var i = 0; i &lt; listeners.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">         var listener = listeners[i];</span><br><span class="line"></span><br><span class="line">         if (listener) &#123;</span><br><span class="line"></span><br><span class="line">             listener.listener.apply(this, args || []);</span><br><span class="line"></span><br><span class="line">             // 给 listener 中 once 为 true 的进行特殊处理</span><br><span class="line"></span><br><span class="line">             if (listener.once) &#123;</span><br><span class="line"></span><br><span class="line">                 this.off(eventName, listener.listener)</span><br><span class="line"></span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     return this;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EventEmitter.prototype.off = function(eventName, listener) &#123;</span><br><span class="line"></span><br><span class="line">     var listeners = this.__events[eventName];</span><br><span class="line"></span><br><span class="line">     if (!listeners) return;</span><br><span class="line"></span><br><span class="line">     var index;</span><br><span class="line"></span><br><span class="line">     for (var i = 0, len = listeners.length; i &lt; len; i++) &#123;</span><br><span class="line"></span><br><span class="line">	    if (listeners[i] &amp;&amp; listeners[i].listener === listener) &#123;</span><br><span class="line"></span><br><span class="line">           index = i;</span><br><span class="line"></span><br><span class="line">           break;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // off 的关键</span><br><span class="line"></span><br><span class="line">    if (typeof index !== &apos;undefined&apos;) &#123;</span><br><span class="line"></span><br><span class="line">         listeners.splice(index, 1, null)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return this;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">从上面的代码中可以看出 emit 的处理方式，其实就是拿到对应自定义事件进行 apply 执行，在执行过程中对于一开始 once 方法绑定的自定义事件进行特殊的处理，当once 为 true的时候，再触发 off 方法对该自定义事件进行解绑，从而实现自定义事件一次执行的效果。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EventEmitter.prototype.once = function(eventName, listener）&#123;</span><br><span class="line"></span><br><span class="line">    // 直接调用 on 方法，once 参数传入 true，待执行之后进行 once 处理</span><br><span class="line"></span><br><span class="line">     return this.on(eventName, &#123;</span><br><span class="line"></span><br><span class="line">         listener: listener,</span><br><span class="line"></span><br><span class="line">         once: true</span><br><span class="line"></span><br><span class="line">     &#125;)</span><br><span class="line"></span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line">EventEmitter.prototype.allOff = function(eventName) &#123;</span><br><span class="line"></span><br><span class="line">     // 如果该 eventName 存在，则将其对应的 listeners 的数组直接清空</span><br><span class="line"></span><br><span class="line">     if (eventName &amp;&amp; this.__events[eventName]) &#123;</span><br><span class="line"></span><br><span class="line">         this.__events[eventName] = []</span><br><span class="line"></span><br><span class="line">     &#125; else &#123;</span><br><span class="line"></span><br><span class="line">         this.__events = &#123;&#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">从上面的代码中可以看到，once 方法的本质还是调用 on 方法，只不过传入的参数区分和非一次执行的情况。当再次触发 emit 方法的时候，once 绑定的执行一次之后再进行解绑。</span><br><span class="line"></span><br><span class="line">这样，alloff 方法也很好理解了，其实就是对内部的__events 对象进行清空，清空之后如果再次触发自定义事件，也就无法触发回调函数了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------------------------Low逼版，见笑了-----------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function EventEmitter() &#123;</span><br><span class="line">  this.__events = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventEmitter.VERSION = &quot;1.0.0&quot;;</span><br><span class="line"></span><br><span class="line">//绑定事件</span><br><span class="line">EventEmitter.prototype.on = function (eventName, event) &#123;</span><br><span class="line">  let events = (this.__events[eventName] = this.__events[eventName] || []);</span><br><span class="line">  //是否存在该事件</span><br><span class="line">  let isExist = events.find((ev) =&gt; ev.listener === (event.listener || event));</span><br><span class="line">  if (!isExist) &#123;</span><br><span class="line">    events.push(</span><br><span class="line">      //对象或函数</span><br><span class="line">      event.listener</span><br><span class="line">        ? event</span><br><span class="line">        : &#123;</span><br><span class="line">            once: false,</span><br><span class="line">            listener: event,</span><br><span class="line">          &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return this;</span><br><span class="line">&#125;;</span><br><span class="line">//触发事件</span><br><span class="line">EventEmitter.prototype.emit = function (eventName, args) &#123;</span><br><span class="line">  let events = this.__events[eventName] || [];</span><br><span class="line"></span><br><span class="line">  //多个事件</span><br><span class="line">  for (let event of events) &#123;</span><br><span class="line">    event.listener.apply(this, args || []);</span><br><span class="line">    if (event.once) &#123;</span><br><span class="line">      this.off(eventName, event);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//执行一次</span><br><span class="line">EventEmitter.prototype.once = function (eventName, event) &#123;</span><br><span class="line">  return this.on(eventName, &#123;</span><br><span class="line">    once: true,</span><br><span class="line">    listener: event.listener || event,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">//移除事件</span><br><span class="line">EventEmitter.prototype.off = function (eventName, event) &#123;</span><br><span class="line">  let events = this.__events[eventName] || [];</span><br><span class="line">  //事件下标</span><br><span class="line">  let eventIndex = events.findIndex(</span><br><span class="line">    (ev) =&gt; ev.listener === (event.listener || event)</span><br><span class="line">  );</span><br><span class="line">  //存在该事件时</span><br><span class="line">  if (eventIndex !== -1) events.splice(eventIndex, 1);</span><br><span class="line">&#125;;</span><br><span class="line">//移除所有事件</span><br><span class="line">EventEmitter.prototype.allOff = function (eventName) &#123;</span><br><span class="line">  if (this.__events[eventName]) this.__events[eventName] = [];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="实现符合-Promise-A-规范的-Promise"><a href="#实现符合-Promise-A-规范的-Promise" class="headerlink" title="实现符合 Promise/A+ 规范的 Promise"></a>实现符合 Promise/A+ 规范的 Promise</h3><h4 id="Promise-A-规范"><a href="#Promise-A-规范" class="headerlink" title="Promise/A+ 规范"></a>Promise/A+ 规范</h4><ul>
<li>Promise/A+ 规范的基本术语，如下所示</li>
</ul>
<ol>
<li>“promise”：是一个具有 then 方法的对象或者函数，它的行为符合该规范。</li>
<li>“thenable”：是一个定义了 then 方法的对象或者函数。</li>
<li>“value”：可以是任何一个合法的 JavaScript 的值（包括 undefined、thenable 或 promise）。</li>
<li>“exception”：是一个异常，是在 Promise 里面可以用 throw 语句抛出来的值。</li>
<li>“reason”：是一个 Promise 里 reject 之后返回的拒绝原因。</li>
</ol>
<ul>
<li>Promise/A+ 规范中，对 Promise 的内部状态的描述，如下所示</li>
</ul>
<ol>
<li>一个 Promise 有三种状态：pending、fulfilled 和 rejected。</li>
<li>当状态为 pending 状态时，即可以转换为 fulfilled 或者 rejected 其中之一。</li>
<li>当状态为 fulfilled 状态时，就不能转换为其他状态了，必须返回一个不能再改变的值。</li>
<li>当状态为 rejected 状态时，同样也不能转换为其他状态，必须有一个原因的值也不能改变</li>
</ol>
<ul>
<li>一个 Promise 必须拥有一个 then 方法来访问它的值或者拒绝原因。</li>
</ul>
<ol>
<li><code>promise.then(onFulfilled, onRejected)</code> then 方法有两个参数：onFulfilled 和 onRejected 都是可选参数。</li>
<li>如果 onFulfilled 是函数，则当 Promise 执行结束之后必须被调用，最终返回值为 value，其调用次数不可超过一次。</li>
<li>而 onRejected 除了最后返回的是 reason 外，其他方面和 onFulfilled 在规范上的表述基本一样。</li>
</ol>
<ul>
<li>then 方法其实可以被一个 Promise 调用多次，且必须返回一个 Promise 对象。<h4 id="一步步实现-Promise"><a href="#一步步实现-Promise" class="headerlink" title="一步步实现 Promise"></a>一步步实现 Promise</h4><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">Promise 构造函数接受一个 executor 函数，executor 函数执行完同步或者异步操作后，调用它的两个参数 resolve 和 reject。</span><br><span class="line">function Promise(executor) &#123;</span><br><span class="line"></span><br><span class="line">  var self = this</span><br><span class="line"></span><br><span class="line">  self.status = &apos;pending&apos;   // Promise当前的状态</span><br><span class="line"></span><br><span class="line">  self.data = undefined     // Promise的值</span><br><span class="line"></span><br><span class="line">  self.onResolvedCallback = [] // Promise resolve时的回调函数集</span><br><span class="line"></span><br><span class="line">  self.onRejectedCallback = [] // Promise reject时的回调函数集</span><br><span class="line"></span><br><span class="line">  executor(resolve, reject) // 执行executor并传入相应的参数</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">从上面的代码中可以看出，我们先定义了一个 Promise 的初始状态 pending，以及参数执行函数 executor，并且按照规范设计了一个 resolve 回调函数集合数组 onResolvedCallback 以及 一个 reject 回调函数集合数组，那么构造函数的初始化就基本完成了。</span><br><span class="line"></span><br><span class="line">function Promise(executor) &#123;</span><br><span class="line"></span><br><span class="line">  var self = this</span><br><span class="line"></span><br><span class="line">  self.status = &apos;pending&apos;   // Promise当前的状态</span><br><span class="line"></span><br><span class="line">  self.data = undefined    // Promise的值</span><br><span class="line"></span><br><span class="line">  self.onResolvedCallback = [] // Promise resolve时的回调函数集</span><br><span class="line"></span><br><span class="line">  self.onRejectedCallback = [] // Promise reject时的回调函数集</span><br><span class="line"></span><br><span class="line">  function resolve(value) &#123;</span><br><span class="line"></span><br><span class="line">    // TODO</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function reject(reason) &#123;</span><br><span class="line"></span><br><span class="line">    // TODO</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  try &#123; // 考虑到执行过程中有可能出错，所以我们用try/catch块给包起</span><br><span class="line"></span><br><span class="line">    executor(resolve, reject) // 执行executor</span><br><span class="line"></span><br><span class="line">  &#125; catch(e) &#123;</span><br><span class="line"></span><br><span class="line">    reject(e)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">resolve 和 reject 内部应该怎么实现呢？我们根据规范知道这两个方法主要做的事情就是返回对应状态的值 value 或者 reason，并把 Promise 内部的 status 从 pending 变成对应的状态，并且这个状态在改变了之后是不可以逆转的。</span><br><span class="line"></span><br><span class="line">function Promise(executor) &#123;</span><br><span class="line"></span><br><span class="line">  // ...上面的省略</span><br><span class="line"></span><br><span class="line">  function resolve(value) &#123;</span><br><span class="line"></span><br><span class="line">    if (self.status === &apos;pending&apos;) &#123;</span><br><span class="line"></span><br><span class="line">      self.status = &apos;resolved&apos;</span><br><span class="line"></span><br><span class="line">      self.data = value</span><br><span class="line"></span><br><span class="line">      for(var i = 0; i &lt; self.onResolvedCallback.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">        self.onResolvedCallback[i](value)</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  function reject(reason) &#123;</span><br><span class="line"></span><br><span class="line">    if (self.status === &apos;pending&apos;) &#123;</span><br><span class="line"></span><br><span class="line">      self.status = &apos;rejected&apos;</span><br><span class="line"></span><br><span class="line">      self.data = reason</span><br><span class="line"></span><br><span class="line">      for(var i = 0; i &lt; self.onRejectedCallback.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">        self.onRejectedCallback[i](reason)</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 下面的省略</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">上述代码所展示的，基本就是在判断状态为 pending 之后，把状态改为相应的值，并把对应的 value 和 reason 存在内部的 data 属性上面，之后执行相应的回调函数。</span><br><span class="line">逻辑比较简单，无非是由于 onResolveCallback 和 onRejectedCallback 这两个是数组，需要通过循环来执行，</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="实现-then-方法"><a href="#实现-then-方法" class="headerlink" title="实现 then 方法"></a>实现 then 方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">then 方法是 Promise 执行完之后可以拿到 value 或者 reason 的方法，并且还要保持 then 执行之后，返回的依旧是一个 Promise 方法，还要支持多次调用</span><br><span class="line">Promise.prototype.then = function(onResolved, onRejected) &#123;</span><br><span class="line"></span><br><span class="line">  var self = this</span><br><span class="line"></span><br><span class="line">  var promise2</span><br><span class="line"></span><br><span class="line">  // 根据标准，如果then的参数不是function，则需要忽略它</span><br><span class="line"></span><br><span class="line">  onResolved = typeof onResolved === &apos;function&apos; ? onResolved : function(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  onRejected = typeof onRejected === &apos;function&apos; ? onRejected : function(reason) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  if (self.status === &apos;resolved&apos;) &#123;</span><br><span class="line"></span><br><span class="line">    // 如果promise1的状态已经确定并且是resolved，我们调用onResolved，考虑到有可能throw，所以还需要将其包在try/catch块里</span><br><span class="line"></span><br><span class="line">    return promise2 = new Promise(function(resolve, reject) &#123;</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line"></span><br><span class="line">        var x = onResolved(self.data)</span><br><span class="line"></span><br><span class="line">        if (x instanceof Promise) &#123;</span><br><span class="line"></span><br><span class="line">// 如果onResolved的返回值是一个Promise对象，直接取它的结果作为promise2的结果</span><br><span class="line"></span><br><span class="line">          x.then(resolve, reject)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        resolve(x) // 否则，以它的返回值作为promise2的结果</span><br><span class="line"></span><br><span class="line">      &#125; catch (e) &#123;</span><br><span class="line"></span><br><span class="line">        reject(e) // 如果出错，以捕获到的错误作为promise2的结果</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 此处与前一个if块的逻辑几乎相同，区别在于所调用的是onRejected函数</span><br><span class="line"></span><br><span class="line">  if (self.status === &apos;rejected&apos;) &#123;</span><br><span class="line"></span><br><span class="line">    return promise2 = new Promise(function(resolve, reject) &#123;</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line"></span><br><span class="line">        var x = onRejected(self.data)</span><br><span class="line"></span><br><span class="line">        if (x instanceof Promise) &#123;</span><br><span class="line"></span><br><span class="line">          x.then(resolve, reject)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125; catch (e) &#123;</span><br><span class="line"></span><br><span class="line">        reject(e)</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (self.status === &apos;pending&apos;) &#123;</span><br><span class="line"></span><br><span class="line">  // 如果当前的Promise还处于pending状态，我们并不能确定调用onResolved还是onRejected，只能等到Promise的状态确定后，才能确定如何处理</span><br><span class="line"></span><br><span class="line">    return promise2 = new Promise(function(resolve, reject) &#123;</span><br><span class="line"></span><br><span class="line">      self.onResolvedCallback.push(function(value) &#123;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line"></span><br><span class="line">          var x = onResolved(self.data)</span><br><span class="line"></span><br><span class="line">          if (x instanceof Promise) &#123;</span><br><span class="line"></span><br><span class="line">            x.then(resolve, reject)</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line"></span><br><span class="line">          reject(e)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      self.onRejectedCallback.push(function(reason) &#123;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line"></span><br><span class="line">          var x = onRejected(self.data)</span><br><span class="line"></span><br><span class="line">          if (x instanceof Promise) &#123;</span><br><span class="line"></span><br><span class="line">            x.then(resolve, reject)</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line"></span><br><span class="line">          reject(e)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="完整版"><a href="#完整版" class="headerlink" title="完整版"></a>完整版</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">  module.exports = Promise</span><br><span class="line"></span><br><span class="line">&#125; catch (e) &#123;&#125;</span><br><span class="line"></span><br><span class="line">function Promise(executor) &#123;</span><br><span class="line"></span><br><span class="line">  var self = this</span><br><span class="line"></span><br><span class="line">  self.status = &apos;pending&apos;</span><br><span class="line"></span><br><span class="line">  self.onResolvedCallback = []</span><br><span class="line"></span><br><span class="line">  self.onRejectedCallback = []</span><br><span class="line"></span><br><span class="line">  function resolve(value) &#123;</span><br><span class="line"></span><br><span class="line">    if (value instanceof Promise) &#123;</span><br><span class="line"></span><br><span class="line">      return value.then(resolve, reject)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setTimeout(function() &#123; // 异步执行所有的回调函数</span><br><span class="line"></span><br><span class="line">      if (self.status === &apos;pending&apos;) &#123;</span><br><span class="line"></span><br><span class="line">        self.status = &apos;resolved&apos;</span><br><span class="line"></span><br><span class="line">        self.data = value</span><br><span class="line"></span><br><span class="line">        for (var i = 0; i &lt; self.onResolvedCallback.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">          self.onResolvedCallback[i](value)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function reject(reason) &#123;</span><br><span class="line"></span><br><span class="line">    setTimeout(function() &#123; // 异步执行所有的回调函数</span><br><span class="line"></span><br><span class="line">      if (self.status === &apos;pending&apos;) &#123;</span><br><span class="line"></span><br><span class="line">        self.status = &apos;rejected&apos;</span><br><span class="line"></span><br><span class="line">        self.data = reason</span><br><span class="line"></span><br><span class="line">        for (var i = 0; i &lt; self.onRejectedCallback.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">          self.onRejectedCallback[i](reason)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  try &#123;</span><br><span class="line"></span><br><span class="line">    executor(resolve, reject)</span><br><span class="line"></span><br><span class="line">  &#125; catch (reason) &#123;</span><br><span class="line"></span><br><span class="line">    reject(reason)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function resolvePromise(promise2, x, resolve, reject) &#123;</span><br><span class="line"></span><br><span class="line">  var then</span><br><span class="line"></span><br><span class="line">  var thenCalledOrThrow = false</span><br><span class="line"></span><br><span class="line">  if (promise2 === x) &#123;</span><br><span class="line"></span><br><span class="line">    return reject(new TypeError(&apos;Chaining cycle detected for promise!&apos;))</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (x instanceof Promise) &#123;</span><br><span class="line"></span><br><span class="line">    if (x.status === &apos;pending&apos;) &#123; </span><br><span class="line"></span><br><span class="line">      x.then(function(v) &#123;</span><br><span class="line"></span><br><span class="line">        resolvePromise(promise2, v, resolve, reject)</span><br><span class="line"></span><br><span class="line">      &#125;, reject)</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">      x.then(resolve, reject)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if ((x !== null) &amp;&amp; ((typeof x === &apos;object&apos;) || (typeof x === &apos;function&apos;))) &#123;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line"></span><br><span class="line">      then = x.then</span><br><span class="line"></span><br><span class="line">      if (typeof then === &apos;function&apos;) &#123;</span><br><span class="line"></span><br><span class="line">        then.call(x, function rs(y) &#123;</span><br><span class="line"></span><br><span class="line">          if (thenCalledOrThrow) return</span><br><span class="line"></span><br><span class="line">          thenCalledOrThrow = true</span><br><span class="line"></span><br><span class="line">          return resolvePromise(promise2, y, resolve, reject)</span><br><span class="line"></span><br><span class="line">        &#125;, function rj(r) &#123;</span><br><span class="line"></span><br><span class="line">          if (thenCalledOrThrow) return</span><br><span class="line"></span><br><span class="line">          thenCalledOrThrow = true</span><br><span class="line"></span><br><span class="line">          return reject(r)</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">      &#125; else &#123;</span><br><span class="line"></span><br><span class="line">        resolve(x)</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line"></span><br><span class="line">      if (thenCalledOrThrow) return</span><br><span class="line"></span><br><span class="line">      thenCalledOrThrow = true</span><br><span class="line"></span><br><span class="line">      return reject(e)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125; else &#123;</span><br><span class="line"></span><br><span class="line">    resolve(x)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise.prototype.then = function(onResolved, onRejected) &#123;</span><br><span class="line"></span><br><span class="line">  var self = this</span><br><span class="line"></span><br><span class="line">  var promise2</span><br><span class="line"></span><br><span class="line">  onResolved = typeof onResolved === &apos;function&apos; ? onResolved : function(v) &#123;</span><br><span class="line"></span><br><span class="line">    return v</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onRejected = typeof onRejected === &apos;function&apos; ? onRejected : function(r) &#123;</span><br><span class="line"></span><br><span class="line">    throw r</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (self.status === &apos;resolved&apos;) &#123;</span><br><span class="line"></span><br><span class="line">    return promise2 = new Promise(function(resolve, reject) &#123;</span><br><span class="line"></span><br><span class="line">      setTimeout(function() &#123; // 异步执行onResolved</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line"></span><br><span class="line">          var x = onResolved(self.data)</span><br><span class="line"></span><br><span class="line">          resolvePromise(promise2, x, resolve, reject)</span><br><span class="line"></span><br><span class="line">        &#125; catch (reason) &#123;</span><br><span class="line"></span><br><span class="line">          reject(reason)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (self.status === &apos;rejected&apos;) &#123;</span><br><span class="line"></span><br><span class="line">    return promise2 = new Promise(function(resolve, reject) &#123;</span><br><span class="line"></span><br><span class="line">      setTimeout(function() &#123; // 异步执行onRejected</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line"></span><br><span class="line">          var x = onRejected(self.data)</span><br><span class="line"></span><br><span class="line">          resolvePromise(promise2, x, resolve, reject)</span><br><span class="line"></span><br><span class="line">        &#125; catch (reason) &#123;</span><br><span class="line"></span><br><span class="line">          reject(reason)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (self.status === &apos;pending&apos;) &#123;</span><br><span class="line"></span><br><span class="line">    // 这里之所以没有异步执行，是因为这些函数必然会被resolve或reject调用，而resolve或reject函数里的内容已是异步执行，构造函数里的定义</span><br><span class="line"></span><br><span class="line">    return promise2 = new Promise(function(resolve, reject) &#123;</span><br><span class="line"></span><br><span class="line">      self.onResolvedCallback.push(function(value) &#123;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line"></span><br><span class="line">          var x = onResolved(value)</span><br><span class="line"></span><br><span class="line">          resolvePromise(promise2, x, resolve, reject)</span><br><span class="line"></span><br><span class="line">        &#125; catch (r) &#123;</span><br><span class="line"></span><br><span class="line">          reject(r)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      self.onRejectedCallback.push(function(reason) &#123;</span><br><span class="line"></span><br><span class="line">          try &#123;</span><br><span class="line"></span><br><span class="line">            var x = onRejected(reason)</span><br><span class="line"></span><br><span class="line">            resolvePromise(promise2, x, resolve, reject)</span><br><span class="line"></span><br><span class="line">          &#125; catch (r) &#123;</span><br><span class="line"></span><br><span class="line">            reject(r)</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise.prototype.catch = function(onRejected) &#123;</span><br><span class="line"></span><br><span class="line">  return this.then(null, onRejected)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 最后这个是测试用的，后面会说</span><br><span class="line"></span><br><span class="line">Promise.deferred = Promise.defer = function() &#123;</span><br><span class="line"></span><br><span class="line">  var dfd = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  dfd.promise = new Promise(function(resolve, reject) &#123;</span><br><span class="line"></span><br><span class="line">    dfd.resolve = resolve</span><br><span class="line"></span><br><span class="line">    dfd.reject = reject</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  return dfd</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="另一版"><a href="#另一版" class="headerlink" title="另一版"></a>另一版</h5><ul>
<li>微信公众号文章：<a href="https://mp.weixin.qq.com/s/C-U93BmK0U_iw3sqG0g70g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/C-U93BmK0U_iw3sqG0g70g</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line">// MyPromise.js</span><br><span class="line"></span><br><span class="line">// 先定义三个常量表示状态</span><br><span class="line">const PENDING = &apos;pending&apos;;</span><br><span class="line">const FULFILLED = &apos;fulfilled&apos;;</span><br><span class="line">const REJECTED = &apos;rejected&apos;;</span><br><span class="line"></span><br><span class="line">// 新建 MyPromise 类</span><br><span class="line">class MyPromise &#123;</span><br><span class="line">  constructor(executor)&#123;</span><br><span class="line">    // executor 是一个执行器，进入会立即执行</span><br><span class="line">    // 并传入resolve和reject方法</span><br><span class="line">    try &#123;</span><br><span class="line">      executor(this.resolve, this.reject)</span><br><span class="line">    &#125; catch (error) &#123;</span><br><span class="line">      this.reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 储存状态的变量，初始值是 pending</span><br><span class="line">  status = PENDING;</span><br><span class="line">  // 成功之后的值</span><br><span class="line">  value = null;</span><br><span class="line">  // 失败之后的原因</span><br><span class="line">  reason = null;</span><br><span class="line"></span><br><span class="line">  // 存储成功回调函数</span><br><span class="line">  onFulfilledCallbacks = [];</span><br><span class="line">  // 存储失败回调函数</span><br><span class="line">  onRejectedCallbacks = [];</span><br><span class="line"></span><br><span class="line">  // 更改成功后的状态</span><br><span class="line">  resolve = (value) =&gt; &#123;</span><br><span class="line">    // 只有状态是等待，才执行状态修改</span><br><span class="line">    if (this.status === PENDING) &#123;</span><br><span class="line">      // 状态修改为成功</span><br><span class="line">      this.status = FULFILLED;</span><br><span class="line">      // 保存成功之后的值</span><br><span class="line">      this.value = value;</span><br><span class="line">      // resolve里面将所有成功的回调拿出来执行</span><br><span class="line">      while (this.onFulfilledCallbacks.length) &#123;</span><br><span class="line">        // Array.shift() 取出数组第一个元素，然后（）调用，shift不是纯函数，取出后，数组将失去该元素，直到数组为空</span><br><span class="line">        this.onFulfilledCallbacks.shift()(value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 更改失败后的状态</span><br><span class="line">  reject = (reason) =&gt; &#123;</span><br><span class="line">    // 只有状态是等待，才执行状态修改</span><br><span class="line">    if (this.status === PENDING) &#123;</span><br><span class="line">      // 状态成功为失败</span><br><span class="line">      this.status = REJECTED;</span><br><span class="line">      // 保存失败后的原因</span><br><span class="line">      this.reason = reason;</span><br><span class="line">      // resolve里面将所有失败的回调拿出来执行</span><br><span class="line">      while (this.onRejectedCallbacks.length) &#123;</span><br><span class="line">        this.onRejectedCallbacks.shift()(reason)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  then(onFulfilled, onRejected) &#123;</span><br><span class="line">    const realOnFulfilled = typeof onFulfilled === &apos;function&apos; ? onFulfilled : value =&gt; value;</span><br><span class="line">    const realOnRejected = typeof onRejected === &apos;function&apos; ? onRejected : reason =&gt; &#123;throw reason&#125;;</span><br><span class="line"></span><br><span class="line">    // 为了链式调用这里直接创建一个 MyPromise，并在后面 return 出去</span><br><span class="line">    const promise2 = new MyPromise((resolve, reject) =&gt; &#123;</span><br><span class="line">      const fulfilledMicrotask = () =&gt;  &#123;</span><br><span class="line">        // 创建一个微任务等待 promise2 完成初始化</span><br><span class="line">        queueMicrotask(() =&gt; &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">            // 获取成功回调函数的执行结果</span><br><span class="line">            const x = realOnFulfilled(this.value);</span><br><span class="line">            // 传入 resolvePromise 集中处理</span><br><span class="line">            resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">          &#125; catch (error) &#123;</span><br><span class="line">            reject(error)</span><br><span class="line">          &#125; </span><br><span class="line">        &#125;)  </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      const rejectedMicrotask = () =&gt; &#123; </span><br><span class="line">        // 创建一个微任务等待 promise2 完成初始化</span><br><span class="line">        queueMicrotask(() =&gt; &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">            // 调用失败回调，并且把原因返回</span><br><span class="line">            const x = realOnRejected(this.reason);</span><br><span class="line">            // 传入 resolvePromise 集中处理</span><br><span class="line">            resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">          &#125; catch (error) &#123;</span><br><span class="line">            reject(error)</span><br><span class="line">          &#125; </span><br><span class="line">        &#125;) </span><br><span class="line">      &#125;</span><br><span class="line">      // 判断状态</span><br><span class="line">      if (this.status === FULFILLED) &#123;</span><br><span class="line">        fulfilledMicrotask() </span><br><span class="line">      &#125; else if (this.status === REJECTED) &#123; </span><br><span class="line">        rejectedMicrotask()</span><br><span class="line">      &#125; else if (this.status === PENDING) &#123;</span><br><span class="line">        // 等待</span><br><span class="line">        // 因为不知道后面状态的变化情况，所以将成功回调和失败回调存储起来</span><br><span class="line">        // 等到执行成功失败函数的时候再传递</span><br><span class="line">        this.onFulfilledCallbacks.push(fulfilledMicrotask);</span><br><span class="line">        this.onRejectedCallbacks.push(rejectedMicrotask);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;) </span><br><span class="line">    </span><br><span class="line">    return promise2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // resolve 静态方法</span><br><span class="line">  static resolve (parameter) &#123;</span><br><span class="line">    // 如果传入 MyPromise 就直接返回</span><br><span class="line">    if (parameter instanceof MyPromise) &#123;</span><br><span class="line">      return parameter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 转成常规方式</span><br><span class="line">    return new MyPromise(resolve =&gt;  &#123;</span><br><span class="line">      resolve(parameter);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // reject 静态方法</span><br><span class="line">  static reject (reason) &#123;</span><br><span class="line">    return new MyPromise((resolve, reject) =&gt; &#123;</span><br><span class="line">      reject(reason);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function resolvePromise(promise2, x, resolve, reject) &#123;</span><br><span class="line">  // 如果相等了，说明return的是自己，抛出类型错误并返回</span><br><span class="line">  if (promise2 === x) &#123;</span><br><span class="line">    return reject(new TypeError(&apos;Chaining cycle detected for promise #&lt;Promise&gt;&apos;))</span><br><span class="line">  &#125;</span><br><span class="line">  // 判断x是不是 MyPromise 实例对象</span><br><span class="line">  if(x instanceof MyPromise) &#123;</span><br><span class="line">    // 执行 x，调用 then 方法，目的是将其状态变为 fulfilled 或者 rejected</span><br><span class="line">    // x.then(value =&gt; resolve(value), reason =&gt; reject(reason))</span><br><span class="line">    // 简化之后</span><br><span class="line">    x.then(resolve, reject)</span><br><span class="line">  &#125; else&#123;</span><br><span class="line">    // 普通值</span><br><span class="line">    resolve(x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = MyPromise;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上面是公众号文章分享的<br>下面是自己的再次实现，根据自己理解加了一些注释<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line">class APromise &#123;</span><br><span class="line">  //容器状态</span><br><span class="line">  status = &quot;pending&quot;;</span><br><span class="line">  //处理成功时的容器值</span><br><span class="line">  value = &quot;&quot;;</span><br><span class="line">  //处理失败时的原因</span><br><span class="line">  reason = &quot;&quot;;</span><br><span class="line">  //处理成功回调函数     then方法被多次调用时，采用数组进行存储回调函数</span><br><span class="line">  fullFilledCallbacks = [];</span><br><span class="line">  //处理失败回调函数</span><br><span class="line">  rejectedCallBacks = [];</span><br><span class="line">  //处理成功</span><br><span class="line">  resolve = (value) =&gt; &#123;</span><br><span class="line">    if (this.status === &quot;pending&quot;) &#123;</span><br><span class="line">      this.status = &quot;fullFilled&quot;;</span><br><span class="line">      this.value = value;</span><br><span class="line"></span><br><span class="line">      //处理成功回调</span><br><span class="line">      while (this.fullFilledCallbacks.length) &#123;</span><br><span class="line">        this.fullFilledCallbacks.shift()(value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  //处理成败</span><br><span class="line">  reject = (reason) =&gt; &#123;</span><br><span class="line">    if (this.status === &quot;pending&quot;) &#123;</span><br><span class="line">      this.status = &quot;rejected&quot;;</span><br><span class="line">      this.reason = reason;</span><br><span class="line"></span><br><span class="line">      //处理失败回调</span><br><span class="line">      while (this.rejectedCallBacks.length) &#123;</span><br><span class="line">        this.rejectedCallBacks.shift()(reason);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  //处理then方法回调函数返回值</span><br><span class="line">  resolvePromise = (promise, res, resolve, reject) =&gt; &#123;</span><br><span class="line">    //then方法成功回调返回值和then方法返回值一样时</span><br><span class="line">    if (promise === res) &#123;</span><br><span class="line">      //避免循环引用</span><br><span class="line">      reject(new TypeError(&quot;Chaining cycle detected for promise #&lt;Promise&gt;&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //返回值为promise（这里的promise指then方法成功回调时返回的promise）时</span><br><span class="line">    if (res instanceof APromise) &#123;</span><br><span class="line">      //对返回的promise（这里的promise指then方法成功回调时返回的promise）的处理结果进行处理</span><br><span class="line">      //通过resolve/reject对返回的promise（这里的promise指调用then方法时返回的promise）状态进行处理</span><br><span class="line">      res.then(resolve, reject);</span><br><span class="line">    &#125;</span><br><span class="line">    //普通值</span><br><span class="line">    else &#123;</span><br><span class="line">      resolve(res);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  //处理完成   (rejected/pending逻辑参考fullFilled状态)</span><br><span class="line">  then = (onFullFilled, onRejected) =&gt; &#123;</span><br><span class="line">    // 如果不传，就使用默认函数</span><br><span class="line">    onFullFilled =</span><br><span class="line">      typeof onFullFilled === &quot;function&quot; ? onFullFilled : (value) =&gt; value;</span><br><span class="line">    // 如果不传，就使用默认函数</span><br><span class="line">    onRejected =</span><br><span class="line">      typeof onRejected === &quot;function&quot;</span><br><span class="line">        ? onRejected</span><br><span class="line">        : (reason) =&gt; &#123;</span><br><span class="line">            throw reason;</span><br><span class="line">          &#125;;</span><br><span class="line"></span><br><span class="line">    //返回promise用于链式调用</span><br><span class="line">    const promise = new APromise((resolve, reject) =&gt; &#123;</span><br><span class="line">      //成功回调</span><br><span class="line">      if (this.status === &quot;fullFilled&quot;) &#123;</span><br><span class="line">        // 为了拿到上面返回的promise实例对象，需要创建一个微任务等待promise初始化</span><br><span class="line">        //否则，会报ReferenceError: Cannot access &apos;promise&apos; before initialization</span><br><span class="line">        queueMicrotask(() =&gt; &#123;</span><br><span class="line">          //异常捕获</span><br><span class="line">          try &#123;</span><br><span class="line">            const res = onFullFilled(this.value);</span><br><span class="line">            this.resolvePromise(promise, res, resolve, reject);</span><br><span class="line">          &#125; catch (error) &#123;</span><br><span class="line">            reject(error);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      //失败回调</span><br><span class="line">      if (this.status === &quot;rejected&quot;) &#123;</span><br><span class="line">        queueMicrotask(() =&gt; &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">            const res = onRejected(this.reason);</span><br><span class="line">            this.resolvePromise(promise, res, resolve, reject);</span><br><span class="line">          &#125; catch (error) &#123;</span><br><span class="line">            reject(error);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      //处理异步任务</span><br><span class="line">      if (this.status === &quot;pending&quot;) &#123;</span><br><span class="line">        //对成功、失败回调进行存储。异步任务执行成功后再进行处理</span><br><span class="line">        //对成功处理函数存储</span><br><span class="line">        this.fullFilledCallbacks.push(() =&gt; &#123;</span><br><span class="line">          //异常捕获</span><br><span class="line">          try &#123;</span><br><span class="line">            const res = onFullFilled(this.value);</span><br><span class="line">            this.resolvePromise(promise, res, resolve, reject);</span><br><span class="line">          &#125; catch (error) &#123;</span><br><span class="line">            reject(error);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        //对失败处理函数进行存储</span><br><span class="line">        this.rejectedCallBacks.push(() =&gt; &#123;</span><br><span class="line">          queueMicrotask(() =&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">              const res = onRejected(this.reason);</span><br><span class="line">              this.resolvePromise(promise, res, resolve, reject);</span><br><span class="line">            &#125; catch (error) &#123;</span><br><span class="line">              reject(error);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return promise;</span><br><span class="line">  &#125;;</span><br><span class="line">  constructor(executor) &#123;</span><br><span class="line">    //异常捕获</span><br><span class="line">    try &#123;</span><br><span class="line">      //执行器</span><br><span class="line">      executor(this.resolve, this.reject);</span><br><span class="line">    &#125; catch (error) &#123;</span><br><span class="line">      console.log(error);</span><br><span class="line">      this.reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default APromise;</span><br></pre></td></tr></table></figure></p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul>
<li>可以毫不夸张地说，不深入地了解数组，就不足以写好 JavaScript。<h3 id="数组构造器"><a href="#数组构造器" class="headerlink" title="数组构造器"></a>数组构造器</h3></li>
<li>new Array(arg1, arg2,…)，参数长度为 0 或长度大于等于 2 时，传入的参数将按照顺序依次成为新数组的第 0 至第 N 项（参数长度为 0 时，返回空数组）；</li>
<li>new Array(len)，当 len 不是数值时，处理同上，返回一个只包含 len 元素一项的数组；当 len 为数值时，len 最大不能超过 32 位无符号整型，即需要小于 2 的 32 次方（len 最大为 Math.pow(2,32)），否则将抛出 RangeError。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 使用 Array 构造器，可以自定义长度</span><br><span class="line"></span><br><span class="line">var a = Array(6); // [empty × 6]</span><br><span class="line"></span><br><span class="line">// 使用对象字面量</span><br><span class="line"></span><br><span class="line">var b = [];</span><br><span class="line"></span><br><span class="line">b.length = 6; // [empty × 6]</span><br><span class="line"></span><br><span class="line">let arr3=Array(6,8,9)</span><br><span class="line">console.log(arr3);  //[6, 8, 9]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="新增的构造方法"><a href="#新增的构造方法" class="headerlink" title="新增的构造方法"></a>新增的构造方法</h3><h4 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of"></a>Array.of</h4><ul>
<li>它基本上与 Array 构造器功能一致，唯一的区别就在单个数字参数的处理上。</li>
<li>：当参数为两个时，返回的结果是一致的；当参数是一个时，Array.of 会把参数变成数组里的一项，而构造器则会生成长度和第一个参数相同的空数组。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Array.of(8.0); // [8]</span><br><span class="line"></span><br><span class="line">Array(8.0); // [empty × 8]</span><br><span class="line"></span><br><span class="line">Array.of(8.0, 5); // [8, 5]</span><br><span class="line"></span><br><span class="line">Array(8.0, 5); // [8, 5]</span><br><span class="line"></span><br><span class="line">Array.of(&apos;8&apos;); // [&quot;8&quot;]</span><br><span class="line"></span><br><span class="line">Array(&apos;8&apos;); // [&quot;8&quot;]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from"></a>Array.from</h4><ul>
<li>Array.from 的设计初衷是快速便捷地基于其他对象创建新数组，准确来说就是从一个类似数组的可迭代对象中创建一个新的数组实例。其实就是，只要一个对象有迭代器，Array.from 就能把它变成一个数组（注意：是返回新的数组，不改变原对象）。</li>
<li>Array.from 拥有 3 个参数：</li>
</ul>
<ol>
<li>类似数组的对象，必选；</li>
<li>加工函数，新生成的数组会经过该函数的加工再返回；</li>
<li>this 作用域，表示加工函数执行时 this 的值。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;0: &apos;a&apos;, 1: &apos;b&apos;, 2:&apos;c&apos;, length: 3&#125;;</span><br><span class="line"></span><br><span class="line">Array.from(obj, function(value, index)&#123;</span><br><span class="line"></span><br><span class="line">  console.log(value, index, this, arguments.length);</span><br><span class="line"></span><br><span class="line">  return value.repeat(3);   //必须指定返回值，否则返回 undefined</span><br><span class="line"></span><br><span class="line">&#125;, obj);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><p>如果这里不指定 this 的话，加工函数完全可以是一个箭头函数。上述代码可以简写为如下形式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Array.from(obj, (value) =&gt; value.repeat(3));</span><br><span class="line"></span><br><span class="line">//  控制台返回 (3) [&quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot;]</span><br></pre></td></tr></table></figure>
</li>
<li><p>拥有迭代器的对象还包括 String、Set、Map 等，Array.from 统统可以处理，请看下面的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// String</span><br><span class="line"></span><br><span class="line">Array.from(&apos;abc&apos;);         // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line"></span><br><span class="line">// Set</span><br><span class="line"></span><br><span class="line">Array.from(new Set([&apos;abc&apos;, &apos;def&apos;])); // [&quot;abc&quot;, &quot;def&quot;]</span><br><span class="line"></span><br><span class="line">// Map</span><br><span class="line"></span><br><span class="line">Array.from(new Map([[1, &apos;ab&apos;], [2, &apos;de&apos;]])); </span><br><span class="line"></span><br><span class="line">// [[1, &apos;ab&apos;], [2, &apos;de&apos;]]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Array-的判断"><a href="#Array-的判断" class="headerlink" title="Array 的判断"></a>Array 的判断</h3><ul>
<li><p>在 ES5 提供该方法之前，我们至少有如下 5 种方式去判断一个变量是否为数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var a = [];</span><br><span class="line"></span><br><span class="line">// 1.基于instanceof</span><br><span class="line"></span><br><span class="line">a instanceof Array;</span><br><span class="line"></span><br><span class="line">// 2.基于constructor</span><br><span class="line"></span><br><span class="line">a.constructor === Array;</span><br><span class="line"></span><br><span class="line">// 3.基于Object.prototype.isPrototypeOf</span><br><span class="line"></span><br><span class="line">Array.prototype.isPrototypeOf(a);</span><br><span class="line"></span><br><span class="line">// 4.基于getPrototypeOf</span><br><span class="line"></span><br><span class="line">Object.getPrototypeOf(a) === Array.prototype;</span><br><span class="line"></span><br><span class="line">// 5.基于Object.prototype.toString</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.apply(a) === &apos;[object Array]&apos;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ES6 之后新增了一个 Array.isArray 方法，能直接判断数据类型是否为数组，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">如果 isArray 不存在，那么 Array.isArray 的 polyfill 通常可以这样写：</span><br><span class="line">if (!Array.isArray)&#123;</span><br><span class="line"></span><br><span class="line">  Array.isArray = function(arg)&#123;</span><br><span class="line"></span><br><span class="line">    return Object.prototype.toString.call(arg) === &apos;[object Array]&apos;;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="改变自身的方法"><a href="#改变自身的方法" class="headerlink" title="改变自身的方法"></a>改变自身的方法</h3><ul>
<li>基于 ES6，会改变自身值的方法一共有 9 个，分别为 pop、push、reverse、shift、sort、splice、unshift，以及两个 ES6 新增的方法 copyWithin 和 fill。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">// pop方法</span><br><span class="line"></span><br><span class="line">var array = [&quot;cat&quot;, &quot;dog&quot;, &quot;cow&quot;, &quot;chicken&quot;, &quot;mouse&quot;];</span><br><span class="line"></span><br><span class="line">var item = array.pop();</span><br><span class="line"></span><br><span class="line">console.log(array); // [&quot;cat&quot;, &quot;dog&quot;, &quot;cow&quot;, &quot;chicken&quot;]</span><br><span class="line"></span><br><span class="line">console.log(item); // mouse</span><br><span class="line"></span><br><span class="line">// push方法</span><br><span class="line"></span><br><span class="line">var array = [&quot;football&quot;, &quot;basketball&quot;,  &quot;badminton&quot;];</span><br><span class="line"></span><br><span class="line">var i = array.push(&quot;golfball&quot;);</span><br><span class="line"></span><br><span class="line">console.log(array); </span><br><span class="line"></span><br><span class="line">// [&quot;football&quot;, &quot;basketball&quot;, &quot;badminton&quot;, &quot;golfball&quot;]</span><br><span class="line"></span><br><span class="line">console.log(i); // 4</span><br><span class="line"></span><br><span class="line">// reverse方法</span><br><span class="line"></span><br><span class="line">var array = [1,2,3,4,5];</span><br><span class="line"></span><br><span class="line">var array2 = array.reverse();</span><br><span class="line"></span><br><span class="line">console.log(array); // [5,4,3,2,1]</span><br><span class="line"></span><br><span class="line">console.log(array2===array); // true</span><br><span class="line"></span><br><span class="line">// shift方法</span><br><span class="line"></span><br><span class="line">var array = [1,2,3,4,5];</span><br><span class="line"></span><br><span class="line">var item = array.shift();</span><br><span class="line"></span><br><span class="line">console.log(array); // [2,3,4,5]</span><br><span class="line"></span><br><span class="line">console.log(item); // 1</span><br><span class="line"></span><br><span class="line">// unshift方法</span><br><span class="line"></span><br><span class="line">var array = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];</span><br><span class="line"></span><br><span class="line">var length = array.unshift(&quot;yellow&quot;);</span><br><span class="line"></span><br><span class="line">console.log(array); // [&quot;yellow&quot;, &quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]</span><br><span class="line"></span><br><span class="line">console.log(length); // 4</span><br><span class="line"></span><br><span class="line">// sort方法</span><br><span class="line"></span><br><span class="line">var array = [&quot;apple&quot;,&quot;Boy&quot;,&quot;Cat&quot;,&quot;dog&quot;];</span><br><span class="line"></span><br><span class="line">var array2 = array.sort();</span><br><span class="line"></span><br><span class="line">console.log(array); // [&quot;Boy&quot;, &quot;Cat&quot;, &quot;apple&quot;, &quot;dog&quot;]</span><br><span class="line"></span><br><span class="line">console.log(array2 == array); // true</span><br><span class="line"></span><br><span class="line">// splice方法</span><br><span class="line"></span><br><span class="line">var array = [&quot;apple&quot;,&quot;boy&quot;];</span><br><span class="line"></span><br><span class="line">var splices = array.splice(1,1);</span><br><span class="line"></span><br><span class="line">console.log(array); // [&quot;apple&quot;]</span><br><span class="line"></span><br><span class="line">console.log(splices); // [&quot;boy&quot;]</span><br><span class="line"></span><br><span class="line">// copyWithin方法</span><br><span class="line"></span><br><span class="line">var array = [1,2,3,4,5]; </span><br><span class="line"></span><br><span class="line">var array2 = array.copyWithin(0,3);</span><br><span class="line"></span><br><span class="line">console.log(array===array2,array2);  // true [4, 5, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">// fill方法</span><br><span class="line"></span><br><span class="line">var array = [1,2,3,4,5];</span><br><span class="line"></span><br><span class="line">var array2 = array.fill(10,0,3);</span><br><span class="line"></span><br><span class="line">console.log(array===array2,array2); </span><br><span class="line"></span><br><span class="line">// true [10, 10, 10, 4, 5], 可见数组区间[0,3]的元素全部替换为10</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="不改变自身的方法"><a href="#不改变自身的方法" class="headerlink" title="不改变自身的方法"></a>不改变自身的方法</h3><ul>
<li>基于 ES7，不会改变自身的方法也有 9 个，分别为 concat、join、slice、toString、toLocaleString、indexOf、lastIndexOf、未形成标准的 toSource，以及 ES7 新增的方法 includes。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">// concat方法</span><br><span class="line"></span><br><span class="line">var array = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">var array2 = array.concat(4,[5,6],[7,8,9]);</span><br><span class="line"></span><br><span class="line">console.log(array2); // [1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line"></span><br><span class="line">console.log(array); // [1, 2, 3], 可见原数组并未被修改</span><br><span class="line"></span><br><span class="line">// join方法</span><br><span class="line"></span><br><span class="line">var array = [&apos;We&apos;, &apos;are&apos;, &apos;Chinese&apos;];</span><br><span class="line"></span><br><span class="line">console.log(array.join()); // &quot;We,are,Chinese&quot;</span><br><span class="line"></span><br><span class="line">console.log(array.join(&apos;+&apos;)); // &quot;We+are+Chinese&quot;</span><br><span class="line"></span><br><span class="line">// slice方法</span><br><span class="line"></span><br><span class="line">var array = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;,&quot;four&quot;, &quot;five&quot;];</span><br><span class="line"></span><br><span class="line">console.log(array.slice()); // [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;,&quot;four&quot;, &quot;five&quot;]</span><br><span class="line"></span><br><span class="line">console.log(array.slice(2,3)); // [&quot;three&quot;]</span><br><span class="line"></span><br><span class="line">// toString方法</span><br><span class="line"></span><br><span class="line">var array = [&apos;Jan&apos;, &apos;Feb&apos;, &apos;Mar&apos;, &apos;Apr&apos;];</span><br><span class="line"></span><br><span class="line">var str = array.toString();</span><br><span class="line"></span><br><span class="line">console.log(str); // Jan,Feb,Mar,Apr</span><br><span class="line"></span><br><span class="line">// tolocalString方法</span><br><span class="line"></span><br><span class="line">var array= [&#123;name:&apos;zz&apos;&#125;, 123, &quot;abc&quot;, new Date()];</span><br><span class="line"></span><br><span class="line">var str = array.toLocaleString();</span><br><span class="line"></span><br><span class="line">console.log(str); // [object Object],123,abc,2016/1/5 下午1:06:23</span><br><span class="line"></span><br><span class="line">// indexOf方法</span><br><span class="line"></span><br><span class="line">var array = [&apos;abc&apos;, &apos;def&apos;, &apos;ghi&apos;,&apos;123&apos;];</span><br><span class="line"></span><br><span class="line">console.log(array.indexOf(&apos;def&apos;)); // 1</span><br><span class="line"></span><br><span class="line">// includes方法</span><br><span class="line"></span><br><span class="line">var array = [-0, 1, 2];</span><br><span class="line"></span><br><span class="line">console.log(array.includes(+0)); // true</span><br><span class="line"></span><br><span class="line">console.log(array.includes(1)); // true</span><br><span class="line"></span><br><span class="line">var array = [NaN];</span><br><span class="line"></span><br><span class="line">console.log(array.includes(NaN)); // true</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="数组遍历的方法"><a href="#数组遍历的方法" class="headerlink" title="数组遍历的方法"></a>数组遍历的方法</h3><ul>
<li>基于 ES6，不会改变自身的遍历方法一共有 12 个，分别为 forEach、every、some、filter、map、reduce、reduceRight，以及 ES6 新增的方法 entries、find、findIndex、keys、values。</li>
<li><p>其中，要注意有些遍历方法不会返回处理之后的数组，比如 forEach；有些方法会返回处理之后的数组，比如 filter。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line">// forEach方法</span><br><span class="line"></span><br><span class="line">var array = [1, 3, 5];</span><br><span class="line"></span><br><span class="line">var obj = &#123;name:&apos;cc&apos;&#125;;</span><br><span class="line"></span><br><span class="line">var sReturn = array.forEach(function(value, index, array)&#123;</span><br><span class="line"></span><br><span class="line">  array[index] = value;</span><br><span class="line"></span><br><span class="line">  console.log(this.name); // cc被打印了三次, this指向obj</span><br><span class="line"></span><br><span class="line">&#125;,obj);</span><br><span class="line"></span><br><span class="line">console.log(array); // [1, 3, 5]</span><br><span class="line"></span><br><span class="line">console.log(sReturn); // undefined, 可见返回值为undefined</span><br><span class="line"></span><br><span class="line">// every方法</span><br><span class="line"></span><br><span class="line">var o = &#123;0:10, 1:8, 2:25, length:3&#125;;</span><br><span class="line"></span><br><span class="line">var bool = Array.prototype.every.call(o,function(value, index, obj)&#123;</span><br><span class="line"></span><br><span class="line">  return value &gt;= 8;</span><br><span class="line"></span><br><span class="line">&#125;,o);</span><br><span class="line"></span><br><span class="line">console.log(bool); // true</span><br><span class="line"></span><br><span class="line">// some方法</span><br><span class="line"></span><br><span class="line">var array = [18, 9, 10, 35, 80];</span><br><span class="line"></span><br><span class="line">var isExist = array.some(function(value, index, array)&#123;</span><br><span class="line"></span><br><span class="line">  return value &gt; 20;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(isExist); // true </span><br><span class="line"></span><br><span class="line">// map 方法</span><br><span class="line"></span><br><span class="line">var array = [18, 9, 10, 35, 80];</span><br><span class="line"></span><br><span class="line">array.map(item =&gt; item + 1);</span><br><span class="line"></span><br><span class="line">console.log(array);  // [19, 10, 11, 36, 81]</span><br><span class="line"></span><br><span class="line">// filter 方法</span><br><span class="line"></span><br><span class="line">var array = [18, 9, 10, 35, 80];</span><br><span class="line"></span><br><span class="line">var array2 = array.filter(function(value, index, array)&#123;</span><br><span class="line"></span><br><span class="line">  return value &gt; 20;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(array2); // [35, 80]</span><br><span class="line"></span><br><span class="line">// reduce方法</span><br><span class="line"></span><br><span class="line">var array = [1, 2, 3, 4];</span><br><span class="line"></span><br><span class="line">var s = array.reduce(function(previousValue, value, index, array)&#123;</span><br><span class="line"></span><br><span class="line">  return previousValue * value;</span><br><span class="line"></span><br><span class="line">&#125;,1);</span><br><span class="line"></span><br><span class="line">console.log(s); // 24</span><br><span class="line"></span><br><span class="line">// ES6写法更加简洁</span><br><span class="line"></span><br><span class="line">array.reduce((p, v) =&gt; p * v); // 24</span><br><span class="line"></span><br><span class="line">// reduceRight方法 (和reduce的区别就是从后往前累计)</span><br><span class="line"></span><br><span class="line">var array = [1, 2, 3, 4];</span><br><span class="line"></span><br><span class="line">array.reduceRight((p, v) =&gt; p * v); // 24</span><br><span class="line"></span><br><span class="line">// entries方法</span><br><span class="line"></span><br><span class="line">var array = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];</span><br><span class="line"></span><br><span class="line">var iterator = array.entries();</span><br><span class="line"></span><br><span class="line">console.log(iterator.next().value); // [0, &quot;a&quot;]</span><br><span class="line"></span><br><span class="line">console.log(iterator.next().value); // [1, &quot;b&quot;]</span><br><span class="line"></span><br><span class="line">console.log(iterator.next().value); // [2, &quot;c&quot;]</span><br><span class="line"></span><br><span class="line">console.log(iterator.next().value); // undefined, 迭代器处于数组末尾时, 再迭代就会返回undefined</span><br><span class="line"></span><br><span class="line">// find &amp; findIndex方法</span><br><span class="line"></span><br><span class="line">var array = [1, 3, 5, 7, 8, 9, 10];</span><br><span class="line"></span><br><span class="line">function f(value, index, array)&#123;</span><br><span class="line"></span><br><span class="line">  return value%2==0;     // 返回偶数</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function f2(value, index, array)&#123;</span><br><span class="line"></span><br><span class="line">  return value &gt; 20;     // 返回大于20的数</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(array.find(f)); // 8</span><br><span class="line"></span><br><span class="line">console.log(array.find(f2)); // undefined</span><br><span class="line"></span><br><span class="line">console.log(array.findIndex(f)); // 4</span><br><span class="line"></span><br><span class="line">console.log(array.findIndex(f2)); // -1</span><br><span class="line"></span><br><span class="line">// keys方法</span><br><span class="line"></span><br><span class="line">[...Array(10).keys()];     // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line"></span><br><span class="line">[...new Array(10).keys()]; // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line"></span><br><span class="line">// values方法</span><br><span class="line"></span><br><span class="line">var array = [&quot;abc&quot;, &quot;xyz&quot;];</span><br><span class="line"></span><br><span class="line">var iterator = array.values();</span><br><span class="line"></span><br><span class="line">console.log(iterator.next().value);//abc</span><br><span class="line"></span><br><span class="line">console.log(iterator.next().value);//xyz</span><br></pre></td></tr></table></figure>
</li>
<li><p>reduce 的两个参数</p>
</li>
</ul>
<ol>
<li>首先是 callback（一个在数组的每一项中调用的函数，接受四个参数）：<br>previousValue（上一次调用回调函数时的返回值，或者初始值）<br>currentValue（当前正在处理的数组元素）<br>currentIndex（当前正在处理的数组元素下标）<br>array（调用 reduce() 方法的数组）</li>
<li>然后是 initialValue（可选的初始值，作为第一次调用回调函数时传给 previousValue 的值）。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/* 题目：数组 arr = [1,2,3,4] 求数组的和：*/</span><br><span class="line"></span><br><span class="line">// 第一种方法：</span><br><span class="line"></span><br><span class="line">var arr = [1,2,3,4];</span><br><span class="line"></span><br><span class="line">var sum = 0;</span><br><span class="line"></span><br><span class="line">arr.forEach(function(e)&#123;sum += e;&#125;); // sum = 10</span><br><span class="line"></span><br><span class="line">// 第二种方法</span><br><span class="line"></span><br><span class="line">var arr = [1,2,3,4];</span><br><span class="line"></span><br><span class="line">var sum = 0;</span><br><span class="line"></span><br><span class="line">arr.map(function(obj)&#123;sum += obj&#125;);</span><br><span class="line"></span><br><span class="line">// 第三种方法</span><br><span class="line"></span><br><span class="line">var arr = [1,2,3,4];</span><br><span class="line"></span><br><span class="line">arr.reduce(function(pre,cur)&#123;return pre + cur&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a>类数组</h3><ul>
<li>JavaScript 中有哪些情况下的对象是类数组呢？主要有以下几种：</li>
</ul>
<ol>
<li>函数里面的参数对象 arguments；</li>
<li>用 getElementsByTagName/ClassName/Name 获得的 HTMLCollection；</li>
<li>用 querySelector 获得的 NodeList。<h4 id="如何将类数组转换成数组"><a href="#如何将类数组转换成数组" class="headerlink" title="如何将类数组转换成数组"></a>如何将类数组转换成数组</h4></li>
</ol>
<ul>
<li>类数组借用数组方法转数组<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function sum(a, b) &#123;</span><br><span class="line"></span><br><span class="line">  let args = Array.prototype.slice.call(arguments);</span><br><span class="line"></span><br><span class="line"> // let args = [].slice.call(arguments); // 这样写也是一样效果</span><br><span class="line"></span><br><span class="line">  console.log(args.reduce((sum, cur) =&gt; sum + cur));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(1, 2);  // 3</span><br><span class="line"></span><br><span class="line">function sum(a, b) &#123;</span><br><span class="line"></span><br><span class="line">  let args = Array.prototype.concat.apply([], arguments);</span><br><span class="line"></span><br><span class="line">  console.log(args.reduce((sum, cur) =&gt; sum + cur));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sum(1, 2);  // 3</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="ES6-的方法转数组"><a href="#ES6-的方法转数组" class="headerlink" title="ES6 的方法转数组"></a>ES6 的方法转数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function sum(a, b) &#123;</span><br><span class="line"></span><br><span class="line">  let args = Array.from(arguments);</span><br><span class="line"></span><br><span class="line">  console.log(args.reduce((sum, cur) =&gt; sum + cur));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(1, 2);    // 3</span><br><span class="line"></span><br><span class="line">function sum(a, b) &#123;</span><br><span class="line"></span><br><span class="line">  let args = [...arguments];</span><br><span class="line"></span><br><span class="line">  console.log(args.reduce((sum, cur) =&gt; sum + cur));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(1, 2);    // 3</span><br><span class="line"></span><br><span class="line">function sum(...args) &#123;</span><br><span class="line"></span><br><span class="line">  console.log(args.reduce((sum, cur) =&gt; sum + cur));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(1, 2);    // 3</span><br></pre></td></tr></table></figure>
<h3 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h3><ul>
<li><p>普通的递归实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 方法1</span><br><span class="line"></span><br><span class="line">var a = [1, [2, [3, 4, 5]]];</span><br><span class="line"></span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line"></span><br><span class="line">  let result = [];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  for(let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">    if(Array.isArray(arr[i])) &#123;</span><br><span class="line"></span><br><span class="line">      result = result.concat(flatten(arr[i]));</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">      result.push(arr[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">flatten(a);  //  [1, 2, 3, 4，5]</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用 reduce 函数迭代</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 方法2</span><br><span class="line"></span><br><span class="line">var arr = [1, [2, [3, 4]]];</span><br><span class="line"></span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line"></span><br><span class="line">    return arr.reduce(function(prev, next)&#123;</span><br><span class="line"></span><br><span class="line">        return prev.concat(Array.isArray(next) ? flatten(next) : next)</span><br><span class="line"></span><br><span class="line">    &#125;, [])</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(flatten(arr));//  [1, 2, 3, 4，5]</span><br></pre></td></tr></table></figure>
</li>
<li><p>扩展运算符实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 方法3</span><br><span class="line"></span><br><span class="line">var arr = [1, [2, [3, 4]]];</span><br><span class="line"></span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line"></span><br><span class="line">    while (arr.some(item =&gt; Array.isArray(item))) &#123;</span><br><span class="line"></span><br><span class="line">        arr = [].concat(...arr);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return arr;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(flatten(arr)); //  [1, 2, 3, 4，5]</span><br></pre></td></tr></table></figure>
</li>
<li><p>split 和 toString 共同处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 方法4</span><br><span class="line"></span><br><span class="line">var arr = [1, [2, [3, 4]]];</span><br><span class="line"></span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line"></span><br><span class="line">    return arr.toString().split(&apos;,&apos;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(flatten(arr)); //  [1, 2, 3, 4]</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用 ES6 中的 flat,发现对数组的嵌套层数不确定的时候，最好直接使用 Infinity，可以达到扁平化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 方法5</span><br><span class="line"></span><br><span class="line">var arr = [1, [2, [3, 4]]];</span><br><span class="line"></span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line"></span><br><span class="line">  return arr.flat(Infinity);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(flatten(arr)); //  [1, 2, 3, 4，5]</span><br></pre></td></tr></table></figure>
</li>
<li><p>正则和 JSON 方法共同处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 方法 6</span><br><span class="line"></span><br><span class="line">let arr = [1, [2, [3, [4, 5]]], 6];</span><br><span class="line"></span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line"></span><br><span class="line">  let str = JSON.stringify(arr);</span><br><span class="line"></span><br><span class="line">  str = str.replace(/(\[|\])/g, &apos;&apos;);</span><br><span class="line"></span><br><span class="line">  str = &apos;[&apos; + str + &apos;]&apos;;</span><br><span class="line"></span><br><span class="line">  return JSON.parse(str); </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(flatten(arr)); //  [1, 2, 3, 4，5]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="sort-排序方法的实现原理"><a href="#sort-排序方法的实现原理" class="headerlink" title="sort 排序方法的实现原理"></a>sort 排序方法的实现原理</h3><ul>
<li>sort() 方法用原地算法对数组的元素进行排序，并返回数组。默认排序顺序是在将元素转换为字符串，然后比较它们的UTF-16代码单元值序列时构建的</li>
<li>通过研究源码我们先直接看一下结论，如果要排序的元素个数是 n 的时候，那么就会有以下几种情况：</li>
</ul>
<ol>
<li>当 n&lt;=10 时，采用插入排序；对于很小的数据量，应用插入排序是一个非常不错的选择。</li>
<li>当 n&gt;10 时，采用三路快速排序；<br>快速排序的性能瓶颈在于递归的深度，最坏的情况是每次的哨兵都是最小元素或者最大元素，那么进行 partition（一边是小于哨兵的元素，另一边是大于哨兵的元素）时，就会有一边是空的。<br>如果这么排下去，递归的层数就达到了 n , 而每一层的复杂度是 O(n)，因此快排这时候会退化成 O(n^2) 级别。<br>这种情况是要尽力避免的，那么如何来避免？就是让哨兵元素尽可能地处于数组的中间位置，让最大或者最小的情况尽可能少。</li>
<li>10&lt;n &lt;=1000，采用中位数作为哨兵元素；</li>
<li>n&gt;1000，每隔 200~215 个元素挑出一个元素，放到一个新数组中，然后对它排序，找到中间位置的数，以此作为中位数。<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2></li>
</ol>
<ul>
<li>浏览器在加载页面的时候会用到 GUI 渲染线程和 JavaScript 引擎线程（更详细的浏览器加载和渲染机制将在第 7 讲中介绍）。其中，GUI 渲染线程负责渲染浏览器界面 HTML 元素，JavaScript 引擎线程主要负责处理 JavaScript 脚本程序。由于 JavaScript 在执行过程中还可能会改动界面结构和样式，因此它们之间被设计为互斥的关系。也就是说，当 JavaScript 引擎执行时，GUI 线程会被挂起。</li>
<li>如果我们直接在document.body上进行事件委托，可能会带来额外的问题。由于浏览器在进行页面渲染的时候会有合成的步骤，合成的过程会先将页面分成不同的合成层，而用户与浏览器进行交互的时候需要接收事件。此时，浏览器会将页面上具有事件处理程序的区域进行标记，被标记的区域会与主线程进行通信。</li>
<li>如果我们document.body上被绑定了事件，这时候整个页面都会被标记。即使我们的页面不关心某些部分的用户交互，合成器线程也必须与主线程进行通信，并在每次事件发生时进行等待。这种情况，我们可以使用passive: true选项来解决。<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h3></li>
</ul>
<ol>
<li>盒模型会发生margin外边距叠加，叠加后的值会以最大边距为准。</li>
</ol>
<ul>
<li>需要注意的是，并不是所有情况下都会发生外边距叠加，比如行内框、浮动框或绝对定位框之间的外边距不会叠加。</li>
</ul>
<ol start="2">
<li>们可以通过box-sizing属性进行设置盒模型的计算方式，正常的盒模型默认值是content-box。</li>
</ol>
<ul>
<li>使用box-sizing属性可以解决问题 （调整元素的边框时，不影响元素的宽高），我们可以将元素的box-sizing属性设置为border-box<h3 id="内联元素与块状元素"><a href="#内联元素与块状元素" class="headerlink" title="内联元素与块状元素"></a>内联元素与块状元素</h3></li>
<li>除了内联元素和块状元素，我们还可以将元素设置为inline-block，inline-block可以很方便解决一些问题：使元素居中、给inline元素（<a>/<span>）设置宽高、将多个块状元素放在一行等。<h3 id="文档流和元素定位"><a href="#文档流和元素定位" class="headerlink" title="文档流和元素定位"></a>文档流和元素定位</h3></span></a></li>
<li>文档流布局方式可以使用position样式进行调整，包括：static（默认值）、inherit（继承父元素）、relative（相对定位）、absolute（相对非static父元素绝对定位）、fixed（相对浏览器窗口进行绝对定位）,sticky粘性定位。</li>
<li>这是因为除了同级元素以外，z-index值的设置效果还会受到父元素的z-index值的影响。z-index值的设置只决定同一父元素中的同级子元素的堆叠顺序。因此，即使将某个元素z-index设置为9999999，它依然可能因为父元素的z-index值小于其他父元素同级的元素，而导致该元素依然被其他元素遮挡。<h3 id="常见页面布局方式"><a href="#常见页面布局方式" class="headerlink" title="常见页面布局方式"></a>常见页面布局方式</h3></li>
</ul>
<ol>
<li>传统布局</li>
</ol>
<ul>
<li>除了使用position: fixed或者position: absolute时，会使元素脱离文档流，使用float属性同样会导致元素脱离文档流。</li>
</ul>
<ol start="2">
<li>Flex 布局</li>
<li>Grid 布局<h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2></li>
</ol>
<ul>
<li>每个对象都有<strong>proto</strong>属性来标识自己所继承的原型对象，但只有函数才有prototype属性</li>
<li>对于函数来说，每个函数都有一个prototype属性，该属性为该函数的原型对象</li>
<li>一个对象可通过<strong>proto</strong>访问原型对象上的属性和方法，而该原型同样也可通过<strong>proto</strong>访问它的原型对象，这样我们就在实例和原型之间构造了一条原型链</li>
<li>当 JavaScript 试图访问一个对象的属性时，会基于原型链进行查找。查找的过程是这样的：</li>
</ul>
<ol>
<li>首先会优先在该对象上搜寻。如果找不到，还会依次层层向上搜索该对象的原型对象、该对象的原型对象的原型对象等（套娃警告）；</li>
<li>JavaScript 中的所有对象都来自Object，Object.prototype.<strong>proto</strong> === null。null没有原型，并作为这个原型链中的最后一个环节；</li>
<li>JavaScript 会遍历访问对象的整个原型链，如果最终依然找不到，此时会认为该对象的属性值为undefined。</li>
</ol>
<ul>
<li>原型链继承方式中引用类型的属性被所有实例共享，无法做到实例私有</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/学习/">学习</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/学习/">学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网站/">网站</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/资源/">资源</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-browser" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2021/03/25/browser/" class="article-date">
      <time datetime="2021-03-24T16:00:00.000Z" itemprop="datePublished">2021-03-25</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/25/browser/">浏览器工作原理</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="Chrome架构：仅仅打开了1个页面，为什么有4个进程？"><a href="#Chrome架构：仅仅打开了1个页面，为什么有4个进程？" class="headerlink" title="Chrome架构：仅仅打开了1个页面，为什么有4个进程？"></a>Chrome架构：仅仅打开了1个页面，为什么有4个进程？</h2><h3 id="什么是并行处理？"><a href="#什么是并行处理？" class="headerlink" title="什么是并行处理？"></a>什么是并行处理？</h3><ul>
<li>计算机中的并行处理就是同一时刻处理多个任务，比如我们要计算下面这三个表达式的值，并显示出结果。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">A = 1+2</span><br><span class="line">B = 20/5</span><br><span class="line">C = 7*8</span><br><span class="line"></span><br><span class="line">在编写代码的时候，我们可以把这个过程拆分为四个任务：</span><br><span class="line">任务 1 是计算 A=1+2；</span><br><span class="line">任务 2 是计算 B=20/5；</span><br><span class="line">任务 3 是计算 C=7*8；</span><br><span class="line">任务 4 是显示最后计算的结果。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">正常情况下程序可以使用单线程来处理，也就是分四步按照顺序分别执行这四个任务。</span><br><span class="line">如果采用多线程，会怎么样呢？我们只需分“两步走”：第一步，使用三个线程同时执行前三个任务；第二步，再执行第四个显示任务。</span><br><span class="line"></span><br><span class="line">通过对比分析，你会发现用单线程执行需要四步，而使用多线程只需要两步。因此，使用并行处理能大大提升性能。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="线程-VS-进程"><a href="#线程-VS-进程" class="headerlink" title="线程 VS 进程"></a>线程 VS 进程</h3><ul>
<li>多线程可以并行处理任务，但是线程是不能单独存在的，它是由进程来启动和管理的</li>
<li>一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。</li>
<li>线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率。</li>
<li>进程中的任意一线程执行出错，都会导致整个进程的崩溃。</li>
<li>线程之间共享进程中的数据。</li>
<li>当一个进程关闭之后，操作系统会回收进程所占用的内存。</li>
</ul>
<ol>
<li>当一个进程退出时，操作系统会回收该进程所申请的所有资源；即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。</li>
<li>比如之前的 IE 浏览器，支持很多插件，而这些插件很容易导致内存泄漏，这意味着只要浏览器开着，内存占用就有可能会越来越多，但是当关闭浏览器进程时，这些内存就都会被系统回收掉。</li>
</ol>
<ul>
<li>进程之间的内容相互隔离。</li>
</ul>
<ol>
<li>进程隔离是为保护操作系统中进程互不干扰的技术，每一个进程只能访问自己占有的数据，也就避免出现进程 A 写入数据到进程 B 的情况。</li>
<li>正是因为进程之间的数据是严格隔离的，所以一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。</li>
<li>如果进程之间需要进行数据的通信，这时候，就需要使用用于进程间通信（IPC）的机制了。<h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h3></li>
</ol>
<ul>
<li>采用多进程架构的额外好处是可以使用安全沙箱，你可以把沙箱看成是操作系统给进程上了一把锁，沙箱里面的程序可以运行，但是不能在你的硬盘上写入任何数据，也不能在敏感位置读取任何数据，例如你的文档和桌面。Chrome 把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。</li>
<li>最新的 Chrome 浏览器包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。</li>
</ul>
<ol>
<li>浏览器进程。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。</li>
<li>渲染进程。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</li>
<li>GPU 进程。其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。</li>
<li>网络进程。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。</li>
<li>插件进程。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。</li>
</ol>
<ul>
<li>因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源。<h2 id="TCP协议：如何保证页面文件能被完整送达浏览器？"><a href="#TCP协议：如何保证页面文件能被完整送达浏览器？" class="headerlink" title="TCP协议：如何保证页面文件能被完整送达浏览器？"></a>TCP协议：如何保证页面文件能被完整送达浏览器？</h2></li>
<li>在使用 UDP 发送数据时，有各种因素会导致数据包出错，虽然 UDP 可以校验数据是否正确，但是对于错误的数据包，UDP 并不提供重发机制，只是丢弃当前的包，而且 UDP 在发送之后也无法知道是否能达到目的地。</li>
<li>虽说 UDP 不能保证数据可靠性，但是传输速度却非常快，所以 UDP 会应用在一些关注速度、但不那么严格要求数据完整性的领域，如在线视频、互动游戏等。</li>
<li>如果使用 UDP 来传输会存在两个问题：</li>
</ul>
<ol>
<li>数据包在传输过程中容易丢失；</li>
<li>大文件会被拆分成很多小的数据包来传输，这些小的数据包会经过不同的路由，并在不同的时间到达接收端，而 UDP 协议并不知道如何组装这些数据包，从而把这些数据包还原成完整的文件。</li>
</ol>
<ul>
<li>TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。相对于 UDP，TCP 有下面两个特点:</li>
</ul>
<ol>
<li>对于数据包丢失的情况，TCP 提供重传机制；</li>
<li>TCP 引入了数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件。</li>
</ol>
<ul>
<li>和 UDP 头一样，TCP 头除了包含了目标端口和本机端口号外，还提供了用于排序的序列号，以便接收端通过序号来重排数据包。</li>
</ul>
<h2 id="HTTP请求流程：为什么很多站点第二次打开速度会很快？"><a href="#HTTP请求流程：为什么很多站点第二次打开速度会很快？" class="headerlink" title="HTTP请求流程：为什么很多站点第二次打开速度会很快？"></a>HTTP请求流程：为什么很多站点第二次打开速度会很快？</h2><ul>
<li>HTTP 协议，正是建立在 TCP 连接基础之上的。HTTP 是一种允许浏览器向服务器获取资源的协议，是 Web 的基础</li>
</ul>
<h3 id="浏览器端发起-HTTP-请求流程"><a href="#浏览器端发起-HTTP-请求流程" class="headerlink" title="浏览器端发起 HTTP 请求流程"></a>浏览器端发起 HTTP 请求流程</h3><ul>
<li><p>构建请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">首先，浏览器构建请求行信息（如下所示），构建好后，浏览器准备发起网络请求。</span><br><span class="line"></span><br><span class="line">GET /index.html HTTP1.1</span><br></pre></td></tr></table></figure>
</li>
<li><p>查找缓存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件。</span><br><span class="line">其中，浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术。</span><br></pre></td></tr></table></figure>
</li>
<li><p>准备 IP 地址和端口</p>
</li>
</ul>
<ol>
<li>浏览器会请求 DNS 返回域名对应的 IP。</li>
<li>当然浏览器还提供了 DNS 数据缓存服务，如果某个域名已经解析过了，那么浏览器会缓存解析的结果，以供下次查询时直接使用，这样也会减少一次网络请求。</li>
</ol>
<ul>
<li>等待 TCP 队列</li>
</ul>
<ol>
<li>Chrome 有个机制，同一个域名同时最多只能建立 6 个 TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。</li>
<li>当然，如果当前请求数量少于 6，会直接进入下一步，建立 TCP 连接。</li>
</ol>
<ul>
<li>建立 TCP 连接</li>
<li>发送 HTTP 请求</li>
</ul>
<ol>
<li>首先浏览器会向服务器发送请求行，它包括了请求方法、请求 URI（Uniform Resource Identifier）和 HTTP 版本协议。</li>
<li>请求头把浏览器的一些基础信息告诉服务器。比如包含了浏览器所使用的操作系统、浏览器内核等信息，以及当前请求的域名信息、浏览器端的 Cookie 信息，等等。</li>
<li>如果使用 POST 方法，那么浏览器还要准备数据给服务器，这里准备的数据是通过请求体来发送。<h3 id="服务器端处理-HTTP-请求流程"><a href="#服务器端处理-HTTP-请求流程" class="headerlink" title="服务器端处理 HTTP 请求流程"></a>服务器端处理 HTTP 请求流程</h3></li>
</ol>
<ul>
<li>返回请求</li>
</ul>
<ol>
<li>首先服务器会返回响应行，包括协议版本和状态码</li>
<li>服务器也会随同响应向浏览器发送响应头。响应头包含了服务器自身的一些信息，比如服务器生成返回数据的时间、返回的数据类型（JSON、HTML、流媒体等类型），以及服务器要在客户端保存的 Cookie 等信息。</li>
<li>发送完响应头后，服务器就可以继续发送响应体的数据，通常，响应体就包含了 HTML 的实际内容。</li>
</ol>
<ul>
<li>断开连接</li>
</ul>
<ol>
<li>通常情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接。不过如果浏览器或者服务器在其头信息中加入了：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Connection:Keep-Alive </span><br><span class="line">那么 TCP 连接在发送后将仍然保持打开状态，这样浏览器就可以继续通过同一个 TCP 连接发送请求。</span><br><span class="line">保持 TCP 连接可以省去下次请求时需要建立连接的时间，提升资源加载速度。</span><br><span class="line">比如，一个 Web 页面中内嵌的图片就都来自同一个 Web 站点，如果初始化了一个持久连接，你就可以复用该连接，以请求其他资源，而不需要重新再建立新的 TCP 连接。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>重定向</li>
</ul>
<ol>
<li>状态 301 就是告诉浏览器，我需要重定向到另外一个网址，而需要重定向的网址正是包含在响应头的 Location 字段中，接下来，浏览器获取 Location 字段中的地址，并使用该地址重新导航，这就是一个完整重定向的执行流程。</li>
</ol>
<h3 id="为什么很多站点第二次打开速度会很快？"><a href="#为什么很多站点第二次打开速度会很快？" class="headerlink" title="为什么很多站点第二次打开速度会很快？"></a>为什么很多站点第二次打开速度会很快？</h3><ul>
<li>如果第二次页面打开很快，主要原因是第一次加载页面过程中，缓存了一些耗时的数据。</li>
<li>DNS 缓存和页面资源缓存这两块数据是会被浏览器缓存的。DNS 缓存比较简单，它主要就是在浏览器本地把对应的 IP 和域名关联起来</li>
<li>当服务器返回 HTTP 响应头给浏览器时，浏览器是通过响应头中的 Cache-Control 字段来设置是否缓存该资源。</li>
<li><p>通常，我们还需要为这个资源设置一个缓存过期时长，而这个时长是通过 Cache-Control 中的 Max-age 参数来设置的，比如上图设置的缓存过期时间是 2000 秒。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Cache-Control:Max-age=2000</span><br><span class="line">这也就意味着，在该缓存资源还未过期的情况下, 如果再次请求该资源，会直接返回缓存中的资源给浏览器。</span><br></pre></td></tr></table></figure>
</li>
<li><p>但如果缓存过期了，浏览器则会继续发起网络请求，并且在 HTTP 请求头中带上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-None-Match:&quot;4f80f-13c-3a1xb12a&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>服务器收到请求头后，会根据 If-None-Match 的值来判断请求的资源是否有更新。</p>
</li>
</ul>
<ol>
<li>如果没有更新，就返回 304 状态码，相当于服务器告诉浏览器：“这个缓存可以继续使用，这次就不重复发送数据给你了。“</li>
<li>如果资源有更新，服务器就直接返回最新资源给浏览器。</li>
</ol>
<h3 id="登录状态是如何保持的？"><a href="#登录状态是如何保持的？" class="headerlink" title="登录状态是如何保持的？"></a>登录状态是如何保持的？</h3><ul>
<li><p>服务器接收到浏览器提交的信息之后，查询后台，验证用户登录信息是否正确，如果正确的话，会生成一段表示用户身份的字符串，并把该字符串写到响应头的 Set-Cookie 字段里，如下所示，然后把响应头发送给浏览器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Set-Cookie: UID=3431uad;</span><br></pre></td></tr></table></figure>
</li>
<li><p>浏览器在接收到服务器的响应头后，开始解析响应头，如果遇到响应头里含有 Set-Cookie 字段的情况，浏览器就会把这个字段信息保存到本地。比如把UID=3431uad保持到本地。</p>
</li>
<li><p>当用户再次访问时，浏览器会发起 HTTP 请求，但在发起请求之前，浏览器会读取之前保存的 Cookie 数据，并把数据写进请求头里的 Cookie 字段里（如下所示），然后浏览器再将请求头发送给服务器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Cookie: UID=3431uad;</span><br></pre></td></tr></table></figure>
</li>
<li><p>服务器在收到 HTTP 请求头数据之后，就会查找请求头里面的“Cookie”字段信息，当查找到包含UID=3431uad的信息时，服务器查询后台，并判断该用户是已登录状态，然后生成含有该用户信息的页面数据，并把生成的数据发送给浏览器。</p>
</li>
<li>简单地说，如果服务器端发送的响应头内有 Set-Cookie 的字段，那么浏览器就会将该字段的内容保持到本地。当下次客户端再往该服务器发送请求时，客户端会自动在请求头中加入 Cookie 值后再发送出去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到该用户的状态信息。</li>
<li>浏览器中的 HTTP 请求从发起到结束一共经历了如下八个阶段：构建请求、查找缓存、准备 IP 和端口、等待 TCP 队列、建立 TCP 连接、发起 HTTP 请求、服务器处理请求、服务器返回请求和断开连接。</li>
</ul>
<h2 id="导航流程：从输入URL到页面展示，这中间发生了什么？"><a href="#导航流程：从输入URL到页面展示，这中间发生了什么？" class="headerlink" title="导航流程：从输入URL到页面展示，这中间发生了什么？"></a>导航流程：从输入URL到页面展示，这中间发生了什么？</h2><ul>
<li>整个过程需要各个进程之间的配合，所以在开始正式流程之前，我们还是先来快速回顾下浏览器进程、渲染进程和网络进程的主要职责。</li>
</ul>
<ol>
<li>浏览器进程主要负责用户交互、子进程管理和文件储存等功能。</li>
<li>网络进程是面向渲染进程和浏览器进程等提供网络下载功能。</li>
<li>渲染进程的主要职责是把从网络下载的 HTML、JavaScript、CSS、图片等资源解析为可以显示和交互的页面。因为渲染进程所有的内容都是通过网络获取的，会存在一些恶意代码利用浏览器漏洞对系统进行攻击，所以运行在渲染进程里面的代码是不被信任的。这也是为什么 Chrome 会让渲染进程运行在安全沙箱里，就是为了保证系统的安全。</li>
</ol>
<ul>
<li>大致描述为如下。</li>
</ul>
<ol>
<li>首先，浏览器进程接收到用户输入的 URL 请求，浏览器进程便将该 URL 转发给网络进程。</li>
<li>然后，在网络进程中发起真正的 URL 请求。</li>
<li>接着网络进程接收到了响应头数据，便解析响应头数据，并将数据转发给浏览器进程。</li>
<li>浏览器进程接收到网络进程的响应头数据之后，发送“提交导航 (CommitNavigation)”消息到渲染进程；</li>
<li>渲染进程接收到“提交导航”的消息之后，便开始准备接收 HTML 数据，接收数据的方式是直接和网络进程建立数据管道；</li>
<li>最后渲染进程会向浏览器进程“确认提交”，这是告诉浏览器进程：“已经准备好接受和解析页面数据了”。</li>
<li>浏览器进程接收到渲染进程“提交文档”的消息之后，便开始移除之前旧的文档，然后更新浏览器进程中的页面状态。<h3 id="用户输入"><a href="#用户输入" class="headerlink" title="用户输入"></a>用户输入</h3></li>
</ol>
<ul>
<li>当用户在地址栏中输入一个查询关键字时，地址栏会判断输入的关键字是搜索内容，还是请求的 URL。</li>
<li>当用户输入关键字并键入回车之后，这意味着当前页面即将要被替换成新的页面，不过在这个流程继续之前，浏览器还给了当前页面一次执行 beforeunload 事件的机会，beforeunload 事件允许页面在退出之前执行一些数据清理操作，还可以询问用户是否要离开当前页面，比如当前页面可能有未提交完成的表单等情况，因此用户可以通过 beforeunload 事件来取消导航，让浏览器不再执行任何后续工作。<h3 id="URL-请求过程"><a href="#URL-请求过程" class="headerlink" title="URL 请求过程"></a>URL 请求过程</h3></li>
<li>浏览器进程会通过进程间通信（IPC）把 URL 请求发送至网络进程，网络进程接收到 URL 请求后，会在这里发起真正的 URL 请求流程。</li>
<li>网络进程会查找本地缓存是否缓存了该资源。如果有缓存资源，那么直接返回资源给浏览器进程；如果在缓存中没有查找到资源，那么直接进入网络请求流程。</li>
<li>请求前的第一步是要进行 DNS 解析，以获取请求域名的服务器 IP 地址。如果请求协议是 HTTPS，那么还需要建立 TLS 连接。</li>
<li>接下来就是利用 IP 地址和服务器建立 TCP 连接。连接建立之后，浏览器端会构建请求行、请求头等信息，并把和该域名相关的 Cookie 等数据附加到请求头中，然后向服务器发送构建的请求信息。</li>
<li>服务器接收到请求信息后，会根据请求信息生成响应数据（包括响应行、响应头和响应体等信息），并发给网络进程。等网络进程接收了响应行和响应头之后，就开始解析响应头的内容了。</li>
<li>在接收到服务器返回的响应头后，网络进程开始解析响应头，如果发现返回的状态码是 301 或者 302，那么说明服务器需要浏览器重定向到其他 URL。这时网络进程会从响应头的 Location 字段里面读取重定向的地址，然后再发起新的 HTTP 或者 HTTPS 请求，一切又重头开始了。</li>
<li>在导航过程中，如果服务器响应行的状态码包含了 301、302 一类的跳转信息，浏览器会跳转到新的地址继续导航；如果响应行是 200，那么表示浏览器可以继续处理该请求。</li>
<li>Content-Type 是 HTTP 头中一个非常重要的字段， 它告诉浏览器服务器返回的响应体数据是什么类型，然后浏览器会根据 Content-Type 的值来决定如何显示响应体的内容。</li>
<li>Content-Type 的值是 application/octet-stream，显示数据是字节流类型的，通常情况下，浏览器会按照下载类型来处理该请求。</li>
<li>如果 Content-Type 字段的值被浏览器判断为下载类型，那么该请求会被提交给浏览器的下载管理器，同时该 URL 请求的导航流程就此结束。但如果是 HTML，那么浏览器则会继续进行导航流程。由于 Chrome 的页面渲染是运行在渲染进程中的，所以接下来就需要准备渲染进程了。<h3 id="渲染进程"><a href="#渲染进程" class="headerlink" title="渲染进程"></a>渲染进程</h3></li>
<li>默认情况下，Chrome 会为每个页面分配一个渲染进程，也就是说，每打开一个新页面就会配套创建一个新的渲染进程。但是，也有一些例外，在某些情况下，浏览器会让多个页面直接运行在同一个渲染进程中。</li>
<li>那什么情况下多个页面会同时运行在一个渲染进程中呢？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https://time.diamonds.org</span><br><span class="line">https://www.diamonds.org</span><br><span class="line">https://www.diamonds.org:8080</span><br><span class="line"></span><br><span class="line">它们都是属于同一站点，因为它们的协议都是 HTTPS，而且根域名也都是 diamonds.org。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li>Chrome 的默认策略是，每个标签对应一个渲染进程。但如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程。官方把这个默认策略叫 process-per-site-instance。</li>
</ol>
<ul>
<li>总结来说，打开一个新页面采用的渲染进程策略就是：</li>
</ul>
<ol>
<li>通常情况下，打开新的页面都会使用单独的渲染进程；如果从 A 页面打开 B 页面，且 A 和 B 都属于同一站点的话，那么 B 页面复用 A 页面的渲染进程；</li>
<li>如果是其他情况，浏览器进程则会为 B 创建一个新的渲染进程。</li>
</ol>
<ul>
<li>渲染进程准备好之后，还不能立即进入文档解析状态，因为此时的文档数据还在网络进程中，并没有提交给渲染进程，所以下一步就进入了提交文档阶段。<h3 id="提交文档"><a href="#提交文档" class="headerlink" title="提交文档"></a>提交文档</h3></li>
<li>所谓提交文档，就是指浏览器进程将网络进程接收到的 HTML 数据提交给渲染进程，具体流程是这样的：</li>
</ul>
<ol>
<li>首先当浏览器进程接收到网络进程的响应头数据之后，便向渲染进程发起“提交文档”的消息；</li>
<li>渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”；</li>
<li>等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程；</li>
<li>浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。</li>
</ol>
<ul>
<li>这也就解释了为什么在浏览器的地址栏里面输入了一个地址后，之前的页面没有立马消失，而是要加载一会儿才会更新页面。<h3 id="渲染阶段"><a href="#渲染阶段" class="headerlink" title="渲染阶段"></a>渲染阶段</h3></li>
<li>一旦文档被提交，渲染进程便开始页面解析和子资源加载了</li>
</ul>
<h2 id="渲染流程（上）：HTML、CSS和JavaScript，是如何变成页面的？"><a href="#渲染流程（上）：HTML、CSS和JavaScript，是如何变成页面的？" class="headerlink" title="渲染流程（上）：HTML、CSS和JavaScript，是如何变成页面的？"></a>渲染流程（上）：HTML、CSS和JavaScript，是如何变成页面的？</h2><ul>
<li>HTML 的内容是由标记和文本组成。标记也称为标签，每个标签都有它自己的语义，浏览器会根据标签的语义来正确展示 HTML 内容。</li>
<li>CSS 又称为层叠样式表，是由选择器和属性组成</li>
<li>至于 JavaScript（简称为 JS），使用它可以使网页的内容“动”起来</li>
<li>由于渲染机制过于复杂，所以渲染模块在执行过程中会被划分为很多子阶段，输入的 HTML 经过这些子阶段，最后输出像素。我们把这样的一个处理流程叫做渲染流水线</li>
<li>按照渲染的时间顺序，流水线可分为如下几个子阶段：构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成。<h3 id="构建-DOM-树"><a href="#构建-DOM-树" class="headerlink" title="构建 DOM 树"></a>构建 DOM 树</h3></li>
<li>为什么要构建 DOM 树呢？这是因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM 树。<h3 id="样式计算（Recalculate-Style）"><a href="#样式计算（Recalculate-Style）" class="headerlink" title="样式计算（Recalculate Style）"></a>样式计算（Recalculate Style）</h3></li>
<li>样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式，这个阶段大体可分为三步来完成。</li>
<li>把 CSS 转换为浏览器能够理解的结构<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CSS 样式来源主要有三种：</span><br><span class="line">通过 link 引用的外部 CSS 文件</span><br><span class="line">&lt;style&gt;标记内的 CSS</span><br><span class="line">元素的 style 属性内嵌的 CSS</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li>和 HTML 文件一样，浏览器也是无法直接理解这些纯文本的 CSS 样式，所以当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets。</li>
</ol>
<ul>
<li><p>转换样式表中的属性值，使其标准化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">现在我们已经把现有的 CSS 文本转化为浏览器可以理解的结构了，那么接下来就要对其进行属性值的标准化操作。</span><br><span class="line">要理解什么是属性值标准化，你可以看下面这样一段 CSS 文本：</span><br><span class="line"></span><br><span class="line">body &#123; font-size: 2em &#125;  =&gt; body &#123; font-size: 32px &#125;</span><br><span class="line">p &#123;color:blue;&#125;  =&gt; p &#123;rgba(0,0,255)&#125;</span><br><span class="line">span  &#123;display: none&#125;</span><br><span class="line">div &#123;font-weight: bold&#125;  =&gt; div &#123;font-weight: 700)&#125;</span><br><span class="line">div  p &#123;color:green;&#125; =&gt; div &#123;rgba(0,128,0)&#125;</span><br><span class="line">div &#123;color:red; &#125;  =&gt; div &#123;rgba(255,0,0)&#125;</span><br><span class="line"></span><br><span class="line">可以看到上面的 CSS 文本中有很多属性值，如 2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算出 DOM 树中每个节点的具体样式</p>
</li>
<li>涉及到 CSS 的继承规则和层叠规则</li>
</ul>
<ol>
<li><p>首先是 CSS 继承。CSS 继承就是每个 DOM 节点都包含有父节点的样式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">body &#123; font-size: 20px &#125;</span><br><span class="line">p &#123;color:blue;&#125;</span><br><span class="line">span  &#123;display: none&#125;</span><br><span class="line">div &#123;font-weight: bold;color:red&#125;</span><br><span class="line">div  p &#123;color:green;&#125;</span><br><span class="line">所有子节点都继承了父节点样式。</span><br><span class="line">比如 body 节点的 font-size 属性是 20，那 body 节点下面的所有节点的 font-size 都等于 20。</span><br></pre></td></tr></table></figure>
</li>
<li><p>样式计算过程中的第二个规则是样式层叠。层叠是 CSS 的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法。它在 CSS 处于核心地位，CSS 的全称“层叠样式表”正是强调了这一点。</p>
</li>
</ol>
<ul>
<li>总之，样式计算阶段的目的是为了计算出 DOM 节点中每个元素的具体样式，在计算过程中需要遵守 CSS 的继承和层叠两个规则。这个阶段最终输出的内容是每个 DOM 节点的样式，并被保存在 ComputedStyle 的结构内。<h3 id="布局阶段"><a href="#布局阶段" class="headerlink" title="布局阶段"></a>布局阶段</h3></li>
<li>有 DOM 树和 DOM 树中元素的样式，但这还不足以显示页面，因为我们还不知道 DOM 元素的几何位置信息。那么接下来就需要计算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做布局。</li>
<li>Chrome 在布局阶段需要完成两个任务：创建布局树和布局计算。</li>
<li>创建布局树</li>
</ul>
<ol>
<li>DOM 树还含有很多不可见的元素，比如 head 标签，还有使用了 display:none 属性的元素。所以在显示之前，我们还要额外地构建一棵只包含可见元素布局树。</li>
<li>DOM 树中所有不可见的节点都没有包含到布局树中。</li>
<li>为了构建布局树，浏览器大体上完成了下面这些工作：<br>遍历 DOM 树中的所有可见节点，并把这些节点加到布局树中；<br>而不可见的节点会被布局树忽略掉，如 head 标签下面的全部内容，再比如 body.p.span 这个元素，因为它的属性包含 dispaly:none，所以这个元素也没有被包进布局树。</li>
</ol>
<ul>
<li>布局计算</li>
</ul>
<ol>
<li>有了一棵完整的布局树。那么接下来，就要计算布局树节点的坐标位置了。</li>
<li>在执行布局操作的时候，会把布局运算的结果重新写回布局树中，所以布局树既是输入内容也是输出内容，这是布局阶段一个不合理的地方，因为在布局阶段并没有清晰地将输入内容和输出内容区分开来。<br>针对这个问题，Chrome 团队正在重构布局代码，下一代布局系统叫 LayoutNG，试图更清晰地分离输入和输出，从而让新设计的布局算法更加简单。<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3></li>
</ol>
<ul>
<li>渲染流程的前三个阶段：DOM 生成、样式计算和布局。要点可大致总结为如下：</li>
</ul>
<ol>
<li>浏览器不能直接理解 HTML 数据，所以第一步需要将其转换为浏览器能够理解的 DOM 树结构；</li>
<li>生成 DOM 树后，还需要根据 CSS 样式表，来计算出 DOM 树所有节点的样式；</li>
<li>最后计算 DOM 元素的布局信息，使其都保存在布局树中。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">当从服务器接收HTML页面的第一批数据时，DOM解析器就开始工作了，在解析过程中，如果遇到了JS脚本，如下所示：</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        极客时间</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">        document.write(&quot;--foo&quot;)</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">那么DOM解析器会先执行JavaScript脚本，执行完成之后，再继续往下解析。</span><br><span class="line"></span><br><span class="line">那么第二种情况复杂点了，我们内联的脚本替换成js外部文件，如下所示：</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        极客时间</span><br><span class="line">        &lt;script type=&quot;text/javascript&quot; src=&quot;foo.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">这种情况下，当解析到JavaScript的时候，会先暂停DOM解析，并下载foo.js文件，下载完成之后执行该段JS文件，然后再继续往下解析DOM。这就是JavaScript文件为什么会阻塞DOM渲染。</span><br><span class="line"></span><br><span class="line">我们再看第三种情况，还是看下面代码：</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;style type=&quot;text/css&quot; src = &quot;theme.css&quot; /&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;p&gt;极客时间&lt;/p&gt;</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            let e = document.getElementsByTagName(&apos;p&apos;)[0]</span><br><span class="line">            e.style.color = &apos;blue&apos;</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">当我在JavaScript中访问了某个元素的样式，那么这时候就需要等待这个样式被下载完成才能继续往下执行，所以在这种情况下，CSS也会阻塞DOM的解析。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">所以JS和CSS都有可能会阻塞DOM解析</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="渲染流程（下）：HTML、CSS和JavaScript，是如何变成页面的？"><a href="#渲染流程（下）：HTML、CSS和JavaScript，是如何变成页面的？" class="headerlink" title="渲染流程（下）：HTML、CSS和JavaScript，是如何变成页面的？"></a>渲染流程（下）：HTML、CSS和JavaScript，是如何变成页面的？</h2><h3 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h3><ul>
<li>页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）。</li>
<li>如果你熟悉 PS，相信你会很容易理解图层的概念，正是这些图层叠加在一起构成了最终的页面图像。</li>
<li>浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。</li>
<li>通常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层</li>
<li>拥有层叠上下文属性的元素会被提升为单独的一层。页面是个二维平面，但是层叠上下文能够让 HTML 元素具有三维概念，这些 HTML 元素按照自身属性的优先级分布在垂直于这个二维平面的 z 轴上。</li>
<li>明确定位属性的元素、定义透明属性的元素、使用 CSS 滤镜的元素等，都拥有层叠上下文属性。</li>
<li>需要剪裁（clip）的地方也会被创建为图层。<h3 id="图层绘制"><a href="#图层绘制" class="headerlink" title="图层绘制"></a>图层绘制</h3></li>
<li>在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制<h3 id="栅格化（raster）操作"><a href="#栅格化（raster）操作" class="headerlink" title="栅格化（raster）操作"></a>栅格化（raster）操作</h3></li>
<li>绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。</li>
<li>当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程</li>
<li>通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做视口（viewport）。</li>
<li>在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。基于这个原因，合成线程会将图层划分为图块（tile）。</li>
<li>合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的</li>
<li>通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。GPU 操作是运行在 GPU 进程中，如果栅格化操作使用了 GPU，那么最终生成位图的操作是在 GPU 中完成的，这就涉及到了跨进程操作</li>
<li>渲染进程把生成图块的指令发送给 GPU，然后在 GPU 中执行生成图块的位图，并保存在 GPU 的内存中。<h3 id="合成和显示"><a href="#合成和显示" class="headerlink" title="合成和显示"></a>合成和显示</h3></li>
<li>一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。</li>
<li>浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。<h3 id="渲染总结"><a href="#渲染总结" class="headerlink" title="渲染总结"></a>渲染总结</h3></li>
<li>一个完整的渲染流程大致可总结为如下：</li>
</ul>
<ol>
<li>渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。</li>
<li>渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。</li>
<li>创建布局树，并计算元素的布局信息。</li>
<li>对布局树进行分层，并生成分层树。</li>
<li>为每个图层生成绘制列表，并将其提交到合成线程。</li>
<li>合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。</li>
<li>合成线程发送绘制图块命令 DrawQuad 给浏览器进程。</li>
<li>浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。<h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3></li>
</ol>
<ul>
<li>更新了元素的几何属性（重排）</li>
</ul>
<ol>
<li>如果你通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。</li>
<li>无疑，重排需要更新完整的渲染流水线，所以开销也是最大的。</li>
</ol>
<ul>
<li>更新元素的绘制属性（重绘）</li>
</ul>
<ol>
<li>如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。</li>
<li>相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。</li>
</ol>
<ul>
<li>直接合成阶段</li>
</ul>
<ol>
<li>使用 CSS 的 transform 来实现动画效果，可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。</li>
<li>这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，</li>
<li>所以相对于重绘和重排，合成能大大提升绘制效率。</li>
</ol>
<h2 id="变量提升：JavaScript代码是按顺序执行的吗？"><a href="#变量提升：JavaScript代码是按顺序执行的吗？" class="headerlink" title="变量提升：JavaScript代码是按顺序执行的吗？"></a>变量提升：JavaScript代码是按顺序执行的吗？</h2><h3 id="变量提升（Hoisting）"><a href="#变量提升（Hoisting）" class="headerlink" title="变量提升（Hoisting）"></a>变量提升（Hoisting）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var myname = &apos;diamonds&apos;</span><br><span class="line">这段代码你可以把它看成是两行代码组成的：</span><br><span class="line">var myname    //声明部分</span><br><span class="line">myname = &apos;diamonds&apos;  //赋值部分</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function foo()&#123;</span><br><span class="line">  console.log(&apos;foo&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var bar = function()&#123;</span><br><span class="line">  console.log(&apos;bar&apos;)</span><br><span class="line">&#125;</span><br><span class="line">第一个函数 foo 是一个完整的函数声明，也就是说没有涉及到赋值操作；</span><br><span class="line">第二个函数是先声明变量 bar，再把function()&#123;console.log(&apos;bar&apos;)&#125;赋值给 bar。</span><br></pre></td></tr></table></figure>
<ul>
<li>所谓的变量提升，是指在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。</li>
<li>变量被提升后，会给变量设置默认值，这个默认值就是我们熟悉的 undefined。<h3 id="JavaScript-代码的执行流程"><a href="#JavaScript-代码的执行流程" class="headerlink" title="JavaScript 代码的执行流程"></a>JavaScript 代码的执行流程</h3></li>
<li>实际上变量和函数声明在代码里的位置是不会改变的，而且是在编译阶段被 JavaScript 引擎放入内存中。<h4 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h4></li>
<li>输入一段代码，经过编译后，会生成两部分内容：执行上下文（Execution context）和可执行代码。</li>
<li>执行上下文是 JavaScript 执行一段代码时的运行环境，比如调用一个函数，就会进入这个函数的执行上下文，确定该函数在执行期间用到的诸如 this、变量、对象以及函数等。</li>
<li>在执行上下文中存在一个变量环境的对象（Viriable Environment），该对象中保存了变量提升的内容<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">showName()</span><br><span class="line">console.log(myname)</span><br><span class="line">var myname = &apos;diamonds&apos;</span><br><span class="line">function showName() &#123;</span><br><span class="line">    console.log(&apos;函数showName被执行&apos;);</span><br><span class="line">&#125;</span><br><span class="line">第 1 行和第 2 行，由于这两行代码不是声明操作，所以 JavaScript 引擎不会做任何处理；</span><br><span class="line">第 3 行，由于这行是经过 var 声明的，因此 JavaScript 引擎将在环境对象中创建一个名为 myname 的属性，并使用 undefined 对其初始化；</span><br><span class="line">第 4 行，JavaScript 引擎发现了一个通过 function 定义的函数，所以它将函数定义存储到堆 (HEAP）中，并在环境对象中创建一个 showName 的属性，然后将该属性值指向堆中函数的位置（不了解堆也没关系，JavaScript 的执行堆和执行栈我会在后续文章中介绍）。</span><br><span class="line"></span><br><span class="line"> JavaScript 引擎会把声明以外的代码编译为字节码</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">showName()</span><br><span class="line">console.log(myname)</span><br><span class="line">var myname = &apos;diamonds&apos;</span><br><span class="line">function showName() &#123;</span><br><span class="line">    console.log(&apos;函数showName被执行&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当执行到 showName 函数时，JavaScript 引擎便开始在变量环境对象中查找该函数，由于变量环境对象中存在该函数的引用，所以 JavaScript 引擎便开始执行该函数，并输出“函数 showName 被执行”结果。</span><br><span class="line">接下来打印“myname”信息，JavaScript 引擎继续在变量环境对象中查找该对象，由于变量环境存在 myname 变量，并且其值为 undefined，所以这时候就输出 undefined。</span><br><span class="line">接下来执行第 3 行，把“diamonds”赋给 myname 变量，赋值后变量环境中的 myname 属性值改变为“diamonds</span><br></pre></td></tr></table></figure>
<ul>
<li>实际上，编译阶段和执行阶段都是非常复杂的，包括了词法分析、语法解析、代码优化、代码生成等<h3 id="代码中出现相同的变量或者函数怎么办？"><a href="#代码中出现相同的变量或者函数怎么办？" class="headerlink" title="代码中出现相同的变量或者函数怎么办？"></a>代码中出现相同的变量或者函数怎么办？</h3></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function showName() &#123;</span><br><span class="line">    console.log(&apos;diamond&apos;);</span><br><span class="line">&#125;</span><br><span class="line">showName();</span><br><span class="line">function showName() &#123;</span><br><span class="line">    console.log(&apos;diamonds&apos;);</span><br><span class="line">&#125;</span><br><span class="line">showName(); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">首先是编译阶段。遇到了第一个 showName 函数，会将该函数体存放到变量环境中。</span><br><span class="line">接下来是第二个 showName 函数，继续存放至变量环境中，但是变量环境中已经存在一个 showName 函数了，此时，第二个 showName 函数会将第一个 showName 函数覆盖掉。这样变量环境中就只存在第二个 showName 函数了。</span><br><span class="line">接下来是执行阶段。先执行第一个 showName 函数，但由于是从变量环境中查找 showName 函数，而变量环境中只保存了第二个 showName 函数，所以最终调用的是第二个函数，打印的内容是“diamonds”。第二次执行 showName 函数也是走同样的流程，所以输出的结果也是“diamonds”。</span><br></pre></td></tr></table></figure>
<h2 id="调用栈：为什么JavaScript代码会出现栈溢出？"><a href="#调用栈：为什么JavaScript代码会出现栈溢出？" class="headerlink" title="调用栈：为什么JavaScript代码会出现栈溢出？"></a>调用栈：为什么JavaScript代码会出现栈溢出？</h2><ul>
<li>当一段代码被执行时，JavaScript 引擎先会对其进行编译，并创建执行上下文。</li>
</ul>
<ol>
<li>当 JavaScript 执行全局代码的时候，会编译全局代码并创建全局执行上下文，而且在整个页面的生存周期内，全局执行上下文只有一份。</li>
<li>当调用一个函数的时候，函数体内的代码会被编译，并创建函数执行上下文，一般情况下，函数执行结束之后，创建的函数执行上下文会被销毁。</li>
<li>当使用 eval 函数的时候，eval 的代码也会被编译，并创建执行上下文。</li>
</ol>
<ul>
<li>用栈就是用来管理函数调用关系的一种数据结构。</li>
</ul>
<h3 id="什么是函数调用"><a href="#什么是函数调用" class="headerlink" title="什么是函数调用"></a>什么是函数调用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var a = 2</span><br><span class="line">function add()&#123;</span><br><span class="line">var b = 10</span><br><span class="line">return  a+b</span><br><span class="line">&#125;</span><br><span class="line">add()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在执行到函数 add() 之前，JavaScript 引擎会为上面这段代码创建全局执行上下文，包含了声明的函数和变量。</span><br><span class="line">代码中全局变量和函数都保存在全局上下文的变量环境中。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">执行上下文准备好之后，便开始执行全局代码，当执行到 add 这儿时，JavaScript 判断这是一个函数调用，那么将执行以下操作：</span><br><span class="line">1.首先，从全局执行上下文中，取出 add 函数代码。</span><br><span class="line">2.其次，对 add 函数的这段代码进行编译，并创建该函数的执行上下文和可执行代码。</span><br><span class="line">3.最后，执行代码，输出结果。</span><br><span class="line"></span><br><span class="line">当执行到 add 函数的时候，我们就有了两个执行上下文了——全局执行上下文和 add 函数的执行上下文。也就是说在执行 JavaScript 时，可能会存在多个执行上下文。</span><br><span class="line"></span><br><span class="line">JavaScript 引擎通过一种叫栈的数据结构来管理执行上下文。</span><br></pre></td></tr></table></figure>
<h3 id="什么是-JavaScript-的调用栈"><a href="#什么是-JavaScript-的调用栈" class="headerlink" title="什么是 JavaScript 的调用栈"></a>什么是 JavaScript 的调用栈</h3><ul>
<li><p>JavaScript 引擎正是利用栈的这种结构来管理执行上下文的。在执行上下文创建好后，JavaScript 引擎会将执行上下文压入栈中，通常把这种用来管理执行上下文的栈称为执行上下文栈，又称调用栈。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var a = 2</span><br><span class="line">function add(b,c)&#123;</span><br><span class="line">  return b+c</span><br><span class="line">&#125;</span><br><span class="line">function addAll(b,c)&#123;</span><br><span class="line">var d = 10</span><br><span class="line">result = add(b,c)</span><br><span class="line">return  a+result+d</span><br><span class="line">&#125;</span><br><span class="line">addAll(3,6)</span><br><span class="line"></span><br><span class="line">第一步，创建全局上下文，并将其压入栈底</span><br><span class="line">变量 a、函数 add 和 addAll 都保存到了全局上下文的变量环境对象中。</span><br><span class="line">全局执行上下文压入到调用栈后，JavaScript 引擎便开始执行全局代码了。</span><br><span class="line">首先会执行 a=2 的赋值操作，执行该语句会将全局上下文变量环境中 a 的值设置为 2。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第二步是调用 addAll 函数。</span><br><span class="line">当调用该函数时，JavaScript 引擎会编译该函数，并为其创建一个执行上下文，最后还将该函数的执行上下文压入栈中</span><br><span class="line">addAll 函数的执行上下文创建好之后，便进入了函数代码的执行阶段了，这里先执行的是 d=10 的赋值操作，执行语句会将 addAll 函数执行上下文中的 d 由 undefined 变成了 10。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第三步，当执行到 add 函数调用语句时，同样会为其创建执行上下文，并将其压入调用栈</span><br><span class="line">当 add 函数返回时，该函数的执行上下文就会从栈顶弹出，并将 result 的值设置为 add 函数的返回值，也就是 9</span><br><span class="line">紧接着 addAll 执行最后一个相加操作后并返回，addAll 的执行上下文也会从栈顶部弹出，此时调用栈中就只剩下全局上下文了。</span><br><span class="line">至此，整个 JavaScript 流程执行结束了。</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用栈是 JavaScript 引擎追踪函数执行的一个机制，当一次有多个函数被调用时，通过调用栈就能够追踪到哪个函数正在被执行以及各函数之间的调用关系。</p>
</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol>
<li>每调用一个函数，JavaScript 引擎会为其创建执行上下文，并把该执行上下文压入调用栈，然后 JavaScript 引擎开始执行函数代码。</li>
<li>如果在一个函数 A 中调用了另外一个函数 B，那么 JavaScript 引擎会为 B 函数创建执行上下文，并将 B 函数的执行上下文压入栈顶。</li>
<li>当前函数执行完毕后，JavaScript 引擎会将该函数的执行上下文弹出栈。</li>
<li>当分配的调用栈空间被占满时，会引发“堆栈溢出”问题。</li>
</ol>
<h2 id="块级作用域：var缺陷以及为什么要引入let和const？"><a href="#块级作用域：var缺陷以及为什么要引入let和const？" class="headerlink" title="块级作用域：var缺陷以及为什么要引入let和const？"></a>块级作用域：var缺陷以及为什么要引入let和const？</h2><ul>
<li>作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。</li>
<li>在 ES6 之前，ES 的作用域只有两种：全局作用域和函数作用域。</li>
</ul>
<ol>
<li>全局作用域中的对象在代码中的任何地方都能访问，其生命周期伴随着页面的生命周期。</li>
<li>函数作用域就是在函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部被访问。函数执行结束之后，函数内部定义的变量会被销毁。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function foo()&#123;</span><br><span class="line">  for (var i = 0; i &lt; 7; i++) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(i); </span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line">如果你使用 C 语言或者其他的大部分语言实现类似代码，在 for 循环结束之后，i 就已经被销毁了，</span><br><span class="line">但是在 JavaScript 代码中，i 的值并未被销毁，所以最后打印出来的是 7。</span><br><span class="line">这同样也是由变量提升而导致的，在创建执行上下文阶段，变量 i 就已经被提升了，所以当 for 循环结束之后，变量 i 并没有被销毁。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="JavaScript-是如何支持块级作用域的"><a href="#JavaScript-是如何支持块级作用域的" class="headerlink" title="JavaScript 是如何支持块级作用域的"></a>JavaScript 是如何支持块级作用域的</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function foo()&#123;</span><br><span class="line">    var a = 1</span><br><span class="line">    let b = 2</span><br><span class="line">    &#123;</span><br><span class="line">      let b = 3</span><br><span class="line">      var c = 4</span><br><span class="line">      let d = 5</span><br><span class="line">      console.log(a)</span><br><span class="line">      console.log(b)</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(b) </span><br><span class="line">    console.log(c)</span><br><span class="line">    console.log(d)</span><br><span class="line">&#125;   </span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line">第一步是编译并创建执行上下文</span><br><span class="line">函数内部通过 var 声明的变量，在编译阶段全都被存放到变量环境里面了。</span><br><span class="line">通过 let 声明的变量，在编译阶段会被存放到词法环境（Lexical Environment）中。</span><br><span class="line">在函数的作用域块内部，通过 let 声明的变量并没有被存放到词法环境中。</span><br><span class="line"></span><br><span class="line">第二步继续执行代码，当执行到代码块里面时，变量环境中 a 的值已经被设置成了 1，词法环境中 b 的值已经被设置成了 2</span><br><span class="line">当进入函数的作用域块时，作用域块中通过 let 声明的变量，会被存放在词法环境的一个单独的区域中，这个区域中的变量并不影响作用域块外面的变量，比如在作用域外面声明了变量 b，在该作用域块内部也声明了变量 b，当执行到作用域内部时，它们都是独立的存在。</span><br><span class="line">其实，在词法环境内部，维护了一个小型栈结构，栈底是函数最外层的变量，进入一个作用域块后，就会把该作用域块内部的变量压到栈顶；当作用域执行完成之后，该作用域的信息就会从栈顶弹出，这就是词法环境的结构。</span><br><span class="line">需要注意下，我这里所讲的变量是指通过 let 或者 const 声明的变量。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">再接下来，当执行到作用域块中的console.log(a)这行代码时，就需要在词法环境和变量环境中查找变量 a 的值了，</span><br><span class="line">具体查找方式是：沿着词法环境的栈顶向下查询，如果在词法环境中的某个块中查找到了，就直接返回给 JavaScript 引擎，</span><br><span class="line">如果没有查找到，那么继续在变量环境中查找。</span><br></pre></td></tr></table></figure>
<h2 id="作用域链和闭包-：代码中出现相同的变量，JavaScript引擎是如何选择的？"><a href="#作用域链和闭包-：代码中出现相同的变量，JavaScript引擎是如何选择的？" class="headerlink" title="作用域链和闭包 ：代码中出现相同的变量，JavaScript引擎是如何选择的？"></a>作用域链和闭包 ：代码中出现相同的变量，JavaScript引擎是如何选择的？</h2><ul>
<li>ES6 是如何通过变量环境和词法环境来同时支持变量提升和块级作用域</li>
<li>在每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，我们把这个外部引用称为 outer。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function bar() &#123;</span><br><span class="line">    console.log(myName)</span><br><span class="line">&#125;</span><br><span class="line">function foo() &#123;</span><br><span class="line">    var myName = &quot;diamonds&quot;</span><br><span class="line">    bar()</span><br><span class="line">&#125;</span><br><span class="line">var myName = &quot;diamond&quot;</span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line">上面那段代码在查找 myName 变量时，如果在当前的变量环境中没有查找到，那么 JavaScript 引擎会继续在 outer 所指向的执行上下文中查找。</span><br><span class="line">bar 函数和 foo 函数的 outer 都是指向全局上下文的，这也就意味着如果在 bar 函数或者 foo 函数中使用了外部变量，那么 JavaScript 引擎会去全局执行上下文中查找。我们把这个查找的链条就称为作用域链。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foo 函数调用的 bar 函数，那为什么 bar 函数的外部引用是全局执行上下文，而不是 foo 函数的执行上下文？</span><br><span class="line">要回答这个问题，你还需要知道什么是词法作用域。这是因为在 JavaScript 执行过程中，其作用域链是由词法作用域决定的。</span><br><span class="line">这是因为根据词法作用域，foo 和 bar 的上级作用域都是全局作用域，所以如果 foo 或者 bar 函数使用了一个它们没有定义的变量，那么它们会到全局作用域去查找。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><ul>
<li><p>词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let count=1</span><br><span class="line">function main()&#123;</span><br><span class="line">let count=2</span><br><span class="line">function bar()&#123;</span><br><span class="line">let count=3</span><br><span class="line">function foo()&#123;</span><br><span class="line">let count=4</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">词法作用域就是根据代码的位置来决定的，其中 main 函数包含了 bar 函数，bar 函数中包含了 foo 函数，因为 JavaScript 作用域链是由词法作用域决定的，所以整个词法作用域链的顺序是：foo 函数作用域—&gt;bar 函数作用域—&gt;main 函数作用域—&gt; 全局作用域。</span><br></pre></td></tr></table></figure>
</li>
<li><p>词法作用域是代码编译阶段就决定好的，和函数是怎么调用的没有关系。</p>
</li>
</ul>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">    var myName = &quot;diamond&quot;</span><br><span class="line">    let test1 = 1</span><br><span class="line">    const test2 = 2</span><br><span class="line">    var innerBar = &#123;</span><br><span class="line">        getName:function()&#123;</span><br><span class="line">            console.log(test1)</span><br><span class="line">            return myName</span><br><span class="line">        &#125;,</span><br><span class="line">        setName:function(newName)&#123;</span><br><span class="line">            myName = newName</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return innerBar</span><br><span class="line">&#125;</span><br><span class="line">var bar = foo()</span><br><span class="line">bar.setName(&quot;diamonds&quot;)</span><br><span class="line">bar.getName()</span><br><span class="line">console.log(bar.getName())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。</span><br><span class="line">比如外部函数是 foo，那么这些变量的集合就称为 foo 函数的闭包。</span><br></pre></td></tr></table></figure>
<ul>
<li>如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一个局部变量。</li>
</ul>
<h2 id="this：从JavaScript执行上下文的视角讲清楚this"><a href="#this：从JavaScript执行上下文的视角讲清楚this" class="headerlink" title="this：从JavaScript执行上下文的视角讲清楚this"></a>this：从JavaScript执行上下文的视角讲清楚this</h2><ul>
<li>this 是和执行上下文绑定的，也就是说每个执行上下文中都有一个 this</li>
<li>执行上下文主要分为三种——全局执行上下文、函数执行上下文和 eval 执行上下文，所以对应的 this 也只有这三种——全局执行上下文中的 this、函数中的 this 和 eval 中的 this。<h3 id="this-的设计缺陷以及应对方案"><a href="#this-的设计缺陷以及应对方案" class="headerlink" title="this 的设计缺陷以及应对方案"></a>this 的设计缺陷以及应对方案</h3></li>
<li><p>嵌套函数中的 this 不会从外层函数中继承</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var myObj = &#123;</span><br><span class="line">  name : &quot;diamonds&quot;, </span><br><span class="line">  showThis: function()&#123;</span><br><span class="line">    console.log(this)</span><br><span class="line">    function bar()&#123;console.log(this)&#125;</span><br><span class="line">    bar()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myObj.showThis()</span><br><span class="line"></span><br><span class="line">执行这段代码后，你会发现函数 bar 中的 this 指向的是全局 window 对象，而函数 showThis 中的 this 指向的是 myObj 对象。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var myObj = &#123;</span><br><span class="line">  name : &quot;diamond&quot;, </span><br><span class="line">  showThis: function()&#123;</span><br><span class="line">    console.log(this)</span><br><span class="line">    var bar = ()=&gt;&#123;</span><br><span class="line">      this.name = &quot;diamonds&quot;</span><br><span class="line">      console.log(this)</span><br><span class="line">    &#125;</span><br><span class="line">    bar()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myObj.showThis()</span><br><span class="line">console.log(myObj.name)</span><br><span class="line">console.log(window.name)</span><br><span class="line"></span><br><span class="line">ES6 中的箭头函数并不会创建其自身的执行上下文，所以箭头函数中的 this 取决于它的外部函数。</span><br><span class="line">因为箭头函数没有自己的执行上下文，所以箭头函数的 this 就是它外层函数的 this。</span><br></pre></td></tr></table></figure>
</li>
<li><p>普通函数中的 this 默认指向全局对象 window</p>
</li>
</ul>
<ol>
<li>在严格模式下，默认执行一个函数，其函数的执行上下文中的 this 值是 undefined</li>
</ol>
<h2 id="栈空间和堆空间：数据是如何存储的？"><a href="#栈空间和堆空间：数据是如何存储的？" class="headerlink" title="栈空间和堆空间：数据是如何存储的？"></a>栈空间和堆空间：数据是如何存储的？</h2><ul>
<li>我们把这种在使用之前就需要确认其变量数据类型的称为静态语言。</li>
<li>相反地，我们把在运行过程中需要检查数据类型的语言称为动态语言。</li>
<li>JavaScript 就是动态语言，因为在声明变量之前并不需要确认其数据类型。</li>
<li>支持隐式类型转换的语言称为弱类型语言，不支持隐式类型转换的语言称为强类型语言。</li>
<li>JavaScript 是一种弱类型的、动态的语言。</li>
</ul>
<ol>
<li>弱类型，意味着你不需要告诉 JavaScript 引擎这个或那个变量是什么数据类型，JavaScript 引擎在运行代码的时候自己会计算出来。</li>
<li>动态，意味着你可以使用同一个变量保存不同类型的数据。</li>
</ol>
<ul>
<li>使用 typeof 检测 Null 类型时，返回的是 Object。这是当初 JavaScript 语言的一个 Bug，一直保留至今，之所以一直没修改过来，主要是为了兼容老的代码。</li>
<li>Object 类型比较特殊，Object 是由 key-value 组成的，其中的 vaule 可以是任何类型，包括函数，这也就意味着你可以通过 Object 来存储函数，Object 中的函数又称为方法</li>
<li>在 JavaScript 的执行过程中， 主要有三种类型内存空间，分别是代码空间、栈空间和堆空间。代码空间主要是存储可执行代码的。<h3 id="栈空间和堆空间"><a href="#栈空间和堆空间" class="headerlink" title="栈空间和堆空间"></a>栈空间和堆空间</h3></li>
<li>调用栈，是用来存储执行上下文的</li>
<li>对象类型是存放在堆空间的，在栈空间中只是保留了对象的引用地址，当 JavaScript 需要访问该数据的时候，是通过栈中的引用地址来访问的</li>
<li>JavaScript 引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。</li>
<li>通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据。而引用类型的数据占用的空间都比较大，所以这一类数据会被存放到堆中，堆空间很大，能存放很多大的数据，不过缺点是分配内存和回收内存都会占用一定的时间</li>
<li>原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址。</li>
</ul>
<h2 id="垃圾回收：垃圾数据是如何自动回收的？"><a href="#垃圾回收：垃圾数据是如何自动回收的？" class="headerlink" title="垃圾回收：垃圾数据是如何自动回收的？"></a>垃圾回收：垃圾数据是如何自动回收的？</h2><ul>
<li>有些数据被使用之后，可能就不再需要了，我们把这种数据称为垃圾数据。如果这些垃圾数据一直保存在内存中，那么内存会越用越多，所以我们需要对这些垃圾数据进行回收，以释放有限的内存空间。</li>
<li>通常情况下，垃圾数据回收分为手动回收和自动回收两种策略。<h3 id="调用栈中的数据是如何回收的"><a href="#调用栈中的数据是如何回收的" class="headerlink" title="调用栈中的数据是如何回收的"></a>调用栈中的数据是如何回收的</h3></li>
<li>当一个函数执行结束之后，JavaScript 引擎会通过向下移动 ESP（记录当前执行状态的指针） 来销毁该函数保存在栈中的执行上下文。<h3 id="堆中的数据是如何回收的"><a href="#堆中的数据是如何回收的" class="headerlink" title="堆中的数据是如何回收的"></a>堆中的数据是如何回收的</h3></li>
<li>要回收堆中的垃圾数据，就需要用到 JavaScript 中的垃圾回收器了。<h3 id="代际假说和分代收集"><a href="#代际假说和分代收集" class="headerlink" title="代际假说和分代收集"></a>代际假说和分代收集</h3></li>
<li>代际假说（The Generational Hypothesis）的内容，这是垃圾回收领域中一个重要的术语，后续垃圾回收的策略都是建立在该假说的基础之上的，所以很是重要。</li>
<li>代际假说有以下两个特点：</li>
</ul>
<ol>
<li>第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；</li>
<li>第二个是不死的对象，会活得更久。</li>
</ol>
<ul>
<li>通常，垃圾回收算法有很多种，但是并没有哪一种能胜任所有的场景，你需要权衡各种场景，根据对象的生存周期的不同而使用不同的算法，以便达到最好的效果。</li>
<li>在 V8 中会把堆分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象。</li>
<li>新生区通常只支持 1～8M 的容量，而老生区支持的容量就大很多了。对于这两块区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。</li>
<li>副垃圾回收器，主要负责新生代的垃圾回收。主垃圾回收器，主要负责老生代的垃圾回收。<h3 id="垃圾回收器的工作流程"><a href="#垃圾回收器的工作流程" class="headerlink" title="垃圾回收器的工作流程"></a>垃圾回收器的工作流程</h3></li>
<li>V8 把堆分成两个区域——新生代和老生代，并分别使用两个不同的垃圾回收器。其实不论什么类型的垃圾回收器，它们都有一套共同的执行流程。</li>
</ul>
<ol>
<li>第一步是标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。</li>
<li>第二步是回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。</li>
<li>第三步是做内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为内存碎片。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。所以最后一步需要整理这些内存碎片，但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片，比如接下来我们要介绍的副垃圾回收器。<h4 id="副垃圾回收器"><a href="#副垃圾回收器" class="headerlink" title="副垃圾回收器"></a>副垃圾回收器</h4></li>
</ol>
<ul>
<li>副垃圾回收器主要负责新生区的垃圾回收。而通常情况下，大多数小的对象都会被分配到新生区，所以说这个区域虽然不大，但是垃圾回收还是比较频繁的。</li>
<li>新生代中用 Scavenge 算法来处理。所谓 Scavenge 算法，是把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域</li>
<li>新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。</li>
<li>在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。</li>
<li>完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时这种角色翻转的操作还能让新生代中的这两块区域无限重复使用下去。</li>
<li>由于新生代中采用的 Scavenge 算法，所以每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域。但复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以为了执行效率，一般新生区的空间会被设置得比较小。</li>
<li>也正是因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JavaScript 引擎采用了对象晋升策略，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。<h4 id="主垃圾回收器"><a href="#主垃圾回收器" class="headerlink" title="主垃圾回收器"></a>主垃圾回收器</h4></li>
<li>主垃圾回收器主要负责老生区中的垃圾回收。除了新生区中晋升的对象，一些大的对象会直接被分配到老生区。因此老生区中的对象有两个特点，一个是对象占用空间大，另一个是对象存活时间长。</li>
<li>由于老生区的对象比较大，若要在老生区中使用 Scavenge 算法进行垃圾回收，复制这些大的对象将会花费比较多的时间，从而导致回收执行效率不高，同时还会浪费一半的空间。因而，主垃圾回收器是采用标记 - 清除（Mark-Sweep）的算法进行垃圾回收的。</li>
<li><p>首先是标记过程阶段。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function foo()&#123;</span><br><span class="line">    var a = 1</span><br><span class="line">    var b = &#123;name:&quot;diamond&quot;&#125;  堆地址：  1050</span><br><span class="line">    function showName()&#123;</span><br><span class="line">      var c = 2</span><br><span class="line">      var d = &#123;name:&quot;diamonds&quot;&#125; 堆地址：   1003</span><br><span class="line">    &#125;</span><br><span class="line">    showName()</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">当 showName 函数执行结束之后，ESP 向下移动，指向了 foo 函数的执行上下文，这时候如果遍历调用栈，是不会找到引用 1003 地址的变量，也就意味着 1003 这块数据为垃圾数据，被标记为红色。</span><br><span class="line">由于 1050 这块数据被变量 b 引用了，所以这块数据会被标记为活动对象。这就是大致的标记过程。</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来就是垃圾的清除过程。它和副垃圾回收器的垃圾清除过程完全不同</p>
</li>
<li>对一块内存多次执行标记 - 清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存，于是又产生了另外一种算法——标记 - 整理（Mark-Compact），这个标记过程仍然与标记 - 清除算法里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。<h3 id="全停顿"><a href="#全停顿" class="headerlink" title="全停顿"></a>全停顿</h3></li>
<li>由于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做全停顿（Stop-The-World）。</li>
<li>比如堆中的数据有 1.5GB，V8 实现一次完整的垃圾回收需要 1 秒以上的时间，这也是由于垃圾回收而引起 JavaScript 线程暂停执行的时间，若是这样的时间花销，那么应用的性能和响应能力都会直线下降。</li>
<li>在 V8 新生代的垃圾回收中，因其空间较小，且存活对象较少，所以全停顿的影响不大</li>
<li>老生代就不一样了。如果在执行垃圾回收的过程中，占用主线程时间过久，主线程是不能做其他事情的。比如页面正在执行一个 JavaScript 动画，因为垃圾回收器在工作，就会导致这个动画在这 200 毫秒内无法执行的，这将会造成页面的卡顿现象。</li>
<li>为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为增量标记（Incremental Marking）算法</li>
<li>使用增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的 JavaScript 任务中间执行，这样当执行上述动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了。<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3></li>
<li>无论是垃圾回收的策略，还是处理全停顿的策略，往往都没有一个完美的解决方案，你需要花一些时间来做权衡，而这需要牺牲当前某几方面的指标来换取其他几个指标的提升。</li>
<li>其实站在工程师的视角，我们经常需要在满足需求的前提下，权衡各个指标的得失，把系统设计得尽可能适应最核心的需求。</li>
<li>生活中处理事情的原则也与之类似，古人很早就说过“两害相权取其轻，两利相权取其重”，所以与其患得患失，不如冷静地分析哪些才是核心诉求，然后果断决策牺牲哪些以使得利益最大化。</li>
</ul>
<h2 id="编译器和解释器：V8是如何执行一段JavaScript代码的？"><a href="#编译器和解释器：V8是如何执行一段JavaScript代码的？" class="headerlink" title="编译器和解释器：V8是如何执行一段JavaScript代码的？"></a>编译器和解释器：V8是如何执行一段JavaScript代码的？</h2><ul>
<li>要深入理解 V8 的工作原理，你需要搞清楚一些概念和原理，比如编译器（Compiler）、解释器（Interpreter）、抽象语法树（AST）、字节码（Bytecode）、即时编译器（JIT）等概念<h3 id="编译器和解释器"><a href="#编译器和解释器" class="headerlink" title="编译器和解释器"></a>编译器和解释器</h3></li>
<li>之所以存在编译器和解释器，是因为机器不能直接理解我们所写的代码，所以在执行程序之前，需要将我们所写的代码“翻译”成机器能读懂的机器语言。</li>
<li>按语言的执行流程，可以把语言划分为编译型语言和解释型语言。</li>
<li>编译型语言在程序执行之前，需要经过编译器的编译过程，并且编译之后会直接保留机器能读懂的二进制文件，这样每次运行程序时，都可以直接运行该二进制文件，而不需要再次重新编译了。比如 C/C++、GO 等都是编译型语言。</li>
<li>解释型语言编写的程序，在每次运行时都需要通过解释器对程序进行动态解释和执行。比如 Python、JavaScript 等都属于解释型语言。</li>
<li>在编译型语言的编译过程中，编译器首先会依次对源代码进行词法分析、语法分析，生成抽象语法树（AST），然后是优化代码，最后再生成处理器能够理解的机器码。如果编译成功，将会生成一个可执行的文件。但如果编译过程发生了语法或者其他的错误，那么编译器就会抛出异常，最后的二进制文件也不会生成成功。</li>
<li>在解释型语言的解释过程中，同样解释器也会对源代码进行词法分析、语法分析，并生成抽象语法树（AST），不过它会再基于抽象语法树生成字节码，最后再根据字节码来执行程序、输出结果。<h3 id="V8-是如何执行一段-JavaScript-代码的"><a href="#V8-是如何执行一段-JavaScript-代码的" class="headerlink" title="V8 是如何执行一段 JavaScript 代码的"></a>V8 是如何执行一段 JavaScript 代码的</h3></li>
<li>V8 在执行过程中既有解释器 Ignition，又有编译器 TurboFan<h4 id="生成抽象语法树（AST）和执行上下文"><a href="#生成抽象语法树（AST）和执行上下文" class="headerlink" title="生成抽象语法树（AST）和执行上下文"></a>生成抽象语法树（AST）和执行上下文</h4></li>
<li>将源代码转换为抽象语法树，并生成执行上下文</li>
<li>高级语言是开发者可以理解的语言，但是让编译器或者解释器来理解就非常困难了。</li>
<li>对于编译器或者解释器来说，它们可以理解的就是 AST 了。所以无论你使用的是解释型语言还是编译型语言，在编译过程中，它们都会生成一个 AST。这和渲染引擎将 HTML 格式文件转换为计算机可以理解的 DOM 树的情况类似。</li>
<li>AST 的结构和代码的结构非常相似，其实你也可以把 AST 看成代码的结构化的表示，编译器或者解释器后续的工作都需要依赖于 AST，而不是源代码。</li>
<li>AST 是非常重要的一种数据结构，在很多项目中有着广泛的应用。其中最著名的一个项目是 Babel。</li>
<li>Babel 是一个被广泛使用的代码转码器，可以将 ES6 代码转为 ES5 代码，这意味着你可以现在就用 ES6 编写程序，而不用担心现有环境是否支持 ES6。Babel 的工作原理就是先将 ES6 源码转换为 AST，然后再将 ES6 语法的 AST 转换为 ES5 语法的 AST，最后利用 ES5 的 AST 生成 JavaScript 源代码。</li>
<li>除了 Babel 外，还有 ESLint 也使用 AST。ESLint 是一个用来检查 JavaScript 编写规范的插件，其检测流程也是需要将源码转换为 AST，然后再利用 AST 来检查代码规范化的问题。</li>
<li>通常，生成 AST 需要经过两个阶段。</li>
</ul>
<ol>
<li><p>第一阶段是分词（tokenize），又称为词法分析，其作用是将一行行的源码拆解成一个个 token。所谓 token，指的是语法上不可能再分的、最小的单个字符或字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var myName = “diamond”</span><br><span class="line"></span><br><span class="line">通过var myName = “diamond”简单地定义了一个变量，</span><br><span class="line">其中关键字“var”、标识符“myName” 、赋值运算符“=”、字符串“极客时间”四个都是 token，而且它们代表的属性还不一样。</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二阶段是解析（parse），又称为语法分析，其作用是将上一步生成的 token 数据，根据语法规则转为 AST。如果源码符合语法规则，这一步就会顺利完成。但如果源码存在语法错误，这一步就会终止，并抛出一个“语法错误”。</p>
</li>
<li>这就是 AST 的生成过程，先分词，再解析。有了 AST 后，那接下来 V8 就会生成该段代码的执行上下文。<h4 id="生成字节码"><a href="#生成字节码" class="headerlink" title="生成字节码"></a>生成字节码</h4></li>
</ol>
<ul>
<li>有了 AST 和执行上下文后，那接下来的第二步，解释器 Ignition 就登场了，它会根据 AST 生成字节码，并解释执行字节码。</li>
<li>其实一开始 V8 并没有字节码，而是直接将 AST 转换为机器码，由于执行机器码的效率是非常高效的，所以这种方式在发布后的一段时间内运行效果是非常好的。但是随着 Chrome 在手机上的广泛普及，特别是运行在 512M 内存的手机上，内存占用问题也暴露出来了，因为 V8 需要消耗大量的内存来存放转换后的机器码。</li>
<li>为了解决内存占用问题，V8 团队大幅重构了引擎架构，引入字节码，并且抛弃了之前的编译器，最终花了将进四年的时间，实现了现在的这套架构。</li>
<li>字节码就是介于 AST 和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行。机器码所占用的空间远远超过了字节码，所以使用字节码可以减少系统的内存使用。<h4 id="执行代码"><a href="#执行代码" class="headerlink" title="执行代码"></a>执行代码</h4></li>
<li>生成字节码之后，接下来就要进入执行阶段了。</li>
<li>解释器 Ignition 除了负责生成字节码之外，它还有另外一个作用，就是解释执行字节码。</li>
<li>在 Ignition 执行字节码的过程中，如果发现有热点代码（HotSpot），比如一段代码被重复执行多次，这种就称为热点代码，那么后台的编译器 TurboFan 就会把该段热点的字节码编译为高效的机器码，然后当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了，这样就大大提升了代码的执行效率。</li>
<li>字节码配合解释器和编译器是最近一段时间很火的技术，比如 Java 和 Python 的虚拟机也都是基于这种技术实现的，我们把这种技术称为即时编译（JIT）。具体到 V8，就是指解释器 Ignition 在解释执行字节码的同时，收集代码信息，当它发现某一部分代码变热了之后，TurboFan 编译器便闪亮登场，把热点的字节码转换为机器码，并把转换后的机器码保存起来，以备下次使用。<h3 id="JavaScript-的性能优化"><a href="#JavaScript-的性能优化" class="headerlink" title="JavaScript 的性能优化"></a>JavaScript 的性能优化</h3></li>
<li>对于优化 JavaScript 执行效率，你应该将优化的中心聚焦在单次脚本的执行时间和脚本的网络下载上，主要关注以下三点内容：</li>
</ul>
<ol>
<li>提升单次脚本的执行速度，避免 JavaScript 的长任务霸占主线程，这样可以使得页面快速响应交互；</li>
<li>避免大的内联脚本，因为在解析 HTML 的过程中，解析和编译也会占用主线程；</li>
<li>减少 JavaScript 文件的容量，因为更小的文件会提升下载速度，并且占用更低的内存。</li>
</ol>
<h2 id="消息队列和事件循环：页面是怎么“活”起来的？"><a href="#消息队列和事件循环：页面是怎么“活”起来的？" class="headerlink" title="消息队列和事件循环：页面是怎么“活”起来的？"></a>消息队列和事件循环：页面是怎么“活”起来的？</h2><ul>
<li>主线程非常繁忙，既要处理 DOM，又要计算样式，还要处理布局，同时还需要处理 JavaScript 任务以及各种输入事件。要让这么多不同类型的任务在主线程中有条不紊地执行，这就需要一个系统来统筹调度这些任务，这个统筹调度系统就是我们今天要讲的消息队列和事件循环系统。</li>
<li>消息队列中的任务类型：如输入事件（鼠标滚动、点击、移动）、微任务、文件读写、WebSocket、JavaScript 定时器等等。除此之外，消息队列中还包含了很多与页面相关的事件，如 JavaScript 执行、解析 DOM、样式计算、布局计算、CSS 动画等。以上这些事件都是在主线程中执行的，所以在编写 Web 应用时，你还需要衡量这些事件所占用的时长，并想办法解决单个任务占用主线程过久的问题。</li>
<li>如何安全退出？确定要退出当前页面时，页面主线程会设置一个退出标志的变量，在每次执行完一个任务时，判断是否有设置退出标志。如果设置了，那么就直接中断当前的所有任务，退出线程</li>
<li>通常我们把消息队列中的任务称为宏任务，每个宏任务中都包含了一个微任务队列，在执行宏任务的过程中，如果 DOM 有变化，那么就会将该变化添加到微任务列表中，这样就不会影响到宏任务的继续执行，因此也就解决了执行效率的问题。</li>
<li>等宏任务中的主要功能都直接完成之后，这时候，渲染引擎并不着急去执行下一个宏任务，而是执行当前宏任务中的微任务，因为 DOM 变化的事件都保存在这些微任务队列中，这样也就解决了实时性问题。<h2 id="WebAPI：setTimeout是如何实现的？"><a href="#WebAPI：setTimeout是如何实现的？" class="headerlink" title="WebAPI：setTimeout是如何实现的？"></a>WebAPI：setTimeout是如何实现的？</h2></li>
<li>定时器，用来指定某个函数在多少毫秒之后执行。它会返回一个整数，表示定时器的编号，同时你还可以通过该编号来取消这个定时器。<h3 id="浏览器怎么实现-setTimeout"><a href="#浏览器怎么实现-setTimeout" class="headerlink" title="浏览器怎么实现 setTimeout"></a>浏览器怎么实现 setTimeout</h3></li>
<li>渲染进程中所有运行在主线程上的任务都需要先添加到消息队列，然后事件循环系统再按照顺序执行消息队列中的任务。下面我们来看看那些典型的事件：</li>
</ul>
<ol>
<li>当接收到 HTML 文档数据，渲染引擎就会将“解析 DOM”事件添加到消息队列中，</li>
<li>当用户改变了 Web 页面的窗口大小，渲染引擎就会将“重新布局”的事件添加到消息队列中。</li>
<li>当触发了 JavaScript 引擎垃圾回收机制，渲染引擎会将“垃圾回收”任务添加到消息队列中。</li>
<li>同样，如果要执行一段异步 JavaScript 代码，也是需要将执行任务添加到消息队列中。</li>
</ol>
<ul>
<li>在 Chrome 中除了正常使用的消息队列之外，还有另外一个消息队列（其实是一个hashmap结构，等到执行这个结构的时候，会计算hashmap中的每个任务是否到期了，到期了就去执行，直到所有到期的任务都执行结束，才会进入下一轮循环！），这个队列中维护了需要延迟执行的任务列表，包括了定时器和 Chromium 内部一些需要延迟执行的任务。所以当通过 JavaScript 创建一个定时器时，渲染进程会将该定时器的回调任务添加到延迟队列中。</li>
<li>浏览器内部实现取消定时器的操作也是非常简单的，就是直接从延迟队列中，通过 ID 查找到对应的任务，然后再将其从队列中删除掉就可以了。</li>
<li>使用 setTimeout 的一些注意事项</li>
</ul>
<ol>
<li>如果当前任务执行时间过久，会影响定时器任务的执行</li>
<li>如果 setTimeout 存在嵌套调用，那么系统会设置最短时间间隔为 4 毫秒。在 Chrome 中，定时器被嵌套调用 5 次以上，系统会判断该函数方法被阻塞了，如果定时器的调用时间间隔小于 4 毫秒，那么浏览器会将每次调用的时间间隔设置为 4 毫秒。所以，一些实时性较高的需求就不太适合使用 setTimeout 了，比如你用 setTimeout 来实现 JavaScript 动画就不是一个很好的主意。</li>
<li>未激活的页面，setTimeout 执行最小间隔是 1000 毫秒，目的是为了优化后台页面的加载损耗以及降低耗电量。</li>
<li>延时执行时间有最大值。Chrome、Safari、Firefox 都是以 32 个 bit 来存储延时值的，32bit 最大只能存放的数字是 2147483647 毫秒，这就意味着，如果 setTimeout 设置的延迟值大于 2147483647 毫秒（大约 24.8 天）时就会溢出，那么相当于延时值被设置为 0 了，这导致定时器会被立即执行。</li>
<li>使用 setTimeout 设置的回调函数中的 this 不符合直觉。如果被 setTimeout 推迟执行的回调函数是某个对象的方法，那么该方法中的 this 关键字将指向全局环境，而不是定义时所在的那个对象。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var name= 1;</span><br><span class="line">var MyObj = &#123;</span><br><span class="line">  name: 2,</span><br><span class="line">  showName: function()&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(MyObj.showName,1000)</span><br><span class="line">这里输出的是 1，因为这段代码在编译的时候，执行上下文中的 this 会被设置为全局 window，如果是严格模式，会被设置为 undefined。</span><br><span class="line">那么该怎么解决这个问题呢？通常可以使用下面这两种方法。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//箭头函数</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    MyObj.showName()</span><br><span class="line">&#125;, 1000);</span><br><span class="line">//或者function函数</span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">  MyObj.showName();</span><br><span class="line">&#125;, 1000)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">setTimeout(MyObj.showName.bind(MyObj), 1000)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="WebAPI：XMLHttpRequest是怎么实现的？"><a href="#WebAPI：XMLHttpRequest是怎么实现的？" class="headerlink" title="WebAPI：XMLHttpRequest是怎么实现的？"></a>WebAPI：XMLHttpRequest是怎么实现的？</h2><h3 id="回调函数-VS-系统调用栈"><a href="#回调函数-VS-系统调用栈" class="headerlink" title="回调函数 VS 系统调用栈"></a>回调函数 VS 系统调用栈</h3><ul>
<li><p>将一个函数作为参数传递给另外一个函数，那作为参数的这个函数就是回调函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">let callback = function()&#123;</span><br><span class="line">    console.log(&apos;i am do homework&apos;)</span><br><span class="line">&#125;</span><br><span class="line">function doWork(cb) &#123;</span><br><span class="line">    console.log(&apos;start do work&apos;)</span><br><span class="line">    cb()</span><br><span class="line">    console.log(&apos;end do work&apos;)</span><br><span class="line">&#125;</span><br><span class="line">doWork(callback)</span><br><span class="line"></span><br><span class="line">上面的回调方法有个特点，就是回调函数 callback 是在主函数 doWork 返回之前执行的，我们把这个回调过程称为同步回调。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let callback = function()&#123;</span><br><span class="line">    console.log(&apos;i am do homework&apos;)</span><br><span class="line">&#125;</span><br><span class="line">function doWork(cb) &#123;</span><br><span class="line">    console.log(&apos;start do work&apos;)</span><br><span class="line">    setTimeout(cb,1000)   </span><br><span class="line">    console.log(&apos;end do work&apos;)</span><br><span class="line">&#125;</span><br><span class="line">doWork(callback)</span><br><span class="line"></span><br><span class="line">在这个例子中，我们使用了 setTimeout 函数让 callback 在 doWork 函数执行结束后，又延时了 1 秒再执行，</span><br><span class="line">这次 callback 并没有在主函数 doWork 内部被调用，我们把这种回调函数在主函数外部执行的过程称为异步回调。</span><br></pre></td></tr></table></figure>
</li>
<li><p>消息队列和主线程循环机制保证了页面有条不紊地运行。那就是当循环系统在执行一个任务的时候，都要为这个任务维护一个系统调用栈。这个系统调用栈类似于 JavaScript 的调用栈，只不过系统调用栈是 Chromium 的开发语言 C++ 来维护的</p>
<h3 id="XMLHttpRequest-运作机制"><a href="#XMLHttpRequest-运作机制" class="headerlink" title="XMLHttpRequest 运作机制"></a>XMLHttpRequest 运作机制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"> function GetWebData(URL)&#123;</span><br><span class="line">    /**</span><br><span class="line">     * 1:新建XMLHttpRequest请求对象</span><br><span class="line">     */</span><br><span class="line">    let xhr = new XMLHttpRequest()</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 2:注册相关事件回调处理函数 </span><br><span class="line">     */</span><br><span class="line">    xhr.onreadystatechange = function () &#123;</span><br><span class="line">        switch(xhr.readyState)&#123;</span><br><span class="line">          case 0: //请求未初始化</span><br><span class="line">            console.log(&quot;请求未初始化&quot;)</span><br><span class="line">            break;</span><br><span class="line">          case 1://OPENED</span><br><span class="line">            console.log(&quot;OPENED&quot;)</span><br><span class="line">            break;</span><br><span class="line">          case 2://HEADERS_RECEIVED</span><br><span class="line">            console.log(&quot;HEADERS_RECEIVED&quot;)</span><br><span class="line">            break;</span><br><span class="line">          case 3://LOADING  </span><br><span class="line">            console.log(&quot;LOADING&quot;)</span><br><span class="line">            break;</span><br><span class="line">          case 4://DONE</span><br><span class="line">            if(this.status == 200||this.status == 304)&#123;</span><br><span class="line">                console.log(this.responseText);</span><br><span class="line">                &#125;</span><br><span class="line">            console.log(&quot;DONE&quot;)</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    xhr.ontimeout = function(e) &#123; console.log(&apos;ontimeout&apos;) &#125;</span><br><span class="line">    xhr.onerror = function(e) &#123; console.log(&apos;onerror&apos;) &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 3:打开请求</span><br><span class="line">     */</span><br><span class="line">    xhr.open(&apos;Get&apos;, URL, true);//创建一个Get请求,采用异步</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 4:配置参数</span><br><span class="line">     */</span><br><span class="line">    xhr.timeout = 3000 //设置xhr请求的超时时间</span><br><span class="line">    xhr.responseType = &quot;text&quot; //设置响应返回的数据格式</span><br><span class="line">    xhr.setRequestHeader(&quot;X_TEST&quot;,&quot;time.geekbang&quot;)</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 5:发送请求</span><br><span class="line">     */</span><br><span class="line">    xhr.send();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>渲染进程会将请求发送给网络进程，然后网络进程负责资源的下载，等网络进程接收到数据之后，就会利用 IPC 来通知渲染进程；渲染进程接收到消息之后，会将 xhr 的回调函数封装成任务并添加到消息队列中，等主线程循环系统执行到该任务的时候，就会根据相关的状态来调用对应的回调函数。</p>
<h3 id="XMLHttpRequest-使用过程中的“坑”"><a href="#XMLHttpRequest-使用过程中的“坑”" class="headerlink" title="XMLHttpRequest 使用过程中的“坑”"></a>XMLHttpRequest 使用过程中的“坑”</h3></li>
<li>跨域问题</li>
<li>HTTPS 混合内容的问题</li>
</ul>
<ol>
<li>HTTPS 混合内容是 HTTPS 页面中包含了不符合 HTTPS 安全要求的内容，比如包含了 HTTP 资源，通过 HTTP 加载的图像、视频、样式表、脚本等，都属于混合内容。</li>
<li>通过 HTML 文件加载的混合资源，虽然给出警告，但大部分类型还是能加载的。而使用 XMLHttpRequest 请求时，浏览器认为这种请求可能是攻击者发起的，会阻止此类危险的请求。</li>
</ol>
<h2 id="宏任务和微任务：不是所有任务都是一个待遇"><a href="#宏任务和微任务：不是所有任务都是一个待遇" class="headerlink" title="宏任务和微任务：不是所有任务都是一个待遇"></a>宏任务和微任务：不是所有任务都是一个待遇</h2><h3 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h3><ul>
<li>页面中的大部分任务都是在主线程上执行的，这些任务包括了：</li>
</ul>
<ol>
<li>渲染事件（如解析 DOM、计算布局、绘制）；</li>
<li>用户交互事件（如鼠标点击、滚动页面、放大缩小等）；</li>
<li>JavaScript 脚本执行事件；</li>
<li>网络请求完成、文件读写完成事件。</li>
</ol>
<ul>
<li>为了协调这些任务有条不紊地在主线程上执行，页面进程引入了消息队列和事件循环机制，渲染进程内部会维护多个消息队列，比如延迟执行队列和普通的消息队列。</li>
<li>然后主线程采用一个 for 循环，不断地从这些任务队列中取出任务并执行任务。我们把这些消息队列中的任务称为宏任务。</li>
<li>页面的渲染事件、各种 IO 的完成事件、执行 JavaScript 脚本的事件、用户交互的事件等都随时有可能被添加到消息队列中，而且添加事件是由系统操作的，JavaScript 代码不能准确掌控任务要添加到队列中的位置，控制不了任务在消息队列中的位置，所以很难控制开始执行任务的时间。</li>
<li>宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合了，比如后面要介绍的监听 DOM 变化的需求。<h3 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h3></li>
<li>异步回调的概念，其主要有两种方式</li>
</ul>
<ol>
<li>第一种是把异步回调函数封装成一个宏任务，添加到消息队列尾部，当循环系统执行到该任务的时候执行回调函数。这种比较好理解，我们前面介绍的 setTimeout 和 XMLHttpRequest 的回调函数都是通过这种方式来实现的。</li>
<li>第二种方式的执行时机是在主函数执行结束之后、当前宏任务结束之前执行回调函数，这通常都是以微任务形式体现的。</li>
</ol>
<ul>
<li>微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。</li>
<li>当 JavaScript 执行一段脚本的时候，V8 会为其创建一个全局执行上下文，在创建全局执行上下文的同时，V8 引擎也会在内部创建一个微任务队列。顾名思义，这个微任务队列就是用来存放微任务的，因为在当前宏任务执行的过程中，有时候会产生多个微任务，这时候就需要使用这个微任务队列来保存这些微任务了。不过这个微任务队列是给 V8 引擎内部使用的，所以你是无法通过 JavaScript 直接访问的。</li>
<li>在现代浏览器里面，产生微任务有两种方式。</li>
</ul>
<ol>
<li>第一种方式是使用 MutationObserver 监控某个 DOM 节点，然后再通过 JavaScript 来修改这个节点，或者为这个节点添加、删除部分子节点，当 DOM 节点发生变化时，就会产生 DOM 变化记录的微任务。</li>
<li>第二种方式是使用 Promise，当调用 Promise.resolve() 或者 Promise.reject() 的时候，也会产生微任务。</li>
</ol>
<ul>
<li>通常情况下，在当前宏任务中的 JavaScript 快执行完成时，也就在 JavaScript 引擎准备退出全局执行上下文并清空调用栈的时候，JavaScript 引擎会检查全局执行上下文中的微任务队列，然后按照顺序执行队列中的微任务。WHATWG 把执行微任务的时间点称为检查点。当然除了在退出全局执行上下文式这个检查点之外，还有其他的检查点。</li>
<li>如果在执行微任务的过程中，产生了新的微任务，同样会将该微任务添加到微任务队列中，V8 引擎一直循环执行微任务队列中的任务，直到队列为空才算执行结束。也就是说在执行微任务过程中产生的新的微任务并不会推迟到下个宏任务中执行，而是在当前的宏任务中继续执行。<h3 id="监听-DOM-变化方法演变"><a href="#监听-DOM-变化方法演变" class="headerlink" title="监听 DOM 变化方法演变"></a>监听 DOM 变化方法演变</h3></li>
<li>早期页面并没有提供对监听的支持，所以那时要观察 DOM 是否变化，唯一能做的就是轮询检测，比如使用 setTimeout 或者 setInterval 来定时检测 DOM 是否有改变。这种方式简单粗暴，但是会遇到两个问题：如果时间间隔设置过长，DOM 变化响应不够及时；反过来如果时间间隔设置过短，又会浪费很多无用的工作量去检查 DOM，会让页面变得低效。</li>
<li>直到 2000 年的时候引入了 Mutation Event，Mutation Event 采用了观察者的设计模式，当 DOM 有变动时就会立刻触发相应的事件，这种方式属于同步回调。</li>
<li>采用 Mutation Event 解决了实时性的问题，因为 DOM 一旦发生变化，就会立即调用 JavaScript 接口。但也正是这种实时性造成了严重的性能问题，因为每次 DOM 变动，渲染引擎都会去调用 JavaScript，这样会产生较大的性能开销。</li>
<li>为了解决了 Mutation Event 由于同步调用 JavaScript 而造成的性能问题，从 DOM4 开始，推荐使用 MutationObserver 来代替 Mutation Event。MutationObserver API 可以用来监视 DOM 的变化，包括属性的变化、节点的增减、内容的变化等。</li>
</ul>
<ol>
<li>MutationObserver 将响应函数改成异步调用，可以不用在每次 DOM 变化都触发异步调用，而是等多次 DOM 变化后，一次触发异步调用，并且还会使用一个数据结构来记录这期间所有的 DOM 变化。这样即使频繁地操纵 DOM，也不会对性能造成太大的影响。</li>
<li>在每次 DOM 节点发生变化的时候，渲染引擎将变化记录封装成微任务，并将微任务添加进当前的微任务队列中。这样当执行到检查点的时候，V8 引擎就会按照顺序执行微任务了。</li>
<li>综上所述， MutationObserver 采用了“异步 + 微任务”的策略。通过异步操作解决了同步操作的性能问题；通过微任务解决了实时性的问题。</li>
</ol>
<h2 id="async-await：使用同步的方式去写异步代码"><a href="#async-await：使用同步的方式去写异步代码" class="headerlink" title="async/await：使用同步的方式去写异步代码"></a>async/await：使用同步的方式去写异步代码</h2><ul>
<li>ES7 引入了 async/await，这是 JavaScript 异步编程的一个重大改进，提供了在不阻塞主线程的情况下使用同步代码实现异步访问资源的能力，并且使得代码逻辑更加清晰。</li>
<li>async 是一个通过异步执行并隐式返回 Promise 作为结果的函数。</li>
</ul>
<h3 id="生成器-VS-协程"><a href="#生成器-VS-协程" class="headerlink" title="生成器 VS 协程"></a>生成器 VS 协程</h3><ul>
<li><p>生成器函数是一个带星号函数，而且是可以暂停执行和恢复执行的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function* genDemo() &#123;</span><br><span class="line">    console.log(&quot;开始执行第一段&quot;)</span><br><span class="line">    yield &apos;generator 2&apos;</span><br><span class="line"></span><br><span class="line">    console.log(&quot;开始执行第二段&quot;)</span><br><span class="line">    yield &apos;generator 2&apos;</span><br><span class="line"></span><br><span class="line">    console.log(&quot;开始执行第三段&quot;)</span><br><span class="line">    yield &apos;generator 2&apos;</span><br><span class="line"></span><br><span class="line">    console.log(&quot;执行结束&quot;)</span><br><span class="line">    return &apos;generator 2&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(&apos;main 0&apos;)</span><br><span class="line">let gen = genDemo()</span><br><span class="line">console.log(gen.next().value)</span><br><span class="line">console.log(&apos;main 1&apos;)</span><br><span class="line">console.log(gen.next().value)</span><br><span class="line">console.log(&apos;main 2&apos;)</span><br><span class="line">console.log(gen.next().value)</span><br><span class="line">console.log(&apos;main 3&apos;)</span><br><span class="line">console.log(gen.next().value)</span><br><span class="line">console.log(&apos;main 4&apos;)</span><br><span class="line">执行上面这段代码，观察输出结果，你会发现函数 genDemo 并不是一次执行完的，全局代码和 genDemo 函数交替执行。其实这就是生成器函数的特性，可以暂停执行，也可以恢复执行。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">可以看出来协程的四点规则：</span><br><span class="line">1.通过调用生成器函数 genDemo 来创建一个协程 gen，创建之后，gen 协程并没有立即执行。</span><br><span class="line">2.要让 gen 协程执行，需要通过调用 gen.next。</span><br><span class="line">3.当协程正在执行的时候，可以通过 yield 关键字来暂停 gen 协程的执行，并返回主要信息给父协程。</span><br><span class="line">4.如果协程在执行期间，遇到了 return 关键字，那么 JavaScript 引擎会结束当前协程，并将 return 后面的内容返回给父协程。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gen 协程和父协程是在主线程上交互执行的，并不是并发执行的，它们之前的切换是通过 yield 和 gen.next 来配合完成的。</span><br><span class="line">当在 gen 协程中调用了 yield 方法时，JavaScript 引擎会保存 gen 协程当前的调用栈信息，并恢复父协程的调用栈信息。同样，当在父协程中执行 gen.next 时，JavaScript 引擎会保存父协程的调用栈信息，并恢复 gen 协程的调用栈信息。</span><br></pre></td></tr></table></figure>
</li>
<li><p>一个线程上可以存在多个协程，但是在线程上同时只能执行一个协程，比如当前执行的是 A 协程，要启动 B 协程，那么 A 协程就需要将主线程的控制权交给 B 协程，这就体现在 A 协程暂停执行，B 协程恢复执行；同样，也可以从 B 协程中启动 A 协程。通常，如果从 A 协程启动 B 协程，我们就把 A 协程称为 B 协程的父协程。</p>
</li>
<li><p>正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。最重要的是，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">//foo函数</span><br><span class="line">function* foo() &#123;</span><br><span class="line">    let response1 = yield fetch(&apos;https://www.geekbang.org&apos;)</span><br><span class="line">    console.log(&apos;response1&apos;)</span><br><span class="line">    console.log(response1)</span><br><span class="line">    let response2 = yield fetch(&apos;https://www.geekbang.org/test&apos;)</span><br><span class="line">    console.log(&apos;response2&apos;)</span><br><span class="line">    console.log(response2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//执行foo函数的代码</span><br><span class="line">let gen = foo()</span><br><span class="line">function getGenPromise(gen) &#123;</span><br><span class="line">    return gen.next().value</span><br><span class="line">&#125;</span><br><span class="line">getGenPromise(gen).then((response) =&gt; &#123;</span><br><span class="line">    console.log(&apos;response1&apos;)</span><br><span class="line">    console.log(response)</span><br><span class="line">    return getGenPromise(gen)</span><br><span class="line">&#125;).then((response) =&gt; &#123;</span><br><span class="line">    console.log(&apos;response2&apos;)</span><br><span class="line">    console.log(response)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">面我们就来分析下这段代码是如何工作的。</span><br><span class="line">1.首先执行的是let gen = foo()，创建了 gen 协程。</span><br><span class="line">2.然后在父协程中通过执行 gen.next 把主线程的控制权交给 gen 协程。</span><br><span class="line">3.gen 协程获取到主线程的控制权后，就调用 fetch 函数创建了一个 Promise 对象 response1，然后通过 yield 暂停 gen 协程的执行，并将 response1 返回给父协程。</span><br><span class="line">4.父协程恢复执行后，调用 response1.then 方法等待请求结果。</span><br><span class="line">5.等通过 fetch 发起的请求完成之后，会调用 then 中的回调函数，then 中的回调函数拿到结果之后，通过调用 gen.next 放弃主线程的控制权，将控制权交 gen 协程继续执行下个请求。</span><br></pre></td></tr></table></figure>
</li>
<li><p>通常，我们把执行生成器的代码封装成一个函数，并把这个执行生成器代码的函数称为执行器（可参考著名的 co 框架），如下面这种方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">function* foo() &#123;</span><br><span class="line">    let response1 = yield fetch(&apos;https://www.geekbang.org&apos;)</span><br><span class="line">    console.log(&apos;response1&apos;)</span><br><span class="line">    console.log(response1)</span><br><span class="line">    let response2 = yield fetch(&apos;https://www.geekbang.org/test&apos;)</span><br><span class="line">    console.log(&apos;response2&apos;)</span><br><span class="line">    console.log(response2)</span><br><span class="line">&#125;</span><br><span class="line">co(foo());</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Chrome开发者工具：利用网络面板做性能分析"><a href="#Chrome开发者工具：利用网络面板做性能分析" class="headerlink" title="Chrome开发者工具：利用网络面板做性能分析"></a>Chrome开发者工具：利用网络面板做性能分析</h2><h3 id="单个资源的时间线"><a href="#单个资源的时间线" class="headerlink" title="单个资源的时间线"></a>单个资源的时间线</h3><ul>
<li>我们介绍过发起一个 HTTP 请求之后，浏览器首先查找缓存，如果缓存没有命中，那么继续发起 DNS 请求获取 IP 地址，然后利用 IP 地址和服务器端建立 TCP 连接，再发送 HTTP 请求，等待服务器响应；不过，如果服务器响应头中包含了重定向的信息，那么整个流程就需要重新再走一遍。这就是在浏览器中一个 HTTP 请求的基础流程。</li>
<li>当浏览器发起一个请求的时候，会有很多原因导致该请求不能被立即执行，而是需要排队等待。导致请求处于排队状态的原因有很多。</li>
</ul>
<ol>
<li>首先，页面中的资源是有优先级的，比如 CSS、HTML、JavaScript 等都是页面中的核心文件，所以优先级最高；而图片、视频、音频这类资源就不是核心资源，优先级就比较低。通常当后者遇到前者时，就需要“让路”，进入待排队状态。</li>
<li>其次，我们前面也提到过，浏览器会为每个域名最多维护 6 个 TCP 连接，如果发起一个 HTTP 请求时，这 6 个 TCP 连接都处于忙碌状态，那么这个请求就会处于排队状态</li>
<li>最后，网络进程在为数据分配磁盘空间时，新的 HTTP 请求也需要短暂地等待磁盘分配结束。</li>
</ol>
<ul>
<li>等待排队完成之后，就要进入发起连接的状态了。不过在发起连接之前，还有一些原因可能导致连接过程被推迟，这个推迟就表现在面板中的 Stalled 上，它表示停滞的意思。</li>
<li>这里需要额外说明的是，如果你使用了代理服务器，还会增加一个 Proxy Negotiation 阶段，也就是代理协商阶段，它表示代理服务器连接协商所用的时间。</li>
<li>接下来，就到了 Initial connection/SSL 阶段了，也就是和服务器建立连接的阶段，这包括了建立 TCP 连接所花费的时间；不过如果你使用了 HTTPS 协议，那么还需要一个额外的 SSL 握手时间，这个过程主要是用来协商一些加密信息的。</li>
<li>和服务器建立好连接之后，网络进程会准备请求数据，并将其发送给网络，这就是 Request sent 阶段。通常这个阶段非常快，因为只需要把浏览器缓冲区的数据发送出去就结束了，并不需要判断服务器是否接收到了，所以这个时间通常不到 1 毫秒。</li>
<li>数据发送出去了，接下来就是等待接收服务器第一个字节的数据，这个阶段称为 Waiting (TTFB)，通常也称为“第一字节时间”。 TTFB 是反映服务端响应速度的重要指标，对服务器来说，TTFB 时间越短，就说明服务器响应越快。</li>
<li>接收到第一个字节之后，进入陆续接收完整数据的阶段，也就是 Content Download 阶段，这意味着从第一字节时间到接收到全部响应数据所用的时间。<h3 id="优化时间线上耗时项"><a href="#优化时间线上耗时项" class="headerlink" title="优化时间线上耗时项"></a>优化时间线上耗时项</h3></li>
<li>排队（Queuing）时间过久</li>
</ul>
<ol>
<li>排队时间过久，大概率是由浏览器为每个域名最多维护 6 个连接导致的。那么基于这个原因，你就可以让 1 个站点下面的资源放在多个域名下面，比如放到 3 个域名下面，这样就可以同时支持 18 个连接了，这种方案称为域名分片技术。</li>
<li>还可以把站点升级到 HTTP2，因为 HTTP2 已经没有每个域名最多维护 6 个 TCP 连接的限制了。</li>
</ol>
<ul>
<li>第一字节时间（TTFB）时间过久，这可能的原因有如下：</li>
</ul>
<ol>
<li>服务器生成页面数据的时间过久。对于动态网页来说，服务器收到用户打开一个页面的请求时，首先要从数据库中读取该页面需要的数据，然后把这些数据传入到模板中，模板渲染后，再返回给用户。服务器在处理这个数据的过程中，可能某个环节会出问题。</li>
<li>网络的原因。比如使用了低带宽的服务器，或者本来用的是电信的服务器，可联通的网络用户要来访问你的服务器，这样也会拖慢网速。</li>
<li>发送请求头时带上了多余的用户信息。比如一些不必要的 Cookie 信息，服务器接收到这些 Cookie 信息之后可能需要对每一项都做处理，这样就加大了服务器的处理时长</li>
</ol>
<ul>
<li>Content Download 时间过久</li>
</ul>
<ol>
<li>如果单个请求的 Content Download 花费了大量时间，有可能是字节数太多的原因导致的。这时候你就需要减少文件大小，比如压缩、去掉源码中不必要的注释等方法。</li>
</ol>
<h2 id="DOM树：JavaScript是如何影响DOM树构建的？"><a href="#DOM树：JavaScript是如何影响DOM树构建的？" class="headerlink" title="DOM树：JavaScript是如何影响DOM树构建的？"></a>DOM树：JavaScript是如何影响DOM树构建的？</h2><h3 id="什么是-DOM"><a href="#什么是-DOM" class="headerlink" title="什么是 DOM"></a>什么是 DOM</h3><ul>
<li>在渲染引擎中，DOM 有三个层面的作用。</li>
</ul>
<ol>
<li>从页面的视角来看，DOM 是生成页面的基础数据结构。</li>
<li>从 JavaScript 脚本视角来看，DOM 提供给 JavaScript 脚本操作的接口，通过这套接口，JavaScript 可以对 DOM 结构进行访问，从而改变文档的结构、样式和内容</li>
<li>从安全视角来看，DOM 是一道安全防护线，一些不安全的内容在 DOM 解析阶段就被拒之门外了。<h3 id="DOM-树如何生成"><a href="#DOM-树如何生成" class="headerlink" title="DOM 树如何生成"></a>DOM 树如何生成</h3></li>
</ol>
<ul>
<li>在渲染引擎内部，有一个叫 HTML 解析器（HTMLParser）的模块，它的职责就是负责将 HTML 字节流转换为 DOM 结构。</li>
<li>HTML 解析器并不是等整个文档加载完成之后再解析的，而是网络进程加载了多少数据，HTML 解析器便解析多少数据。</li>
<li>网络进程接收到响应头之后，会根据响应头中的 content-type 字段来判断文件的类型，比如 content-type 的值是“text/html”，那么浏览器就会判断这是一个 HTML 类型的文件，然后为该请求选择或者创建一个渲染进程。渲染进程准备好之后，网络进程和渲染进程之间会建立一个共享数据的管道，网络进程接收到数据后就往这个管道里面放，而渲染进程则从管道的另外一端不断地读取数据，并同时将读取的数据“喂”给 HTML 解析器。你可以把这个管道想象成一个“水管”，网络进程接收到的字节流像水一样倒进这个“水管”，而“水管”的另外一端是渲染进程的 HTML 解析器，它会动态接收字节流，并将其解析为 DOM。</li>
<li>字节流转换为 DOM 需要三个阶段：</li>
</ul>
<ol>
<li>第一个阶段，通过分词器将字节流转换为 Token。V8 编译 JavaScript 过程中的第一步是做词法分析，将 JavaScript 先分解为一个个 Token。解析 HTML 也是一样的，需要通过分词器先将字节流转换为一个个 Token，分为 Tag Token 和文本 Token。<br>Tag Token 又分 StartTag 和 EndTag，比如<body>就是 StartTag ，</body>就是EndTag。</li>
</ol>
<ul>
<li>至于后续的第二个和第三个阶段是同步进行的，需要将 Token 解析为 DOM 节点，并将 DOM 节点添加到 DOM 树中。</li>
<li>HTML 解析器维护了一个 Token 栈结构，该 Token 栈主要用来计算节点之间的父子关系，在第一个阶段中生成的 Token 会被按照顺序压到这个栈中。具体的处理规则如下所示：</li>
</ul>
<ol>
<li>如果压入到栈中的是 StartTag Token，HTML 解析器会为该 Token 创建一个 DOM 节点，然后将该节点加入到 DOM 树中，它的父节点就是栈中相邻的那个元素生成的节点。</li>
<li>如果分词器解析出来是文本 Token，那么会生成一个文本节点，然后将该节点加入到 DOM 树中，文本 Token 是不需要压入到栈中，它的父节点就是当前栈顶 Token 所对应的 DOM 节点。</li>
<li>如果分词器解析出来的是 EndTag 标签，比如是 EndTag div，HTML 解析器会查看 Token 栈顶的元素是否是 StarTag div，如果是，就将 StartTag  div 从栈中弹出，表示该 div 元素解析完成。</li>
</ol>
<ul>
<li>通过分词器产生的新 Token 就这样不停地压栈和出栈，整个解析过程就这样一直持续下去，直到分词器将所有字节流分词完成。</li>
<li>为了更加直观地理解整个过程，下面我们结合一段 HTML 代码（如下），来一步步分析 DOM 树的生成过程。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;1&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;test&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这段代码以字节流的形式传给了 HTML 解析器，经过分词器处理，解析出来的第一个 Token 是 StartTag html，解析出来的 Token 会被压入到栈中，并同时创建一个 html 的 DOM 节点，将其加入到 DOM 树中。</span><br><span class="line"></span><br><span class="line">HTML 解析器开始工作时，会默认创建了一个根为 document 的空 DOM 结构，同时会将一个 StartTag document 的 Token 压入栈底。然后经过分词器解析出来的第一个 StartTag html Token 会被压入到栈中，并创建一个 html 的 DOM 节点，添加到 document 上</span><br><span class="line"></span><br><span class="line">然后按照同样的流程解析出来 StartTag body 和 StartTag div，</span><br><span class="line"></span><br><span class="line">接下来解析出来的是第一个 div 的文本 Token，渲染引擎会为该 Token 创建一个文本节点，并将该 Token 添加到 DOM 中，它的父节点就是当前 Token 栈顶元素对应的节点</span><br><span class="line"></span><br><span class="line">再接下来，分词器解析出来第一个 EndTag div，这时候 HTML 解析器会去判断当前栈顶的元素是否是 StartTag div，如果是则从栈顶弹出 StartTag div</span><br><span class="line"></span><br><span class="line">不过在实际生产环境中，HTML 源文件中既包含 CSS 和 JavaScript，又包含图片、音频、视频等文件，所以处理过程远比上面这个示范 Demo 复杂。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="JavaScript-是如何影响-DOM-生成的"><a href="#JavaScript-是如何影响-DOM-生成的" class="headerlink" title="JavaScript 是如何影响 DOM 生成的"></a>JavaScript 是如何影响 DOM 生成的</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;1&lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">    let div1 = document.getElementsByTagName(&apos;div&apos;)[0]</span><br><span class="line">    div1.innerText = &apos;time.geekbang&apos;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">    &lt;div&gt;test&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在两段 div 中间插入了一段 JavaScript 脚本，这段脚本的解析过程就有点不一样了。&lt;script&gt;标签之前，所有的解析流程还是和之前介绍的一样，但是解析到&lt;script&gt;标签时，渲染引擎判断这是一段脚本，此时 HTML 解析器就会暂停 DOM 的解析，因为接下来的 JavaScript 可能要修改当前已经生成的 DOM 结构。</span><br><span class="line"></span><br><span class="line">这时候 HTML 解析器暂停工作，JavaScript 引擎介入，并执行 script 标签中的这段脚本，因为这段 JavaScript 脚本修改了 DOM 中第一个 div 中的内容，所以执行这段脚本之后，div 节点内容已经修改为 time.geekbang 了。脚本执行完成之后，HTML 解析器恢复解析过程，继续解析后续的内容，直至生成最终的 DOM。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//foo.js</span><br><span class="line">let div1 = document.getElementsByTagName(&apos;div&apos;)[0]</span><br><span class="line">div1.innerText = &apos;time.geekbang&apos;</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;1&lt;/div&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot; src=&apos;foo.js&apos;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;div&gt;test&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">这段代码的功能还是和前面那段代码是一样的，不过这里把内嵌 JavaScript 脚本修改成了通过 JavaScript 文件加载。其整个执行流程还是一样的，执行到 JavaScript 标签时，暂停整个 DOM 的解析，执行 JavaScript 代码，不过这里执行 JavaScript 时，需要先下载这段 JavaScript 代码。</span><br><span class="line"></span><br><span class="line">这里需要重点关注下载环境，因为 JavaScript 文件的下载过程会阻塞 DOM 解析，而通常下载又是非常耗时的，会受到网络环境、JavaScript 文件大小等因素的影响。</span><br><span class="line"></span><br><span class="line">不过 Chrome 浏览器做了很多优化，其中一个主要的优化是预解析操作。当渲染引擎收到字节流之后，会开启一个预解析线程，用来分析 HTML 文件中包含的 JavaScript、CSS 等相关文件，解析到相关文件之后，预解析线程会提前下载这些文件。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">再回到 DOM 解析上，我们知道引入 JavaScript 线程会阻塞 DOM，不过也有一些相关的策略来规避，比如使用 CDN 来加速 JavaScript 文件的加载，压缩 JavaScript 文件的体积。另外，如果 JavaScript 文件中没有操作 DOM 相关代码，就可以将该 JavaScript 脚本设置为异步加载，通过 async 或 defer 来标记代码，使用方式如下所示：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script async type=&quot;text/javascript&quot; src=&apos;foo.js&apos;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script defer type=&quot;text/javascript&quot; src=&apos;foo.js&apos;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">async 和 defer 虽然都是异步的，不过还有一些差异，使用 async 标志的脚本文件一旦加载完成，会立即执行；</span><br><span class="line">而使用了 defer 标记的脚本文件，需要在 DOMContentLoaded 事件之前执行。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">现在我们知道了 JavaScript 是如何阻塞 DOM 解析的了，那接下来我们再来结合文中代码看看另外一种情况：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//theme.css</span><br><span class="line">div &#123;color:blue&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;style src=&apos;theme.css&apos;&gt;&lt;/style&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;1&lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">            let div1 = document.getElementsByTagName(&apos;div&apos;)[0]</span><br><span class="line">            div1.innerText = &apos;time.geekbang&apos; //需要DOM</span><br><span class="line">            div1.style.color = &apos;red&apos;  //需要CSSOM</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">    &lt;div&gt;test&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">该示例中，JavaScript 代码出现了 div1.style.color = ‘red&apos; 的语句，它是用来操纵 CSSOM 的，所以在执行 JavaScript 之前，需要先解析 JavaScript 语句之上所有的 CSS 样式。所以如果代码里引用了外部的 CSS 文件，那么在执行 JavaScript 之前，还需要等待外部的 CSS 文件下载完成，并解析生成 CSSOM 对象之后，才能执行 JavaScript 脚本。</span><br><span class="line"></span><br><span class="line">而 JavaScript 引擎在解析 JavaScript 之前，是不知道 JavaScript 是否操纵了 CSSOM 的，所以渲染引擎在遇到 JavaScript 脚本时，不管该脚本是否操纵了 CSSOM，都会执行 CSS 文件下载，解析操作，再执行 JavaScript 脚本。</span><br><span class="line"></span><br><span class="line">所以说 JavaScript 脚本是依赖样式表的，这又多了一个阻塞过程。JavaScript 会阻塞 DOM 生成，而样式文件又会阻塞 JavaScript 的执行。</span><br></pre></td></tr></table></figure>
<h2 id="渲染流水线：CSS如何影响首次加载时的白屏时间？"><a href="#渲染流水线：CSS如何影响首次加载时的白屏时间？" class="headerlink" title="渲染流水线：CSS如何影响首次加载时的白屏时间？"></a>渲染流水线：CSS如何影响首次加载时的白屏时间？</h2><h3 id="渲染流水线视角下的-CSS"><a href="#渲染流水线视角下的-CSS" class="headerlink" title="渲染流水线视角下的 CSS"></a>渲染流水线视角下的 CSS</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//theme.css</span><br><span class="line">div&#123; </span><br><span class="line">    color : coral;</span><br><span class="line">    background-color:black</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;link href=&quot;theme.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;geekbang com&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">首先是发起主页面的请求，这个发起请求方可能是渲染进程，也有可能是浏览器进程，发起的请求被送到网络进程中去执行。</span><br><span class="line">网络进程接收到返回的 HTML 数据之后，将其发送给渲染进程，渲染进程会解析 HTML 数据并构建 DOM。</span><br><span class="line">这里你需要特别注意下，请求 HTML 数据和构建 DOM 中间有一段空闲时间，这个空闲时间有可能成为页面渲染的瓶颈。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">当渲染进程接收 HTML 文件字节流时，会先开启一个预解析线程，如果遇到 JavaScript 文件或者 CSS 文件，那么预解析线程会提前下载这些数据。对于上面的代码，预解析线程会解析出来一个外部的 theme.css 文件，并发起 theme.css 的下载。</span><br><span class="line">这里也有一个空闲时间需要你注意一下，就是在 DOM 构建结束之后、theme.css 文件还未下载完成的这段时间内，渲染流水线无事可做，因为下一步是合成布局树，而合成布局树需要 CSSOM 和 DOM，所以这里需要等待 CSS 加载结束并解析成 CSSOM。</span><br></pre></td></tr></table></figure>
<h4 id="那渲染流水线为什么需要-CSSOM-呢？"><a href="#那渲染流水线为什么需要-CSSOM-呢？" class="headerlink" title="那渲染流水线为什么需要 CSSOM 呢？"></a>那渲染流水线为什么需要 CSSOM 呢？</h4><ul>
<li>和 HTML 一样，渲染引擎也是无法直接理解 CSS 文件内容的，所以需要将其解析成渲染引擎能够理解的结构，这个结构就是 CSSOM。</li>
<li>和 DOM 一样，CSSOM 也具有两个作用，第一个是提供给 JavaScript 操作样式表的能力，第二个是为布局树的合成提供基础的样式信息。这个 CSSOM 体现在 DOM 中就是document.styleSheets。</li>
<li>等 DOM 和 CSSOM 都构建好之后，渲染引擎就会构造布局树。布局树的结构基本上就是复制 DOM 树的结构，不同之处在于 DOM 树中那些不需要显示的元素会被过滤掉，如 display:none 属性的元素、head 标签、script 标签等。</li>
<li>复制好基本的布局树结构之后，渲染引擎会为对应的 DOM 元素选择对应的样式信息，这个过程就是样式计算。</li>
<li>样式计算完成之后，渲染引擎还需要计算布局树中每个元素对应的几何位置，这个过程就是计算布局。</li>
<li>通过样式计算和计算布局就完成了最终布局树的构建。再之后，就该进行后续的绘制操作了。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//theme.css</span><br><span class="line">div&#123; </span><br><span class="line">    color : coral;</span><br><span class="line">    background-color:black</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;link href=&quot;theme.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;geekbang com&lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        console.log(&apos;time.geekbang.org&apos;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">    &lt;div&gt;geekbang com&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在解析 DOM 的过程中，如果遇到了 JavaScript 脚本，那么需要先暂停 DOM 解析去执行 JavaScript，因为 JavaScript 有可能会修改当前状态下的 DOM。</span><br><span class="line">不过在执行 JavaScript 脚本之前，如果页面中包含了外部 CSS 文件的引用，或者通过 style 标签内置了 CSS 内容，那么渲染引擎还需要将这些内容转换为 CSSOM，因为 JavaScript 有修改 CSSOM 的能力，所以在执行 JavaScript 之前，还需要依赖 CSSOM。</span><br><span class="line">也就是说 CSS 在部分情况下也会阻塞 DOM 的生成。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//theme.css</span><br><span class="line">div&#123; </span><br><span class="line">    color : coral;</span><br><span class="line">    background-color:black</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//foo.js</span><br><span class="line">console.log(&apos;time.geekbang.org&apos;)</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;link href=&quot;theme.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;geekbang com&lt;/div&gt;</span><br><span class="line">    &lt;script src=&apos;foo.js&apos;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;div&gt;geekbang com&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">在接收到 HTML 数据之后的预解析过程中，HTML 预解析器识别出来了有 CSS 文件和 JavaScript 文件需要下载，然后就同时发起这两个文件的下载请求，需要注意的是，这两个文件的下载过程是重叠的，所以下载时间按照最久的那个文件来算。</span><br><span class="line"></span><br><span class="line">后面的流水线就和前面是一样的了，不管 CSS 文件和 JavaScript 文件谁先到达，都要先等到 CSS 文件下载完成并生成 CSSOM，然后再执行 JavaScript 脚本，最后再继续构建 DOM，构建布局树，绘制页面。</span><br></pre></td></tr></table></figure>
<h3 id="影响页面展示的因素以及优化策略"><a href="#影响页面展示的因素以及优化策略" class="headerlink" title="影响页面展示的因素以及优化策略"></a>影响页面展示的因素以及优化策略</h3><ul>
<li>为什么要花这么多文字来分析渲染流水线呢？主要原因就是渲染流水线影响到了首次页面展示的速度，而首次页面展示的速度又直接影响到了用户体验</li>
<li>从发起 URL 请求开始，到首次显示页面的内容，在视觉上经历的三个阶段。</li>
</ul>
<ol>
<li>第一个阶段，等请求发出去之后，到提交数据阶段，这时页面展示出来的还是之前页面的内容。</li>
<li>第二个阶段，提交数据之后渲染进程会创建一个空白页面，我们通常把这段时间称为解析白屏，并等待 CSS 文件和 JavaScript 文件的加载完成，生成 CSSOM 和 DOM，然后合成布局树，最后还要经过一系列的步骤准备首次渲染。</li>
<li>第三个阶段，等首次渲染完成之后，就开始进入完整页面的生成阶段了，然后页面会一点点被绘制出来。</li>
</ol>
<ul>
<li>影响第一个阶段的因素主要是网络或者是服务器处理这块儿,</li>
<li>第二个阶段，这个阶段的主要问题是白屏时间，通常情况下的瓶颈主要体现在下载 CSS 文件、下载 JavaScript 文件和执行 JavaScript。所以要想缩短白屏时长，可以有以下策略：</li>
</ul>
<ol>
<li>通过内联 JavaScript、内联 CSS 来移除这两种类型的文件下载，这样获取到 HTML 文件之后就可以直接开始渲染流程了。</li>
<li>并不是所有的场合都适合内联，那么还可以尽量减少文件大小，比如通过 webpack 等工具移除一些不必要的注释，并压缩 JavaScript 文件。</li>
<li>还可以将一些不需要在解析 HTML 阶段使用的 JavaScript 标记上 async 或者 defer。</li>
<li>对于大的 CSS 文件，可以通过媒体查询属性，将其拆分为多个不同用途的 CSS 文件，这样只有在特定的场景下才会加载特定的 CSS 文件。</li>
</ol>
<h2 id="分层和合成机制：为什么CSS动画比JavaScript高效？"><a href="#分层和合成机制：为什么CSS动画比JavaScript高效？" class="headerlink" title="分层和合成机制：为什么CSS动画比JavaScript高效？"></a>分层和合成机制：为什么CSS动画比JavaScript高效？</h2><h3 id="显示器是怎么显示图像的"><a href="#显示器是怎么显示图像的" class="headerlink" title="显示器是怎么显示图像的"></a>显示器是怎么显示图像的</h3><ul>
<li>每个显示器都有固定的刷新频率，通常是 60HZ，也就是每秒更新 60 张图片，更新的图片都来自于显卡中一个叫前缓冲区的地方，显示器所做的任务很简单，就是每秒固定读取 60 次前缓冲区中的图像，并将读取的图像显示到显示器上。</li>
<li>显卡的职责就是合成新的图像，并将图像保存到后缓冲区中，一旦显卡把合成的图像写到后缓冲区，系统就会让后缓冲区和前缓冲区互换，这样就能保证显示器能读取到最新显卡合成的图像。通常情况下，显卡的更新频率和显示器的刷新频率是一致的。但有时候，在一些复杂的场景中，显卡处理一张图片的速度会变慢，这样就会造成视觉上的卡顿。<h3 id="帧-VS-帧率"><a href="#帧-VS-帧率" class="headerlink" title="帧 VS 帧率"></a>帧 VS 帧率</h3></li>
<li>当你通过滚动条滚动页面，或者通过手势缩放页面时，屏幕上就会产生动画的效果。之所以你能感觉到有动画的效果，是因为在滚动或者缩放操作时，渲染引擎会通过渲染流水线生成新的图片，并发送到显卡的后缓冲区。</li>
<li>大多数设备屏幕的更新频率是 60 次 / 秒，这也就意味着正常情况下要实现流畅的动画效果，渲染引擎需要每秒更新 60 张图片到显卡的后缓冲区。</li>
<li>我们把渲染流水线生成的每一副图片称为一帧，把渲染流水线每秒更新了多少帧称为帧率，比如滚动过程中 1 秒更新了 60 帧，那么帧率就是 60Hz（或者 60FPS）</li>
<li>由于用户很容易观察到那些丢失的帧，如果在一次动画过程中，渲染引擎生成某些帧的时间过久，那么用户就会感受到卡顿，这会给用户造成非常不好的印象。</li>
<li>要解决卡顿问题，就要解决每帧生成时间过久的问题，为此 Chrome 对浏览器渲染方式做了大量的工作，其中最卓有成效的策略就是引入了分层和合成机制。<h3 id="如何生成一帧图像"><a href="#如何生成一帧图像" class="headerlink" title="如何生成一帧图像"></a>如何生成一帧图像</h3></li>
<li>重排、重绘和合成这三种方式的渲染路径是不同的，通常渲染路径越长，生成图像花费的时间就越多。</li>
</ul>
<ol>
<li>比如重排，它需要重新根据 CSSOM 和 DOM 来计算布局树，这样生成一幅图片时，会让整个渲染流水线的每个阶段都执行一遍，如果布局复杂的话，就很难保证渲染的效率了。</li>
<li>而重绘因为没有了重新布局的阶段，操作效率稍微高点，但是依然需要重新计算绘制信息，并触发绘制操作之后的一系列操作。</li>
<li>相较于重排和重绘，合成操作的路径就显得非常短了，并不需要触发布局和绘制两个阶段，如果采用了 GPU，那么合成的效率会非常高。</li>
</ol>
<ul>
<li>所以，关于渲染引擎生成一帧图像的几种方式，按照效率我们推荐合成方式优先，若实在不能满足需求，那么就再退后一步使用重绘或者重排的方式。</li>
<li>Chrome 中的合成技术，可以用三个词来概括总结：分层、分块和合成。<h3 id="分层和合成"><a href="#分层和合成" class="headerlink" title="分层和合成"></a>分层和合成</h3></li>
<li>通常页面的组成是非常复杂的，有的页面里要实现一些复杂的动画效果，如果没有采用分层机制，从布局树直接生成目标图片的话，那么每次页面有很小的变化时，都会触发重排或者重绘机制，这种“牵一发而动全身”的绘制策略会严重影响页面的渲染效率。</li>
<li>为了提升每帧的渲染效率，Chrome 引入了分层和合成的机制。那该怎么来理解分层和合成机制呢？</li>
</ul>
<ol>
<li>你可以把一张网页想象成是由很多个图片叠加在一起的，每个图片就对应一个图层，Chrome 合成器最终将这些图层合成了用于显示页面的图片。</li>
<li>如果你熟悉 PhotoShop 的话，就能很好地理解这个过程了，PhotoShop 中一个项目是由很多图层构成的，每个图层都可以是一张单独图片，可以设置透明度、边框阴影，可以旋转或者设置图层的上下位置，将这些图层叠加在一起后，就能呈现出最终的图片了。</li>
<li>在这个过程中，将素材分解为多个图层的操作就称为分层，最后将这些图层合并到一起的操作就称为合成。所以，分层和合成通常是一起使用的。</li>
<li>考虑到一个页面被划分为两个层，当进行到下一帧的渲染时，上面的一帧可能需要实现某些变换，如平移、旋转、缩放、阴影或者 Alpha 渐变，这时候合成器只需要将两个层进行相应的变化操作就可以了，显卡处理这些操作驾轻就熟，所以这个合成过程时间非常短。</li>
</ol>
<ul>
<li>理解了为什么要引入合成和分层机制，下面我们再来看看 Chrome 是怎么实现分层和合成机制的。</li>
</ul>
<ol>
<li>在 Chrome 的渲染流水线中，分层体现在生成布局树之后，渲染引擎会根据布局树的特点将其转换为层树（Layer Tree），层树是渲染流水线后续流程的基础结构。</li>
<li>层树中的每个节点都对应着一个图层，下一步的绘制阶段就依赖于层树中的节点。</li>
<li>绘制阶段其实并不是真正地绘出图片，而是将绘制指令组合成一个列表，比如一个图层要设置的背景为黑色，并且还要在中间画一个圆形，那么绘制过程会生成|Paint BackGroundColor:Black | Paint Circle|这样的绘制指令列表，绘制过程就完成了。</li>
<li>有了绘制列表之后，就需要进入光栅化阶段了，光栅化就是按照绘制列表中的指令生成图片。每一个图层都对应一张图片，合成线程有了这些图片之后，会将这些图片合成为“一张”图片，并最终将生成的图片发送到后缓冲区。这就是一个大致的分层、合成流程。</li>
<li>合成操作是在合成线程上完成的，这也就意味着在执行合成操作时，是不会影响到主线程执行的。这就是为什么经常主线程卡住了，但是 CSS 动画依然能执行的原因。<h3 id="分块"><a href="#分块" class="headerlink" title="分块"></a>分块</h3></li>
</ol>
<ul>
<li>如果说分层是从宏观上提升了渲染效率，那么分块则是从微观层面提升了渲染效率。</li>
<li>通常情况下，页面的内容都要比屏幕大得多，显示一个页面时，如果等待所有的图层都生成完毕，再进行合成的话，会产生一些不必要的开销，也会让合成图片的时间变得更久。</li>
<li>因此，合成线程会将每个图层分割为大小固定的图块，然后优先绘制靠近视口的图块，这样就可以大大加速页面的显示速度。不过有时候， 即使只绘制那些优先级最高的图块，也要耗费不少的时间，因为涉及到一个很关键的因素——纹理上传，这是因为从计算机内存上传到 GPU 内存的操作会比较慢。</li>
<li>为了解决这个问题，Chrome 又采取了一个策略：在首次合成图块的时候使用一个低分辨率的图片。比如可以是正常分辨率的一半，分辨率减少一半，纹理就减少了四分之三。在首次显示页面内容的时候，将这个低分辨率的图片显示出来，然后合成器继续绘制正常比例的网页内容，当正常比例的网页内容绘制完成后，再替换掉当前显示的低分辨率内容。这种方式尽管会让用户在开始时看到的是低分辨率的内容，但是也比用户在开始时什么都看不到要好。<h3 id="如何利用分层技术优化代码"><a href="#如何利用分层技术优化代码" class="headerlink" title="如何利用分层技术优化代码"></a>如何利用分层技术优化代码</h3></li>
<li><p>你可以使用 will-change 来告诉渲染引擎你会对该元素做一些特效变换，CSS 代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.box &#123;</span><br><span class="line">will-change: transform, opacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">这段代码就是提前告诉渲染引擎 box 元素将要做几何变换和透明度变换操作，这时候渲染引擎会将该元素单独实现一帧，</span><br><span class="line">等这些变换发生时，渲染引擎会通过合成线程直接去处理变换，这些变换并没有涉及到主线程，这样就大大提升了渲染的效率。</span><br><span class="line">这也是 CSS 动画比 JavaScript 动画高效的原因。</span><br></pre></td></tr></table></figure>
</li>
<li><p>所以，如果涉及到一些可以使用合成线程来处理 CSS 特效或者动画的情况，就尽量使用 will-change 来提前告诉渲染引擎，让它为该元素准备独立的层。但是凡事都有两面性，每当渲染引擎为一个元素准备一个独立层的时候，它占用的内存也会大大增加，因为从层树开始，后续每个阶段都会多一个层结构，这些都需要额外的内存，所以你需要恰当地使用 will-change。</p>
</li>
</ul>
<h2 id="页面性能：如何系统地优化页面？"><a href="#页面性能：如何系统地优化页面？" class="headerlink" title="页面性能：如何系统地优化页面？"></a>页面性能：如何系统地优化页面？</h2><ul>
<li>通常一个页面有三个阶段：加载阶段、交互阶段和关闭阶段。</li>
</ul>
<ol>
<li>加载阶段，是指从发出请求到渲染出完整页面的过程，影响到这个阶段的主要因素有网络和 JavaScript 脚本。</li>
<li>交互阶段，主要是从页面加载完成到用户交互的整合过程，影响到这个阶段的主要因素是 JavaScript 脚本。</li>
<li>关闭阶段，主要是用户发出关闭指令后页面所做的一些清理操作。<h3 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h3></li>
</ol>
<ul>
<li>图片、音频、视频等文件就不会阻塞页面的首次渲染；而 JavaScript、首次请求的 HTML 资源文件、CSS 文件是会阻塞首次渲染的，因为在构建 DOM 的过程中需要 HTML 和 JavaScript 文件，在构造渲染树的过程中需要用到 CSS 文件。</li>
<li>我们把这些能阻塞网页首次渲染的资源称为关键资源。基于关键资源，我们可以继续细化出来三个影响页面首次渲染的核心因素。</li>
</ul>
<ol>
<li>第一个是关键资源个数。关键资源个数越多，首次页面的加载时间就会越长。比如上图中的关键资源个数就是 3 个，1 个 HTML 文件、1 个 JavaScript 和 1 个 CSS 文件。</li>
<li>第二个是关键资源大小。通常情况下，所有关键资源的内容越小，其整个资源的下载时间也就越短，那么阻塞渲染的时间也就越短。上图中关键资源的大小分别是 6KB、8KB 和 9KB，那么整个关键资源大小就是 23KB。</li>
<li>第三个是请求关键资源需要多少个 RTT（Round Trip Time）。那什么是 RTT 呢？<br>当使用 TCP 协议传输一个文件时，比如这个文件大小是 0.1M，由于 TCP 的特性，这个数据并不是一次传输到服务端的，而是需要拆分成一个个数据包来回多次进行传输的。<br>RTT 就是这里的往返时延。它是网络中一个重要的性能指标，表示从发送端发送数据开始，到发送端收到来自接收端的确认，总共经历的时延。<br>通常 1 个 HTTP 的数据包在 14KB 左右，所以 1 个 0.1M 的页面就需要拆分成 8 个包来传输了，也就是说需要 8 个 RTT。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">首先是请求 HTML 资源，大小是 6KB，小于 14KB，所以 1 个 RTT 就可以解决了。</span><br><span class="line">至于 JavaScript 和 CSS 文件，这里需要注意一点，由于渲染引擎有一个预解析的线程，在接收到 HTML 数据之后，预解析线程会快速扫描 HTML 数据中的关键资源，一旦扫描到了，会立马发起请求，你可以认为 JavaScript 和 CSS 是同时发起请求的，所以它们的请求是重叠的，那么计算它们的 RTT 时，只需要计算体积最大的那个数据就可以了。这里最大的是 CSS 文件（9KB），所以我们就按照 9KB 来计算，同样由于 9KB 小于 14KB，所以 JavaScript 和 CSS 资源也就可以算成 1 个 RTT。也就是说，关键资源请求共花费了 2 个 RTT。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>总的优化原则就是减少关键资源个数，降低关键资源大小，降低关键资源的 RTT 次数。</li>
</ul>
<ol>
<li>如何减少关键资源的个数？一种方式是可以将 JavaScript 和 CSS 改成内联的形式，比如上图的 JavaScript 和 CSS，若都改成内联模式，那么关键资源的个数就由 3 个减少到了 1 个。另一种方式，如果 JavaScript 代码没有 DOM 或者 CSSOM 的操作，则可以改成 async 或者 defer 属性；同样对于 CSS，如果不是在构建页面之前加载的，则可以添加媒体取消阻止显现的标志。当 JavaScript 标签加上了 async 或者 defer、CSSlink 属性之前加上了取消阻止显现的标志后，它们就变成了非关键资源了。</li>
<li>如何减少关键资源的大小？可以压缩 CSS 和 JavaScript 资源，移除 HTML、CSS、JavaScript 文件中一些注释内容，也可以通过前面讲的取消 CSS 或者 JavaScript 中关键资源的方式。</li>
<li>如何减少关键资源 RTT 的次数？可以通过减少关键资源的个数和减少关键资源的大小搭配来实现。除此之外，还可以使用 CDN 来减少每次 RTT 时长<h3 id="交互阶段"><a href="#交互阶段" class="headerlink" title="交互阶段"></a>交互阶段</h3></li>
</ol>
<ul>
<li>如果在计算样式阶段发现有布局信息的修改，那么就会触发重排操作，然后触发后续渲染流水线的一系列操作，这个代价是非常大的。</li>
<li>同样如果在计算样式阶段没有发现有布局信息的修改，只是修改了颜色一类的信息，那么就不会涉及到布局相关的调整，所以可以跳过布局阶段，直接进入绘制阶段，这个过程叫重绘。不过重绘阶段的代价也是不小的。</li>
<li>还有另外一种情况，通过 CSS 实现一些变形、渐变、动画等特效，这是由 CSS 触发的，并且是在合成线程上执行的，这个过程称为合成。因为它不会触发重排或者重绘，而且合成操作本身的速度就非常快，所以执行合成是效率最高的方式。</li>
<li>分析下在交互阶段渲染流水线中有哪些因素影响了帧的生成速度以及如何去优化。</li>
</ul>
<ol>
<li>减少 JavaScript 脚本执行时间，针对这种情况我们可以采用以下两种策略：一种是将一次执行的函数分解为多个任务，使得每次的执行时间不要过久。另一种是采用 Web Workers。你可以把 Web Workers 当作主线程之外的一个线程，在 Web Workers 中是可以执行 JavaScript 脚本的，不过 Web Workers 中没有 DOM、CSSOM 环境，这意味着在 Web Workers 中是无法通过 JavaScript 来访问 DOM 的，所以我们可以把一些和 DOM 操作无关且耗时的任务放到 Web Workers 中去执行。</li>
<li><p>避免强制同步布局<br>所谓强制同步布局，是指 JavaScript 强制将计算样式和布局操作提前到当前的任务中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;mian_div&quot;&gt;</span><br><span class="line">        &lt;li id=&quot;time_li&quot;&gt;time&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;geekbang&lt;/li&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;p id=&quot;demo&quot;&gt;强制布局demo&lt;/p&gt;</span><br><span class="line">    &lt;button onclick=&quot;foo()&quot;&gt;添加新元素&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        function foo() &#123;</span><br><span class="line">            let main_div = document.getElementById(&quot;mian_div&quot;)      </span><br><span class="line">            let new_node = document.createElement(&quot;li&quot;)</span><br><span class="line">            let textnode = document.createTextNode(&quot;time.geekbang&quot;)</span><br><span class="line">            new_node.appendChild(textnode);</span><br><span class="line">            document.getElementById(&quot;mian_div&quot;).appendChild(new_node);</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">执行 JavaScript 添加元素是在一个任务中执行的，重新计算样式布局是在另外一个任务中执行，这就是正常情况下的布局操作。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">    let main_div = document.getElementById(&quot;mian_div&quot;)</span><br><span class="line">    let new_node = document.createElement(&quot;li&quot;)</span><br><span class="line">    let textnode = document.createTextNode(&quot;time.geekbang&quot;)</span><br><span class="line">    new_node.appendChild(textnode);</span><br><span class="line">    document.getElementById(&quot;mian_div&quot;).appendChild(new_node);</span><br><span class="line">    //由于要获取到offsetHeight，</span><br><span class="line">    //但是此时的offsetHeight还是老的数据，</span><br><span class="line">    //所以需要立即执行布局操作</span><br><span class="line">    console.log(main_div.offsetHeight)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">将新的元素添加到 DOM 之后，我们又调用了main_div.offsetHeight来获取新 main_div 的高度信息。</span><br><span class="line">如果要获取到 main_div 的高度，就需要重新布局，所以这里在获取到 main_div 的高度之前，JavaScript 还需要强制让渲染引擎默认执行一次布局操作。</span><br><span class="line">我们把这个操作称为强制同步布局。</span><br></pre></td></tr></table></figure>
</li>
<li><p>避免布局抖动<br>所谓布局抖动，是指在一次 JavaScript 执行过程中，多次执行强制布局和抖动操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">    let time_li = document.getElementById(&quot;time_li&quot;)</span><br><span class="line">    for (let i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">        let main_div = document.getElementById(&quot;mian_div&quot;)</span><br><span class="line">        let new_node = document.createElement(&quot;li&quot;)</span><br><span class="line">        let textnode = document.createTextNode(&quot;time.geekbang&quot;)</span><br><span class="line">        new_node.appendChild(textnode);</span><br><span class="line">        new_node.offsetHeight = time_li.offsetHeight;</span><br><span class="line">        document.getElementById(&quot;mian_div&quot;).appendChild(new_node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在 foo 函数内部重复执行计算样式和布局，这会大大影响当前函数的执行效率。这种情况的避免方式和强制同步布局一样，都是尽量不要在修改 DOM 结构时再去查询一些相关值。</span><br></pre></td></tr></table></figure>
</li>
<li><p>合理利用 CSS 合成动画<br>合成动画是直接在合成线程上执行的，这和在主线程上执行的布局、绘制等操作不同，如果主线程被 JavaScript 或者一些布局任务占用，CSS 动画依然能继续执行。所以要尽量利用好 CSS 合成动画，如果能让 CSS 处理动画，就尽量交给 CSS 来操作。<br>另外，如果能提前知道对某个元素执行动画操作，那就最好将其标记为 will-change，这是告诉渲染引擎需要将该元素单独生成一个图层。</p>
</li>
<li>避免频繁的垃圾回收<br>如果在一些函数中频繁创建临时对象，那么垃圾回收器也会频繁地去执行垃圾回收策略。这样当垃圾回收操作发生时，就会占用主线程，从而影响到其他任务的执行，严重的话还会让用户产生掉帧、不流畅的感觉。</li>
</ol>
<h2 id="虚拟DOM：虚拟DOM和实际的DOM有何不同？"><a href="#虚拟DOM：虚拟DOM和实际的DOM有何不同？" class="headerlink" title="虚拟DOM：虚拟DOM和实际的DOM有何不同？"></a>虚拟DOM：虚拟DOM和实际的DOM有何不同？</h2><h3 id="DOM-的缺陷"><a href="#DOM-的缺陷" class="headerlink" title="DOM 的缺陷"></a>DOM 的缺陷</h3><ul>
<li>调用document.body.appendChild(node)往 body 节点上添加一个元素，调用该 API 之后会引发一系列的连锁反应。首先渲染引擎会将 node 节点添加到 body 节点之上，然后触发样式计算、布局、绘制、栅格化、合成等任务，我们把这一过程称为重排。除了重排之外，还有可能引起重绘或者合成操作，形象地理解就是“牵一发而动全身”。另外，对于 DOM 的不当操作还有可能引发强制同步布局和布局抖动的问题，这些操作都会大大降低渲染效率。因此，对于 DOM 的操作我们时刻都需要非常小心谨慎。</li>
<li>为 DOM 结构复杂，所生成的页面结构也会很复杂，对于这些复杂的页面，执行一次重排或者重绘操作都是非常耗时的，这就给我们带来了真正的性能问题。<h3 id="什么是虚拟-DOM"><a href="#什么是虚拟-DOM" class="headerlink" title="什么是虚拟 DOM"></a>什么是虚拟 DOM</h3></li>
<li>将页面改变的内容应用到虚拟 DOM 上，而不是直接应用到 DOM 上。</li>
<li>变化被应用到虚拟 DOM 上时，虚拟 DOM 并不急着去渲染页面，而仅仅是调整虚拟 DOM 的内部状态，这样操作虚拟 DOM 的代价就变得非常轻了。</li>
<li>在虚拟 DOM 收集到足够的改变时，再把这些变化一次性应用到真实的 DOM 上。<h3 id="虚拟-DOM-到底怎么运行的"><a href="#虚拟-DOM-到底怎么运行的" class="headerlink" title="虚拟 DOM 到底怎么运行的"></a>虚拟 DOM 到底怎么运行的</h3></li>
<li>创建阶段。首先依据 JSX 和基础数据创建出来虚拟 DOM，它反映了真实的 DOM 树的结构。然后由虚拟 DOM 树创建出真实 DOM 树，真实的 DOM 树生成完后，再触发渲染流水线往屏幕输出页面。</li>
<li>新阶段。如果数据发生了改变，那么就需要根据新的数据创建一个新的虚拟 DOM 树；然后 React 比较两个树，找出变化的地方，并把变化的地方一次性更新到真实的 DOM 树上；最后渲染引擎更新渲染流水线，并生成新的页面。<h3 id="React-Fiber-更新机制。"><a href="#React-Fiber-更新机制。" class="headerlink" title="React Fiber 更新机制。"></a>React Fiber 更新机制。</h3></li>
<li>最开始的时候，比较两个虚拟 DOM 的过程是在一个递归函数里执行的，其核心算法是 reconciliation。</li>
<li>常情况下，这个比较过程执行得很快，不过当虚拟 DOM 比较复杂的时候，执行比较函数就有可能占据主线程比较久的时间，这样就会导致其他任务的等待，造成页面卡顿。</li>
<li>为了解决这个问题，React 团队重写了 reconciliation 算法，新的算法称为 Fiber reconciler，之前老的算法称为 Stack reconciler。</li>
<li>其实协程的另外一个称呼就是 Fiber，所以在这里我们可以把 Fiber 和协程关联起来，那么所谓的 Fiber reconciler ，就是在执行算法的过程中出让主线程，这样就解决了 Stack reconciler 函数占用时间过久的问题。<h4 id="双缓存"><a href="#双缓存" class="headerlink" title="双缓存"></a>双缓存</h4></li>
<li>在开发游戏或者处理其他图像的过程中，屏幕从前缓冲区读取数据然后显示。但是很多图形操作都很复杂且需要大量的运算，比如一幅完整的画面，可能需要计算多次才能完成，如果每次计算完一部分图像，就将其写入缓冲区，那么就会造成一个后果，那就是在显示一个稍微复杂点的图像的过程中，你看到的页面效果可能是一部分一部分地显示出来，因此在刷新页面的过程中，会让用户感受到界面的闪烁。</li>
<li>而使用双缓存，可以让你先将计算的中间结果存放在另一个缓冲区中，等全部的计算结束，该缓冲区已经存储了完整的图形之后，再将该缓冲区的图形数据一次性复制到显示缓冲区，这样就使得整个图像的输出非常稳定。</li>
<li>双缓存是一种经典的思路，应用在很多场合，能解决页面无效刷新和闪屏的问题，虚拟 DOM 就是双缓存思想的一种体现。<h4 id="MVC-模式"><a href="#MVC-模式" class="headerlink" title="MVC 模式"></a>MVC 模式</h4></li>
<li>其核心思想就是将数据和视图分离，也就是说视图和模型之间是不允许直接通信的，它们之间的通信都是通过控制器来完成的。</li>
<li>基于 MVC 又能衍生出很多其他的模式，如 MVP、MVVM 等，不过万变不离其宗，它们的基础骨架都是基于 MVC 而来。</li>
<li>我们可以把虚拟 DOM 看成是 MVC 的视图部分，其控制器和模型都是由 Redux 提供的。其具体实现过程如下：</li>
</ul>
<ol>
<li>控制器是用来监控 DOM 的变化，一旦 DOM 发生变化，控制器便会通知模型，让其更新数据；</li>
<li>模型数据更新好之后，控制器会通知视图，告诉它模型的数据发生了变化；</li>
<li>视图接收到更新消息之后，会根据模型所提供的数据来生成新的虚拟 DOM；</li>
<li>新的虚拟 DOM 生成好之后，就需要与之前的虚拟 DOM 进行比较，找出变化的节点；</li>
<li>比较出变化的节点之后，React 将变化的虚拟节点应用到 DOM 上，这样就会触发 DOM 节点的更新；</li>
<li>DOM 节点的变化又会触发后续一系列渲染流水线的变化，从而实现页面的更新</li>
</ol>
<h2 id="渐进式网页应用（PWA）：它究竟解决了Web应用的哪些问题？"><a href="#渐进式网页应用（PWA）：它究竟解决了Web应用的哪些问题？" class="headerlink" title="渐进式网页应用（PWA）：它究竟解决了Web应用的哪些问题？"></a>渐进式网页应用（PWA）：它究竟解决了Web应用的哪些问题？</h2><ul>
<li>它是一套理念，渐进式增强 Web 的优势，并通过技术手段渐进式缩短和本地应用或者小程序的距离。</li>
<li>Web 应用缺少离线使用能力，在离线或者在弱网环境下基本上是无法使用的。而用户需要的是沉浸式的体验，在离线或者弱网环境下能够流畅地使用是用户对一个应用的基本要求。</li>
<li>Web 应用还缺少了消息推送的能力，因为作为一个 App 厂商，需要有将消息送达到应用的能力。</li>
<li>Web 应用缺少一级入口，也就是将 Web 应用安装到桌面，在需要的时候直接从桌面打开 Web 应用，而不是每次都需要通过浏览器来打开。</li>
<li>针对以上 Web 缺陷，PWA 提出了两种解决方案：通过引入 Service Worker 来试着解决离线存储和消息推送的问题，通过引入 manifest.json 来解决一级入口的问题。</li>
<li>另外，PWA 还提供了 manifest.json 配置文件，可以让开发者自定义桌面的图标、显示名称、启动方式等信息，还可以设置启动画面、页面主题颜色等信息。<h3 id="什么是-Service-Worker"><a href="#什么是-Service-Worker" class="headerlink" title="什么是 Service Worker"></a>什么是 Service Worker</h3></li>
<li>它的主要思想是在页面和网络之间增加一个拦截器，用来缓存和拦截请求。</li>
<li>在没有安装 Service Worker 之前，WebApp 都是直接通过网络模块来请求资源的。安装了 Service Worker 模块之后，WebApp 请求资源时，会先通过 Service Worker，让它判断是返回 Service Worker 缓存的资源还是重新去网络请求资源。一切的控制权都交由 Service Worker 来处理。</li>
<li>为了避免 JavaScript 过多占用页面主线程时长的情况，浏览器实现了 Web Worker 的功能。Web Worker 的目的是让 JavaScript 能够运行在页面主线程之外，不过由于 Web Worker 中是没有当前页面的 DOM 环境的，所以在 Web Worker 中只能执行一些和 DOM 无关的 JavaScript 脚本，并通过 postMessage 方法将执行的结果返回给主线程。所以说在 Chrome 中， Web Worker 其实就是在渲染进程中开启的一个新线程，它的生命周期是和页面关联的。</li>
<li>“让其运行在主线程之外”就是 Service Worker 来自 Web Worker 的一个核心思想。不过 Web Worker 是临时的，每次 JavaScript 脚本执行完成之后都会退出，执行结果也不能保存下来，如果下次还有同样的操作，就还得重新来一遍。所以 Service Worker 需要在 Web Worker 的基础之上加上储存功能。</li>
<li>由于 Service Worker 还需要会为多个页面提供服务，所以还不能把 Service Worker 和单个页面绑定起来。在目前的 Chrome 架构中，Service Worker 是运行在浏览器进程中的，因为浏览器进程生命周期是最长的，所以在浏览器的生命周期内，能够为所有的页面提供服务。</li>
<li>消息推送也是基于 Service Worker 来实现的。因为消息推送时，浏览器页面也许并没有启动，这时就需要 Service Worker 来接收服务器推送的消息，并将消息通过一定方式展示给用户</li>
<li>HTTP 采用的是明文传输信息，存在被窃听、被篡改和被劫持的风险，在项目中使用 HTTP 来传输数据无疑是“裸奔”。所以在设计之初，就考虑对 Service Worker 采用 HTTPS 协议，因为采用 HTTPS 的通信数据都是经过加密的，即便拦截了数据，也无法破解数据内容，而且 HTTPS 还有校验机制，通信双方很容易知道数据是否被篡改。</li>
<li>除了必须要使用 HTTPS，Service Worker 还需要同时支持 Web 页面默认的安全策略、储入同源策略、内容安全策略（CSP）等</li>
</ul>
<h2 id="WebComponent：像搭积木一样构建Web应用"><a href="#WebComponent：像搭积木一样构建Web应用" class="headerlink" title="WebComponent：像搭积木一样构建Web应用"></a>WebComponent：像搭积木一样构建Web应用</h2><ul>
<li>WebComponent 是一套技术的组合，具体涉及到了 Custom elements（自定义元素）、Shadow DOM（影子 DOM）和HTML templates（HTML 模板）</li>
<li>要使用 WebComponent，通常要实现下面三个步骤。</li>
</ul>
<ol>
<li>首先，使用 template 属性来创建模板。<br>利用 DOM 可以查找到模板的内容，但是模板元素是不会被渲染到页面上的，也就是说 DOM 树中的 template 节点不会出现在布局树中，所以我们可以使用 template 来自定义一些基础的元素结构，这些基础的元素结构是可以被重复使用的。一般模板定义好之后，我们还需要在模板的内部定义样式信息。</li>
<li>其次，我们需要创建一个类。在该类的构造函数中要完成三件事：查找模板内容；创建影子 DOM；再将模板添加到影子 DOM 上。<br>影子 DOM 的作用是将模板中的内容与全局 DOM 和 CSS 进行隔离，这样我们就可以实现元素和样式的私有化了。<br>你可以把影子 DOM 看成是一个作用域，其内部的样式和元素是不会影响到全局的样式和元素的，而在全局环境下，要访问影子 DOM 内部的样式或者元素也是需要通过约定好的接口的。<br>通过影子 DOM，我们就实现了 CSS 和元素的封装，在创建好封装影子 DOM 的类之后，我们就可以使用 customElements.define 来自定义元素了</li>
<li>最后，就很简单了，可以像正常使用 HTML 元素一样使用该元素<br>影子 DOM 内部的样式是不会影响到全局 CSSOM 的。另外，使用 DOM 接口也是无法直接查询到影子 DOM 内部元素的，比如你可以使用document.getElementsByTagName(‘div’)来查找所有 div 元素，这时候你会发现影子 DOM 内部的元素都是无法查找的，因为要想查找影子 DOM 内部的元素需要专门的接口，所以通过这种方式又将影子内部的 DOM 和外部的 DOM 进行了隔离。<br>影子 DOM 的 JavaScript 脚本是不会被隔离的，比如在影子 DOM 定义的 JavaScript 函数依然可以被外部访问，这是因为 JavaScript 语言本身已经可以很好地实现组件化了。<h3 id="浏览器如何实现影子-DOM"><a href="#浏览器如何实现影子-DOM" class="headerlink" title="浏览器如何实现影子 DOM"></a>浏览器如何实现影子 DOM</h3></li>
</ol>
<ul>
<li>影子 DOM 的作用主要有以下两点：</li>
</ul>
<ol>
<li>影子 DOM 中的元素对于整个网页是不可见的；</li>
<li>影子 DOM 的 CSS 不会影响到整个网页的 CSSOM，影子 DOM 内部的 CSS 只对内部的元素起作用。</li>
</ol>
<ul>
<li>每个影子 DOM 都有一个 shadow root 的根节点，我们可以将要展示的样式或者元素添加到影子 DOM 的根节点上，每个影子 DOM 你都可以看成是一个独立的 DOM，它有自己的样式、自己的属性，内部样式不会影响到外部样式，外部样式也不会影响到内部样式。</li>
</ul>
<h2 id="HTTP-1：HTTP性能优化"><a href="#HTTP-1：HTTP性能优化" class="headerlink" title="HTTP/1：HTTP性能优化"></a>HTTP/1：HTTP性能优化</h2><h3 id="超文本传输协议-HTTP-0-9"><a href="#超文本传输协议-HTTP-0-9" class="headerlink" title="超文本传输协议 HTTP/0.9"></a>超文本传输协议 HTTP/0.9</h3><ul>
<li>HTTP/0.9 的实现有以下三个特点。</li>
</ul>
<ol>
<li>第一个是只有一个请求行，并没有 HTTP 请求头和请求体，因为只需要一个请求行就可以完整表达客户端的需求了。</li>
<li>第二个是服务器也没有返回头信息，这是因为服务器端并不需要告诉客户端太多信息，只需要返回数据就可以了。</li>
<li>第三个是返回的文件内容是以 ASCII 字符流来传输的，因为都是 HTML 格式的文件，所以使用 ASCII 字节码来传输是最合适的。<h3 id="被浏览器推动的-HTTP-1-0"><a href="#被浏览器推动的-HTTP-1-0" class="headerlink" title="被浏览器推动的 HTTP/1.0"></a>被浏览器推动的 HTTP/1.0</h3></li>
</ol>
<ul>
<li>浏览器中展示的不单是 HTML 文件了，还包括了 JavaScript、CSS、图片、音频、视频等不同类型的文件。因此支持多种类型的文件下载是 HTTP/1.0 的一个核心诉求，而且文件格式不仅仅局限于 ASCII 编码，还有很多其他类型编码的文件。</li>
<li>HTTP/1.0 引入了请求头和响应头，它们都是以为 Key-Value 形式保存的，在 HTTP 发送请求时，会带上请求头信息，服务器返回数据时，会先返回响应头信息。</li>
<li>HTTP/1.0 是怎么通过请求头和响应头来支持多种不同类型的数据呢？</li>
</ul>
<ol>
<li>首先，浏览器需要知道服务器返回的数据是什么类型的，然后浏览器才能根据不同的数据类型做针对性的处理。</li>
<li>其次，由于万维网所支持的应用变得越来越广，所以单个文件的数据量也变得越来越大。为了减轻传输性能，服务器会对数据进行压缩后再传输，所以浏览器需要知道服务器压缩的方法。</li>
<li>再次，由于万维网是支持全球范围的，所以需要提供国际化的支持，服务器需要对不同的地区提供不同的语言版本，这就需要浏览器告诉服务器它想要什么语言版本的页面。</li>
<li>最后，由于增加了各种不同类型的文件，而每种文件的编码形式又可能不一样，为了能够准确地读取文件，浏览器需要知道文件的编码类型。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 的方案是通过请求头和响应头来进行协商，在发起请求时候会通过 HTTP 请求头告诉服务器它期待服务器返回什么类型的文件、采取什么形式的压缩、提供什么语言的文件以及文件的具体编码。</span><br><span class="line">最终发送出来的请求头内容如下：</span><br><span class="line">accept: text/html   表示期望服务器返回 html 类型的文件</span><br><span class="line">accept-encoding: gzip, deflate, br   期望服务器可以采用 gzip、deflate 或者 br 其中的一种压缩方式</span><br><span class="line">accept-Charset: ISO-8859-1,utf-8  期望返回的文件编码是 UTF-8 或者 ISO-8859-1</span><br><span class="line">accept-language: zh-CN,zh  望页面的优先语言是中文。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">服务器接收到浏览器发送过来的请求头信息之后，会根据请求头的信息来准备响应数据。</span><br><span class="line">不过有时候会有一些意外情况发生，比如浏览器请求的压缩类型是 gzip，但是服务器不支持 gzip，只支持 br 压缩，那么它会通过响应头中的 content-encoding 字段告诉浏览器最终的压缩类型，也就是说最终浏览器需要根据响应头的信息来处理数据。</span><br><span class="line">下面是一段响应头的数据信息：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">content-encoding: br   表示服务器采用了 br 的压缩方法</span><br><span class="line">content-type: text/html; charset=UTF-8   表示服务器返回的是 html 文件，并且该文件的编码类型是 UTF-8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">有了响应头的信息，浏览器就会使用 br 方法来解压文件，</span><br><span class="line">再按照 UTF-8 的编码格式来处理原始文件，最后按照 HTML 的方式来解析该文件。</span><br><span class="line">这就是 HTTP/1.0 支持多文件的一个基本的处理流程。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>HTTP/1.0 除了对多文件提供良好的支持外，还依据当时实际的需求引入了很多其他的特性，这些特性都是通过请求头和响应头来实现的。</li>
</ul>
<ol>
<li>有的请求服务器可能无法处理，或者处理出错，这时候就需要告诉浏览器服务器最终处理该请求的情况，这就引入了状态码。状态码是通过响应行的方式来通知浏览器的。</li>
<li>为了减轻服务器的压力，在 HTTP/1.0 中提供了 Cache 机制，用来缓存已经下载过的数据。</li>
<li>服务器需要统计客户端的基础信息，比如 Windows 和 macOS 的用户数量分别是多少，所以 HTTP/1.0 的请求头中还加入了用户代理的字段。<h3 id="缝缝补补的-HTTP-1-1"><a href="#缝缝补补的-HTTP-1-1" class="headerlink" title="缝缝补补的 HTTP/1.1"></a>缝缝补补的 HTTP/1.1</h3></li>
</ol>
<ul>
<li>改进持久连接</li>
</ul>
<ol>
<li>HTTP/1.0 每进行一次 HTTP 通信，都需要经历建立 TCP 连接、传输 HTTP 数据和断开 TCP 连接三个阶段</li>
<li>随着浏览器普及，单个页面中的图片文件越来越多，有时候一个页面可能包含了几百个外部引用的资源文件，如果在下载每个文件的时候，都需要经历建立 TCP 连接、传输数据和断开连接这样的步骤，无疑会增加大量无谓的开销。<br>为了解决这个问题，HTTP/1.1 中增加了持久连接的方法，它的特点是在一个 TCP 连接上可以传输多个 HTTP 请求，只要浏览器或者服务器没有明确断开连接，那么该 TCP 连接会一直保持。</li>
<li>HTTP 的持久连接可以有效减少 TCP 建立连接和断开连接的次数，这样的好处是减少了服务器额外的负担，并提升整体 HTTP 的请求时长。</li>
<li>持久连接在 HTTP/1.1 中是默认开启的，所以你不需要专门为了持久连接去 HTTP 请求头设置信息，如果你不想要采用持久连接，可以在 HTTP 请求头中加上Connection: close。</li>
<li>目前浏览器中对于同一个域名，默认允许同时建立 6 个 TCP 持久连接。</li>
</ol>
<ul>
<li>不成熟的 HTTP 管线化</li>
</ul>
<ol>
<li>持久连接虽然能减少 TCP 的建立和断开次数，但是它需要等待前面的请求返回之后，才能进行下一次请求。<br>如果 TCP 通道中的某个请求因为某些原因没有及时返回，那么就会阻塞后面的所有请求，这就是著名的队头阻塞的问题。</li>
<li>HTTP/1.1 中试图通过管线化的技术来解决队头阻塞的问题。HTTP/1.1 中的管线化是指将多个 HTTP 请求整批提交给服务器的技术，虽然可以整批发送请求，不过服务器依然需要根据请求顺序来回复浏览器的请求。<br>FireFox、Chrome 都做过管线化的试验，但是由于各种原因，它们最终都放弃了管线化技术。</li>
</ol>
<ul>
<li>提供虚拟主机的支持</li>
</ul>
<ol>
<li>在 HTTP/1.0 中，每个域名绑定了一个唯一的 IP 地址，因此一个服务器只能支持一个域名。但是随着虚拟主机技术的发展，需要实现在一台物理主机上绑定多个虚拟主机，每个虚拟主机都有自己的单独的域名，这些单独的域名都公用同一个 IP 地址。</li>
<li>HTTP/1.1 的请求头中增加了 Host 字段，用来表示当前的域名地址，这样服务器就可以根据不同的 Host 值做不同的处理。</li>
</ol>
<ul>
<li>对动态生成的内容提供了完美支持</li>
</ul>
<ol>
<li>在设计 HTTP/1.0 时，需要在响应头中设置完整的数据大小，如Content-Length: 901，这样浏览器就可以根据设置的数据大小来接收数据。</li>
<li>随着服务器端的技术发展，很多页面的内容都是动态生成的，因此在传输数据之前并不知道最终的数据大小，这就导致了浏览器不知道何时会接收完所有的文件数据。</li>
<li>HTTP/1.1 通过引入 Chunk transfer 机制来解决这个问题，服务器会将数据分割成若干个任意大小的数据块，每个数据块发送时会附上上个数据块的长度，最后使用一个零长度的块作为发送数据完成的标志。这样就提供了对动态内容的支持。</li>
</ol>
<ul>
<li>客户端 Cookie、安全机制</li>
</ul>
<ol>
<li>HTTP/1.1 还引入了客户端 Cookie 机制和安全机制。</li>
</ol>
<h2 id="HTTP-2：如何提升网络速度？"><a href="#HTTP-2：如何提升网络速度？" class="headerlink" title="HTTP/2：如何提升网络速度？"></a>HTTP/2：如何提升网络速度？</h2><ul>
<li>HTTP/1.1 为网络效率做了大量的优化，最核心的有如下三种方式：</li>
</ul>
<ol>
<li>增加了持久连接；</li>
<li>浏览器为每个域名最多同时维护 6 个 TCP 持久连接；</li>
<li>使用 CDN 的实现域名分片机制。<br>引入了 CDN，并同时为每个域名维护 6 个连接，这样就大大减轻了整个资源的下载时间。<br>这里我们可以简单计算下：如果使用单个 TCP 的持久连接，下载 100 个资源所花费的时间为 100 <em> n </em> RTT；<br>若通过上面的技术，就可以把整个时间缩短为 100 <em> n </em> RTT/(6 * CDN 个数)。<br>从这个计算结果来看，我们的页面加载速度变快了不少。<h3 id="HTTP-1-1-的主要问题"><a href="#HTTP-1-1-的主要问题" class="headerlink" title="HTTP/1.1 的主要问题"></a>HTTP/1.1 的主要问题</h3></li>
</ol>
<ul>
<li>HTTP/1.1对带宽的利用率却并不理想，这也是 HTTP/1.1 的一个核心问题。</li>
<li>带宽是指每秒最大能发送或者接收的字节数。我们把每秒能发送的最大字节数称为上行带宽，每秒能够接收的最大字节数称为下行带宽。</li>
<li>之所以说 HTTP/1.1 对带宽的利用率不理想，是因为 HTTP/1.1 很难将带宽用满。比如我们常说的 100M 带宽，实际的下载速度能达到 12.5M/S，而采用 HTTP/1.1 时，也许在加载页面资源时最大只能使用到 2.5M/S，很难将 12.5M 全部用满。</li>
<li>主要是由以下三个原因导致的。</li>
</ul>
<ol>
<li>TCP 的慢启动。<br>一旦一个 TCP 连接建立之后，就进入了发送数据状态，刚开始 TCP 协议会采用一个非常慢的速度去发送数据，<br>然后慢慢加快发送数据的速度，直到发送数据的速度达到一个理想状态，我们把这个过程称为慢启动。</li>
</ol>
<p>慢启动是 TCP 为了减少网络拥塞的一种策略，我们是没有办法改变的。<br>之所以说慢启动会带来性能问题，是因为页面中常用的一些关键资源文件本来就不大，如 HTML 文件、CSS 文件和 JavaScript 文件，通常这些文件在 TCP 连接建立好之后就要发起请求的，但这个过程是慢启动，所以耗费的时间比正常的时间要多很多，这样就推迟了宝贵的首次渲染页面的时长了。</p>
<ol start="2">
<li>同时开启了多条 TCP 连接，那么这些连接会竞争固定的带宽。<br>系统同时建立了多条 TCP 连接，当带宽充足时，每条连接发送或者接收速度会慢慢向上增加；<br>而一旦带宽不足时，这些 TCP 连接又会减慢发送或者接收的速度。</li>
</ol>
<p>比如一个页面有 200 个文件，使用了 3 个 CDN，那么加载该网页的时候就需要建立 6 * 3，也就是 18 个 TCP 连接来下载资源；<br>在下载过程中，当发现带宽不足的时候，各个 TCP 连接就需要动态减慢接收数据的速度。</p>
<p>这样就会出现一个问题，因为有的 TCP 连接下载的是一些关键资源，如 CSS 文件、JavaScript 文件等，而有的 TCP 连接下载的是图片、视频等普通的资源文件，<br>但是多条 TCP 连接之间又不能协商让哪些关键资源优先下载，这样就有可能影响那些关键资源的下载速度了。</p>
<ol start="3">
<li>HTTP/1.1 队头阻塞的问题。<br>HTTP/1.1 中使用持久连接时，虽然能公用一个 TCP 管道，但是在一个管道中同一时刻只能处理一个请求，在当前的请求没有结束之前，其他的请求只能处于阻塞状态。<br>这意味着我们不能随意在一个管道中发送请求和接收内容。</li>
</ol>
<p>这是一个很严重的问题，因为阻塞请求的因素有很多，并且都是一些不确定性的因素，<br>假如有的请求被阻塞了 5 秒，那么后续排队的请求都要延迟等待 5 秒，<br>在这个等待的过程中，带宽、CPU 都被白白浪费了。</p>
<h3 id="HTTP-2-的多路复用"><a href="#HTTP-2-的多路复用" class="headerlink" title="HTTP/2 的多路复用"></a>HTTP/2 的多路复用</h3><ul>
<li>HTTP/2 的思路就是一个域名只使用一个 TCP 长连接来传输数据，这样整个页面资源的下载过程只需要一次慢启动，同时也避免了多个 TCP 连接竞争带宽所带来的问题。</li>
<li>HTTP/2 需要实现资源的并行请求，也就是任何时候都可以将请求发送给服务器，而并不需要等待其他请求的完成，然后服务器也可以随时返回处理好的请求资源给浏览器。</li>
<li>HTTP/2 最核心、最重要且最具颠覆性的多路复用机制。</li>
</ul>
<ol>
<li>每个请求都有一个对应的 ID，如 stream1 表示 index.html 的请求，stream2 表示 foo.css 的请求。这样在浏览器端，就可以随时将请求发送给服务器了。</li>
<li>服务器端接收到这些请求后，会根据自己的喜好来决定优先返回哪些内容，<br>比如服务器可能早就缓存好了 index.html 和 bar.js 的响应头信息，<br>那么当接收到请求的时候就可以立即把 index.html 和 bar.js 的响应头信息返回给浏览器，<br>然后再将 index.html 和 bar.js 的响应体数据返回给浏览器。</li>
<li>之所以可以随意发送，是因为每份数据都有对应的 ID，浏览器接收到之后，会筛选出相同 ID 的内容，将其拼接为完整的 HTTP 响应数据。</li>
<li>HTTP/2 使用了多路复用技术，可以将请求分成一帧一帧的数据去传输，<br>这样带来了一个额外的好处，就是当收到一个优先级高的请求时，比如接收到 JavaScript 或者 CSS 关键资源的请求，服务器可以暂停之前的请求来优先处理关键资源的请求。</li>
</ol>
<h3 id="多路复用的实现"><a href="#多路复用的实现" class="headerlink" title="多路复用的实现"></a>多路复用的实现</h3><ul>
<li>HTTP/2 添加了一个二进制分帧层</li>
</ul>
<ol>
<li>首先，浏览器准备好请求数据，包括了请求行、请求头等信息，如果是 POST 方法，那么还要有请求体。</li>
<li>这些数据经过二进制分帧层处理之后，会被转换为一个个带有请求 ID 编号的帧，通过协议栈将这些帧发送给服务器。</li>
<li>服务器接收到所有帧之后，会将所有相同 ID 的帧合并为一条完整的请求信息。</li>
<li>然后服务器处理该条请求，并将处理的响应行、响应头和响应体分别发送至二进制分帧层。</li>
<li>同样，二进制分帧层会将这些响应数据转换为一个个带有请求 ID 编号的帧，经过协议栈发送给浏览器。</li>
<li>浏览器接收到响应帧之后，会根据 ID 编号将帧的数据提交给对应的请求。</li>
</ol>
<ul>
<li>通过引入二进制分帧层，就实现了 HTTP 的多路复用技术。</li>
</ul>
<h3 id="HTTP-2-其他特性"><a href="#HTTP-2-其他特性" class="headerlink" title="HTTP/2 其他特性"></a>HTTP/2 其他特性</h3><ul>
<li>可以设置请求的优先级</li>
</ul>
<ol>
<li>HTTP/2 提供了请求优先级，可以在发送请求时，标上该请求的优先级，这样服务器接收到请求之后，会优先处理优先级高的请求。</li>
</ol>
<ul>
<li>服务器推送</li>
</ul>
<ol>
<li>HTTP/2 还可以直接将数据提前推送到浏览器。<br>当用户请求一个 HTML 页面之后，服务器知道该 HTML 页面会引用几个重要的 JavaScript 文件和 CSS 文件，<br>那么在接收到 HTML 请求之后，附带将要使用的 CSS 文件和 JavaScript 文件一并发送给浏览器，<br>这样当浏览器解析完 HTML 文件之后，就能直接拿到需要的 CSS 文件和 JavaScript 文件，<br>这对首次打开页面的速度起到了至关重要的作用。</li>
</ol>
<ul>
<li>头部压缩</li>
</ul>
<ol>
<li>HTTP/2 对请求头和响应头进行了压缩<br>你可能觉得一个 HTTP 的头文件没有多大，压不压缩可能关系不大，<br>但你这样想一下，在浏览器发送请求的时候，基本上都是发送 HTTP 请求头，很少有请求体的发送，<br>通常情况下页面也有 100 个左右的资源，如果将这 100 个请求头的数据压缩为原来的 20%，那么传输效率肯定能得到大幅提升。</li>
</ol>
<h2 id="HTTP-3：甩掉TCP、TLS-的包袱，构建高效网络"><a href="#HTTP-3：甩掉TCP、TLS-的包袱，构建高效网络" class="headerlink" title="HTTP/3：甩掉TCP、TLS 的包袱，构建高效网络"></a>HTTP/3：甩掉TCP、TLS 的包袱，构建高效网络</h2><ul>
<li>从目前的情况来看，HTTP/2 似乎可以完美取代 HTTP/1 了，不过 HTTP/2 依然存在一些缺陷，于是就有了 HTTP/3。和通常一样，介绍 HTTP/3 之前，我们先来看看 HTTP/2 到底有什么缺陷。<h3 id="TCP-的队头阻塞"><a href="#TCP-的队头阻塞" class="headerlink" title="TCP 的队头阻塞"></a>TCP 的队头阻塞</h3></li>
<li>虽然 HTTP/2 解决了应用层面的队头阻塞问题，不过和 HTTP/1.1 一样，HTTP/2 依然是基于 TCP 协议的，而 TCP 最初就是为了单连接而设计的</li>
<li>你可以把 TCP 连接看成是两台计算机之前的一个虚拟管道，计算机的一端将要传输的数据按照顺序放入管道，最终数据会以相同的顺序出现在管道的另外一头。</li>
<li>HTTP/1.1 协议栈中 TCP 是如何传输数据的</li>
</ul>
<ol>
<li>从一端发送给另外一端的数据会被拆分为一个个按照顺序排列的数据包</li>
<li>这些数据包通过网络传输到了接收端，接收端再按照顺序将这些数据包组合成原始数据，这样就完成了数据传输。</li>
<li>如果在数据传输的过程中，有一个数据因为网络故障或者其他原因而丢包了，那么整个 TCP 的连接就会处于暂停状态，需要等待丢失的数据包被重新传输过来。</li>
<li>你可以把 TCP 连接看成是一个按照顺序传输数据的管道，管道中的任意一个数据丢失了，那之后的数据都需要等待该数据的重新传输。</li>
</ol>
<ul>
<li>在 TCP 传输过程中，由于单个数据包的丢失而造成的阻塞称为 TCP 上的队头阻塞。</li>
<li>HTTP/2 是怎么传输多路请求的</li>
</ul>
<ol>
<li>在 HTTP/2 中，多个请求是跑在一个 TCP 管道中的，如果其中任意一路数据流中出现了丢包的情况，那么就会阻塞该 TCP 连接中的所有请求。</li>
<li>这不同于 HTTP/1.1，使用 HTTP/1.1 时，浏览器为每个域名开启了 6 个 TCP 连接，如果其中的 1 个 TCP 连接发生了队头阻塞，那么其他的 5 个连接依然可以继续传输数据。</li>
<li>所以随着丢包率的增加，HTTP/2 的传输效率也会越来越差。有测试数据表明，当系统达到了 2% 的丢包率时，HTTP/1.1 的传输效率反而比 HTTP/2 表现得更好<h3 id="TCP-建立连接的延时"><a href="#TCP-建立连接的延时" class="headerlink" title="TCP 建立连接的延时"></a>TCP 建立连接的延时</h3></li>
</ol>
<ul>
<li>网络延迟又称为 RTT（Round Trip Time）。我们把从浏览器发送一个数据包到服务器，再从服务器返回数据包到浏览器的整个往返时间称为 RTT。RTT 是反映网络性能的一个重要指标。</li>
<li>建立 TCP 连接时，需要花费多少个 RTT 呢？下面我们来计算下。</li>
</ul>
<ol>
<li>如果使用 HTTPS 的话，还需要使用 TLS 协议进行安全传输，而使用 TLS 也需要一个握手过程，这样就需要有两个握手延迟过程。</li>
<li>在建立 TCP 连接的时候，需要和服务器进行三次握手来确认连接成功，也就是说需要在消耗完 1.5 个 RTT 之后才能进行数据传输。</li>
<li>进行 TLS 连接，TLS 有两个版本——TLS1.2 和 TLS1.3，每个版本建立连接所花的时间不同，大致是需要 1～2 个 RTT</li>
<li>总之，在传输数据之前，我们需要花掉 3～4 个 RTT。如果浏览器和服务器的物理距离较近，那么 1 个 RTT 的时间可能在 10 毫秒以内，也就是说总共要消耗掉 30～40 毫秒。这个时间也许用户还可以接受，但如果服务器相隔较远，那么 1 个 RTT 就可能需要 100 毫秒以上了，这种情况下整个握手过程需要 300～400 毫秒，这时用户就能明显地感受到“慢”了。<h3 id="TCP-协议僵化"><a href="#TCP-协议僵化" class="headerlink" title="TCP 协议僵化"></a>TCP 协议僵化</h3></li>
</ol>
<ul>
<li>中间设备的僵化。</li>
</ul>
<ol>
<li>我们知道互联网是由多个网络互联的网状结构，为了能够保障互联网的正常工作，我们需要在互联网的各处搭建各种设备，这些设备就被称为中间设备。</li>
<li>这些中间设备有很多种类型，并且每种设备都有自己的目的，这些设备包括了路由器、防火墙、NAT、交换机等。它们通常依赖一些很少升级的软件，这些软件使用了大量的 TCP 特性，这些功能被设置之后就很少更新了。</li>
<li>所以，如果我们在客户端升级了 TCP 协议，但是当新协议的数据包经过这些中间设备时，它们可能不理解包的内容，于是这些数据就会被丢弃掉。这就是中间设备僵化，它是阻碍 TCP 更新的一大障碍。</li>
</ol>
<ul>
<li>除了中间设备僵化外，操作系统也是导致 TCP 协议僵化的另外一个原因。</li>
</ul>
<ol>
<li>因为 TCP 协议都是通过操作系统内核来实现的，应用程序只能使用不能修改。通常操作系统的更新都滞后于软件的更新，因此要想自由地更新内核中的 TCP 协议也是非常困难的。QUIC 协议<h3 id="QUIC-协议"><a href="#QUIC-协议" class="headerlink" title="QUIC 协议"></a>QUIC 协议</h3></li>
</ol>
<ul>
<li>HTTP/3 选择了一个折衷的方法——UDP 协议，基于 UDP 实现了类似于 TCP 的多路数据流、传输可靠性等功能，我们把这套功能称为 QUIC 协议。</li>
<li>HTTP/3 中的 QUIC 协议集合了以下几点功能。</li>
</ul>
<ol>
<li>实现了类似 TCP 的流量控制、传输可靠性的功能。虽然 UDP 不提供可靠性的传输，但 QUIC 在 UDP 的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些 TCP 中存在的特性。</li>
<li>集成了 TLS 加密功能。目前 QUIC 使用的是 TLS1.3，相较于早期版本 TLS1.3 有更多的优点，其中最重要的一点是减少了握手所花费的 RTT 个数。</li>
<li>实现了 HTTP/2 中的多路复用功能。和 TCP 不同，QUIC 实现了在同一物理连接上可以有多个独立的逻辑数据流。实现了数据流的单独传输，就解决了 TCP 中队头阻塞的问题。</li>
<li>实现了快速握手功能。由于 QUIC 是基于 UDP 的，所以 QUIC 可以实现使用 0-RTT 或者 1-RTT 来建立连接，这意味着 QUIC 可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度。<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3></li>
</ol>
<ul>
<li>HTTP/3 正是基于 QUIC 协议的，你可以把 QUIC 看成是集成了“TCP+HTTP/2 的多路复用 +TLS 等功能”的一套协议。</li>
<li>这是集众家所长的一个协议，从协议最底层对 Web 的文件传输做了比较彻底的优化，所以等生态相对成熟时，可以用来打造比现在的 HTTP/2 还更加高效的网络。</li>
</ul>
<h2 id="同源策略：为什么XMLHttpRequest不能跨域请求资源？"><a href="#同源策略：为什么XMLHttpRequest不能跨域请求资源？" class="headerlink" title="同源策略：为什么XMLHttpRequest不能跨域请求资源？"></a>同源策略：为什么XMLHttpRequest不能跨域请求资源？</h2><h3 id="什么是同源策略"><a href="#什么是同源策略" class="headerlink" title="什么是同源策略"></a>什么是同源策略</h3><ul>
<li>如果两个 URL 的协议、域名和端口都相同，我们就称这两个 URL 同源。</li>
<li>浏览器默认两个相同的源之间是可以相互访问资源和操作 DOM 的。两个不同的源之间若想要相互访问资源或者操作 DOM，那么会有一套基础的安全策略的制约，我们把这称为同源策略。</li>
<li>同源策略主要表现在 DOM、Web 数据和网络这三个层面。</li>
</ul>
<ol>
<li><p>第一个，DOM 层面。同源策略限制了来自不同源的 JavaScript 脚本对当前 DOM 对象读和写的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">let pdom = opener.document</span><br><span class="line">pdom.body.style.display = &quot;none&quot;</span><br><span class="line">&#125;</span><br><span class="line">该代码中，对象 opener 就是指向第一个页面的 window 对象，我们可以通过操作 opener 来控制第一个页面中的 DOM。</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二个，数据层面。同源策略限制了不同源的站点读取当前站点的 Cookie、IndexDB、LocalStorage 等数据。</p>
</li>
<li>第三个，网络层面。同源策略限制了通过 XMLHttpRequest 等方式将站点的数据发送给不同源的站点。</li>
</ol>
<h3 id="安全和便利性的权衡"><a href="#安全和便利性的权衡" class="headerlink" title="安全和便利性的权衡"></a>安全和便利性的权衡</h3><ul>
<li>页面中可以嵌入第三方资源</li>
</ul>
<ol>
<li>为了解决 XSS 攻击，浏览器中引入了内容安全策略，称为 CSP。</li>
<li>CSP 的核心思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联 JavaScript 代码。通过这些手段就可以大大减少 XSS 攻击。</li>
</ol>
<ul>
<li>跨域资源共享和跨文档消息机制</li>
</ul>
<ol>
<li>跨域资源共享（CORS），使用该机制可以进行跨域访问控制，从而使跨域数据传输得以安全进行。</li>
<li>在实际应用中，经常需要两个不同源的 DOM 之间进行通信，于是浏览器中又引入了跨文档消息机制，可以通过 window.postMessage 的 JavaScript 接口来和不同源的 DOM 进行通信。</li>
</ol>
<h2 id="跨站脚本攻击（XSS）：为什么Cookie中有HttpOnly属性？"><a href="#跨站脚本攻击（XSS）：为什么Cookie中有HttpOnly属性？" class="headerlink" title="跨站脚本攻击（XSS）：为什么Cookie中有HttpOnly属性？"></a>跨站脚本攻击（XSS）：为什么Cookie中有HttpOnly属性？</h2><h3 id="什么是-XSS-攻击"><a href="#什么是-XSS-攻击" class="headerlink" title="什么是 XSS 攻击"></a>什么是 XSS 攻击</h3><ul>
<li>XSS 全称是 Cross Site Scripting，为了与“CSS”区分开来，故简称 XSS，翻译过来就是“跨站脚本”。</li>
<li>XSS 攻击是指黑客往 HTML 文件中或者 DOM 中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段。</li>
<li>如果页面被注入了恶意 JavaScript 脚本，恶意脚本都能做哪些事情</li>
</ul>
<ol>
<li>可以窃取 Cookie 信息。恶意 JavaScript 可以通过“document.cookie”获取 Cookie 信息，然后通过 XMLHttpRequest 或者 Fetch 加上 CORS 功能将数据发送给恶意服务器；恶意服务器拿到用户的 Cookie 信息之后，就可以在其他电脑上模拟用户的登录，然后进行转账等操作。</li>
<li>可以监听用户行为。恶意 JavaScript 可以使用“addEventListener”接口来监听键盘事件，比如可以获取用户输入的信用卡等信息，将其发送到恶意服务器。黑客掌握了这些信息之后，又可以做很多违法的事情。</li>
<li>可以通过修改 DOM 伪造假的登录窗口，用来欺骗用户输入用户名和密码等信息。</li>
<li>还可以在页面内生成浮窗广告，这些广告会严重地影响用户体验。<h3 id="恶意脚本是怎么注入的"><a href="#恶意脚本是怎么注入的" class="headerlink" title="恶意脚本是怎么注入的"></a>恶意脚本是怎么注入的</h3></li>
</ol>
<ul>
<li>通常情况下，主要有存储型 XSS 攻击、反射型 XSS 攻击和基于 DOM 的 XSS 攻击三种方式来注入恶意脚本。</li>
</ul>
<ol>
<li>存储型 XSS 攻击<br>①首先黑客利用站点漏洞将一段恶意 JavaScript 代码提交到网站的数据库中；<br>②然后用户向网站请求包含了恶意 JavaScript 脚本的页面；<br>③当用户浏览该页面的时候，恶意脚本就会将用户的 Cookie 信息等数据上传到服务器<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">下面我们来看个例子，2015 年喜马拉雅就被曝出了存储型 XSS 漏洞。</span><br><span class="line">起因是在用户设置专辑名称时，服务器对关键字过滤不严格，比如可以将专辑名称设置为一段 JavaScript，</span><br><span class="line"></span><br><span class="line">当黑客将专辑名称设置为一段 JavaScript 代码并提交时，喜马拉雅的服务器会保存该段 JavaScript 代码到数据库中。</span><br><span class="line">然后当用户打开黑客设置的专辑时，这段代码就会在用户的页面里执行，这样就可以获取用户的 Cookie 等数据信息。</span><br><span class="line">当用户打开黑客设置的专辑页面时，服务器也会将这段恶意 JavaScript 代码返回给用户，因此这段恶意脚本就在用户的页面中执行了。</span><br><span class="line"></span><br><span class="line">恶意脚本可以通过 XMLHttpRequest 或者 Fetch 将用户的 Cookie 数据上传到黑客的服务器。</span><br><span class="line">黑客拿到了用户 Cookie 信息之后，就可以利用 Cookie 信息在其他机器上登录该用户的账号，并利用用户账号进行一些恶意操作。</span><br><span class="line"></span><br><span class="line">以上就是存储型 XSS 攻击的一个典型案例，这是乌云网在 2015 年曝出来的。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="反射型-XSS-攻击"><a href="#反射型-XSS-攻击" class="headerlink" title="反射型 XSS 攻击"></a>反射型 XSS 攻击</h3><ul>
<li>在一个反射型 XSS 攻击过程中，恶意 JavaScript 脚本属于用户发送给网站请求中的一部分，随后网站又把恶意 JavaScript 脚本返回给用户。当恶意 JavaScript 脚本在用户页面中被执行时，黑客就可以利用该脚本做一些恶意操作。</li>
<li><p>下面我们结合一个简单的 Node 服务程序来看看什么是反射型 XSS。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">首先我们使用 Node 来搭建一个简单的页面环境，搭建好的服务代码如下所示：</span><br><span class="line">var express = require(&apos;express&apos;);</span><br><span class="line">var router = express.Router();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* GET home page. */</span><br><span class="line">router.get(&apos;/&apos;, function(req, res, next) &#123;</span><br><span class="line">  res.render(&apos;index&apos;, &#123; title: &apos;Express&apos;,xss:req.query.xss &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">module.exports = router;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;title&gt;&lt;%= title %&gt;&lt;/title&gt;</span><br><span class="line">  &lt;link rel=&apos;stylesheet&apos; href=&apos;/stylesheets/style.css&apos; /&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;h1&gt;&lt;%= title %&gt;&lt;/h1&gt;</span><br><span class="line">  &lt;p&gt;Welcome to &lt;%= title %&gt;&lt;/p&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">      &lt;%- xss %&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">上面这两段代码，第一段是路由，第二段是视图，作用是将 URL 中 xss 参数的内容显示在页面。我们可以在本地演示下，比如打开http://localhost:3000/?xss=123这个链接，这样在页面中展示就是“123”了，是正常的，没有问题的。</span><br><span class="line">但当打开http://localhost:3000/?xss=&lt;script&gt;alert(&apos;你被xss攻击了&apos;)&lt;/script&gt;这段 URL 时</span><br><span class="line"></span><br><span class="line">通过这个操作，我们会发现用户将一段含有恶意代码的请求提交给 Web 服务器，Web 服务器接收到请求时，又将恶意代码反射给了浏览器端，这就是反射型 XSS 攻击。</span><br><span class="line">在现实生活中，黑客经常会通过 QQ 群或者邮件等渠道诱导用户去点击这些恶意链接，所以对于一些链接我们一定要慎之又慎。</span><br></pre></td></tr></table></figure>
</li>
<li><p>另外需要注意的是，Web 服务器不会存储反射型 XSS 攻击的恶意脚本，这是和存储型 XSS 攻击不同的地方。</p>
</li>
</ul>
<h3 id="基于-DOM-的-XSS-攻击"><a href="#基于-DOM-的-XSS-攻击" class="headerlink" title="基于 DOM 的 XSS 攻击"></a>基于 DOM 的 XSS 攻击</h3><ul>
<li>基于 DOM 的 XSS 攻击是不牵涉到页面 Web 服务器的。具体来讲，黑客通过各种手段将恶意脚本注入用户的页面中，比如通过网络劫持在页面传输过程中修改 HTML 页面的内容，这种劫持类型很多，有通过 WiFi 路由器劫持的，有通过本地恶意软件来劫持的，它们的共同点是在 Web 资源传输过程或者在用户使用页面的过程中修改 Web 页面的数据。</li>
</ul>
<h3 id="如何阻止-XSS-攻击"><a href="#如何阻止-XSS-攻击" class="headerlink" title="如何阻止 XSS 攻击"></a>如何阻止 XSS 攻击</h3><ul>
<li>存储型 XSS 攻击和反射型 XSS 攻击都是需要经过 Web 服务器来处理的，因此可以认为这两种类型的漏洞是服务端的安全漏洞。</li>
<li>而基于 DOM 的 XSS 攻击全部都是在浏览器端完成的，因此基于 DOM 的 XSS 攻击是属于前端的安全漏洞。</li>
<li>无论是何种类型的 XSS 攻击，它们都有一个共同点，那就是首先往浏览器中注入恶意脚本，然后再通过恶意脚本将用户信息发送至黑客部署的恶意服务器上。</li>
<li>一些常用的阻止 XSS 攻击的策略。</li>
</ul>
<ol>
<li><p>服务器对输入脚本进行过滤或转码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">不管是反射型还是存储型 XSS 攻击，我们都可以在服务器端将一些关键的字符进行转码，比如最典型的：</span><br><span class="line">code:&lt;script&gt;alert(&apos;你被xss攻击了&apos;)&lt;/script&gt;</span><br><span class="line">这段代码过滤后，只留下了：</span><br><span class="line">code:</span><br><span class="line">这样，当用户再次请求该页面时，由于&lt;script&gt;标签的内容都被过滤了，所以这段脚本在客户端是不可能被执行的。</span><br><span class="line">除了过滤之外，服务器还可以对这些内容进行转码，还是上面那段代码，经过转码之后，效果如下所示：</span><br><span class="line">code:&amp;lt;script&amp;gt;alert(&amp;#39;你被xss攻击了&amp;#39;)&amp;lt;/script&amp;gt;</span><br><span class="line">经过转码之后的内容，如&lt;script&gt;标签被转换为&amp;lt;script&amp;gt;，因此即使这段脚本返回给页面，页面也不会执行这段脚本。</span><br></pre></td></tr></table></figure>
</li>
<li><p>充分利用 CSP<br>虽然在服务器端执行过滤或者转码可以阻止 XSS 攻击的发生，但完全依靠服务器端依然是不够的，我们还需要把 CSP 等策略充分地利用起来，以降低 XSS 攻击带来的风险和后果。<br>实施严格的 CSP 可以有效地防范 XSS 攻击，具体来讲 CSP 有如下几个功能：<br>①限制加载其他域下的资源文件，这样即使黑客插入了一个 JavaScript 文件，这个 JavaScript 文件也是无法被加载的；<br>②禁止向第三方域提交数据，这样用户数据也不会外泄；<br>③禁止执行内联脚本和未授权的脚本；<br>④还提供了上报机制，这样可以帮助我们尽快发现有哪些 XSS 攻击，以便尽快修复问题</p>
</li>
<li>使用 HttpOnly 属性<br>由于很多 XSS 攻击都是来盗用 Cookie 的，因此还可以通过使用 HttpOnly 属性来保护我们 Cookie 的安全。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">通常服务器可以将某些 Cookie 设置为 HttpOnly 标志，HttpOnly 是服务器通过 HTTP 响应头来设置的，下面是打开 Google 时，HTTP 响应头中的一段：</span><br><span class="line"></span><br><span class="line">set-cookie: NID=189=M8q2FtWbsR8RlcldPVt7qkrqR38LmFY9jUxkKo3-4Bi6Qu_ocNOat7nkYZUTzolHjFnwBw0izgsATSI7TZyiiiaV94qGh-BzEYsNVa7TZmjAYTxYTOM9L_-0CN9ipL6cXi8l6-z41asXtm2uEwcOC5oh9djkffOMhWqQrlnCtOI; expires=Sat, 18-Apr-2020 06:52:22 GMT; path=/; domain=.google.com; HttpOnly</span><br><span class="line"></span><br><span class="line">我们可以看到，set-cookie 属性值最后使用了 HttpOnly 来标记该 Cookie。顾名思义，使用 HttpOnly 标记的 Cookie 只能使用在 HTTP 请求过程中，所以无法通过 JavaScript 来读取这段 Cookie。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">由于 JavaScript 无法读取设置了 HttpOnly 的 Cookie 数据，所以即使页面被注入了恶意 JavaScript 脚本，也是无法获取到设置了 HttpOnly 的数据。因此一些比较重要的数据我们建议设置 HttpOnly 标志。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><ul>
<li>XSS 攻击就是黑客往页面中注入恶意脚本，然后将页面的一些重要数据上传到恶意服务器。常见的三种 XSS 攻击模式是存储型 XSS 攻击、反射型 XSS 攻击和基于 DOM 的 XSS 攻击。</li>
<li>针对这些 XSS 攻击，主要有三种防范策略，第一种是通过服务器对输入的内容进行过滤或者转码，第二种是充分利用好 CSP，第三种是使用 HttpOnly 来保护重要的 Cookie 信息。</li>
<li>当然除了以上策略之外，我们还可以通过添加验证码防止脚本冒充用户提交危险操作。而对于一些不受信任的输入，还可以限制其输入长度，这样可以增大 XSS 攻击的难度。</li>
</ul>
<h2 id="CSRF攻击：陌生链接不要随便点"><a href="#CSRF攻击：陌生链接不要随便点" class="headerlink" title="CSRF攻击：陌生链接不要随便点"></a>CSRF攻击：陌生链接不要随便点</h2><ul>
<li>结合一个真实的关于 CSRF 攻击的典型案例来分析下，在 2007 年的某一天，David 无意间打开了 Gmail 邮箱中的一份邮件，并点击了该邮件中的一个链接。过了几天，David 就发现他的域名被盗了。不过几经周折，David 还是要回了他的域名，也弄清楚了他的域名之所以被盗，就是因为无意间点击的那个链接。</li>
<li>那 David 的域名是怎么被盗的呢？</li>
</ul>
<ol>
<li>首先 David 发起登录 Gmail 邮箱请求，然后 Gmail 服务器返回一些登录状态给 David 的浏览器，这些信息包括了 Cookie、Session 等，这样在 David 的浏览器中，Gmail 邮箱就处于登录状态了。</li>
<li>接着黑客通过各种手段引诱 David 去打开他的链接，比如 hacker.com，然后在 hacker.com 页面中，黑客编写好了一个邮件过滤器，并通过 Gmail 提供的 HTTP 设置接口设置好了新的邮件过滤功能，该过滤器会将 David 所有的邮件都转发到黑客的邮箱中。</li>
<li>最后的事情就很简单了，因为有了 David 的邮件内容，所以黑客就可以去域名服务商那边重置 David 域名账户的密码，重置好密码之后，就可以将其转出到黑客的账户了。<h3 id="什么是-CSRF-攻击"><a href="#什么是-CSRF-攻击" class="headerlink" title="什么是 CSRF 攻击"></a>什么是 CSRF 攻击</h3></li>
</ol>
<ul>
<li>CSRF 英文全称是 Cross-site request forgery，所以又称为“跨站请求伪造”</li>
<li>指黑客引诱用户打开黑客的网站，在黑客的网站中，利用用户的登录状态发起的跨站请求。</li>
<li>简单来讲，CSRF 攻击就是黑客利用了用户的登录状态，并通过第三方的站点来做一些坏事。</li>
<li>通常当用户打开了黑客的页面后，黑客有三种方式去实施 CSRF 攻击。</li>
</ul>
<ol>
<li><p>自动发起 Get 请求<br>黑客最容易实施的攻击方式是自动发起 Get 请求，具体攻击方式你可以参考下面这段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;h1&gt;黑客的站点：CSRF攻击演示&lt;/h1&gt;</span><br><span class="line">    &lt;img src=&quot;https://diamonds.org/sendcoin?user=hacker&amp;number=100&quot;&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这是黑客页面的 HTML 代码，在这段代码中，黑客将转账的请求接口隐藏在 img 标签内，欺骗浏览器这是一张图片资源。</span><br><span class="line">当该页面被加载时，浏览器会自动发起 img 的资源请求，如果服务器没有对该请求做判断的话，那么服务器就会认为该请求是一个转账请求，于是用户账户上的钱就被转移到黑客的账户上去了。</span><br></pre></td></tr></table></figure>
</li>
<li><p>自动发起 POST 请求</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">除了自动发送 Get 请求之外，有些服务器的接口是使用 POST 方法的，所以黑客还需要在他的站点上伪造 POST 请求，</span><br><span class="line">当用户打开黑客的站点时，是自动提交 POST 请求，具体的方式你可以参考下面示例代码：</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;h1&gt;黑客的站点：CSRF攻击演示&lt;/h1&gt;</span><br><span class="line">  &lt;form id=&apos;hacker-form&apos; action=&quot;https://diamonds.org/sendcoin&quot; method=POST&gt;</span><br><span class="line">    &lt;input type=&quot;hidden&quot; name=&quot;user&quot; value=&quot;hacker&quot; /&gt;</span><br><span class="line">    &lt;input type=&quot;hidden&quot; name=&quot;number&quot; value=&quot;100&quot; /&gt;</span><br><span class="line">  &lt;/form&gt;</span><br><span class="line">  &lt;script&gt; document.getElementById(&apos;hacker-form&apos;).submit(); &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在这段代码中，我们可以看到黑客在他的页面中构建了一个隐藏的表单，该表单的内容就是网站的转账接口。</span><br><span class="line">当用户打开该站点之后，这个表单会被自动执行提交；</span><br><span class="line">当表单被提交之后，服务器就会执行转账操作。</span><br><span class="line">因此使用构建自动提交表单这种方式，就可以自动实现跨站点 POST 数据提交。</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>引诱用户点击链接<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">除了自动发起 Get 和 Post 请求之外，还有一种方式是诱惑用户点击黑客站点上的链接，这种方式通常出现在论坛或者恶意邮件上。</span><br><span class="line">黑客会采用很多方式去诱惑用户点击链接，示例代码如下所示：</span><br><span class="line"></span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;img width=150 src=http://images.xuejuzi.cn/1612/1_161230185104_1.jpg&gt; &lt;/img&gt; &lt;/div&gt; &lt;div&gt;</span><br><span class="line">  &lt;a href=&quot;https://diamonds.org/sendcoin?user=hacker&amp;number=100&quot; taget=&quot;_blank&quot;&gt;</span><br><span class="line">    点击下载美女照片</span><br><span class="line">  &lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">这段黑客站点代码，页面上放了一张美女图片，下面放了图片下载地址，而这个下载地址实际上是黑客用来转账的接口，一旦用户点击了这个链接，那么他的钱就被转到黑客账户上了。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>和 XSS 不同的是，CSRF 攻击不需要将恶意代码注入用户的页面，仅仅是利用服务器的漏洞和用户的登录状态来实施攻击。<h3 id="如何防止-CSRF-攻击"><a href="#如何防止-CSRF-攻击" class="headerlink" title="如何防止 CSRF 攻击"></a>如何防止 CSRF 攻击</h3></li>
<li>CSRF 攻击的三个必要条件：</li>
</ul>
<ol>
<li>第一个，目标站点一定要有 CSRF 漏洞；</li>
<li>第二个，用户要登录过目标站点，并且在浏览器上保持有该站点的登录状态；</li>
<li>第三个，需要用户打开一个第三方站点，可以是黑客的站点，也可以是一些论坛。</li>
</ol>
<ul>
<li>满足以上三个条件之后，黑客就可以对用户进行 CSRF 攻击了。这里还需要额外注意一点，与 XSS 攻击不同，CSRF 攻击不会往页面注入恶意脚本，因此黑客是无法通过 CSRF 攻击来获取用户页面数据的；</li>
<li>其最关键的一点是要能找到服务器的漏洞，所以说对于 CSRF 攻击我们主要的防护手段是提升服务器的安全性。</li>
<li>要让服务器避免遭受到 CSRF 攻击，通常有以下几种途径。</li>
</ul>
<ol>
<li>充分利用好 Cookie 的 SameSite 属性<br>①黑客会利用用户的登录状态来发起 CSRF 攻击，而 Cookie 正是浏览器和服务器之间维护登录状态的一个关键数据，因此要阻止 CSRF 攻击，我们首先就要考虑在 Cookie 上来做文章。<br>②通常 CSRF 攻击都是从第三方站点发起的，要防止 CSRF 攻击，我们最好能实现从第三方站点发送请求时禁止 Cookie 的发送，因此在浏览器通过不同来源发送 HTTP 请求时，有如下区别：<br>如果是从第三方站点发起的请求，那么需要浏览器禁止发送某些关键 Cookie 数据到服务器；<br>如果是同一个站点发起的请求，那么就需要保证 Cookie 数据正常发送。<br>③而我们要聊的 Cookie 中的 SameSite 属性正是为了解决这个问题的，通过使用 SameSite 可以有效地降低 CSRF 攻击的风险。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在 HTTP 响应头中，通过 set-cookie 字段设置 Cookie 时，可以带上 SameSite 选项，如下：</span><br><span class="line">set-cookie: 1P_JAR=2019-10-20-06; expires=Tue, 19-Nov-2019 06:36:21 GMT; path=/; domain=.google.com; SameSite=none</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SameSite 选项通常有 Strict、Lax 和 None 三个值。</span><br><span class="line">1. Strict 最为严格。如果 SameSite 的值是 Strict，那么浏览器会完全禁止第三方 Cookie。</span><br><span class="line">简言之，如果你从a页面中访问 b的资源，而 b 的某些 Cookie 设置了 SameSite = Strict 的话，</span><br><span class="line">那么这些 Cookie 是不会被发送到 b 的服务器上的。</span><br><span class="line">只有你从 b的站点去请求 b的资源时，才会带上这些 Cookie。</span><br><span class="line">2.Lax 相对宽松一点。在跨站点的情况下，从第三方站点的链接打开和从第三方站点提交 Get 方式的表单这两种方式都会携带 Cookie。</span><br><span class="line">但如果在第三方站点中使用 Post 方法，或者通过 img、iframe 等标签加载的 URL，这些场景都不会携带 Cookie。</span><br><span class="line">3.而如果使用 None 的话，在任何情况下都会发送 Cookie 数据。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>④对于防范 CSRF 攻击，我们可以针对实际情况将一些关键的 Cookie 设置为 Strict 或者 Lax 模式，这样在跨站点请求时，这些关键的 Cookie 就不会被发送到服务器，从而使得黑客的 CSRF 攻击失效。</p>
<ol start="2">
<li>验证请求的来源站点<br>①在服务器端验证请求来源的站点。<br>②Referer 是 HTTP 请求头中的一个字段，记录了该 HTTP 请求的来源地址。<br>③虽然可以通过 Referer 告诉服务器 HTTP 请求的来源，但是有一些场景是不适合将来源 URL 暴露给服务器的，因此浏览器提供给开发者一个选项，可以不用上传 Referer 值，具体可参考 Referrer Policy。<br>④但在服务器端验证请求头中的 Referer 并不是太可靠，因此标准委员会又制定了 Origin 属性，在一些重要的场合，比如通过 XMLHttpRequest、Fecth 发起跨站请求或者通过 Post 方法发送请求时，都会带上 Origin 属性<br>Origin 属性只包含了域名信息，并没有包含具体的 URL 路径，这是 Origin 和 Referer 的一个主要区别。<br>Origin 的值之所以不包含详细路径信息，是有些站点因为安全考虑，不想把源站点的详细路径暴露给服务器。<br>⑤因此，服务器的策略是优先判断 Origin，如果请求头中没有包含 Origin 属性，再根据实际情况判断是否使用 Referer 值。</li>
<li>CSRF Token<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">大致分为两步：</span><br><span class="line">第一步，在浏览器向服务器发起请求时，服务器生成一个 CSRF Token。</span><br><span class="line">CSRF Token 其实就是服务器生成的字符串，然后将该字符串植入到返回的页面中。你可以参考下面示例代码：</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form action=&quot;https://diamonds.org/sendcoin&quot; method=&quot;POST&quot;&gt;</span><br><span class="line">      &lt;input type=&quot;hidden&quot; name=&quot;csrf-token&quot; value=&quot;nc98P987bcpncYhoadjoiydc9ajDlcn&quot;&gt;</span><br><span class="line">      &lt;input type=&quot;text&quot; name=&quot;user&quot;&gt;</span><br><span class="line">      &lt;input type=&quot;text&quot; name=&quot;number&quot;&gt;</span><br><span class="line">      &lt;input type=&quot;submit&quot;&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第二步，在浏览器端如果要发起转账的请求，那么需要带上页面中的 CSRF Token，然后服务器会验证该 Token 是否合法。</span><br><span class="line">如果是从第三方站点发出的请求，那么将无法获取到 CSRF Token 的值，所以即使发出了请求，服务器也会因为 CSRF Token 不正确而拒绝请求。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="安全沙箱：页面和系统之间的隔离墙"><a href="#安全沙箱：页面和系统之间的隔离墙" class="headerlink" title="安全沙箱：页面和系统之间的隔离墙"></a>安全沙箱：页面和系统之间的隔离墙</h2><ul>
<li>在最开始的阶段，浏览器是单进程的，这意味着渲染过程、JavaScript 执行过程、网络加载过程、UI 绘制过程和页面显示过程等都是在同一个进程中执行的，这种结构虽然简单，但是也带来了很多问题。</li>
<li>从稳定性视角来看，单进程架构的浏览器是不稳定的，因为只要浏览器进程中的任意一个功能出现异常都有可能影响到整个浏览器，如页面卡死、浏览器崩溃等。</li>
<li>浏览器本身的漏洞是单进程浏览器的一个主要问题，如果浏览器被曝出存在漏洞，那么在这些漏洞没有被及时修复的情况下，黑客就有可能通过恶意的页面向浏览器中注入恶意程序，其中最常见的攻击方式是利用缓冲区溢出，不过需要注意这种类型的攻击和 XSS 注入的脚本是不一样的。</li>
</ul>
<ol>
<li>XSS 攻击只是将恶意的 JavaScript 脚本注入到页面中，虽然能窃取一些 Cookie 相关的数据，但是 XSS 无法对操作系统进行攻击。</li>
<li>而通过浏览器漏洞进行的攻击是可以入侵到浏览器进程内部的，可以读取和修改浏览器进程内部的任意内容，还可以穿透浏览器，在用户的操作系统上悄悄地安装恶意软件、监听用户键盘输入信息以及读取用户硬盘上的文件内容。</li>
<li>和 XSS 攻击页面相比，这类攻击无疑是枚“核弹”，它会将整个操作系统的内容都暴露给黑客，这样我们操作系统上所有的资料都是不安全的了。</li>
</ol>
<ul>
<li>现代浏览器采用了多进程架构，将渲染进程和浏览器主进程做了分离，浏览器被划分为浏览器内核和渲染内核两个核心模块，其中浏览器内核是由网络进程、浏览器主进程和 GPU 进程组成的，渲染内核就是渲染进程。</li>
</ul>
<ol>
<li>所有的网络资源都是通过浏览器内核来下载的，下载后的资源会通过 IPC 将其提交给渲染进程（浏览器内核和渲染进程之间都是通过 IPC 来通信的）。</li>
<li>然后渲染进程会对这些资源进行解析、绘制等操作，最终生成一幅图片。</li>
<li>但是渲染进程并不负责将图片显示到界面上，而是将最终生成的图片提交给浏览器内核模块，由浏览器内核模块负责显示这张图片。</li>
</ol>
<ul>
<li>虽然设计成了多进程架构，不过这些模块之间的沟通方式却有些复杂，也许你还有以下问题：</li>
</ul>
<ol>
<li>为什么一定要通过浏览器内核去请求资源，再将数据转发给渲染进程，而不直接从进程内部去请求网络资源？</li>
<li>为什么渲染进程只负责生成页面图片，生成图片还要经过 IPC 通知浏览器内核模块，然后让浏览器内核去负责展示图片？<h3 id="安全沙箱"><a href="#安全沙箱" class="headerlink" title="安全沙箱"></a>安全沙箱</h3></li>
</ol>
<ul>
<li>由于渲染进程需要执行 DOM 解析、CSS 解析、网络图片解码等操作，如果渲染进程中存在系统级别的漏洞，那么以上操作就有可能让恶意的站点获取到渲染进程的控制权限，进而又获取操作系统的控制权限，这对于用户来说是非常危险的。</li>
<li>如果你下载了一个恶意程序，但是没有执行它，那么恶意程序是不会生效的。同理，浏览器之于网络内容也是如此，浏览器可以安全地下载各种网络资源，但是如果要执行这些网络资源，比如解析 HTML、解析 CSS、执行 JavaScript、图片编解码等操作，就需要非常谨慎了，因为一不小心，黑客就会利用这些操作对含有漏洞的浏览器发起攻击。</li>
<li>基于以上原因，我们需要在渲染进程和操作系统之间建一道墙，即便渲染进程由于存在漏洞被黑客攻击，但由于这道墙，黑客就获取不到渲染进程之外的任何操作权限。将渲染进程和操作系统隔离的这道墙就是我们要聊的安全沙箱。</li>
<li>浏览器中的安全沙箱是利用操作系统提供的安全技术，让渲染进程在执行过程中无法访问或者修改操作系统中的数据，在渲染进程需要访问系统资源的时候，需要通过浏览器内核来实现，然后将访问的结果通过 IPC 转发给渲染进程。</li>
<li>安全沙箱最小的保护单位是进程。因为单进程浏览器需要频繁访问或者修改操作系统的数据，所以单进程浏览器是无法被安全沙箱保护的，而现代浏览器采用的多进程架构使得安全沙箱可以发挥作用。<h4 id="安全沙箱如何影响各个模块功能"><a href="#安全沙箱如何影响各个模块功能" class="headerlink" title="安全沙箱如何影响各个模块功能"></a>安全沙箱如何影响各个模块功能</h4></li>
<li>如果要让安全沙箱应用在某个进程上，那么这个进程必须没有读写操作系统的功能，比如读写本地文件、发起网络请求、调用 GPU 接口等。</li>
<li>那安全沙箱是如何影响到各个模块功能的呢？</li>
</ul>
<ol>
<li>持久存储<br>①由于安全沙箱需要负责确保渲染进程无法直接访问用户的文件系统，<br>但是在渲染进程内部有访问 Cookie 的需求、有上传文件的需求，为了解决这些文件的访问需求，<br>所以现代浏览器将读写文件的操作全部放在了浏览器内核中实现，然后通过 IPC 将操作结果转发给渲染进程。<br>②存储 Cookie 数据的读写。通常浏览器内核会维护一个存放所有 Cookie 的 Cookie 数据库，<br>然后当渲染进程通过 JavaScript 来读取 Cookie 时，渲染进程会通过 IPC 将读取 Cookie 的信息发送给浏览器内核，<br>浏览器内核读取 Cookie 之后再将内容返回给渲染进程。<br>③一些缓存文件的读写也是由浏览器内核实现的，比如网络文件缓存的读取。</li>
<li>网络访问<br>① 在渲染进程内部也是不能直接访问网络的，如果要访问网络，则需要通过浏览器内核。<br>② 不过浏览器内核在处理 URL 请求之前，会检查渲染进程是否有权限请求该 URL，比如检查 XMLHttpRequest 或者 Fetch 是否是跨站点请求，或者检测 HTTPS 的站点中是否包含了 HTTP 的请求。</li>
<li>用户交互<br>①通常情况下，如果你要实现一个 UI 程序，操作系统会提供一个界面给你，该界面允许应用程序与用户交互，允许应用程序在该界面上进行绘制，比如 Windows 提供的是 HWND，Linux 提供的 X Window，我们就把 HWND 和 X Window 统称为窗口句柄。应用程序可以在窗口句柄上进行绘制和接收键盘鼠标消息。<br>②在现代浏览器中，由于每个渲染进程都有安全沙箱的保护，所以在渲染进程内部是无法直接操作窗口句柄的，这也是为了限制渲染进程监控到用户的输入事件。<br>③由于渲染进程不能直接访问窗口句柄，所以渲染进程需要完成以下两点大的改变。<br>第一点，渲染进程需要渲染出位图。为了向用户显示渲染进程渲染出来的位图，渲染进程需要将生成好的位图发送到浏览器内核，然后浏览器内核将位图复制到屏幕上。<br>第二点，操作系统没有将用户输入事件直接传递给渲染进程，而是将这些事件传递给浏览器内核。然后浏览器内核再根据当前浏览器界面的状态来判断如何调度这些事件，如果当前焦点位于浏览器地址栏中，则输入事件会在浏览器内核内部处理；如果当前焦点在页面的区域内，则浏览器内核会将输入事件转发给渲染进程。<br>④之所以这样设计，就是为了限制渲染进程有监控到用户输入事件的能力，所以所有的键盘鼠标事件都是由浏览器内核来接收的，然后浏览器内核再通过 IPC 将这些事件发送给渲染进程。<h3 id="站点隔离（Site-Isolation）"><a href="#站点隔离（Site-Isolation）" class="headerlink" title="站点隔离（Site Isolation）"></a>站点隔离（Site Isolation）</h3></li>
</ol>
<ul>
<li>所谓站点隔离是指 Chrome 将同一站点（包含了相同根域名和相同协议的地址）中相互关联的页面放到同一个渲染进程中执行。</li>
<li>最开始 Chrome 划分渲染进程是以标签页为单位，也就是说整个标签页会被划分给某个渲染进程。但是，按照标签页划分渲染进程存在一些问题，原因就是一个标签页中可能包含了多个 iframe，而这些 iframe 又有可能来自于不同的站点，这就导致了多个不同站点中的内容通过 iframe 同时运行在同一个渲染进程中。</li>
<li>目前所有操作系统都面临着两个 A 级漏洞——幽灵（Spectre）和熔毁（Meltdown），这两个漏洞是由处理器架构导致的，很难修补，黑客通过这两个漏洞可以直接入侵到进程的内部，如果入侵的进程没有安全沙箱的保护，那么黑客还可以发起对操作系统的攻击。</li>
<li>所以如果一个银行站点包含了一个恶意 iframe，然后这个恶意的 iframe 利用这两个 A 级漏洞去入侵渲染进程，那么恶意程序就能读取银行站点渲染进程内的所有内容了，这对于用户来说就存在很大的风险了。</li>
<li>因此 Chrome 几年前就开始重构代码，将标签级的渲染进程重构为 iframe 级的渲染进程，然后严格按照同一站点的策略来分配渲染进程，这就是 Chrome 中的站点隔离。</li>
<li>实现了站点隔离，就可以将恶意的 iframe 隔离在恶意进程内部，使得它无法继续访问其他 iframe 进程的内容，因此也就无法攻击其他站点了。</li>
<li>值得注意是，2019 年 10 月 20 日 Chrome 团队宣布安卓版的 Chrome 已经全面支持站点隔离。</li>
</ul>
<h2 id="HTTPS：让数据传输更安全"><a href="#HTTPS：让数据传输更安全" class="headerlink" title="HTTPS：让数据传输更安全"></a>HTTPS：让数据传输更安全</h2><ul>
<li>使用 HTTP 传输的内容很容易被中间人窃取、伪造和篡改，通常我们把这种攻击方式称为中间人攻击。</li>
<li>在将 HTTP 数据提交给 TCP 层之后，数据会经过用户电脑、WiFi 路由器、运营商和目标服务器，在这中间的每个环节中，数据都有可能被窃取或篡改。</li>
<li>比如用户电脑被黑客安装了恶意软件，那么恶意软件就能抓取和篡改所发出的 HTTP 请求的内容。或者用户一不小心连接上了 WiFi 钓鱼路由器，那么数据也都能被黑客抓取或篡改。<h3 id="在-HTTP-协议栈中引入安全层"><a href="#在-HTTP-协议栈中引入安全层" class="headerlink" title="在 HTTP 协议栈中引入安全层"></a>在 HTTP 协议栈中引入安全层</h3></li>
<li>HTTPS 并非是一个新的协议，通常 HTTP 直接和 TCP 通信，HTTPS 则先和安全层通信，然后安全层再和 TCP 层通信。</li>
<li>HTTPS 所有的安全核心都在安全层，它不会影响到上面的 HTTP 协议，也不会影响到下面的 TCP/IP</li>
<li>安全层有两个主要的职责：对发起 HTTP 请求的数据进行加密操作和对接收到 HTTP 的内容进行解密操作。<h3 id="第一版：使用对称加密"><a href="#第一版：使用对称加密" class="headerlink" title="第一版：使用对称加密"></a>第一版：使用对称加密</h3></li>
<li>所谓对称加密是指加密和解密都使用的是相同的密钥。</li>
<li>HTTPS 首先要协商加解密方式，这个过程就是 HTTPS 建立安全连接的过程。为了让加密的密钥更加难以破解，我们让服务器和客户端同时决定密钥，具体过程如下：</li>
</ul>
<ol>
<li>浏览器发送它所支持的加密套件列表和一个随机数 client-random，这里的加密套件是指加密的方法，加密套件列表就是指浏览器能支持多少种加密方法列表。</li>
<li>服务器会从加密套件列表中选取一个加密套件，然后还会生成一个随机数 service-random，并将 service-random 和加密套件列表返回给浏览器。</li>
<li>最后浏览器和服务器分别返回确认消息。</li>
<li>这样浏览器端和服务器端都有相同的 client-random 和 service-random 了，然后它们再使用相同的方法将 client-random 和 service-random 混合起来生成一个密钥 master secret，有了密钥 master secret 和加密套件之后，双方就可以进行数据的加密传输了。</li>
</ol>
<ul>
<li>虽然这个版本能够很好地工作，但是其中传输 client-random 和 service-random 的过程却是明文的，这意味着黑客也可以拿到协商的加密套件和双方的随机数，由于利用随机数合成密钥的算法是公开的，所以黑客拿到随机数之后，也可以合成密钥，这样数据依然可以被破解，那么黑客也就可以使用密钥来伪造或篡改数据了。<h3 id="第二版：使用非对称加密"><a href="#第二版：使用非对称加密" class="headerlink" title="第二版：使用非对称加密"></a>第二版：使用非对称加密</h3></li>
<li>非对称加密算法有 A、B 两把密钥，如果你用 A 密钥来加密，那么只能使用 B 密钥来解密；反过来，如果你要 B 密钥来加密，那么只能用 A 密钥来解密。</li>
<li>在 HTTPS 中，服务器会将其中的一个密钥通过明文的形式发送给浏览器，我们把这个密钥称为公钥，服务器自己留下的那个密钥称为私钥。顾名思义，公钥是每个人都能获取到的，而私钥只有服务器才能知道，不对任何人公开。</li>
<li>我们来分析下使用非对称加密的请求流程。</li>
</ul>
<ol>
<li>首先浏览器还是发送加密套件列表给服务器。</li>
<li>然后服务器会选择一个加密套件，不过和对称加密不同的是，使用非对称加密时服务器上需要有用于浏览器加密的公钥和服务器解密 HTTP 数据的私钥，由于公钥是给浏览器加密使用的，因此服务器会将加密套件和公钥一道发送给浏览器。</li>
<li>最后就是浏览器和服务器返回确认消息。</li>
<li>这样浏览器端就有了服务器的公钥，在浏览器端向服务器端发送数据时，就可以使用该公钥来加密数据。由于公钥加密的数据只有私钥才能解密，所以即便黑客截获了数据和公钥，他也是无法使用公钥来解密数据的。</li>
</ol>
<ul>
<li>因此采用非对称加密，就能保证浏览器发送给服务器的数据是安全的了，这看上去似乎很完美，不过这种方式依然存在两个严重的问题。</li>
</ul>
<ol>
<li>第一个是非对称加密的效率太低。这会严重影响到加解密数据的速度，进而影响到用户打开页面的速度。</li>
<li>第二个是无法保证服务器发送给浏览器的数据安全。虽然浏览器端可以使用公钥来加密，但是服务器端只能采用私钥来加密，私钥加密只有公钥能解密，但黑客也是可以获取得到公钥的，这样就不能保证服务器端数据的安全了。<h3 id="第三版：对称加密和非对称加密搭配使用"><a href="#第三版：对称加密和非对称加密搭配使用" class="headerlink" title="第三版：对称加密和非对称加密搭配使用"></a>第三版：对称加密和非对称加密搭配使用</h3></li>
</ol>
<ul>
<li>在传输数据阶段依然使用对称加密，但是对称加密的密钥我们采用非对称加密来传输。</li>
<li>改造后的流程是这样的：</li>
</ul>
<ol>
<li>首先浏览器向服务器发送对称加密套件列表、非对称加密套件列表和随机数 client-random；</li>
<li>服务器保存随机数 client-random，选择对称加密和非对称加密的套件，然后生成随机数 service-random，向浏览器发送选择的加密套件、service-random 和公钥；</li>
<li>浏览器保存公钥，并生成随机数 pre-master，然后利用公钥对 pre-master 加密，并向服务器发送加密后的数据；</li>
<li>最后服务器拿出自己的私钥，解密出 pre-master 数据，并返回确认消息。</li>
<li>到此为止，服务器和浏览器就有了共同的 client-random、service-random 和 pre-master，然后服务器和浏览器会使用这三组随机数生成对称密钥，因为服务器和浏览器使用同一套方法来生成密钥，所以最终生成的密钥也是相同的。</li>
<li>需要特别注意的一点，pre-master 是经过公钥加密之后传输的，所以黑客无法获取到 pre-master，这样黑客就无法生成密钥，也就保证了黑客无法破解传输过程中的数据了<h3 id="第四版：添加数字证书"><a href="#第四版：添加数字证书" class="headerlink" title="第四版：添加数字证书"></a>第四版：添加数字证书</h3></li>
</ol>
<ul>
<li>通过对称和非对称混合方式，我们完美地实现了数据的加密传输。不过这种方式依然存在着问题，比如我要打开a的官网，但是黑客通过 DNS 劫持将a的官网的 IP 地址替换成了黑客的 IP 地址，这样我访问的其实是黑客的服务器了，黑客就可以在自己的服务器上实现公钥和私钥，而对浏览器来说，它完全不知道现在访问的是个黑客的站点。</li>
<li>结合实际生活中的一个例子，比如你要买房子，首先你需要给房管局提交你买房的材料，包括银行流水、银行证明、身份证等，然后房管局工作人员在验证无误后，会发给你一本盖了章的房产证，房产证上包含了你的名字、身份证号、房产地址、实际面积、公摊面积等信息。在这个例子中，你之所以能证明房子是你自己的，是因为引进了房管局这个权威机构，并通过这个权威机构给你颁发一个证书：房产证。</li>
<li>对于浏览器来说，数字证书有两个作用：一个是通过数字证书向浏览器证明服务器的身份，另一个是数字证书里面包含了服务器公钥。</li>
<li>相较于第三版的 HTTPS 协议，这里主要有两点改变：</li>
</ul>
<ol>
<li>服务器没有直接返回公钥给浏览器，而是返回了数字证书，而公钥正是包含在数字证书中的；</li>
<li>在浏览器端多了一个证书验证的操作，验证了证书之后，才继续后续流程。</li>
</ol>
<ul>
<li>通过引入数字证书，我们就实现了服务器的身份认证功能，这样即便黑客伪造了服务器，但是由于证书是没有办法伪造的，所以依然无法欺骗用户。</li>
</ul>
<h2 id="如何计算Chrome中渲染进程的个数？"><a href="#如何计算Chrome中渲染进程的个数？" class="headerlink" title="如何计算Chrome中渲染进程的个数？"></a>如何计算Chrome中渲染进程的个数？</h2><ul>
<li>同一站点，从 A 标签页中打开 B 标签页，就会使用同一个渲染进程，而分别打开这两个标签页，会分别使用不同的渲染进程<h3 id="标签页之间的连接"><a href="#标签页之间的连接" class="headerlink" title="标签页之间的连接"></a>标签页之间的连接</h3></li>
<li>第一种是通过<a>标签来和新标签建立连接</a></li>
<li>还可以通过 JavaScript 中的 window.open 方法来和新标签页建立连接</li>
<li>通过上述两种方式打开的新标签页，不论这两个标签页是否属于同一站点，他们之间都能通过 opener 来建立连接，所以他们之间是有联系的。在 WhatWG 规范中，把这一类具有相互连接关系的标签页称为浏览上下文组 ( browsing context group)。</li>
<li>既然提到浏览上下文组，就有必要提下浏览上下文，通常情况下，我们把一个标签页所包含的内容，诸如 window 对象，历史记录，滚动条位置等信息称为浏览上下文。这些通过脚本相互连接起来的浏览上下文就是浏览上下文组。</li>
<li>Chrome 浏览器会将浏览上下文组中属于同一站点的标签分配到同一个渲染进程中，这是因为如果一组标签页，既在同一个浏览上下文组中，又属于同一站点，那么它们可能需要在对方的标签页中执行脚本。因此，它们必须运行在同一渲染进程中。<h3 id="一个“例外”"><a href="#一个“例外”" class="headerlink" title="一个“例外”"></a>一个“例外”</h3></li>
<li>通常，将 noopener 的值引入 rel 属性中，就是告诉浏览器通过这个链接打开的标签页中的 opener 值设置为 null，引入 noreferrer 是告诉浏览器，新打开的标签页不要有引用关系。<h3 id="站点隔离"><a href="#站点隔离" class="headerlink" title="站点隔离"></a>站点隔离</h3></li>
<li>目前 Chrome 浏览器已经默认实现了站点隔离的功能，这意味着标签页中的 iframe 也会遵守同一站点的分配原则，如果标签页中的 iframe 和标签页是同一站点，并且有连接关系，那么标签页依然会和当前标签页运行在同一个渲染进程中，如果 iframe 和标签页不属于同一站点，那么 iframe 会运行在单独的渲染进程中。</li>
</ul>
<h2 id="任务调度：有了setTimeOut，为什么还要使用rAF？"><a href="#任务调度：有了setTimeOut，为什么还要使用rAF？" class="headerlink" title="任务调度：有了setTimeOut，为什么还要使用rAF？"></a>任务调度：有了setTimeOut，为什么还要使用rAF？</h2><ul>
<li>用 JavaScript 实现高性能的动画，那就得使用 requestAnimationFrame 这个 API，我们简称 rAF，那么为什么都推荐使用 rAF 而不是 setTimeOut 呢？</li>
</ul>
<ol>
<li>要解释清楚这个问题，就要从渲染进程的任务调度系统讲起，理解了渲染进程任务调度系统，你自然就明白了 rAF 和 setTimeOut 的区别。</li>
<li>渲染进程内部的大多数任务都是在主线程上执行的，诸如 JavaScript 执行、DOM、CSS、计算布局、V8 的垃圾回收等任务。要让这些任务能够在主线程上有条不紊地运行，就需要引入消息队列。</li>
<li>主线程维护了一个普通的消息队列和一个延迟消息队列，调度模块会按照规则依次取出这两个消息队列中的任务，并在主线程上执行。</li>
</ol>
<ul>
<li>CSS 动画是由渲染进程自动处理的，所以渲染进程会让 CSS 渲染每帧动画的过程与 VSync 的时钟保持一致, 这样就能保证 CSS 动画的高效率执行。</li>
<li>但是 JavaScript 是由用户控制的，如果采用 setTimeout 来触发动画每帧的绘制，那么其绘制时机是很难和 VSync 时钟保持一致的，所以 JavaScript 中又引入了 window.requestAnimationFrame，用来和 VSync 的时钟周期同步</li>
</ul>
<h3 id="单消息队列的队头阻塞问题"><a href="#单消息队列的队头阻塞问题" class="headerlink" title="单消息队列的队头阻塞问题"></a>单消息队列的队头阻塞问题</h3><ul>
<li>渲染主线程会按照先进先出的顺序执行消息队列中的任务，具体地讲，当产生了新的任务，渲染进程会将其添加到消息队列尾部，在执行任务过程中，渲染进程会顺序地从消息队列头部取出任务并依次执行。在最初，采用这种方式没有太大的问题，因为页面中的任务还不算太多，渲染主线程也不是太繁忙。</li>
<li>不过浏览器是向前不停进化的，其进化路线体现在架构的调整、功能的增加以及更加精细的优化策略等方面，这些变化让渲染进程所需要处理的任务变多了，对应的渲染进程的主线程也变得越拥挤。</li>
<li>在基于这种单消息队列的架构下，如果用户发出一个点击事件或者缩放页面的事件，而在此时，该任务前面可能还有很多不太重要的任务在排队等待着被执行，诸如 V8 的垃圾回收、DOM 定时器等任务，如果执行这些任务需要花费的时间过久的话，那么就会让用户产生卡顿的感觉。</li>
<li>因此，在单消息队列架构下，存在着低优先级任务会阻塞高优先级任务的情况，比如在一些性能不高的手机上，有时候滚动页面需要等待一秒以上。这像极了我们在介绍 HTTP 协议时所谈论的队头阻塞问题<h3 id="Chromium-是如何解决队头阻塞问题的？"><a href="#Chromium-是如何解决队头阻塞问题的？" class="headerlink" title="Chromium 是如何解决队头阻塞问题的？"></a>Chromium 是如何解决队头阻塞问题的？</h3></li>
</ul>
<h3 id="第一次迭代：引入一个高优先级队列"><a href="#第一次迭代：引入一个高优先级队列" class="headerlink" title="第一次迭代：引入一个高优先级队列"></a>第一次迭代：引入一个高优先级队列</h3><ul>
<li>在交互阶段，下面几种任务都应该视为高优先级的任务：</li>
</ul>
<ol>
<li>通过鼠标触发的点击任务、滚动页面任务；</li>
<li>通过手势触发的页面缩放任务；</li>
<li>通过 CSS、JavaScript 等操作触发的动画特效等任务</li>
</ol>
<ul>
<li>这些任务被触发后，用户想立即得到页面的反馈，所以我们需要让这些任务能够优先与其他的任务执行。</li>
<li>要实现这种效果，我们可以增加一个高优级的消息队列，将高优先级的任务都添加到这个队列里面，然后优先执行该消息队列中的任务。</li>
<li>我们使用了一个优先级高的消息队列和一个优先级低消息队列，渲染进程会将它认为是紧急的任务添加到高优先级队列中，不紧急的任务就添加到低优先级的队列中。</li>
<li>然后我们再在渲染进程中引入一个任务调度器，负责从多个消息队列中选出合适的任务，通常实现的逻辑，先按照顺序从高优先级队列中取出任务，如果高优先级的队列为空，那么再按照顺序从低优级队列中取出任务。</li>
<li>还可以更进一步，将任务划分为多个不同的优先级，来实现更加细粒度的任务调度，比如可以划分为高优先级，普通优先级和低优先级</li>
<li>不过大多数任务需要保持其相对执行顺序，如果将用户输入的消息或者合成消息添加进多个不同优先级的队列中，那么这种任务的相对执行顺序就会被打乱，甚至有可能出现还未处理输入事件，就合成了该事件要显示的图片。因此我们需要让一些相同类型的任务保持其相对执行顺序。<h3 id="第二次迭代：根据消息类型来实现消息队列"><a href="#第二次迭代：根据消息类型来实现消息队列" class="headerlink" title="第二次迭代：根据消息类型来实现消息队列"></a>第二次迭代：根据消息类型来实现消息队列</h3></li>
<li>我们可以为不同类型的任务创建不同优先级的消息队列，比如：</li>
</ul>
<ol>
<li>可以创建输入事件的消息队列，用来存放输入事件。</li>
<li>可以创建合成任务的消息队列，用来存放合成事件。</li>
<li>可以创建默认消息队列，用来保存如资源加载的事件和定时器回调等事件。</li>
<li>还可以创建一个空闲消息队列，用来存放 V8 的垃圾自动垃圾回收这一类实时性不高的事件。</li>
</ol>
<ul>
<li>但是它依然存在着问题，那就是这几种消息队列的优先级都是固定的，任务调度器会按照这种固定好的静态的优先级来分别调度任务。</li>
<li>页面大致的生存周期大体分为两个阶段，加载阶段和交互阶段。</li>
<li>虽然在交互阶段，采用上述这种静态优先级的策略没有什么太大问题的，但是在页面加载阶段，如果依然要优先执行用户输入事件和合成事件，那么页面的解析速度将会被拖慢。Chromium 团队曾测试过这种情况，使用静态优先级策略，网页的加载速度会被拖慢 14%。<h3 id="第三次迭代：动态调度策略"><a href="#第三次迭代：动态调度策略" class="headerlink" title="第三次迭代：动态调度策略"></a>第三次迭代：动态调度策略</h3></li>
<li>页面加载阶段的场景，在这个阶段，用户的最高诉求是在尽可能短的时间内看到页面，至于交互和合成并不是这个阶段的核心诉求，因此我们需要调整策略，在加载阶段将页面解析，JavaScript 脚本执行等任务调整为优先级最高的队列，降低交互合成这些队列的优先级。</li>
<li>页面加载完成之后就进入了交互阶段</li>
</ul>
<ol>
<li>在显卡中有一块叫着前缓冲区的地方，这里存放着显示器要显示的图像，显示器会按照一定的频率来读取这块前缓冲区，并将前缓冲区中的图像显示在显示器上，不同的显示器读取的频率是不同的，通常情况下是 60HZ，也就是说显示器会每间隔 1/60 秒就读取一次前缓冲区。</li>
<li>如果浏览器要更新显示的图片，那么浏览器会将新生成的图片提交到显卡的后缓冲区中，提交完成之后，GPU 会将后缓冲区和前缓冲区互换位置，也就是前缓冲区变成了后缓冲区，后缓冲区变成了前缓冲区，这就保证了显示器下次能读取到 GPU 中最新的图片。</li>
<li>显示器从前缓冲区读取图片，和浏览器生成新的图像到后缓冲区的过程是不同步的，这种显示器读取图片和浏览器生成图片不同步，容易造成众多问题。<br>如果渲染进程生成的帧速比屏幕的刷新率慢，那么屏幕会在两帧中显示同一个画面，当这种断断续续的情况持续发生时，用户将会很明显地察觉到动画卡住了。<br>如果渲染进程生成的帧速率实际上比屏幕刷新率快，那么也会出现一些视觉上的问题，比如当帧速率在 100fps 而刷新率只有 60Hz 的时候，GPU 所渲染的图像并非全都被显示出来，这就会造成丢帧现象。<br>就算屏幕的刷新频率和 GPU 更新图片的频率一样，由于它们是两个不同的系统，所以屏幕生成帧的周期和 VSync 的周期也是很难同步起来的。</li>
<li>所以 VSync 和系统的时钟不同步就会造成掉帧、卡顿、不连贯等问题。为了解决这些问题，就需要将显示器的时钟同步周期和浏览器生成页面的周期绑定起来。</li>
<li>当显示器将一帧画面绘制完成后，并在准备读取下一帧之前，显示器会发出一个垂直同步信号（vertical synchronization）给 GPU，简称 VSync。这时候浏览器就会充分利用好 VSync 信号。</li>
<li>具体地讲，当 GPU 接收到 VSync 信号后，会将 VSync 信号同步给浏览器进程，浏览器进程再将其同步到对应的渲染进程，渲染进程接收到 VSync 信号之后，就可以准备绘制新的一帧了</li>
<li>当渲染进程接收到用户交互的任务后，接下来大概率是要进行绘制合成操作，因此我们可以设置，当在执行用户交互的任务时，将合成任务的优先级调整到最高。</li>
<li>处理完成 DOM，计算好布局和绘制，就需要将信息提交给合成线程来合成最终图片了，然后合成线程进入工作状态。</li>
</ol>
<ul>
<li>现在的场景是合成线程在工作了，那么我们就可以把下个合成任务的优先级调整为最低，并将页面解析、定时器等任务优先级提升。</li>
<li>在合成完成之后，合成线程会提交给渲染主线程提交完成合成的消息，如果当前合成操作执行的非常快，比如从用户发出消息到完成合成操作只花了 8 毫秒，因为 VSync 同步周期是 16.66（1/60）毫秒，那么这个 VSync 时钟周期内就不需要再次生成新的页面了。那么从合成结束到下个 VSync 周期内，就进入了一个空闲时间阶段，那么就可以在这段空闲时间内执行一些不那么紧急的任务，比如 V8 的垃圾回收，或者通过 window.requestIdleCallback() 设置的回调任务等，都会在这段空闲时间内执行。4. 第四次迭代：任务饿死<h3 id="第四次迭代：任务饿死"><a href="#第四次迭代：任务饿死" class="headerlink" title="第四次迭代：任务饿死"></a>第四次迭代：任务饿死</h3></li>
<li>以上方案看上去似乎非常完美了，不过依然存在一个问题，那就是在某个状态下，一直有新的高优先级的任务加入到队列中，这样就会导致其他低优先级的任务得不到执行，这称为任务饿死。</li>
<li>Chromium 为了解决任务饿死的问题，给每个队列设置了执行权重，也就是如果连续执行了一定个数的高优先级的任务，那么中间会执行一次低优先级的任务，这样就缓解了任务饿死的情况。</li>
</ul>
<h2 id="加载阶段性能：使用Audits来优化Web性能"><a href="#加载阶段性能：使用Audits来优化Web性能" class="headerlink" title="加载阶段性能：使用Audits来优化Web性能"></a>加载阶段性能：使用Audits来优化Web性能</h2><h3 id="到底什么是-Web-性能"><a href="#到底什么是-Web-性能" class="headerlink" title="到底什么是 Web 性能?"></a>到底什么是 Web 性能?</h3><ul>
<li>Web 性能描述了 Web 应用在浏览器上的加载和显示的速度。</li>
<li>关于 Web 应用的速度，我们需要从两个阶段来考虑：页面加载阶段；页面交互阶段。<h3 id="性能检测工具：Performance-vs-Audits"><a href="#性能检测工具：Performance-vs-Audits" class="headerlink" title="性能检测工具：Performance vs Audits"></a>性能检测工具：Performance vs Audits</h3></li>
<li>Chrome 为我们提供了非常完善的性能检测工具：Performance 和 Audits，它们能够准确统计页面在加载阶段和运行阶段的一些核心数据，诸如任务执行记录、首屏展示花费的时长等，有了这些数据我们就能很容易定位到 Web 应用的性能瓶颈 。</li>
<li>首先 Performance 非常强大，因为它为我们提供了非常多的运行时数据，利用这些数据我们就可以分析出来 Web 应用的瓶颈。但是要完全学会其使用方式却是非常有难度的，其难点在于这些数据涉及到了特别多的概念，而这些概念又和浏览器的系统架构、消息循环机制、渲染流水线等知识紧密联系在了一起。</li>
<li>相反，Audtis 就简单了许多，它将检测到的细节数据隐藏在背后，只提供给我们一些直观的性能数据，同时，还会给我们提供一些优化建议。<h3 id="利用-Audits-生成-Web-性能报告"><a href="#利用-Audits-生成-Web-性能报告" class="headerlink" title="利用 Audits 生成 Web 性能报告"></a>利用 Audits 生成 Web 性能报告</h3></li>
<li>这里我们可以拿B 站作为分析的列子。</li>
<li>首先我们打开浏览器的隐身窗口，Windows 系统下面的快捷键是 Control+Shift+N，Mac 系统下面的快捷键是 Command+Shift+N。我们需要在 Chrome 的隐身模式下工作，这样可以确保我们安装的扩展、浏览器缓存、Cookie 等数据不会影响到检测结果。</li>
<li>然后在隐身窗口中输入 B 站的网站。</li>
<li>打开 Chrome 的开发者工具，选择 Audits 标签。</li>
<li>在生成报告之前，我们需要先配置 Audits，配置模块主要有两部分组成，一个是监测类型 (Categories)，另外一个是设备类型 (Device)。</li>
<li>监控类型 (Categories) 是指需要监控哪些内容，这里有五个对应的选项，它们的功能分别是：</li>
</ul>
<ol>
<li>监测并分析 Web 性能 (Performance)</li>
<li>监测并分析 PWA(Progressive Web App) 程序的性能；</li>
<li>监测并分析 Web 应用是否采用了最佳实践策略 (Best practices)；</li>
<li>监测并分析是否实施了无障碍功能 (Accessibility)，无障碍功能让一些身体有障碍的人可以方便地浏览你的 Web 应用。</li>
<li>监测并分析 Web 应用是否采实施了 SEO 搜素引擎优化 (SEO)。</li>
</ol>
<ul>
<li>设备 (Device) 部分，它给了我们两个选项，Moblie 选项是用来模拟移动设备环境的，另外一个 Desktop 选项是用来模拟桌面环境的。这里我们选择移动设备选项，因为目前大多数流量都是由移动设备产生的，所以移动设备上的 Web 性能显得更加重要。</li>
<li>配置好选项之后，我们就可以点击最上面的生成报告 (Generate report) 按钮来生成报告了。<h3 id="解读性能报告"><a href="#解读性能报告" class="headerlink" title="解读性能报告"></a>解读性能报告</h3></li>
<li>中间圆圈中的数字表示该站点在加载过程中的总体 Web 性能得分，总分是 100 分。</li>
<li>Audits 除了生成性能指标以外，还会分析该站点并提供了很多优化建议，我们可以根据这些建议来改进 Web 应用以获得更高的得分，进而获得更好的用户体验效果。</li>
<li>报告的第一个部分是性能指标 (Metrics)，性能指标下面一共有六项内容，这六项内容分别对应了从 Web 应用的加载到页面展示完成的这段时间中，各个阶段所消耗的时长。在中间还有一个 View Trace 按钮，点击该按钮可以跳转到 Performance 标签，并且查看这些阶段在 Performance 中所对应的位置。</li>
<li>报告的第二个部分是可优化项 (Opportunities)，这些可优化项是 Audits 发现页面中的一些可以直接优化的部分，你可以对照 Audits 给的这些提示来优化你的 Web 应用。</li>
<li>报告的第三部分是手动诊断 (Diagnostics)，在手动诊断部分，采集了一些可能存在性能问题的指标，这些指标可能会影响到页面的加载性能，Audits 把详情列出来，并让你依据实际情况，来手动排查每一项。</li>
<li>报告的最后一部分是运行时设置 (Runtime Settings)，这是运行时的一些基本数据，如果选择移动设备模式，你可以看到发送网络请求时的 User Agent 会变成设备相关信息，还有会模拟设备的网速，这个体现在网络限速上。<h3 id="根据性能报告优化-Web-性能"><a href="#根据性能报告优化-Web-性能" class="headerlink" title="根据性能报告优化 Web 性能"></a>根据性能报告优化 Web 性能</h3></li>
<li>最直接的方式是想办法提高性能指标的分数，而性能指标的分数是由六项指标决定的，它们分别是</li>
</ul>
<ol>
<li>首次绘制 (First Paint)；</li>
<li>首次有效绘制 (First Meaningfull Paint)；</li>
<li>首屏时间 (Speed Index)；</li>
<li>首次 CPU 空闲时间 (First CPU Idle)；</li>
<li>完全可交互时间 (Time to Interactive)；</li>
<li>最大估计输入延时 (Max Potential First Input Delay)。</li>
</ol>
<ul>
<li>在渲染进程确认要渲染当前的请求后，渲染进程会创建一个空白页面，我们把创建空白页面的这个时间点称为 First Paint，简称 FP。</li>
</ul>
<ol>
<li>关键资源包括了 JavaScript 文件和 CSS 文件，因为关键资源会阻塞页面的渲染，所以我们需要等待关键资源加载完成后，才能执行进一步的页面绘制。</li>
</ol>
<ul>
<li>当页面中绘制了第一个像素时，我们把这个时间点称为 First Content Paint，简称 FCP。</li>
<li>接下来继续执行 JavaScript 脚本，当首屏内容完全绘制完成时，我们把这个时间点称为 Largest Content Paint，简称 LCP。</li>
<li>在 FCP 和 LCP 中间，还有一个 FMP，这个是首次有效绘制，由于 FMP 计算复杂，而且容易出错，现在不推荐使用该指标</li>
<li>接下来 JavaScript 脚本执行结束，渲染进程判断该页面的 DOM 生成完毕，于是触发 DOMContentLoad 事件。等所有资源都加载结束之后，再触发 onload 事件。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">第一项指标 FP，如果 FP 时间过久，那么直接说明了一个问题，那就是页面的 HTML 文件可能由于网络原因导致加载时间过久</span><br><span class="line">第二项是 FMP，,如果 FMP 和 LCP 消耗时间过久，那么有可能是加载关键资源花的时间过久，也有可能是 JavaScript 执行过程中所花的时间过久，所以我们可以针对具体的情况来具体分析。</span><br><span class="line">第三项是首屏时间 (Speed Index)，这就是我们上面提到的 LCP，它表示填满首屏页面所消耗的时间，首屏时间的值越大，那么加载速度越慢，具体的优化方式同优化第二项 FMP 是一样。</span><br><span class="line">第四项是首次 CPU 空闲时间 (First CPU Idle)，也称为 First Interactive，它表示页面达到最小化可交互的时间，也就是说并不需要等到页面上的所有元素都可交互，只要可以对大部分用户输入做出响应即可。要缩短首次 CPU 空闲时长，我们就需要尽可能快地加载完关键资源，尽可能快地渲染出来首屏内容，因此优化方式和第二项 FMP 和第三项 LCP 是一样的。</span><br><span class="line">第五项是完全可交互时间 (Time to Interactive)，简称 TTI，它表示页面中所有元素都达到了可交互的时长。简单理解就这时候页面的内容已经完全显示出来了，所有的 JavaScript 事件已经注册完成，页面能够对用户的交互做出快速响应，通常满足响应速度在 50 毫秒以内。如果要解决 TTI 时间过久的问题，我们可以推迟执行一些和生成页面无关的 JavaScript 工作。</span><br><span class="line">第六项是最大估计输入延时 (Max Potential First Input Delay），这个指标是估计你的 Web 页面在加载最繁忙的阶段， 窗口中响应用户输入所需的时间，为了改善该指标，我们可以使用 WebWorker 来执行一些计算，从而释放主线程。另一个有用的措施是重构 CSS 选择器，以确保它们执行较少的计算。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="页面性能工具：如何使用Performance？"><a href="#页面性能工具：如何使用Performance？" class="headerlink" title="页面性能工具：如何使用Performance？"></a>页面性能工具：如何使用Performance？</h2><ul>
<li>通常，使用 Performance 需要分三步走：</li>
</ul>
<ol>
<li>第一步是配置 Performance；</li>
<li>第二步是生成报告页；</li>
<li>第三步就是人工分析报告页，并找出页面的性能瓶颈。<h3 id="配置-Performance"><a href="#配置-Performance" class="headerlink" title="配置 Performance"></a>配置 Performance</h3></li>
</ol>
<ul>
<li>我们可以设置该区域中的“Network”来限制网络加载速度，设置“CPU”来限制 CPU 的运算速度。通过设置，我们就可以在 Chrome 浏览器上来模拟手机等性能不高的设备了。</li>
<li>不同于 Audits 只能监控加载阶段的性能数据，Performance 还可以监控交互阶段的性能数据，不过 Performance 是分别录制这两个阶段的，黑色按钮是用来记录交互阶段性能数据的，下面那个带箭头的圆圈形按钮用来记录加载阶段的性能数据。</li>
<li>当你录制加载阶段的性能数据时，Performance 会重新刷新页面，并等到页面完全渲染出来后，Performance 就会自动停止录制。</li>
<li>如果你是录制交互阶段的性能时，那么需要手动停止录制过程。<h3 id="认识报告页"><a href="#认识报告页" class="headerlink" title="认识报告页"></a>认识报告页</h3></li>
<li>分为三个主要的部分，分别为概览面板、性能指标面板和详情面板。</li>
<li>概览面板</li>
</ul>
<ol>
<li>引入了时间线，Performance 就会将几个关键指标，诸如页面帧速 (FPS)、CPU 资源消耗、网络请求流量、V8 内存使用量 (堆内存) 等，按照时间顺序做成图表的形式展现出来，这就是概览面板</li>
<li>如果 FPS 图表上出现了红色块，那么就表示红色块附近渲染出一帧所需时间过久，帧的渲染时间过久，就有可能导致页面卡顿。</li>
<li>如果 CPU 图形占用面积太大，表示 CPU 使用率就越高，那么就有可能因为某个 JavaScript 占用太多的主线程时间，从而影响其他任务的执行。</li>
<li>如果 V8 的内存使用量一直在增加，就有可能是某种原因导致了内存泄漏。</li>
</ol>
<ul>
<li>性能面板</li>
</ul>
<ol>
<li>在性能面板中，记录了非常多的性能指标项，比如 Main 指标记录渲染主线程的任务执行过程，Compositor 指标记录了合成线程的任务执行过程，GPU 指标记录了 GPU 进程主线程的任务执行过程。</li>
<li>简而言之，我们通过概览面板来定位问题的时间节点，然后再使用性能面板分析该时间节点内的性能数据。</li>
</ol>
<ul>
<li>解读性能面板的各项指标</li>
</ul>
<ol>
<li>一条完整的渲染流水线包括了解析 HTML 文件生成 DOM、解析 CSS 生成 CSSOM、执行 JavaScript、样式计算、构造布局树、准备绘制列表、光栅化、合成、显示等一系列操作。</li>
<li>渲染流水线主要是在渲染进程中执行的，在执行渲染流水线的过程中，渲染进程又需要网络进程、浏览器进程、GPU 等进程配合，才能完成如此复杂的任务。另外在渲染进程内部，又有很多线程来相互配合。</li>
<li>主线程上跑了特别多的任务，诸如渲染流水线的大部分流程，JavaScript 执行、V8 的垃圾回收、定时器设置的回调任务等等，因此 Main 指标的内容非常多，而且非常重要，所以我们在使用 Perofrmance 的时候，大部分时间都是在分析 Main 指标。</li>
<li>通过渲染流水线，我们知道了渲染主线程在生成层树 (LayerTree) 之后，然后根据层树生成每一层的绘制列表，我们把这个过程称为绘制 (Paint)。</li>
<li>在绘制阶段结束之后，渲染主线程会将这些绘列表制提交 (commit)给合成线程，并由合成线程合成出来漂亮的页面。因此，监控合成线程的任务执行记录也相对比较重要，所以 Chrome 又在性能面板中引入了Compositor 指标，也就是合成线程的任务执行记录。</li>
<li>在合成线程执行任务的过程中，还需要 GPU 进程的配合来生成位图，我们把这个 GPU 生成位图的过程称为光栅化。</li>
<li>如果合成线程直接和 GPU 进程进行通信，那么势必会阻塞后面的合成任务，因此合成线程又维护了一个光栅化线程池 (Raster)，用来让 GPU 执行光栅化的任务。</li>
<li>因为光栅化线程池和 GPU 进程中的任务执行也会影响到页面的性能，所以性能面板也添加了这两个指标，分别是 Raster 指标和 GPU 指标。因为 Raster 是线程池，所以如果你点开 Raster 项，可以看到它维护了多个线程。</li>
<li>渲染进程中除了有主线程、合成线程、光栅化线程池之外，还维护了一个 IO 线程，IO 线程主要用来接收用户输入事件、网络事件、设备相关等事件，如果事件需要渲染主线程来处理，那么 IO 线程还会将这些事件转发给渲染主线程。在性能面板上，Chrome_ChildIOThread 指标对应的就是 IO 线程的任务记录。</li>
<li>Network 指标，网络记录展示了页面中的每个网络请求所消耗的时长，并以瀑布流的形式展现。这块内容和网络面板的瀑布流类似，之所以放在性能面板中是为了方便我们和其他指标对照着分析。</li>
<li>第二个是 Timings 指标，用来记录一些关键的时间节点在何时产生的数据信息，诸如 FP、FCP、LCP 等。</li>
<li>第三个是 Frames 指标，也就是浏览器生成每帧的记录，我们知道页面所展现出来的画面都是由渲染进程一帧一帧渲染出来的，帧记录就是用来记录渲染进程生成所有帧信息，包括了渲染出每帧的时长、每帧的图层构造等信息，你可以点击对应的帧，然后在详细信息面板里面查看具体信息。</li>
<li>第四个是 Interactions 指标，用来记录用户交互操作，比如点击鼠标、输入文字等交互信息。</li>
</ol>
<ul>
<li>详情面板<br>1.你可以通过在性能面板中选中性能指标中的任何历史数据，然后选中记录的细节信息就会展现在详情面板中了。</li>
</ul>
<h2 id="性能分析工具：如何分析Performance中的Main指标？"><a href="#性能分析工具：如何分析Performance中的Main指标？" class="headerlink" title="性能分析工具：如何分析Performance中的Main指标？"></a>性能分析工具：如何分析Performance中的Main指标？</h2><h3 id="任务-vs-过程"><a href="#任务-vs-过程" class="headerlink" title="任务 vs 过程"></a>任务 vs 过程</h3><ul>
<li>渲染进程中维护了消息队列，如果通过 SetTimeout 设置的回调函数，通过鼠标点击的消息事件，都会以任务的形式添加消息队列中，然后任务调度器会按照一定规则从消息队列中取出合适的任务，并让其在渲染主线程上执行。</li>
<li>Main 指标就记录渲染主线上所执行的全部任务，以及每个任务的详细执行过程。</li>
<li>每个灰色横条就对应了一个任务，灰色长条的长度对应了任务的执行时长。通常，渲染主线程上的任务都是比较复杂的，如果只单纯记录任务执行的时长，那么依然很难定位问题，因此，还需要将任务执行过程中的一些关键的细节记录下来，这些细节就是任务的过程，灰线下面的横条就是一个个过程，同样这些横条的长度就代表这些过程执行的时长。<h3 id="分析页面加载过程"><a href="#分析页面加载过程" class="headerlink" title="分析页面加载过程"></a>分析页面加载过程</h3></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Main&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        area &#123;</span><br><span class="line">            border: 2px ridge;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        box &#123;</span><br><span class="line">            background-color: rgba(106, 24, 238, 0.26);</span><br><span class="line">            height: 5em;</span><br><span class="line">            margin: 1em;</span><br><span class="line">            width: 5em;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;area&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;box rAF&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        function setNewArea() &#123;</span><br><span class="line">            let el = document.createElement(&apos;div&apos;)</span><br><span class="line">            el.setAttribute(&apos;class&apos;, &apos;area&apos;)</span><br><span class="line">            el.innerHTML = &apos;&lt;div class=&quot;box rAF&quot;&gt;&lt;/div&gt;&apos;</span><br><span class="line">            document.body.append(el)</span><br><span class="line">        &#125;</span><br><span class="line">        setNewArea()   </span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">加载过程主要分为三个阶段，它们分别是：</span><br><span class="line"></span><br><span class="line">1. 导航阶段，该阶段主要是从网络进程接收 HTML 响应头和 HTML 响应体。</span><br><span class="line">2. 解析 HTML 数据阶段，该阶段主要是将接收到的 HTML 数据转换为 DOM 和 CSSOM。</span><br><span class="line">3. 生成可显示的位图阶段，该阶段主要是利用 DOM 和 CSSOM，经过计算布局、生成层树 (LayerTree)、生成绘制列表 (Paint)、完成合成等操作，生成最终的图片。</span><br></pre></td></tr></table></figure>
<ul>
<li>导航阶段</li>
</ul>
<ol>
<li>当你点击了 Performance 上的重新录制按钮之后，浏览器进程会通知网络进程去请求对应的 URL 资源；一旦网络进程从服务器接收到 URL 的响应头，便立即判断该响应头中的 content-type 字段是否属于 text/html 类型；如果是，那么浏览器进程会让当前的页面执行退出前的清理操作，比如执行 JavaScript 中的 beforeunload 事件，清理操作执行结束之后就准备显示新页面了，这包括了解析、布局、合成、显示等一系列操作。</li>
<li>因此，在导航阶段，这些任务实际上是在老页面的渲染主线程上执行的。</li>
<li>当你点击重新加载按钮后:<br>第一个子过程就是 Send request，该过程表示网络请求已被发送。然后该任务进入了等待状态。<br>接着由网络进程负责下载资源，当接收到响应头的时候，该任务便执行 Receive Respone 过程，该过程表示接收到 HTTP 的响应头了。<br>接着执行 DOM 事件：pagehide、visibilitychange 和 unload 等事件，如果你注册了这些事件的回调函数，那么这些回调函数会依次在该任务中被调用。<br>这些事件被处理完成之后，那么接下来就接收 HTML 数据了，这体现在了 Recive Data 过程，Recive Data 过程表示请求的数据已被接收，如果 HTML 数据过多，会存在多个 Receive Data 过程。<br>等到所有的数据都接收完成之后，渲染进程会触发另外一个任务，该任务主要执行 Finish load 过程，该过程表示网络请求已经完成。</li>
</ol>
<ul>
<li>解析 HTML 数据阶段</li>
</ul>
<ol>
<li>这个阶段的主要任务就是通过解析 HTML 数据、解析 CSS 数据、执行 JavaScript 来生成 DOM 和 CSSOM。</li>
<li>其中一个主要的过程是 HTMLParser，顾名思义，这个过程是用来解析 HTML 文件，解析的就是上个阶段接收到的 HTML 数据。<br>在 ParserHTML 的过程中，如果解析到了 script 标签，那么便进入了脚本执行过程<br>我们知道，要执行一段脚本我们需要首先编译该脚本，于是在 Evalute Script 过程中，先进入了脚本编译过程，脚本编译好之后，就进入程序执行过程，执行全局代码时，V8 会先构造一个 anonymous 过程，在执行 anonymous 过程中，会调用 setNewArea 过程，setNewArea 过程中又调用了 createElement，由于之后调用了 document.append 方法，该方法会触发 DOM 内容的修改，所以又强制执行了 ParserHTML 过程生成的新的 DOM。<br>DOM 生成完成之后，会触发相关的 DOM 事件，比如典型的 DOMContentLoaded，还有 readyStateChanged。<br>DOM 生成之后，ParserHTML 过程继续计算样式表，也就是 Reculate Style，这就是生成 CSSOM 的过程</li>
</ol>
<ul>
<li>生成可显示位图阶段</li>
</ul>
<ol>
<li>生成页面上的位图。通常这需要经历布局 (Layout)、分层、绘制、合成等一系列操作</li>
<li>在生成完了 DOM 和 CSSOM 之后，渲染主线程首先执行了一些 DOM 事件，诸如 readyStateChange、load、pageshow。具体地讲，如果你使用 JavaScript 监听了这些事件，那么这些监听的函数会被渲染主线程依次调用。</li>
<li>接下来就正式进入显示流程了，大致过程如下所示。<br>首先执行布局，这个过程对应 Layout。<br>然后更新层树 (LayerTree)，这个过程对应Update LayerTree。<br>有了层树之后，就需要为层树中的每一层准备绘制列表了，这个过程就称为 Paint。<br>准备每层的绘制列表之后，就需要利用绘制列表来生成相应图层的位图了，这个过程对应 Composite Layers。<br>走到了 Composite Layers 这步，主线程的任务就完成了，接下来主线程会将合成的任务完全教给合成线程来执行</li>
<li>我们再来梳理下最终图像是怎么显示出来的。<br>首先主线程执行到 Composite Layers 过程之后，便会将绘制列表等信息提交给合成线程，合成线程的执行记录你可以通过 Compositor 指标来查看。<br>合成线程维护了一个 Raster 线程池，线程池中的每个线程称为 Rasterize，用来执行光栅化操作，对应的任务就是 Rasterize Paint。<br>当然光栅化操作并不是在 Rasterize 线程中直接执行的，而是在 GPU 进程中执行的，因此 Rasterize 线程需要和 GPU 线程保持通信。<br>然后 GPU 生成图像，最终这些图层会被提交给浏览器进程，浏览器进程将其合成并最终显示在页面上。</li>
</ol>
<h2 id="HTTPS：浏览器如何验证数字证书？"><a href="#HTTPS：浏览器如何验证数字证书？" class="headerlink" title="HTTPS：浏览器如何验证数字证书？"></a>HTTPS：浏览器如何验证数字证书？</h2><ul>
<li>HTTPS 使用了对称和非对称的混合加密方式，这解决了数据传输安全的问题；</li>
<li>HTTPS 引入了中间机构 CA，CA 通过给服务器颁发数字证书，解决了浏览器对服务器的信任问题；<h3 id="浏览器验证证书的流程"><a href="#浏览器验证证书的流程" class="headerlink" title="浏览器验证证书的流程"></a>浏览器验证证书的流程</h3></li>
<li>在浏览器和服务器建立 HTTPS 链接的过程中，浏览器首先会向服务器请求数字证书，之后浏览器要做的第一件事就是验证数字证书。</li>
<li>具体地讲，浏览器需要验证证书的有效期、证书是否被 CA 吊销、证书是否是合法的 CA 机构颁发的。</li>
<li>数字证书和身份证一样也是有时间期限的，所以第一部分就是验证证书的有效期，这部分比较简单，因为证书里面就含有证书的有效期，所以浏览器只需要判断当前时间是否在证书的有效期范围内即可。</li>
<li>有时候有些数字证书被 CA 吊销了，吊销之后的证书是无法使用的，所以第二部分就是验证数字证书是否被吊销了。通常有两种方式，一种是下载吊销证书列表 -CRL (Certificate Revocation Lists)，第二种是在线验证方式 -OCSP (Online Certificate Status Protocol) </li>
<li>验证数字证书是否是 CA 机构颁发的，验证的流程非常简单：</li>
</ul>
<ol>
<li>首先，浏览器利用证书的原始信息计算出信息摘要；</li>
<li>然后，利用 CA 的公钥来解密数字证书中的数字签名，解密出来的数据也是信息摘要；</li>
<li>最后，判断这两个信息摘要是否相等就可以了。</li>
</ol>
<h3 id="浏览器是怎么获取到-CA-公钥的？"><a href="#浏览器是怎么获取到-CA-公钥的？" class="headerlink" title="浏览器是怎么获取到 CA 公钥的？"></a>浏览器是怎么获取到 CA 公钥的？</h3><ul>
<li>通常，当你部署 HTTP 服务器的时候，除了部署当前的数字证书之外，还需要部署 CA 机构的数字证书，CA 机构的数字证书包括了 CA 的公钥，以及 CA 机构的一些基础信息。</li>
<li>服务器就有了两个数字证书:域名的数字证书；签名的 CA 机构的数字证书。</li>
<li>然后在建立 HTTPS 链接时，服务器会将这两个证书一同发送给浏览器，于是浏览器就可以获取到 CA 的公钥了。</li>
<li>如果有些服务器没有部署 CA 的数字证书，那么浏览器还可以通过网络去下载 CA 证书，不过这种方式多了一次证书下载操作，会拖慢首次打开页面的请求速度，一般不推荐使用。<h3 id="证明-CA-机构的合法性"><a href="#证明-CA-机构的合法性" class="headerlink" title="证明 CA 机构的合法性"></a>证明 CA 机构的合法性</h3></li>
<li>这里并没有一个非常好的方法来证明 CA 的合法性，妥协的方案是，直接在操作系统中内置这些 CA 机构的数字证书</li>
<li>我们将所有 CA 机构的数字证书都内置在操作系统中，这样当需要使用某 CA 机构的公钥时，我们只需要依据 CA 机构名称，就能查询到对应的数字证书了，然后再从数字证书中取出公钥。</li>
<li>不过这种方式依然存在问题，因为在实际情况下，CA 机构众多，因此操作系统不可能将每家 CA 的数字证书都内置进操作系统。</li>
</ul>
<h3 id="数字证书链"><a href="#数字证书链" class="headerlink" title="数字证书链"></a>数字证书链</h3><ul>
<li>将颁发证书的机构划分为两种类型，根 CA(Root CAs)和中间 CA(Intermediates CAs)，通常申请者都是向中间 CA 去申请证书的，而根 CA 作用就是给中间 CA 做认证，一个根 CA 会认证很多中间的 CA，而这些中间 CA 又可以去认证其他的中间 CA。<h3 id="如何验证根证书的合法性"><a href="#如何验证根证书的合法性" class="headerlink" title="如何验证根证书的合法性"></a>如何验证根证书的合法性</h3></li>
<li>其实浏览器的判断策略很简单，它只是简单地判断这个根证书在不在操作系统里面，如果在，那么浏览器就认为这个根证书是合法的，如果不在，那么就是非法的。</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/学习/">学习</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/学习/">学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网站/">网站</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/资源/">资源</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-module_webpack" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2021/03/08/module_webpack/" class="article-date">
      <time datetime="2021-03-07T16:00:00.000Z" itemprop="datePublished">2021-03-08</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/08/module_webpack/">模块化/webpack</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="ES-Modules"><a href="#ES-Modules" class="headerlink" title="ES Modules"></a>ES Modules</h2><p>1.自动采用严格模式（use strict）<br>2.每个ESM模块都是单独的私有作用域<br>3.ESM模块通过CORS（跨域资源共享）去请求外部js模块<br>4.ESM的script标签会延迟脚本的执行</p>
<h2 id="url-loader、file-loader"><a href="#url-loader、file-loader" class="headerlink" title="url-loader、file-loader"></a>url-loader、file-loader</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">url-loader  小文件使用Data URLs,减少请求次数</span><br><span class="line">file-loader 大文件单独提取存放，提高加载速度</span><br><span class="line">&#123;</span><br><span class="line">  test:/.png$/,</span><br><span class="line">  use:&#123;</span><br><span class="line">    loader:&quot;url-loader&quot;,</span><br><span class="line">	options:&#123;</span><br><span class="line">	   limit:10*1024,//10kb以下使用url-loader,10kb以上使用file-loader</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="css-loader、style-loader"><a href="#css-loader、style-loader" class="headerlink" title="css-loader、style-loader"></a>css-loader、style-loader</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">css-loader 将css代码转换成js模块</span><br><span class="line">style-loader 将css代码通过style标签插入html当中</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"> test:/.css$/,</span><br><span class="line"> use:[&apos;style-loader&apos;,&apos;css-loader&apos;]  //由后往前加载loader</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="html-loader"><a href="#html-loader" class="headerlink" title="html-loader"></a>html-loader</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> test:/.html$/,</span><br><span class="line"> use:&#123;</span><br><span class="line">  loader:&apos;html-loader&apos;,</span><br><span class="line">  options:&#123;</span><br><span class="line">     attrs:[&apos;img:src&apos;,&apos;a:href&apos;]  //默认只处理img标签src属性</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><ul>
<li>专注实现资源模块加载，实现项目打包</li>
<li>加载过程类似于管道，可以依次使用多个loader，最终结果必须是js代码。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">module:&#123;</span><br><span class="line">rules:[</span><br><span class="line">   &#123;</span><br><span class="line">   test:/.md$/,</span><br><span class="line">   use:&apos;./markdown-loader&apos;  //可以是模块路径或模块名称</span><br><span class="line">   &#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//自定义loader  处理md文件</span><br><span class="line">const marked=reuqire(&apos;marked&apos;)</span><br><span class="line">module.exports=source=&gt;&#123;</span><br><span class="line"> const html = marked(source)</span><br><span class="line"> return  `export default $&#123;JSON.stringify(html)&#125;`   //最终输出结果必须是js代码 。   可以返回html，交给html-loader继续处理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li>编译转换类：将资源模块转换为js代码。   //<code>css-loader</code>:将css代码转换成js模块</li>
<li>文件操作类：将资源模块拷贝到输出目录，向外到处文件的访问路径   //<code>file-loader</code></li>
<li>代码检查类：对资源模块进行校验   //<code>eslint-loader</code></li>
</ul>
<h2 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h2><ul>
<li>增强webpack自动化能力，实现大多前端工程化 //清除dist目录插件、拷贝不需要参与打包的静态资源文件到输出目录、压缩输出代码等</li>
<li>拥有更宽的能力范围，通过钩子机制实现</li>
<li>必须是一个函数或者包含<code>apply</code>方法的对象,通过在生命周期的钩子中挂载函数实现扩展</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//自定义插件</span><br><span class="line">class MyPlugin&#123;</span><br><span class="line"></span><br><span class="line"> //webpack启动时自动调用</span><br><span class="line"> apply(compiler)&#123;</span><br><span class="line">  compiler.hooks.emit.tap(&apos;MyPlugin&apos;,compilation=&gt;&#123;</span><br><span class="line">    //compilation  //打包上下文</span><br><span class="line">	//compilation.assets   //打包的资源文件 (对象)</span><br><span class="line">	//compilation.assets[&apos;文件名&apos;].source()  //资源文件内容</span><br><span class="line">	</span><br><span class="line">	compilation.assets[&apos;文件名&apos;]=&#123;</span><br><span class="line">	 source:()=&gt; 返回更改的文件内容，</span><br><span class="line">	 size:()=&gt;返回文件的大小</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;)</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">const &#123;CleanWebpackPlugin&#125;  from &apos;clean-webpack-plugin&apos; //自动清除输出目录 </span><br><span class="line">const HtmlWebpackPlugin  from &apos;html-webpack-plugin&apos; //自动生成html </span><br><span class="line">const CopyWebpackPlugin  from &apos;copy-webpack-plugin&apos; //拷贝不需要打包静态资源到输出目录</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plugins:[ </span><br><span class="line">new CleanWebpackPlugin(),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//index.html</span><br><span class="line">new HtmlWebpackPlugin(</span><br><span class="line">&#123;</span><br><span class="line">  title:&apos;diamonds&apos;,   //设置生成html的title属性</span><br><span class="line">  meta:&#123;</span><br><span class="line">   viewport:&apos;width=device-width&apos;</span><br><span class="line">  &#125;，</span><br><span class="line">  template:&apos;./src/index.html&apos;   //html使用的模板</span><br><span class="line">&#125;),</span><br><span class="line"></span><br><span class="line">//about.html</span><br><span class="line">new HtmlWebpackPlugin(</span><br><span class="line">&#123;</span><br><span class="line">  filename:&apos;about.html&apos;  //输出的文件名  默认是index.html</span><br><span class="line">&#125;),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//生产阶段使用</span><br><span class="line">new CopyWebpackPlugin([&apos;public&apos;]),  //将public目录下资源拷贝到输出目录</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h2><p>//工作模式  默认production</p>
<ul>
<li>production  //优化打包结果      代码压缩等</li>
<li>development  //优化打包速度，增加辅助函数便于调试</li>
<li>none   //不做处理</li>
</ul>
<h2 id="–watch"><a href="#–watch" class="headerlink" title="–watch"></a>–watch</h2><p> //监听  自动编译</p>
<h2 id="browser-sync"><a href="#browser-sync" class="headerlink" title="browser-sync"></a>browser-sync</h2><p>//实现浏览器自动刷新</p>
<p><code>browser-sync 文件目录  --files  &#39;**/*&#39;</code>   //启动并监听文件改变</p>
<h2 id="webapck-dev-server"><a href="#webapck-dev-server" class="headerlink" title="webapck-dev-server"></a>webapck-dev-server</h2><p>//集成自动编译、自动刷新功能</p>
<h2 id="devServer"><a href="#devServer" class="headerlink" title="devServer"></a>devServer</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//webpack-dev-server 配置选项</span><br><span class="line">devServer:&#123;</span><br><span class="line">  contentBase:&apos;&apos; , //额外为开发服务器指定查找资源目录</span><br><span class="line">  //代理服务配置</span><br><span class="line">  proxy:&#123;</span><br><span class="line">    //前缀</span><br><span class="line">    &apos;/api&apos;:&#123;</span><br><span class="line">	   //代理请求目标  http://localhost:8080/api/users -&gt; https://api.github.com/api/users</span><br><span class="line">	  target:&apos;https://api.github.com&apos;,</span><br><span class="line">	  //路径重写</span><br><span class="line">	  pathRewrite:&#123;</span><br><span class="line">	  &apos;^/api&apos;:&apos;&apos;   // https://api.github.com/users</span><br><span class="line">	  &#125;,</span><br><span class="line">	  //改变请求源</span><br><span class="line">	  changeOrigin:true</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="devtool"><a href="#devtool" class="headerlink" title="devtool"></a>devtool</h2><p>(build初次构建速度、rebuild监视模式重新打包速度、production是否适合在生产环境中使用、quality质量)     </p>
<ul>
<li><code>source-map</code></li>
<li><code>eval</code>  //通过<code>sourceURL</code>描述对应模块文件的资源路径   不生成对应的<code>sourceMap</code>,只能定位到错误出现的具体文件  构建速度快</li>
<li><code>cheap-eveal-source-map</code>   阉割版  生成的<code>sourceMap</code>只能定位到错误具体行，没有列的信息</li>
<li><code>cheap-module-eveal-source-map</code>   解析出来的源代码没有经过对应的loader加工，与手写时候的代码一样  一般开发环境使用多</li>
<li><code>inline-source-map</code> 通过<code>DataURL</code>方式将<code>sourceMap</code>嵌入到代码当中，<code>eval-source-map</code>也是</li>
<li><code>hidden-source-map</code> 代码当中没有通过注释方式引入<code>sourceMap</code></li>
<li><code>nosources-source-map</code> 能看到错误出现行列信息，但看不到源代码   生产环境不会暴露源代码</li>
<li><code>none</code>  推荐生产环境使用</li>
</ul>
<h2 id="HMR-热更新"><a href="#HMR-热更新" class="headerlink" title="HMR  热更新"></a><code>HMR</code>  热更新</h2><ul>
<li>应用运行过程中实时替换某个模块，应用运行状态不受影响</li>
<li>不刷新页面情况下，及时更新模块</li>
<li>提高开发效率</li>
<li>集成在<code>webpack-dev-server</code> 中  </li>
<li>使用方式：<code>webpack-dev-server --hot</code>  或 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">style-loader自动处理样式文件的热更新  js模块热更新需要手动处理</span><br><span class="line">const webpack=require(&apos;webpack&apos;)</span><br><span class="line">devServer:&#123;</span><br><span class="line">  hot:true  //热替换失败，自动刷新浏览器      hotOnly取消浏览器自动刷新</span><br><span class="line">&#125;,</span><br><span class="line">plugins:[</span><br><span class="line">  //module.hot</span><br><span class="line">  new webpack.HotModuleReplacementPlugin()</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">------------------</span><br><span class="line"></span><br><span class="line">注册模块更新后的处理函数</span><br><span class="line">//打包后代码会被自动移除，不会影响生产环境</span><br><span class="line">if(module.hot)&#123;</span><br><span class="line">module.hot.accept(&apos;模块路径&apos;,()=&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="webpack-config-js"><a href="#webpack-config-js" class="headerlink" title="webpack.config.js"></a>webpack.config.js</h2><p><code>webpack --env production</code>  //生产模式打包<br><code>webpack --config webpack.prod.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module.exports=(env,argv)=&gt;&#123;&#125;</span><br><span class="line">if(env===&apos;production&apos;)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">------------------</span><br><span class="line"></span><br><span class="line">const merge=require(&apos;webpack-merge&apos;)//合并webpack配置文件</span><br></pre></td></tr></table></figure>
<h2 id="definePlugin"><a href="#definePlugin" class="headerlink" title="definePlugin"></a>definePlugin</h2><ul>
<li>为代码注入全局成员</li>
<li><code>production</code>模式下默认启动，并注入<code>process.env.NODE_ENV</code>变量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const webpack =reuqire(&apos;webpack&apos;)</span><br><span class="line"></span><br><span class="line">plugins:[</span><br><span class="line"></span><br><span class="line">//注入全局变量</span><br><span class="line"> new webpack.DefinePlugin(&#123;</span><br><span class="line">    API_BASE_URL:&apos;&quot;&quot;&apos; //代码片段  可以通过JSON.stringify()传递变量</span><br><span class="line"> &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="tree-shaking-基于ES-Modules"><a href="#tree-shaking-基于ES-Modules" class="headerlink" title="tree-shaking  (基于ES Modules)"></a>tree-shaking  (基于ES Modules)</h2><ul>
<li>移除为引用代码</li>
<li>生产模式下自动开启</li>
<li>由Webpack打包的代码必须使用ESM</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//优化选项</span><br><span class="line">optimization:&#123;</span><br><span class="line">  usedExports:true,   //只导出外部使用过的成员</span><br><span class="line">  minimize:true, //代码压缩</span><br><span class="line">  concatenateModules:true  // `ScopeHoisting`作用域提升）   尽可能将所有模块合并在一起，提高运行效率，减少代码体积 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="babel-loader-与-tree-shaking"><a href="#babel-loader-与-tree-shaking" class="headerlink" title="babel-loader 与 tree-shaking"></a>babel-loader 与 tree-shaking</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">module:[</span><br><span class="line">  &#123;</span><br><span class="line">  test:/\.js$/,</span><br><span class="line">  use:&#123;</span><br><span class="line">    loader:&apos;babel-loader&apos;,</span><br><span class="line">	options:&#123;</span><br><span class="line">	 presets:[[&apos;@babel/preset-env&apos;],&#123;</span><br><span class="line">	  modules:&apos;commonjs&apos;   //默认是auto 根据环境判断是否开启ES Module插件</span><br><span class="line">	 &#125;]  //</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="sideEffects"><a href="#sideEffects" class="headerlink" title="sideEffects"></a>sideEffects</h2><p>//副作用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">optimization:&#123;</span><br><span class="line">   //production模式下会自动开启  为tree-shaking提供更大的压缩空间   （使用前应确保代码真的没有副作用。 副作用：模块执行时除了导出成员外所做的其它的事情	）</span><br><span class="line">  sideEffects:true//   webpack会先检查当前项目的package.json当中是否有sideEffects字段 ,  sideEffects:false表示没有副作用，也可是数组 sideEffects:[&apos;*.css&apos;]  表示有副作用的模块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="code-splitting"><a href="#code-splitting" class="headerlink" title="code splitting"></a>code splitting</h2><p>//代码分割 按需加载</p>
<ul>
<li>多入口打包</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">entry:&#123;</span><br><span class="line">   index:&apos;&apos;,</span><br><span class="line">   main:&apos;&apos;</span><br><span class="line">&#125;,</span><br><span class="line">output:&#123;</span><br><span class="line">  //动态生成</span><br><span class="line">   filename:&apos;[name].bundle.js&apos;</span><br><span class="line">&#125;,</span><br><span class="line">plugins:[</span><br><span class="line"></span><br><span class="line">    //默认生成自动注入所有打包结果的html，可以通过chunks属性为生成的html指定所需要的bundle</span><br><span class="line">   new HtmlWebpackPlugin(&#123;</span><br><span class="line">     title:&apos;&apos;,</span><br><span class="line">	 template:&apos;./src/index.html&apos;,</span><br><span class="line">	 filename:&apos;index.html&apos;,</span><br><span class="line">	 chunks:[&apos;index&apos;] </span><br><span class="line">   &#125;),</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">     title:&apos;&apos;,</span><br><span class="line">	 template:&apos;./src/main.html&apos;,</span><br><span class="line">	 filename:&apos;main.html&apos;,</span><br><span class="line">	 chunks:[&apos;main&apos;] </span><br><span class="line">   &#125;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<ul>
<li>ES Module 动态导入   </li>
</ul>
<p>//模块会被自动分包  可以通过魔法注释为生成的bundle文件设置名字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import (/* webpackChunkName:&apos;&apos; */ &apos;&apos;).then((&#123;default:module&#125;)=&gt;&#123;&#125;)   //相同的chunkName会被打包到一起</span><br></pre></td></tr></table></figure>
<ul>
<li>提取公共模块<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">optimization:&#123;</span><br><span class="line">  splitChunks:&#123;</span><br><span class="line">    chunks:&apos;all&apos;  // 会将所有的公共模块提取到单独的bundle当中</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="mini-css-extract-plugin"><a href="#mini-css-extract-plugin" class="headerlink" title="mini-css-extract-plugin"></a>mini-css-extract-plugin</h2><p>//（css文件超过150kb时可以考虑单独提取）  样式会单独存放在文件当中，不在需要style标签引入（style-loader）,通过link标签方式注入样式文件  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">module:&#123;</span><br><span class="line">   rules:[</span><br><span class="line">   &#123;</span><br><span class="line">   test:/\.css$/,</span><br><span class="line">   use:[</span><br><span class="line">   MiniCssExtractPlugin.loader,  //通过link标签引入样式文件</span><br><span class="line">   &apos;css-loader&apos;</span><br><span class="line">   ] </span><br><span class="line">   &#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="optimize-css-assets-webpack-plugin"><a href="#optimize-css-assets-webpack-plugin" class="headerlink" title="optimize-css-assets-webpack-plugin"></a>optimize-css-assets-webpack-plugin</h2><p> //压缩css文件   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">optimization:&#123;         </span><br><span class="line">  //webpack默认压缩js代码</span><br><span class="line">  //production模式自动开启</span><br><span class="line">  //自动压缩插件</span><br><span class="line">  minimizer:[</span><br><span class="line">   new OptimizeCssAssetsWebpackPlugin()</span><br><span class="line">   new TerserWebpackPlugin()   //压缩js代码</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="输出文件名-Hash"><a href="#输出文件名-Hash" class="headerlink" title="输出文件名 Hash"></a>输出文件名 Hash</h2><ul>
<li>filename:’[name]-[hash].bundle.css’  //项目任一文件发生改变，hash值都会改变</li>
<li>filename:’[name]-[chunkhash].bundle.css’  //chunk级别</li>
<li>filename:’[name]-[contenthash:8].bundle.css’  //单个文件级别</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/学习/">学习</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/学习/">学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网站/">网站</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/资源/">资源</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-yeoman" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2021/03/08/yeoman/" class="article-date">
      <time datetime="2021-03-07T16:00:00.000Z" itemprop="datePublished">2021-03-08</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/08/yeoman/">脚手架/yeoman/gulp</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="脚手架"><a href="#脚手架" class="headerlink" title="脚手架"></a>脚手架</h2><ul>
<li>创建项目基本结构、提供项目规范和约定(组织结构、开发范式、模块依赖、工具配置、基础代码)</li>
<li>搭建脚手架</li>
</ul>
<ol>
<li>创建cli.js文件,</li>
<li>在package.json添加字段 “bin”:”cli.js” 指明入口文件  </li>
<li><code>yarn add inquirer</code>来发起命令行交互</li>
<li>创建templates目录</li>
<li><code>yarn add ejs</code></li>
<li>yarn link 使之成为一个全局的模块<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env node</span><br><span class="line">//Node CLI应用入口文件必须要有这样的文件头</span><br><span class="line">//如果是Linux或者macOS还需要修改此文件的读写权限为755</span><br><span class="line"></span><br><span class="line"> const path=require(&apos;path&apos;)</span><br><span class="line"> const fa=require(&apos;fs&apos;)</span><br><span class="line"> const inquirer=require(&apos;inquirer&apos;)</span><br><span class="line"> const ejs=require(&apos;ejs&apos;)</span><br><span class="line"> inquirer.prompt([</span><br><span class="line"> &#123;</span><br><span class="line">  type:&apos;input&apos;,</span><br><span class="line">  name:&apos;name&apos;,</span><br><span class="line">  message:&apos;project name&apos;</span><br><span class="line"> &#125;</span><br><span class="line"> ]).then(answers=&gt;&#123;</span><br><span class="line"> </span><br><span class="line"> //模板目录</span><br><span class="line">    const tmpDir=path.join(__dirname,&apos;templates&apos;)</span><br><span class="line"> //目标目录   </span><br><span class="line">    const destDir=process.cwd() </span><br><span class="line"> </span><br><span class="line">    fs.readdir(tmpDir,(err,files)=&gt;&#123;</span><br><span class="line">	 if(err) return</span><br><span class="line">	 files.forEach(()=&gt;&#123;</span><br><span class="line">	  //通过模板引擎渲染文件</span><br><span class="line">	  </span><br><span class="line">	  ejs.renderFile(path.join(tmpDir,file,answers,(err,result)=&gt;&#123;</span><br><span class="line">	   if(err) return</span><br><span class="line">	  </span><br><span class="line">	  //将结果写入文件</span><br><span class="line">	   fs.writeFileSync(path.join(destDir,file),result)</span><br><span class="line">	  &#125;))</span><br><span class="line">	 </span><br><span class="line">	 &#125;)</span><br><span class="line">	 </span><br><span class="line">	&#125;)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="Yeoman"><a href="#Yeoman" class="headerlink" title="Yeoman"></a>Yeoman</h3><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><ol>
<li>全局安装：<code>yarn global add yo</code> 或 <code>npm install yo --global</code></li>
<li>安装相关generator:例如  <code>yarn global add generator-node</code> 或 <code>npm install generator-node --global</code></li>
<li>运行generator: 例如  <code>yo node</code></li>
</ol>
<h4 id="自定义generator"><a href="#自定义generator" class="headerlink" title="自定义generator"></a>自定义generator</h4><ol>
<li>创建文件目录：</li>
</ol>
<ul>
<li>generator模块名称必须是generator-name格式。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* generators 生成器目录</span><br><span class="line">  * app      默认生成器目录</span><br><span class="line">    * templates 模板目录   内部文件可以使用EJS模板标记输出数据 例如&lt;%= title %&gt; 或&lt;% if (success) &#123; %&gt; &lt;% &#125; %&gt;</span><br><span class="line">    * index.js  默认生成器实现</span><br><span class="line">* package.json   配置文件</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="2">
<li>创建generator</li>
</ol>
<ul>
<li>安装yeoman-generator </li>
<li>在index.js文件编写逻辑<br>index.js文件是generator的入口文件，该文件需要导出一个继承自Yeoman Generator的类型。<br>Yeoman Generator在工作时会自动调用我们在此类型文件中定义的一些生命周期方法。<br>我们可以在这些方法中调用父类提供的一些工具方法实现一些功能，例如文件写入<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">const Generator=require(&apos;yeoman-genertaor&apos;)</span><br><span class="line">module.exports=class extends Generator&#123;</span><br><span class="line"></span><br><span class="line">//yeoman在询问用户时会自动调用此方法</span><br><span class="line">prompting()&#123;</span><br><span class="line">//返回的时promise类型  参数时数组  对应每个问题</span><br><span class="line">return this.prompt([</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  type:&apos;input&quot;,</span><br><span class="line">  name:&apos;name&apos;,</span><br><span class="line">  message:&apos;项目名字&apos;，</span><br><span class="line">  default:this.appname //appname为项目生成目录名称</span><br><span class="line">&#125;</span><br><span class="line">]).then(answers=&gt;&#123;</span><br><span class="line">//answers=&gt;  &#123;name:&apos;用户输入的值&apos;&#125;</span><br><span class="line">  this.answers=answers   //作为模板的上下文数据</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//yeoman在生成文件时自动调用此方法</span><br><span class="line"> writing()&#123;</span><br><span class="line">   </span><br><span class="line"> </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="3">
<li>通过<code>yarn link</code>或<code>npm link</code>使之成为一个全局的模块</li>
<li>通过yo命令运行generator</li>
<li>发布generator <code>npm publish</code>或<code>yarn publish --registry=https://registry.yarnpkg.com</code><h3 id="Plop"><a href="#Plop" class="headerlink" title="Plop"></a>Plop</h3></li>
<li>作为开发依赖安装 <code>yarn add plop --dev</code> </li>
<li><p>创建plopfile.js文件,plop-templates目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">module.exports=plop=&gt;&#123;</span><br><span class="line"></span><br><span class="line"> plop.setGenerator(&apos;component&apos;,&#123;</span><br><span class="line">  description:&apos;create a component&apos;,</span><br><span class="line">  prompts:[&#123;</span><br><span class="line">  </span><br><span class="line">   type:&apos;input&apos;,</span><br><span class="line">   name:&apos;name&apos;,</span><br><span class="line">   message:&apos;component name&apos;,</span><br><span class="line">   default:&apos;MyComponent&apos;</span><br><span class="line">  &#125;],</span><br><span class="line">  actions:[</span><br><span class="line">  &#123;</span><br><span class="line">  //添加文件</span><br><span class="line">  type:&apos;add&apos;,</span><br><span class="line">   path:&apos;src/components/&#123;&#123;name&#125;&#125;/&#123;&#123;name&#125;&#125;.js&apos;</span><br><span class="line">   templateFile:&apos;plop-templates/component.hbs&apos;</span><br><span class="line">  &#125;，</span><br><span class="line">   &#123;</span><br><span class="line">  //添加文件</span><br><span class="line">  type:&apos;add&apos;,</span><br><span class="line">   path:&apos;src/components/&#123;&#123;name&#125;&#125;/&#123;&#123;name&#125;&#125;.css&apos;</span><br><span class="line">   templateFile:&apos;plop-templates/component.css.hbs&apos;</span><br><span class="line">  &#125;，</span><br><span class="line">  ]</span><br><span class="line"> &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>yarn plop component</code> 对应上面设置的generator名字</p>
</li>
</ol>
<h2 id="gulp"><a href="#gulp" class="headerlink" title="gulp"></a>gulp</h2>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/学习/">学习</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/学习/">学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网站/">网站</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/资源/">资源</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-question_five" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2021/01/10/question_five/" class="article-date">
      <time datetime="2021-01-09T16:00:00.000Z" itemprop="datePublished">2021-01-10</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/01/10/question_five/">知识点五</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <blockquote>
<p>2021-1-10</p>
</blockquote>
<h3 id="如何理解-JS-异步编程，EventLoop、消息队列都是做什么的，什么是宏任务，什么是微任务？"><a href="#如何理解-JS-异步编程，EventLoop、消息队列都是做什么的，什么是宏任务，什么是微任务？" class="headerlink" title="如何理解 JS 异步编程，EventLoop、消息队列都是做什么的，什么是宏任务，什么是微任务？"></a>如何理解 JS 异步编程，EventLoop、消息队列都是做什么的，什么是宏任务，什么是微任务？</h3><ul>
<li><p>JS 异步编程</p>
<p>JavaScript 语言的执行环境是单线程的，一次只能执行一个任务，多任务需要排队等候，这种模式可能会阻塞代码，导致代码执行效率低下。为了避免这个问题，出现了异步编程。一般是通过 callback 回调函数、事件发布/订阅、Promise 等来组织代码，本质都是通过回调函数来实现异步代码的存放与执行。</p>
</li>
<li><p>EventLoop 事件环和消息队列</p>
<p><strong>EventLoop</strong> 是一种循环机制 ，不断去轮询一些队列 ，从中找到 需要执行的任务并按顺序执行的一个执行模型。</p>
<p><strong>消息队列</strong> 是用来存放宏任务的队列， 比如定时器时间到了， 定时间内传入的方法引用会存到该队列， ajax回调之后的执行方法也会存到该队列。</p>
</li>
</ul>
<p>  一开始整个脚本作为一个宏任务执行。执行过程中同步代码直接执行，宏任务等待时间到达或者成功后，将方法的回调放入宏任务队列中，微任务进入微任务队列。</p>
<p>  当前主线程的宏任务执行完出队，检查并清空微任务队列。接着执行浏览器 UI 线程的渲染工作，检查web worker 任务，有则执行。</p>
<p>  然后再取出一个宏任务执行。以此循环…</p>
<ul>
<li><p>宏任务与微任务</p>
<p><strong>宏任务</strong>可以理解为每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）。</p>
<p>浏览器为了让 JS 内部宏任务 与 DOM 操作能够有序的执行，会在一个宏任务执行结束后，在下一个宏任务执行开始前，对页面进行重新渲染。</p>
<p>宏任务包含：script(整体代码)、setTimeout、setInterval、I/O、UI交互事件、MessageChannel 等</p>
</li>
</ul>
<p>  <strong>微任务</strong>可以理解是在当前任务执行结束后需要立即执行的任务。也就是说，在当前任务后，在渲染之前，执行清空微任务。</p>
<p>  所以它的响应速度相比宏任务会更快，因为无需等待 UI 渲染。</p>
<p>  微任务包含：Promise.then、MutaionObserver、process.nextTick(Node.js 环境)等</p>
<h3 id="基于以下代码完成下面的四个练习"><a href="#基于以下代码完成下面的四个练习" class="headerlink" title="基于以下代码完成下面的四个练习"></a>基于以下代码完成下面的四个练习</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const fp = require(&apos;lodash/fp&apos;)</span><br><span class="line">// 数据：horsepower 马力，dollar_value 价格，in_stock 库存</span><br><span class="line">const cars = [</span><br><span class="line">    &#123; name: &apos;Ferrari FF&apos;, horsepower: 660, dollar_value: 700000, in_stock: true &#125;,</span><br><span class="line">    &#123; name: &apos;Spyker C12 Zagato&apos;, horsepower: 650, dollar_value: 648000, in_stock: false &#125;,</span><br><span class="line">    &#123; name: &apos;Jaguar XKR-S&apos;, horsepower: 550, dollar_value: 132000, in_stock: false &#125;,</span><br><span class="line">    &#123; name: &apos;Audi R8&apos;, horsepower: 525, dollar_value: 114200, in_stock: false &#125;,</span><br><span class="line">    &#123; name: &apos;Aston Martin One-77&apos;, horsepower: 750, dollar_value: 1850000, in_stock: true &#125;,</span><br><span class="line">    &#123; name: &apos;Pagani Huayra&apos;, horsepower: 700, dollar_value: 1300000, in_stock: false &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h4 id="使用组合函数-fp-flowRight-重新实现下面这个函数"><a href="#使用组合函数-fp-flowRight-重新实现下面这个函数" class="headerlink" title="使用组合函数 fp.flowRight() 重新实现下面这个函数"></a>使用组合函数 fp.flowRight() 重新实现下面这个函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let isLastInStock = function(cars)&#123;</span><br><span class="line">    // 获取最后一条数据</span><br><span class="line">    let last_car = fp.last(cars)</span><br><span class="line">    // 获取最后一条数据的 in_stock 属性值</span><br><span class="line">    return fp.prop(&apos;in_stock&apos;, last_car)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>先定义获取最后一条数据的函数，再定义获取某个对象中的 in_stock 属性的函数，再用 fp.flowRight 组合函数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let isLastInStock = fp.flowRight(fp.prop(&apos;in_stock&apos;), fp.last);</span><br><span class="line">console.log(isLastInStock(cars)); // false</span><br></pre></td></tr></table></figure>
<h4 id="使用-fp-flowRight-、fp-prop-和-fp-first-获取第一个-car-的-name"><a href="#使用-fp-flowRight-、fp-prop-和-fp-first-获取第一个-car-的-name" class="headerlink" title="使用 fp.flowRight()、fp.prop() 和 fp.first() 获取第一个 car 的 name"></a>使用 fp.flowRight()、fp.prop() 和 fp.first() 获取第一个 car 的 name</h4><blockquote>
<p>先定义获取第一条数据的函数，再定义获取某个对象中的 name 属性的函数，再用 fp.flowRight 组合函数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const getFirstName = fp.flowRight(fp.prop(&quot;name&quot;), fp.first)</span><br><span class="line">console.log(getFirstName(cars)) // Ferrari FF</span><br></pre></td></tr></table></figure>
<h4 id="使用帮助函数-average-重构-averageDollarValue，使用函数组合的方式实现"><a href="#使用帮助函数-average-重构-averageDollarValue，使用函数组合的方式实现" class="headerlink" title="使用帮助函数 _average 重构 averageDollarValue，使用函数组合的方式实现"></a>使用帮助函数 _average 重构 averageDollarValue，使用函数组合的方式实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let _average = function(xs)&#123;</span><br><span class="line">    return fp.reduce(fp.add, 0, xs) / xs.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>先定义获取某个对象中的 dollar_value 属性的函数，将该函数作为 fp.map 的数组元素处理函数，再用 fp.flowRight 组合函数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let averageDollarValue = fp.flowRight(_average, fp.map(&apos;dollar_value&apos;));</span><br><span class="line">console.log(averageDollarValue(cars));  //790700</span><br></pre></td></tr></table></figure>
<h4 id="使用-flowRight-写一个-sanitizeNames-函数，返回一个下划线连续的小写字符串，把数组中的-name-转换为这种形式，例如：sanitizeNames-“Hello-World”-gt-“hello-world”"><a href="#使用-flowRight-写一个-sanitizeNames-函数，返回一个下划线连续的小写字符串，把数组中的-name-转换为这种形式，例如：sanitizeNames-“Hello-World”-gt-“hello-world”" class="headerlink" title="使用 flowRight 写一个 sanitizeNames() 函数，返回一个下划线连续的小写字符串，把数组中的 name 转换为这种形式，例如：sanitizeNames([“Hello World”]) =&gt; [“hello_world”]"></a>使用 flowRight 写一个 sanitizeNames() 函数，返回一个下划线连续的小写字符串，把数组中的 name 转换为这种形式，例如：sanitizeNames([“Hello World”]) =&gt; [“hello_world”]</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let _underscore = fp.replace(/\W+/g, &apos;_&apos;) // 无须改动，并在 sanitizeNames 中使用它</span><br></pre></td></tr></table></figure>
<blockquote>
<p>先定义获取某个对象中的 name 属性的函数，再定义转化为小写的函数，再将空格和下划线替换，,再用 fp.flowRight 组合函数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let sanitizeNames = fp.flowRight(</span><br><span class="line">  fp.map(_underscore),</span><br><span class="line">  fp.map(fp.toLower),</span><br><span class="line">  fp.map((car) =&gt; car.name)</span><br><span class="line">);</span><br><span class="line">console.log(sanitizeNames(CARS)) </span><br><span class="line">// [</span><br><span class="line">//  &apos;ferrari_ff&apos;,       </span><br><span class="line">//  &apos;spyker_c12_zagato&apos;,</span><br><span class="line">//  &apos;jaguar_xkr_s&apos;,</span><br><span class="line">//  &apos;audi_r8&apos;,</span><br><span class="line">//  &apos;aston_martin_one_77&apos;,</span><br><span class="line">//  &apos;pagani_huayra&apos;</span><br><span class="line">// ]</span><br></pre></td></tr></table></figure>
<h3 id="基于下面提供的代码，完成后续的四个练习"><a href="#基于下面提供的代码，完成后续的四个练习" class="headerlink" title="基于下面提供的代码，完成后续的四个练习"></a>基于下面提供的代码，完成后续的四个练习</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// support.js</span><br><span class="line">class Container &#123;</span><br><span class="line">    static of(value)&#123;</span><br><span class="line">        return new Container(value)</span><br><span class="line">    &#125;</span><br><span class="line">    constructor(value)&#123;</span><br><span class="line">        this._value = value</span><br><span class="line">    &#125;</span><br><span class="line">    map(fn)&#123;</span><br><span class="line">        return Container.of(fn(this._value))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Maybe &#123;</span><br><span class="line">    static of(x)&#123;</span><br><span class="line">        return new Maybe(x)</span><br><span class="line">    &#125;</span><br><span class="line">    isNothing()&#123;</span><br><span class="line">        return this._value === null || this._value === undefined</span><br><span class="line">    &#125;</span><br><span class="line">    constructor(x)&#123;</span><br><span class="line">        this._value = x</span><br><span class="line">    &#125;</span><br><span class="line">    map(fn)&#123;</span><br><span class="line">        return this.isNothing() ? this : Maybe.of(fn(this._value))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = &#123; Maybe, Container &#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用-fp-add-x-y-和-fp-map-f-x-创建一个能让-functor-里的值增加的函数-ex1"><a href="#使用-fp-add-x-y-和-fp-map-f-x-创建一个能让-functor-里的值增加的函数-ex1" class="headerlink" title="使用 fp.add(x, y) 和 fp.map(f,x) 创建一个能让 functor 里的值增加的函数 ex1"></a>使用 fp.add(x, y) 和 fp.map(f,x) 创建一个能让 functor 里的值增加的函数 ex1</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const fp = require(&apos;lodash/fp&apos;)</span><br><span class="line">const &#123;Maybe, Container&#125; = require(&apos;./support&apos;)</span><br><span class="line">let maybe = Maybe.of([5,6,1])</span><br><span class="line">let ex1 = () =&gt; &#123;</span><br><span class="line">    // 你需要实现的函数。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>函子对象的 map 方法可以运行一个函数对值进行处理，函数的参数为传入 of 方法的参数；接着对传入的整个数组进行遍历，并对每一项执行 fp.add 方法</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let ex1 = maybe.map(i =&gt; fp.map(fp.add(1), i))</span><br><span class="line">console.log(ex1) // [6, 7, 2]</span><br></pre></td></tr></table></figure>
<h4 id="实现一个函数-ex2，能够使用-fp-first-获取列表的第一个元素"><a href="#实现一个函数-ex2，能够使用-fp-first-获取列表的第一个元素" class="headerlink" title="实现一个函数 ex2，能够使用 fp.first 获取列表的第一个元素"></a>实现一个函数 ex2，能够使用 fp.first 获取列表的第一个元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const fp = require(&apos;lodash/fp&apos;)</span><br><span class="line">const &#123;Maybe, Container&#125; = require(&apos;./support&apos;)</span><br><span class="line">let xs = Container.of([&apos;do&apos;, &apos;ray&apos;, &apos;me&apos;, &apos;fa&apos;, &apos;so&apos;, &apos;la&apos;, &apos;ti&apos;, &apos;do&apos;])</span><br><span class="line">let ex2 = () =&gt; &#123;</span><br><span class="line">    // 你需要实现的函数。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>解答如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let ex2 = xs.map(i =&gt; fp.first(i))</span><br><span class="line">console.log(ex2)// do</span><br></pre></td></tr></table></figure>
<h4 id="实现一个函数-ex3，使用-safeProp-和-fp-first-找到-user-的名字的首字母"><a href="#实现一个函数-ex3，使用-safeProp-和-fp-first-找到-user-的名字的首字母" class="headerlink" title="实现一个函数 ex3，使用 safeProp 和 fp.first 找到 user 的名字的首字母"></a>实现一个函数 ex3，使用 safeProp 和 fp.first 找到 user 的名字的首字母</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const fp = require(&apos;lodash/fp&apos;)</span><br><span class="line">const &#123;Maybe, Container&#125; = require(&apos;./support&apos;)</span><br><span class="line">let safeProp = fp.curry(function(x, o)&#123;</span><br><span class="line">    return Maybe.of(o[x])</span><br><span class="line">&#125;)</span><br><span class="line">let user = &#123; id: 2, name: &apos;Albert&apos; &#125;</span><br><span class="line">let ex3 = () =&gt; &#123;</span><br><span class="line">    // 你需要实现的函数。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>调用 ex3 函数传入 user 对象，safeProp 是经过柯里化处理的，可以先传“属性”参数，后传“对象”参数。safeProp 函数处理后返回 user 的值，再调用fp.first 获取首字母</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let ex3 = fp.flowRight(fp.map(i =&gt; fp.first(i)), safeProp(&apos;name&apos;))</span><br><span class="line">console.log(ex3(user)) // A</span><br><span class="line">// 或者 return safeProp(&quot;name&quot;, user).map(x =&gt; fp.first(x));</span><br></pre></td></tr></table></figure>
<h4 id="使用-Maybe-重写-ex4，不要有-if-语句"><a href="#使用-Maybe-重写-ex4，不要有-if-语句" class="headerlink" title="使用 Maybe 重写 ex4，不要有 if 语句"></a>使用 Maybe 重写 ex4，不要有 if 语句</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const fp = require(&apos;lodash/fp&apos;)</span><br><span class="line">const &#123;Maybe, Container&#125; = require(&apos;./support&apos;)</span><br><span class="line">let ex4 = function(n)&#123;</span><br><span class="line">    if(n)&#123;</span><br><span class="line">        return parseInt(n)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>MayBe 函子用来处理外部的空值情况，防止空值的异常，拿到函子的值之后进行 parseInt 转化</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let ex4 = n =&gt; Maybe.of(n).map(parseInt)</span><br><span class="line">console.log(ex4(&apos;1&apos;)) // 1</span><br></pre></td></tr></table></figure>
<h3 id="手写实现-MyPromise-源码"><a href="#手写实现-MyPromise-源码" class="headerlink" title="手写实现 MyPromise 源码"></a>手写实现 MyPromise 源码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始状态</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">"pending"</span>;</span><br><span class="line"><span class="comment">// 完成状态</span></span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">"fulfilled"</span>;</span><br><span class="line"><span class="comment">// 失败状态</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">"rejected"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步执行方法封装</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncExecFun</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> fn(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行promise resolve功能</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise, res, resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回同一个promise</span></span><br><span class="line">  <span class="keyword">if</span> (promise === res) &#123;</span><br><span class="line">    reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Chaining cycle detected for promise #&lt;MyPromise&gt;"</span>));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// promise结果</span></span><br><span class="line">  <span class="keyword">if</span> (res <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">    res.then(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 非promise结果</span></span><br><span class="line">    resolve(res);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 是个构造函数</span></span><br><span class="line"><span class="comment"> * 2. 传入一个可执行函数 函数的入参第一个为 fullFill函数 第二个为 reject函数；  函数立即执行，  参数函数异步执行</span></span><br><span class="line"><span class="comment"> * 3. 状态一旦更改就不可以变更  只能 pending =&gt; fulfilled 或者  pending =&gt; rejected</span></span><br><span class="line"><span class="comment"> * 4. then 的时候要处理入参的情况 successCallback 和failCallback 均可能为非函数</span></span><br><span class="line"><span class="comment"> *      默认的 failCallback 一定要将异常抛出， 这样下一个promise便可将其捕获 异常冒泡的目的</span></span><br><span class="line"><span class="comment"> * 5. then 中执行回调的时候要捕获异常 将其传给下一个promise</span></span><br><span class="line"><span class="comment"> *    如果promise状态未变更 则将回调方法添加到对应队列中</span></span><br><span class="line"><span class="comment"> *    如果promise状态已经变更 需要异步处理成功或者失败回调</span></span><br><span class="line"><span class="comment"> *    因为可能出现 回调结果和当前then返回的Promise一致 从而导致死循环问题</span></span><br><span class="line"><span class="comment"> * 6. catch只是then的一种特殊的写法 方便理解和使用</span></span><br><span class="line"><span class="comment"> * 7. finally 特点 1. 不过resolve或者reject都会执行</span></span><br><span class="line"><span class="comment"> *                2. 回调没有参数</span></span><br><span class="line"><span class="comment"> *                3. 返回一个Promise 且值可以穿透到下一个then或者catch</span></span><br><span class="line"><span class="comment"> * 8. Promise.resolve, Promise.reject 根据其参数返回对应的值 或者状态的Promise即可</span></span><br><span class="line"><span class="comment"> * 9. Proise.all 特点  1. 返回一个Promise</span></span><br><span class="line"><span class="comment"> *                    2. 入参是数组 resolve的情况下出参也是数组 且结果顺序和调用顺序一致</span></span><br><span class="line"><span class="comment"> *                    3. 所有的值或者promise都完成才能resolve 所有要计数</span></span><br><span class="line"><span class="comment"> *                    4. 只要有一个为reject 返回的Promise便reject</span></span><br><span class="line"><span class="comment"> * 10. Proise.race 特点 1. 返回一个Promise</span></span><br><span class="line"><span class="comment"> *                    2. 入参是数组 那么出参根据第一个成功或者失败的参数来确定</span></span><br><span class="line"><span class="comment"> *                    3. 只要有一个resolve 或者reject 便更改返回Promise的状态</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  status = PENDING;</span><br><span class="line">  value = <span class="literal">undefined</span>;</span><br><span class="line">  reason = <span class="literal">undefined</span>;</span><br><span class="line">  successCallbacks = [];</span><br><span class="line">  failCallbacks = [];</span><br><span class="line">  <span class="keyword">constructor</span>(exector) &#123;</span><br><span class="line">    <span class="comment">// 立即执行传入参数</span></span><br><span class="line">    <span class="comment">// 参数直接写为 this.resolve  会导致函数内 this指向会发生改变</span></span><br><span class="line">    <span class="comment">// 异步执行状态变更</span></span><br><span class="line">    <span class="comment">// 捕获执行器的异常</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        exector(</span><br><span class="line">          (value) =&gt; asyncExecFun(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.resolve(value)),</span><br><span class="line">          (reason) =&gt; asyncExecFun(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.reject(reason))</span><br><span class="line">        );</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">this</span>.reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  resolve(value) &#123;</span><br><span class="line">    <span class="comment">// 如果状态已经变更则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.status !== PENDING) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">    <span class="keyword">this</span>.status = FULFILLED;</span><br><span class="line">    <span class="comment">// 执行所有成功回调</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>.successCallbacks.length) <span class="keyword">this</span>.successCallbacks.shift()();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  reject(reason) &#123;</span><br><span class="line">    <span class="comment">// 如果状态已经变更则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.status !== PENDING) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">this</span>.reason = reason;</span><br><span class="line">    <span class="keyword">this</span>.status = REJECTED;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>.failCallbacks.length)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">'(in MyPromise)'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行所有失败回调</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>.failCallbacks.length) <span class="keyword">this</span>.failCallbacks.shift()();</span><br><span class="line">  &#125;</span><br><span class="line">  then(successCallback, failCallback) &#123;</span><br><span class="line">    <span class="comment">// 成功函数处理 忽略函数之外的其他值</span></span><br><span class="line">    successCallback =</span><br><span class="line">      <span class="keyword">typeof</span> successCallback == <span class="string">"function"</span> ? successCallback : <span class="function">(<span class="params">v</span>) =&gt;</span> v;</span><br><span class="line">    <span class="comment">// 失败函数处理 忽略函数之外的其他值 抛出异常  实现catch冒泡的关键</span></span><br><span class="line">    failCallback =</span><br><span class="line">      <span class="keyword">typeof</span> failCallback == <span class="string">"function"</span></span><br><span class="line">        ? failCallback</span><br><span class="line">        : <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> reason;</span><br><span class="line">          &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> promise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 统一异常处理逻辑</span></span><br><span class="line">      <span class="keyword">const</span> execFun = <span class="function">(<span class="params">fn, val</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> res = fn(val);</span><br><span class="line">          resolvePromise(promise, res, resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="comment">// 执行成功回调</span></span><br><span class="line">      <span class="keyword">const</span> execSuccessCallback = <span class="function"><span class="params">()</span> =&gt;</span> execFun(successCallback, <span class="keyword">this</span>.value);</span><br><span class="line">      <span class="comment">// 执行失败回调</span></span><br><span class="line">      <span class="keyword">const</span> execFailCallback = <span class="function"><span class="params">()</span> =&gt;</span> execFun(failCallback, <span class="keyword">this</span>.reason);</span><br><span class="line">      <span class="comment">// 同步将对应成功或者失败回调事件加入对应回调队列</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === PENDING) &#123;</span><br><span class="line">        <span class="comment">// 将成功回调加入队列</span></span><br><span class="line">        <span class="keyword">this</span>.successCallbacks.push(execSuccessCallback);</span><br><span class="line">        <span class="comment">// 讲失败回调加入队列</span></span><br><span class="line">        <span class="keyword">this</span>.failCallbacks.push(execFailCallback);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 延迟执行 可以将函数执行结果和当前then 返回的promise 进行比较</span></span><br><span class="line">      asyncExecFun(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 如果已经 fulfilled 可直接调用成功回调方法</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.status === FULFILLED) &#123;</span><br><span class="line">          execSuccessCallback();</span><br><span class="line">          <span class="comment">// 如果已经 rejected 可直接调用失败回调方法</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.status === REJECTED) &#123;</span><br><span class="line">          execFailCallback();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">catch</span>(failCallback) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">undefined</span>, failCallback);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">finally</span>(callback) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.then(</span><br><span class="line">      <span class="comment">// 穿透正常值</span></span><br><span class="line">      (value) =&gt; MyPromise.resolve(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> value),</span><br><span class="line">      (reason) =&gt;</span><br><span class="line">        MyPromise.resolve(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 穿透异常信息</span></span><br><span class="line">          <span class="keyword">throw</span> reason;</span><br><span class="line">        &#125;)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> resolve(value) &#123;</span><br><span class="line">    <span class="comment">// 如果是MyPromise 实例 则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> MyPromise) <span class="keyword">return</span> value;</span><br><span class="line">    <span class="comment">// 如果是MyPromise 实例 否则返回一个 MyPromise实例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve</span>) =&gt;</span> resolve(value));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> reject(reason) &#123;</span><br><span class="line">    <span class="comment">// 如果是MyPromise 实例 则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (reason <span class="keyword">instanceof</span> MyPromise) <span class="keyword">return</span> reason;</span><br><span class="line">    <span class="comment">// 如果是MyPromise 实例 否则返回一个 MyPromise实例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(reason));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// all方法</span></span><br><span class="line">  <span class="keyword">static</span> all(array) &#123;</span><br><span class="line">    <span class="comment">// 存储结果</span></span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="comment">// 存储数组长度</span></span><br><span class="line">    <span class="keyword">let</span> len = array.length;</span><br><span class="line">    <span class="comment">// 创建返回MyPromise</span></span><br><span class="line">    <span class="keyword">let</span> promise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 定义当前MyPromise的索引</span></span><br><span class="line">      <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// 添加数据的公用方法</span></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">addData</span>(<span class="params">key, data</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 赋值</span></span><br><span class="line">        result[key] = data;</span><br><span class="line">        <span class="comment">// 索引递增</span></span><br><span class="line">        index++;</span><br><span class="line">        <span class="comment">// 全部执行完则resolve</span></span><br><span class="line">        <span class="keyword">if</span> (index == len) &#123;</span><br><span class="line">          resolve(result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 按顺序变量数组</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> curr = array[i];</span><br><span class="line">        <span class="comment">// 如果是MyPromise则 按其规则处理</span></span><br><span class="line">        <span class="keyword">if</span> (curr <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">          curr.then(<span class="function">(<span class="params">value</span>) =&gt;</span> addData(i, value), reject);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 非MyPromise直接赋值</span></span><br><span class="line">          addData(i, curr);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 返回新的MyPromise实例</span></span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 只要有一个成功或者失败就返回</span></span><br><span class="line">  <span class="keyword">static</span> race(array) &#123;</span><br><span class="line">    <span class="keyword">let</span> promise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> curr = array[i];</span><br><span class="line">        <span class="comment">// MyPromise实例 结果处理</span></span><br><span class="line">        <span class="keyword">if</span> (curr <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">          curr.then(resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 非MyPromise实例处理</span></span><br><span class="line">          resolve(curr);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = MyPromise;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/前端/">前端</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/css/">css</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/">js</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-question_four" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2021/01/10/question_four/" class="article-date">
      <time datetime="2021-01-09T16:00:00.000Z" itemprop="datePublished">2021-01-10</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/01/10/question_four/">知识点四</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="请说出下列最终的执行结果，并解释为什么。"><a href="#请说出下列最终的执行结果，并解释为什么。" class="headerlink" title="请说出下列最终的执行结果，并解释为什么。"></a>请说出下列最终的执行结果，并解释为什么。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = [];</span><br><span class="line">for (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    a[i] = function() &#123;</span><br><span class="line">        console.log(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">a[6]()</span><br></pre></td></tr></table></figure>
<p>答：结果是10。因为for循环里的i是全局变量，for循环执行完之后，i已经变成了10，所以之后无论调用a几，输出的都是10。</p>
<hr>
<h2 id="请说出下列最终的执行结果，并解释为什么。-1"><a href="#请说出下列最终的执行结果，并解释为什么。-1" class="headerlink" title="请说出下列最终的执行结果，并解释为什么。"></a>请说出下列最终的执行结果，并解释为什么。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var tmp = 123;</span><br><span class="line">if (true) &#123;</span><br><span class="line">    console.log(tmp)</span><br><span class="line">    let tmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答：结果报错，cannot access ‘tmp’ before initialization<br>     原因：let 会形成块级作用域和封闭作用域，所以 tmp 无法拿到外层 var 声明的值，只能在块级作用域中查找。let 不会导致变量提升，因此<code>console.log(tmp)</code>无法找到声明，出现暂时性死区。</p>
<hr>
<h2 id="结合ES6新语法，用最简单的方法找出数组中的最小值。"><a href="#结合ES6新语法，用最简单的方法找出数组中的最小值。" class="headerlink" title="结合ES6新语法，用最简单的方法找出数组中的最小值。"></a>结合ES6新语法，用最简单的方法找出数组中的最小值。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var arr = [12, 34, 32, 89, 4]</span><br></pre></td></tr></table></figure>
<p>答：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.sort((a, b) =&gt; a-b)[0]</span><br><span class="line">arr.reduce((min,num)=&gt;min&lt;num?min:num)</span><br><span class="line">Math.min(...arr)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="请详细说明-var，let，const-三种声明变量方式之间的具体差别。"><a href="#请详细说明-var，let，const-三种声明变量方式之间的具体差别。" class="headerlink" title="请详细说明 var，let，const 三种声明变量方式之间的具体差别。"></a>请详细说明 var，let，const 三种声明变量方式之间的具体差别。</h2><table>
<thead>
<tr>
<th></th>
<th>var</th>
<th>let</th>
<th>const</th>
</tr>
</thead>
<tbody>
<tr>
<td>提升</td>
<td>声明提升，使用undefined初始化</td>
<td>不存在变量提升</td>
<td>不存在变量提升</td>
</tr>
<tr>
<td>作用域</td>
<td>全局</td>
<td>块级</td>
<td>块级</td>
</tr>
<tr>
<td>初始化</td>
<td>可以仅声明不初始化</td>
<td>可以仅声明不初始化</td>
<td>必须在声明时初始化</td>
</tr>
<tr>
<td>重复定义</td>
<td>可以</td>
<td>不可以</td>
<td>不可以</td>
</tr>
<tr>
<td>多次赋值</td>
<td>可以</td>
<td>可以</td>
<td>基本数据类型不可以，引用数据类型仅可改变值</td>
</tr>
<tr>
<td>声明前访问</td>
<td>可以</td>
<td>不可以</td>
<td>不可以</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="请说出下列代码最终输出的结果，并解释为什么。"><a href="#请说出下列代码最终输出的结果，并解释为什么。" class="headerlink" title="请说出下列代码最终输出的结果，并解释为什么。"></a>请说出下列代码最终输出的结果，并解释为什么。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a = 10;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    a: 20,</span><br><span class="line">    fn () &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(this.a)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.fn()</span><br></pre></td></tr></table></figure>
<p>答：打印20。因为setTimeout是箭头函数，里面的this指向没有改变和fn函数里的this是一致的都指向obj，所以会输出20</p>
<hr>
<h2 id="简述Symbol类型的用途。"><a href="#简述Symbol类型的用途。" class="headerlink" title="简述Symbol类型的用途。"></a>简述Symbol类型的用途。</h2><p>答：</p>
<ul>
<li>作为对象的属性，可以作为对象的私有属性，</li>
<li>阻止对象上属性名的冲突，每个 Symbol 都独一无二的，可以保证不与其他属性名产生冲突，</li>
<li>使用Symbol来替代常量</li>
</ul>
<hr>
<h2 id="说说什么是浅拷贝，什么是深拷贝。"><a href="#说说什么是浅拷贝，什么是深拷贝。" class="headerlink" title="说说什么是浅拷贝，什么是深拷贝。"></a>说说什么是浅拷贝，什么是深拷贝。</h2><p>答：</p>
<ul>
<li>浅拷贝：针对 Object,Array 这种复杂数据类型，浅拷贝复制一层对象的属性，属性中的值是基本数据类型直接复制值，如果是引用类型复制内存地址的指针，所以在修改复制后的变量里引用类型的里面的值时，会导致原始数据也被修改</li>
<li>深拷贝：针对 Object,Array 这种复杂数据类型，深复制递归复制了所有的层级，新数据和原始数据不存在联系，因此在修改复制后的变量里引用类型的里面的值时，不会导致原始数据也被修改</li>
</ul>
<hr>
<h2 id="简述TypeScript和JavaScript之间的关系。"><a href="#简述TypeScript和JavaScript之间的关系。" class="headerlink" title="简述TypeScript和JavaScript之间的关系。"></a>简述TypeScript和JavaScript之间的关系。</h2><p>答：TypeScript 并不是一个完全新的语言, 它是 JavaScript 的超集，为 JavaScript 的生态增加了类型机制，并最终将代码编译为纯粹的 JavaScript 代码。</p>
<table>
<thead>
<tr>
<th>TypeScript</th>
<th>JavaScript</th>
</tr>
</thead>
<tbody>
<tr>
<td>JavaScript 的超集用于解决大型项目的代码复杂性</td>
<td>一种脚本语言，用于创建动态网页。</td>
</tr>
<tr>
<td>可以在编译期间发现并纠正错误</td>
<td>作为一种解释型语言，只能在运行时发现错误</td>
</tr>
<tr>
<td>强类型，支持静态和动态类型</td>
<td>弱类型，没有静态类型选项</td>
</tr>
<tr>
<td>最终被编译成 JavaScript 代码，使浏览器可以理解</td>
<td>可以直接在浏览器中使用</td>
</tr>
<tr>
<td>支持模块、泛型和接口</td>
<td>不支持模块，泛型或接口</td>
</tr>
<tr>
<td>支持 ES3，ES4，ES5 和 ES6 等</td>
<td>不支持编译其他 ES3，ES4，ES5 或 ES6 功能</td>
</tr>
<tr>
<td>社区的支持仍在增长，而且还不是很大</td>
<td>大量的社区支持以及大量文档和解决问题的支持</td>
</tr>
</tbody>
</table>
<h2 id="请谈谈你所认为的TypeScript优缺点。"><a href="#请谈谈你所认为的TypeScript优缺点。" class="headerlink" title="请谈谈你所认为的TypeScript优缺点。"></a>请谈谈你所认为的TypeScript优缺点。</h2><p>优点：</p>
<ul>
<li>任何一种 javascript 运行环境都支持</li>
<li>功能更为强大，生态更健全、更完善</li>
<li>TypeScript 属于渐进式的</li>
<li>增强代码的可读性和可维护性，增强了编译器和 IDE 的功能，定义可以作为文文档</li>
<li>在编译阶段就可以发现大部分大错误，不需要在运行时才发现</li>
</ul>
<p>缺点：</p>
<ul>
<li>语言本身多了很多概率，提高学习成本</li>
<li>项目初期，TypeScript 增加开发成本</li>
<li>集成到构建流程需要一些工足量</li>
<li>可能和一些库结合不完美，需要单独添加一些声明，不过大部分的库都支持了 TypeScript</li>
</ul>
<h2 id="描述引用计数的工作原理和优缺点。"><a href="#描述引用计数的工作原理和优缺点。" class="headerlink" title="描述引用计数的工作原理和优缺点。"></a>描述引用计数的工作原理和优缺点。</h2><p>工作原理：设置引用数,判断当前引用数是否为 0，引用关系改变时修改引用数字</p>
<p>优点：</p>
<ol>
<li>发现垃圾时立即回收</li>
<li>最大限度减少程序暂停（保证空间不会被占满）</li>
</ol>
<p>缺点：</p>
<ol>
<li>无法回收循环引用的对象</li>
<li>时间开销大（监控对象，维护引用数）</li>
</ol>
<h2 id="描述标记整理算法的工作流程。"><a href="#描述标记整理算法的工作流程。" class="headerlink" title="描述标记整理算法的工作流程。"></a>描述标记整理算法的工作流程。</h2><ol>
<li><p>遍历所有对象找标记活动对象</p>
</li>
<li><p>清除阶段会先执行整理，移动对象位置，将活动对象放在一起</p>
</li>
<li><p>清除没有标记的对象，同时把第一次遍历所做的标记抹掉</p>
</li>
<li><p>把回收的空间放到空闲列表上面，方便后续程序申请空间使用</p>
<p>优点： 减少了内存空间的碎片化，缺点： 不能立即回收对象</p>
</li>
</ol>
<h2 id="描述V8中新生代存储区垃圾回收的流程。"><a href="#描述V8中新生代存储区垃圾回收的流程。" class="headerlink" title="描述V8中新生代存储区垃圾回收的流程。"></a>描述V8中新生代存储区垃圾回收的流程。</h2><ol>
<li>回收过程采用复制算法+标记整理算法</li>
<li>新生代分为 from-to 两个等大空间 32M(32 位为 16M)</li>
<li>使用空间为 from 内存区，空闲空间为 to 内存区，当 from 空间应用一定大小会触发标记整理</li>
<li>当发生标记整理后，复制活动对象到 to 内存区，然后 From 空间进行内存释放。</li>
<li>如果拷贝时出现晋升，将新生代活动对象移入老生代</li>
<li>当 To 空间的使用率达到 25%时，将新生代活动对象移入老生代</li>
<li>当一轮 GC 执行完毕后还存活的新生代测需要晋级</li>
<li>当一次 GC 操作后，From 和 to 需要进行置换</li>
</ol>
<h2 id="描述增量标记算法在何时使用及工作原理。"><a href="#描述增量标记算法在何时使用及工作原理。" class="headerlink" title="描述增量标记算法在何时使用及工作原理。"></a>描述增量标记算法在何时使用及工作原理。</h2><p>答： 使用时机：会穿插在程序的运行中执行。</p>
<p>​工作原理： 对象存在直接可达和间接可达，将遍历对象标记，拆分成多个小步骤，先标记直接可达对象。间接可达的标记与程序执行交替执行，最终完成清除。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/前端/">前端</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/">js</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  

</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2021 DiamondsZz
            </div>        
        </div>
    </div>
</footer>

    </div>
    
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>

<script src="/js/main.js"></script>

    <script>
        $(document).ready(function() {
            var backgroundnum = 1;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>






<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" "="">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(
            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


  </div>
</body>
</html>