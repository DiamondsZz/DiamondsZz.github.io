<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  <meta name="baidu-site-verification" content="L6Lm9d5Crl">
  
  
  
  
  <title>DiamondsZz</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="来自一只野生程序猿...">
<meta property="og:type" content="website">
<meta property="og:title" content="DiamondsZz">
<meta property="og:url" content="https://DiamondsZz.github.io/index.html">
<meta property="og:site_name" content="DiamondsZz">
<meta property="og:description" content="来自一只野生程序猿...">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="DiamondsZz">
<meta name="twitter:description" content="来自一只野生程序猿...">
  
    <link rel="alternative" href="/atom.xml" title="DiamondsZz" type="application/atom+xml">
  
  
  
  <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
    
    
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet">
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: true,
          isPost: false,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        
<script src="https://www.unpkg.com/jquery@3.6.0/dist/jquery.js"></script>

        <a href="/" class="profilepic">
            
            <img lazy-src="/img/iu.jpeg" class="js-avatar">
            
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">DiamondsZz</a></h1>
        </hgroup>
        
        <p class="header-subtitle">DiamondsZz</p>
        
        
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        
        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                        </ul>
                    </nav>
                </section>
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/css/" style="font-size: 12.5px;">css</a> <a href="/tags/js/" style="font-size: 15px;">js</a> <a href="/tags/学习/" style="font-size: 20px;">学习</a> <a href="/tags/生活，心情/" style="font-size: 10px;">生活，心情</a> <a href="/tags/网站/" style="font-size: 17.5px;">网站</a> <a href="/tags/资源/" style="font-size: 17.5px;">资源</a>
                    </div>
                </section>
                
                
                
                
                <section class="switch-part switch-part3">
                
                    <div id="js-aboutme">矮穷矬!</div>
                </section>
                
            </div>
        </div>
    </header>
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">DiamondsZz</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/img/iu.jpeg" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">DiamondsZz</a></h1>
            </hgroup>
            
            <p class="header-subtitle">DiamondsZz</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                </div>
            </nav>
        </header>
    </div>
</nav>
      <div class="body-wrap">
  
    <article id="post-graph" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/11/26/graph/" class="article-date">
      <time datetime="2022-11-25T16:00:00.000Z" itemprop="datePublished">2022-11-26</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/11/26/graph/">可视化</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="图形基础篇"><a href="#图形基础篇" class="headerlink" title="图形基础篇"></a>图形基础篇</h2><h3 id="浏览器中实现可视化的四种方式"><a href="#浏览器中实现可视化的四种方式" class="headerlink" title="浏览器中实现可视化的四种方式"></a>浏览器中实现可视化的四种方式</h3><ol>
<li>传统的 HTML+CSS。这种方式通常用来呈现普通的 Web 网页。</li>
<li>SVG 和传统的 HTML+CSS 的绘图方式差别不大。只不过，HTML 元素在绘制矢量图形方面的能力有些不足，而 SVG 恰好弥补了这方面的缺陷。</li>
<li>Canvas2D。这是浏览器提供的 Canvas API 中的其中一种上下文，使用它可以非常方便地绘制出基础的几何图形。在可视化中，Canvas 比较常用。</li>
<li>WebGL。这是浏览器提供的 Canvas API 中的另一种上下文，它是 OpenGL ES 规范在 Web 端的实现。我们可以通过它，用 GPU 渲染各种复杂的 2D 和 3D 图形。值得一提的是，WebGL 利用了 GPU 并行处理的特性，这让它在处理大量数据展现的时候，性能大大优于前 3 种绘图方式。因此，在可视化的应用中，一些数据量大、视觉效果要求高的特殊场景，使用 WebGL 渲染是一种比较合适的选择。</li>
</ol>
<h4 id="HTML-CSS"><a href="#HTML-CSS" class="headerlink" title="HTML+CSS"></a>HTML+CSS</h4><p>用 CSS 实现柱状图其实很简单，原理就是使用网格布局（Grid Layout）加上线性渐变（Linear-gradient）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">   dataset = &#123;</span><br><span class="line">     current: [15, 11, 17, 25, 37],</span><br><span class="line">     total: [25, 26, 40, 45, 68],</span><br><span class="line">   &#125;</span><br><span class="line"> */</span><br><span class="line">.bargraph &#123;</span><br><span class="line">  display: grid;</span><br><span class="line">  width: 150px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  padding: 10px;</span><br><span class="line">  transform: scaleY(3);</span><br><span class="line">  grid-template-columns: repeat(5, 20%);</span><br><span class="line">&#125;</span><br><span class="line">.bargraph div &#123;</span><br><span class="line">  margin: 0 2px;</span><br><span class="line">&#125;</span><br><span class="line">.bargraph div:nth-child(1) &#123;</span><br><span class="line"> background: linear-gradient(to bottom, transparent 75%, #37c 0, #37c 85%, #3c7 0);</span><br><span class="line">&#125;</span><br><span class="line">.bargraph div:nth-child(2) &#123;</span><br><span class="line"> background: linear-gradient(to bottom, transparent 74%, #37c 0, #37c 89%, #3c7 0);</span><br><span class="line">&#125;</span><br><span class="line">.bargraph div:nth-child(3) &#123;</span><br><span class="line"> background: linear-gradient(to bottom, transparent 60%, #37c 0, #37c 83%, #3c7 0);</span><br><span class="line">&#125;</span><br><span class="line">.bargraph div:nth-child(4) &#123;</span><br><span class="line"> background: linear-gradient(to bottom, transparent 55%, #37c 0, #37c 75%, #3c7 0);</span><br><span class="line">&#125;</span><br><span class="line">.bargraph div:nth-child(5) &#123;</span><br><span class="line"> background: linear-gradient(to bottom, transparent 32%, #37c 0, #37c 63%, #3c7 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而要实现饼图，我们可以使用圆锥渐变</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.piegraph &#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  width: 250px;</span><br><span class="line">  height: 250px;</span><br><span class="line">  border-radius: 50%;</span><br><span class="line">  background-image: conic-gradient(#37c 30deg, #3c7 30deg, #3c7 65deg, orange 65deg, orange 110deg, #f73 110deg, #f73 200deg, #ccc 200deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以用高度很小的 Div 元素来模拟线段，然后用 transform 改变角度和位置，这样就能拼成折线图了。 另外，如果使用 clip-path 这样的高级属性，我们还能实现更复杂的图表，比如，用不同的颜色表示两个不同折线的面积。</p>
<p>用 HTML+CSS 实现可视化的缺点:</p>
<p>首先，HTML 和 CSS 主要还是为网页布局而创造的，使用它们虽然能绘制可视化图表，但是绘制的方式并不简洁。这是因为，从 CSS 代码里，我们很难看出数据与图形的对应关系，有很多换算也需要开发人员自己来做。这样一来，一旦图表或数据发生改动，就需要我们重新计算，维护起来会很麻烦。</p>
<p>其次，HTML 和 CSS 作为浏览器渲染引擎的一部分，为了完成页面渲染的工作，除了绘制图形外，还要做很多额外的工作。比如说，浏览器的渲染引擎在工作时，要先解析 HTML、SVG、CSS，构建 DOM 树、RenderObject 树和 RenderLayer 树，然后用 HTML（或 SVG）绘图。当图形发生变化时，我们很可能要重新执行全部的工作，这样的性能开销是非常大的。</p>
<p>因此，相比于 HTML 和 CSS，Canvas2D 和 WebGL 更适合去做可视化这一领域的绘图工作。它们的绘图 API 能够直接操作绘图上下文，一般不涉及引擎的其他部分，在重绘图像时，也不会发生重新解析文档和构建结构的过程，开销要小很多。</p>
<h4 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h4><p>在介绍 Canvas2D 和 WebGL 之前，我们先来说一说 SVG。现代浏览器支持 SVG（Scalable Vector Graphics，可缩放矢量图），SVG 是一种基于 XML 语法的图像格式，可以用图片（img 元素）的 src 属性加载。而且，浏览器更强大的是，它还可以内嵌 SVG 标签，并且像操作普通的 HTML 元素一样，利用 DOM API 操作 SVG 元素。甚至，CSS 也可以作用于内嵌的 SVG 元素。</p>
<p>比如，上面的柱状图，如果用 SVG 实现的话，我们可以用如下所示的代码来实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!--</span><br><span class="line">     dataset = &#123;</span><br><span class="line">       total: [25, 26, 40, 45, 68],</span><br><span class="line">       current: [15, 11, 17, 25, 37],</span><br><span class="line">     &#125;</span><br><span class="line"> --&gt;</span><br><span class="line"> &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;120px&quot; height=&quot;240px&quot; viewBox=&quot;0 0 60 100&quot;&gt;</span><br><span class="line">   &lt;g transform=&quot;translate(0, 100) scale(1, -1)&quot;&gt;</span><br><span class="line">     &lt;g&gt;</span><br><span class="line">       &lt;rect x=&quot;1&quot; y=&quot;0&quot; width=&quot;10&quot; height=&quot;25&quot; fill=&quot;#37c&quot;/&gt;</span><br><span class="line">       &lt;rect x=&quot;13&quot; y=&quot;0&quot; width=&quot;10&quot; height=&quot;26&quot; fill=&quot;#37c&quot;/&gt;</span><br><span class="line">       &lt;rect x=&quot;25&quot; y=&quot;0&quot; width=&quot;10&quot; height=&quot;40&quot; fill=&quot;#37c&quot;/&gt;</span><br><span class="line">       &lt;rect x=&quot;37&quot; y=&quot;0&quot; width=&quot;10&quot; height=&quot;45&quot; fill=&quot;#37c&quot;/&gt;</span><br><span class="line">       &lt;rect x=&quot;49&quot; y=&quot;0&quot; width=&quot;10&quot; height=&quot;68&quot; fill=&quot;#37c&quot;/&gt;</span><br><span class="line">     &lt;/g&gt;</span><br><span class="line">     &lt;g&gt;</span><br><span class="line">       &lt;rect x=&quot;1&quot; y=&quot;0&quot; width=&quot;10&quot; height=&quot;15&quot; fill=&quot;#3c7&quot;/&gt;</span><br><span class="line">       &lt;rect x=&quot;13&quot; y=&quot;0&quot; width=&quot;10&quot; height=&quot;11&quot; fill=&quot;#3c7&quot;/&gt;</span><br><span class="line">       &lt;rect x=&quot;25&quot; y=&quot;0&quot; width=&quot;10&quot; height=&quot;17&quot; fill=&quot;#3c7&quot;/&gt;</span><br><span class="line">       &lt;rect x=&quot;37&quot; y=&quot;0&quot; width=&quot;10&quot; height=&quot;25&quot; fill=&quot;#3c7&quot;/&gt;</span><br><span class="line">       &lt;rect x=&quot;49&quot; y=&quot;0&quot; width=&quot;10&quot; height=&quot;37&quot; fill=&quot;#3c7&quot;/&gt;</span><br><span class="line">     &lt;/g&gt;</span><br><span class="line">   &lt;/g&gt;</span><br><span class="line"> &lt;/svg&gt;</span><br></pre></td></tr></table></figure>
<p>HTML 的不足之处在于 HTML 元素的形状一般是矩形，虽然用 CSS 辅助，也能够绘制出各种其它形状的图形，甚至不规则图形，但是总体而言还是非常麻烦的。而 SVG 则弥补了这方面的不足，让不规则图形的绘制变得更简单了。因此，用 SVG 绘图比用 HTML 和 CSS 要便利得多。</p>
<p>但是，SVG 图表也有缺点。在渲染引擎中，SVG 元素和 HTML 元素一样，在输出图形前都需要经过引擎的解析、布局计算和渲染树生成。而且，一个 SVG 元素只表示一种基本图形，如果展示的数据很复杂，生成图形的 SVG 元素就会很多。这样一来，大量的 SVG 元素不仅会占用很多内存空间，还会增加引擎、布局计算和渲染树生成的开销，降低性能，减慢渲染速度。这也就注定了 SVG 只适合应用于元素较少的简单可视化场景。</p>
<h4 id="Canvas2D"><a href="#Canvas2D" class="headerlink" title="Canvas2D"></a>Canvas2D</h4><p>无论是使用 HTML/CSS 还是 SVG，它们都属于声明式绘图系统，也就是我们根据数据创建各种不同的图形元素（或者 CSS 规则），然后利用浏览器渲染引擎解析它们并渲染出来。但是 Canvas2D 不同，它是浏览器提供的一种可以直接用代码在一块平面的“画布”上绘制图形的 API，使用它来绘图更像是传统的“编写代码”，简单来说就是调用绘图指令，然后引擎直接在页面上绘制图形。这是一种指令式的绘图系统。</p>
<p>那 Canvas 到底是怎么绘制可视化图表的呢？我们一起来看。</p>
<p>首先，Canvas 元素在浏览器上创造一个空白的画布，通过提供渲染上下文，赋予我们绘制内容的能力。然后，我们只需要调用渲染上下文，设置各种属性，然后调用绘图指令完成输出，就能在画布上呈现各种各样的图形了。</p>
<p>为了实现更加复杂的效果，Canvas 还提供了非常丰富的设置和绘图 API，我们可以通过操作上下文，来改变填充和描边颜色，对画布进行几何变换，调用各种绘图指令，然后将绘制的图形输出到画布上。</p>
<p>总结来说，Canvas 能够直接操作绘图上下文，不需要经过 HTML、CSS 解析、构建渲染树、布局等一系列操作。因此单纯绘图的话，Canvas 比 HTML/CSS 和 SVG 要快得多。</p>
<p>但是，因为 HTML 和 SVG 一个元素对应一个基本图形，所以我们可以很方便地操作它们，比如在柱状图的某个柱子上注册点击事件。而同样的功能在 Canvas 上就比较难实现了，因为对于 Canvas 来说，绘制整个柱状图的过程就是一系列指令的执行过程，其中并没有区分“A 柱子”、“B 柱子”，这让我们很难单独对 Canvas 绘图的局部进行控制。不过，这并不代表我们就不能控制 Canvas 的局部了。实际上，通过数学计算我们是可以通过定位的方式来获取局部图形的，在后续的课程中我们会解决这个问题。</p>
<p>这里有一点需要你注意，Canvas 和 SVG 的使用也不是非此即彼的，它们可以结合使用。因为 SVG 作为一种图形格式，也可以作为 image 元素绘制到 Canvas 中。举个例子，我们可以先使用 SVG 生成某些图形，然后用 Canvas 来渲染。这样，我们就既可以享受 SVG 的便利性，又可以享受 Canvas 的高性能了。</p>
<h4 id="WebGL"><a href="#WebGL" class="headerlink" title="WebGL"></a>WebGL</h4><p>一般情况下，Canvas2D 绘制图形的性能已经足够高了，但是在三种情况下我们有必要直接操作更强大的 GPU 来实现绘图。</p>
<p>第一种情况，如果我们要绘制的图形数量非常多，比如有多达数万个几何图形需要绘制，而且它们的位置和方向都在不停地变化，那我们即使用 Canvas2D 绘制了，性能还是会达到瓶颈。这个时候，我们就需要使用 GPU 能力，直接用 WebGL 来绘制。</p>
<p>第二种情况，如果我们要对较大图像的细节做像素处理，比如，实现物体的光影、流体效果和一些复杂的像素滤镜。由于这些效果往往要精准地改变一个图像全局或局部区域的所有像素点，要计算的像素点数量非常的多（一般是数十万甚至上百万数量级的）。这时，即使采用 Canvas2D 操作，也会达到性能瓶颈，所以我们也要用 WebGL 来绘制。</p>
<p>第三种情况是绘制 3D 物体。因为 WebGL 内置了对 3D 物体的投影、深度检测等特性，所以用它来渲染 3D 物体就不需要我们自己对坐标做底层的处理了。那在这种情况下，WebGL 无论是在使用上还是性能上都有很大优势。</p>
<h3 id="指令式绘图系统：如何用Canvas绘制层次关系图？"><a href="#指令式绘图系统：如何用Canvas绘制层次关系图？" class="headerlink" title="指令式绘图系统：如何用Canvas绘制层次关系图？"></a>指令式绘图系统：如何用Canvas绘制层次关系图？</h3><h4 id="Canvas-元素和-2D-上下文"><a href="#Canvas-元素和-2D-上下文" class="headerlink" title="Canvas 元素和 2D 上下文"></a>Canvas 元素和 2D 上下文</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;canvas width=&quot;512&quot; height=&quot;512&quot;&gt;&lt;/canvas&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<p>这里有一点需要特别注意，Canvas 元素上的 width 和 height 属性不等同于 Canvas 元素的 CSS 样式的属性。这是因为，CSS 属性中的宽高影响 Canvas 在页面上呈现的大小，而 HTML 属性中的宽高则决定了 Canvas 的坐标系。为了区分它们，我们称 Canvas 的 HTML 属性宽高为画布宽高，CSS 样式宽高为样式宽高。</p>
<p>在实际绘制的时候，如果我们不设置 Canvas 元素的样式，那么 Canvas 元素的画布宽高就会等于它的样式宽高的像素值，也就是 512px。</p>
<p>而如果这个时候，我们通过 CSS 设置其他的值指定了它的样式宽高。比如说，我们将样式宽高设置成 256px，那么它实际的画布宽高就是样式宽高的两倍了。代码和效果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">canvas &#123;</span><br><span class="line">  width: 256px;</span><br><span class="line">  height: 256px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为画布宽高决定了可视区域的坐标范围，所以 Canvas 将画布宽高和样式宽高分开的做法，能更方便地适配不同的显示设备。</p>
<p>比如，我们要在画布宽高为 <code>500*500</code>的Canvas画布上，绘制一个居中显示的<code>100*100</code> 宽高的正方形。我们只要将它的坐标设置在  x = 200, y = 200 处即可。这样，不论这个 Canvas 以多大的尺寸显示在各种设备上，我们的代码都不需要修改。否则，如果 Canvas 的坐标范围（画布宽高）跟着样式宽高变化，那么当屏幕尺寸改变的时候，我们就要重新计算需要绘制的图形的所有坐标，这对于我们来说将会是一场“灾难”。</p>
<h4 id="Canvas-的坐标系"><a href="#Canvas-的坐标系" class="headerlink" title="Canvas 的坐标系"></a>Canvas 的坐标系</h4><p>Canvas 的坐标系和浏览器窗口的坐标系类似，它们都默认左上角为坐标原点，x 轴水平向右，y 轴垂直向下。那在我们设置好的画布宽高为 512*512 的 Canvas 画布中，它的左上角坐标值为（0,0），右下角坐标值为（512,512） 。这意味着，坐标（0,0）到（512,512）之间的所有图形，都会被浏览器渲染到画布上。</p>
<p>注意，上图中这个坐标系的 y 轴向下，意味着这个坐标系和笛卡尔坐标系不同，它们的 y 轴是相反的。那在实际应用的时候，如果我们想绘制一个向右上平抛小球的动画，它的抛物线轨迹，在 Canvas 上绘制出来的方向就是向下凹的。</p>
<h4 id="利用-Canvas-绘制几何图形"><a href="#利用-Canvas-绘制几何图形" class="headerlink" title="利用 Canvas 绘制几何图形"></a>利用 Canvas 绘制几何图形</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">d3-hierarchy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const TAU = 2 * Math.PI;</span><br><span class="line"></span><br><span class="line">function draw(ctx, node, &#123;fillStyle = &apos;rgba(0, 0, 0, 0.2)&apos;, textColor = &apos;white&apos;&#125; = &#123;&#125;) &#123;</span><br><span class="line">  const children = node.children;</span><br><span class="line">  const &#123;x, y, r&#125; = node;</span><br><span class="line">  ctx.fillStyle = fillStyle;</span><br><span class="line">  ctx.beginPath();</span><br><span class="line">  ctx.arc(x, y, r, 0, TAU);</span><br><span class="line">  ctx.fill();</span><br><span class="line">  if(children) &#123;</span><br><span class="line">    for(let i = 0; i &lt; children.length; i++) &#123;</span><br><span class="line">      draw(ctx, children[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    const name = node.data.name;</span><br><span class="line">    ctx.fillStyle = textColor;</span><br><span class="line">    ctx.font = &apos;1.5rem Arial&apos;;</span><br><span class="line">    ctx.textAlign = &apos;center&apos;;</span><br><span class="line">    ctx.fillText(name, x, y);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">draw(context, root);</span><br></pre></td></tr></table></figure>
<p>因为 Canvas 在 HTML 层面上是一个独立的画布元素，所以所有的绘制内容都是在内部通过绘图指令来完成的，绘制出的图形对于浏览器来说，只是 Canvas 中的一个个像素点，我们很难直接抽取其中的图形对象进行操作。</p>
<h3 id="声明式图形系统：如何用SVG图形元素绘制可视化图表？"><a href="#声明式图形系统：如何用SVG图形元素绘制可视化图表？" class="headerlink" title="声明式图形系统：如何用SVG图形元素绘制可视化图表？"></a>声明式图形系统：如何用SVG图形元素绘制可视化图表？</h3><h4 id="利用-SVG-绘制几何图形"><a href="#利用-SVG-绘制几何图形" class="headerlink" title="利用 SVG 绘制几何图形"></a>利用 SVG 绘制几何图形</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt;</span><br><span class="line">  &lt;circle cx=&quot;100&quot; cy=&quot;50&quot; r=&quot;40&quot; stroke=&quot;black&quot;</span><br><span class="line">  stroke-width=&quot;2&quot; fill=&quot;orange&quot; /&gt;</span><br><span class="line">&lt;/svg&gt;</span><br></pre></td></tr></table></figure>
<p>svg 元素是 SVG 的根元素，属性 xmlns 是 xml 的名字空间。那第一行代码就表示，svg 元素的 xmlns 属性值是”<a href="http://www.w3.org/2000/svg&quot;，浏览器根据这个属性值就能够识别出这是一段" target="_blank" rel="noopener">http://www.w3.org/2000/svg&quot;，浏览器根据这个属性值就能够识别出这是一段</a> SVG 的内容了。</p>
<p>svg 元素下的 circle 元素表示这是一个绘制在 SVG 图像中的圆形，属性 cx 和 cy 是坐标，表示圆心的位置在图像的 x=100、y=50 处。属性 r 表示半径，r=40 表示圆的半径为 40。</p>
<h4 id="利用-SVG-绘制层次关系图"><a href="#利用-SVG-绘制层次关系图" class="headerlink" title="利用 SVG 绘制层次关系图"></a>利用 SVG 绘制层次关系图</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">const svgroot = document.querySelector(&apos;svg&apos;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function draw(parent, node, &#123;fillStyle = &apos;rgba(0, 0, 0, 0.2)&apos;, textColor = &apos;white&apos;&#125; = &#123;&#125;) &#123;</span><br><span class="line">    const &#123;x, y, r&#125; = node;</span><br><span class="line">    const circle = document.createElementNS(&apos;http://www.w3.org/2000/svg&apos;, &apos;circle&apos;);</span><br><span class="line">    circle.setAttribute(&apos;cx&apos;, x);</span><br><span class="line">    circle.setAttribute(&apos;cy&apos;, y);</span><br><span class="line">    circle.setAttribute(&apos;r&apos;, r);</span><br><span class="line">    circle.setAttribute(&apos;fill&apos;, fillStyle);</span><br><span class="line">    parent.appendChild(circle);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">draw(svgroot, root);</span><br></pre></td></tr></table></figure>
<h4 id="SVG-和-Canvas-的不同点"><a href="#SVG-和-Canvas-的不同点" class="headerlink" title="SVG 和 Canvas 的不同点"></a>SVG 和 Canvas 的不同点</h4><p>SVG 和 Canvas 在使用上的不同主要可以分为两点，分别是写法上的不同和用户交互实现上的不同。</p>
<ol>
<li><p>在绘制层次关系图的过程中，SVG 首先通过创建标签来表示图形元素，circle 表示圆，g 表示分组，text 表示文字。接着，SVG 通过元素的 setAttribute 给图形元素赋属性值，这个和操作 HTML 元素是一样的。而 Canvas 先是通过上下文执行绘图指令来绘制图形，画圆是调用 context.arc 指令，然后再调用 context.fill 绘制，画文字是调用 context.fillText 指令。另外，Canvas 还通过上下文设置状态属性，context.fillStyle 设置填充颜色，conext.font 设置元素的字体。我们设置的这些状态，在绘图指令执行时才会生效。从写法上来看，因为 SVG 的声明式类似于 HTML 书写方式，本身对前端工程师会更加友好。但是，SVG 图形需要由浏览器负责渲染和管理，将元素节点维护在 DOM 树中。这样做的缺点是，在一些动态的场景中，也就是需要频繁地增加、删除图形元素的场景中，SVG 与一般的 HTML 元素一样会带来 DOM 操作的开销，所以 SVG 的渲染性能相对比较低。</p>
</li>
<li><p>利用 SVG 的一个图形对应一个 svg 元素的机制，我们就可以像操作普通的 HTML 元素那样，给 svg 元素添加事件实现用户交互了。所以，SVG 有一个非常大的优点，那就是可以让图形的用户交互非常简单。和 SVG 相比，利用 Canvas 对图形元素进行用户交互就没有那么容易了。不过，对于圆形的层次关系图来说，在 Canvas 图形上定位鼠标处于哪个圆中并不难，我们只需要计算一下鼠标到每个圆的圆心距离，如果这个距离小于圆的半径，我们就可以确定鼠标在某个圆内部了。</p>
</li>
</ol>
<h4 id="绘制大量几何图形时-SVG-的性能问题"><a href="#绘制大量几何图形时-SVG-的性能问题" class="headerlink" title="绘制大量几何图形时 SVG 的性能问题"></a>绘制大量几何图形时 SVG 的性能问题</h4><p>在绘制如上的层次关系图时，我们只需要绘制数十个节点。但是如果是更复杂的应用，比如我们要绘制数百上千甚至上万个节点，这个时候，DOM 树渲染就会成为性能瓶颈。事实上，在一般情况下，当 SVG 节点超过一千个的时候，你就能很明显感觉到性能问题了。</p>
<p>幸运的是，对于 SVG 的性能问题，我们也是有解决方案的。比如说，我们可以使用虚拟 DOM 方案来尽可能地减少重绘，这样就可以优化 SVG 的渲染。但是这些方案只能解决一部分问题，当节点数太多时，这些方案也无能为力。这个时候，我们还是得依靠 Canvas 和 WebGL 来绘图，才能彻底解决问题。</p>
<p>那在上万个节点的可视化应用场景中，SVG 就真的一无是处了吗？当然不是。SVG 除了嵌入 HTML 文档的用法，还可以直接作为一种图像格式使用。所以，即使是在用 Canvas 和 WebGL 渲染的应用场景中，我们也依然可能会用到 SVG，将它作为一些局部的图形使用，这也会给我们的应用实现带来方便。</p>
<h3 id="GPU与渲染管线：如何用WebGL绘制最简单的几何图形？"><a href="#GPU与渲染管线：如何用WebGL绘制最简单的几何图形？" class="headerlink" title="GPU与渲染管线：如何用WebGL绘制最简单的几何图形？"></a>GPU与渲染管线：如何用WebGL绘制最简单的几何图形？</h3><h4 id="图形系统是如何绘图的？"><a href="#图形系统是如何绘图的？" class="headerlink" title="图形系统是如何绘图的？"></a>图形系统是如何绘图的？</h4><p>一个通用计算机图形系统主要包括 6 个部分，分别是输入设备、中央处理单元、图形处理单元、存储器、帧缓存和输出设备。</p>
<ol>
<li>光栅（Raster）：几乎所有的现代图形系统都是基于光栅来绘制图形的，光栅就是指构成图像的像素阵列。</li>
<li>像素（Pixel）：一个像素对应图像上的一个点，它通常保存图像上的某个具体位置的颜色等信息。</li>
<li>帧缓存（Frame Buffer）：在绘图过程中，像素信息被存放于帧缓存中，帧缓存是一块内存地址。</li>
<li>CPU（Central Processing Unit）：中央处理单元，负责逻辑计算。</li>
<li>GPU（Graphics Processing Unit）：图形处理单元，负责图形计算。</li>
</ol>
<p>来看一个典型的绘图过程，帮你来明晰一下这些概念的实际用途。</p>
<p>首先，数据经过 CPU 处理，成为具有特定结构的几何信息。然后，这些信息会被送到 GPU 中进行处理。在 GPU 中要经过两个步骤生成光栅信息。这些光栅信息会输出到帧缓存中，最后渲染到屏幕上。</p>
<p>主要做了两件事，一是对给定的数据结合绘图的场景要素（例如相机、光源、遮挡物体等等）进行计算，最终将图形变为屏幕空间的 2D 坐标。二是为屏幕空间的每个像素点进行着色，把最终完成的图形输出到显示设备上。这整个过程是一步一步进行的，前一步的输出就是后一步的输入，所以我们也把这个过程叫做渲染管线（RenderPipelines）。</p>
<h4 id="GPU-是什么？"><a href="#GPU-是什么？" class="headerlink" title="GPU 是什么？"></a>GPU 是什么？</h4><p>CPU 和 GPU 都属于处理单元，但是结构不同。形象点来说，CPU 就像个大的工业管道，等待处理的任务就像是依次通过这个管道的货物。一条 CPU 流水线串行处理这些任务的速度，取决于 CPU（管道）的处理能力。</p>
<p>实际上，一个计算机系统会有很多条 CPU 流水线，而且任何一个任务都可以随机地通过任意一个流水线，这样计算机就能够并行处理多个任务了。这样的一条流水线就是我们常说的线程（Thread）。</p>
<p>这样的结构用来处理大型任务是足够的，但是要处理图像应用就不太合适了。这是因为，处理图像应用，实际上就是在处理计算图片上的每一个像素点的颜色和其他信息。每处理一个像素点就相当于完成了一个简单的任务，而一个图片应用又是由成千上万个像素点组成的，所以，我们需要在同一时间处理成千上万个小任务。</p>
<p>要处理这么多的小任务，比起使用若干个强大的 CPU，使用更小、更多的处理单元，是一种更好的处理方式。而 GPU 就是这样的处理单元。</p>
<p>GPU 是由大量的小型处理单元构成的，它可能远远没有 CPU 那么强大，但胜在数量众多，可以保证每个单元处理一个简单的任务。即使我们要处理一张 800 * 600 大小的图片，GPU 也可以保证这 48 万个像素点分别对应一个小单元，这样我们就可以同时对每个像素点进行计算了。</p>
<h4 id="如何用-WebGL-绘制三角形？"><a href="#如何用-WebGL-绘制三角形？" class="headerlink" title="如何用 WebGL 绘制三角形？"></a>如何用 WebGL 绘制三角形？</h4><p>浏览器提供的 WebGL API 是 OpenGL ES 的 JavaScript 绑定版本，它赋予了开发者操作 GPU 的能力。这一特点也让 WebGL 的绘图方式和其他图形系统的“开箱即用”（直接调用绘图指令或者创建图形元素就可以完成绘图）的绘图方式完全不同，甚至要复杂得多。我们可以总结为以下 5 个步骤：</p>
<ol>
<li>创建 WebGL 上下文</li>
<li>创建 WebGL 程序（WebGL Program）</li>
<li>将数据存入缓冲区</li>
<li>将缓冲区数据读取到 GPU</li>
<li>GPU 执行 WebGL 程序，输出结果</li>
</ol>
<h5 id="步骤一：创建-WebGL-上下文"><a href="#步骤一：创建-WebGL-上下文" class="headerlink" title="步骤一：创建 WebGL 上下文"></a>步骤一：创建 WebGL 上下文</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const canvas = document.querySelector(&apos;canvas&apos;);</span><br><span class="line">const gl = canvas.getContext(&apos;webgl&apos;);</span><br></pre></td></tr></table></figure>
<h5 id="步骤二：创建-WebGL-程序"><a href="#步骤二：创建-WebGL-程序" class="headerlink" title="步骤二：创建 WebGL 程序"></a>步骤二：创建 WebGL 程序</h5><p>接下来，我们要创建一个 WebGL 程序。你可能会觉得奇怪，我们不是正在写一个绘制三角形的程序吗？为什么这里又要创建一个 WebGL 程序呢？实际上，这里的 WebGL 程序是一个 WebGLProgram 对象，它是给 GPU 最终运行着色器的程序，而不是我们正在写的三角形的 JavaScript 程序。好了，解决了这个疑问，我们就正式开始创建一个 WebGL 程序吧！</p>
<p>首先，要创建这个 WebGL 程序，我们需要编写两个着色器（Shader）。着色器是用 GLSL 这种编程语言编写的代码片段，这里我们先不用过多纠结于 GLSL 语言，在后续的课程中我们会详细讲解。那在这里，我们只需要理解绘制三角形的这两个着色器的作用就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">const vertex = `</span><br><span class="line">  attribute vec2 position;</span><br><span class="line"></span><br><span class="line">  void main() &#123;</span><br><span class="line">    gl_PointSize = 1.0;</span><br><span class="line">    gl_Position = vec4(position, 1.0, 1.0);</span><br><span class="line">  &#125;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const fragment = `</span><br><span class="line">  precision mediump float;</span><br><span class="line"></span><br><span class="line">  void main()</span><br><span class="line">  &#123;</span><br><span class="line">    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);</span><br><span class="line">  &#125;    </span><br><span class="line">`;</span><br></pre></td></tr></table></figure>
<p>那我们为什么要创建两个着色器呢？这就需要我们先来理解顶点和图元这两个基本概念了。在绘图的时候，WebGL 是以顶点和图元来描述图形几何信息的。顶点就是几何图形的顶点，比如，三角形有三个顶点，四边形有四个顶点。图元是 WebGL 可直接处理的图形单元，由 WebGL 的绘图模式决定，有点、线、三角形等等。</p>
<p>所以，顶点和图元是绘图过程中必不可少的。因此，WebGL 绘制一个图形的过程，一般需要用到两段着色器，一段叫顶点着色器（Vertex Shader）负责处理图形的顶点信息，另一段叫片元着色器（Fragment Shader）负责处理图形的像素信息。</p>
<p>更具体点来说，我们可以把顶点着色器理解为处理顶点的 GPU 程序代码。它可以改变顶点的信息（如顶点的坐标、法线方向、材质等等），从而改变我们绘制出来的图形的形状或者大小等等。</p>
<p>顶点处理完成之后，WebGL 就会根据顶点和绘图模式指定的图元，计算出需要着色的像素点，然后对它们执行片元着色器程序。简单来说，就是对指定图元中的像素点着色。</p>
<p>WebGL 从顶点着色器和图元提取像素点给片元着色器执行代码的过程，就是我们前面说的生成光栅信息的过程，我们也叫它光栅化过程。所以，片元着色器的作用，就是处理光栅化后的像素信息。</p>
<p>这么说可能比较抽象，我 来举个例子。我们可以将图元设为线段，那么片元着色器就会处理顶点之间的线段上的像素点信息，这样画出来的图形就是空心的。而如果我们把图元设为三角形，那么片元着色器就会处理三角形内部的所有像素点，这样画出来的图形就是实心的。</p>
<p>这里你要注意一点，因为图元是 WebGL 可以直接处理的图形单元，所以其他非图元的图形最终必须要转换为图元才可以被 WebGL 处理。举个例子，如果我们要绘制实心的四边形，我们就需要将四边形拆分成两个三角形，再交给 WebGL 分别绘制出来。</p>
<p>好了，那让我们回到片元着色器对像素点着色的过程。你还要注意，这个过程是并行的。也就是说，无论有多少个像素点，片元着色器都可以同时处理。这也是片元着色器一大特点。</p>
<p>首先，因为在 JavaScript 中，顶点着色器和片元着色器只是一段代码片段，所以我们要将它们分别创建成 shader 对象。代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const vertexShader = gl.createShader(gl.VERTEX_SHADER);</span><br><span class="line">gl.shaderSource(vertexShader, vertex);</span><br><span class="line">gl.compileShader(vertexShader);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);</span><br><span class="line">gl.shaderSource(fragmentShader, fragment);</span><br><span class="line">gl.compileShader(fragmentShader);</span><br></pre></td></tr></table></figure>
<p>接着，我们创建 WebGLProgram 对象，并将这两个 shader 关联到这个 WebGL 程序上。WebGLProgram 对象的创建过程主要是添加 vertexShader 和 fragmentShader，然后将这个 WebGLProgram 对象链接到 WebGL 上下文对象上。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const program = gl.createProgram();</span><br><span class="line">gl.attachShader(program, vertexShader);</span><br><span class="line">gl.attachShader(program, fragmentShader);</span><br><span class="line">gl.linkProgram(program);</span><br></pre></td></tr></table></figure>
<p>最后，我们要通过 useProgram 选择启用这个 WebGLProgram 对象。这样，当我们绘制图形时，GPU 就会执行我们通过 WebGLProgram 设定的 两个 shader 程序了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">gl.useProgram(program);</span><br></pre></td></tr></table></figure>
<h5 id="步骤三：将数据存入缓冲区"><a href="#步骤三：将数据存入缓冲区" class="headerlink" title="步骤三：将数据存入缓冲区"></a>步骤三：将数据存入缓冲区</h5><p>我们要知道 WebGL 的坐标系是一个三维空间坐标系，坐标原点是（0,0,0）。其中，x 轴朝右，y 轴朝上，z 轴朝外。</p>
<p>假设，我们要在这个坐标系上显示一个顶点坐标分别是（-1, -1）、（1, -1）、（0, 1）的三角形。</p>
<p>首先，我们要定义这个三角形的三个顶点。WebGL 使用的数据需要用类型数组定义，默认格式是 Float32Array。Float32Array 是 JavaScript 的一种类型化数组（TypedArray），JavaScript 通常用类型化数组来处理二进制缓冲区。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const points = new Float32Array([</span><br><span class="line">  -1, -1,</span><br><span class="line">  0, 1,</span><br><span class="line">  1, -1,</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>
<p>接着，我们要将定义好的数据写入 WebGL 的缓冲区。这个过程我们可以简单总结为三步，分别是创建一个缓存对象，将它绑定为当前操作对象，再把当前的数据写入缓存对象。这三个步骤主要是利用 createBuffer、bindBuffer、bufferData 方法来实现的，过程很简单你可以看一下我下面给出的实现代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">const bufferId = gl.createBuffer();</span><br><span class="line">gl.bindBuffer(gl.ARRAY_BUFFER, bufferId);</span><br><span class="line">gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);</span><br></pre></td></tr></table></figure>
<h5 id="步骤四：将缓冲区数据读取到-GPU"><a href="#步骤四：将缓冲区数据读取到-GPU" class="headerlink" title="步骤四：将缓冲区数据读取到 GPU"></a>步骤四：将缓冲区数据读取到 GPU</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">attribute vec2 position;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  gl_PointSize = 1.0;</span><br><span class="line">  gl_Position = vec4(position, 1.0, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 GLSL 中，attribute 表示声明变量，vec2 是变量的类型，它表示一个二维向量，position 是变量名。接下来我们将 buffer 的数据绑定给顶点着色器的 position 变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const vPosition = gl.getAttribLocation(program, &apos;position&apos;);获取顶点着色器中的position变量的地址</span><br><span class="line">gl.vertexAttribPointer(vPosition, 2, gl.FLOAT, false, 0, 0);给变量设置长度和类型</span><br><span class="line">gl.enableVertexAttribArray(vPosition);激活这个变量</span><br></pre></td></tr></table></figure>
<h5 id="步骤五：执行着色器程序完成绘制"><a href="#步骤五：执行着色器程序完成绘制" class="headerlink" title="步骤五：执行着色器程序完成绘制"></a>步骤五：执行着色器程序完成绘制</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">gl.clear(gl.COLOR_BUFFER_BIT);</span><br><span class="line">gl.drawArrays(gl.TRIANGLES, 0, points.length / 2);</span><br></pre></td></tr></table></figure>
<p>在片元着色器里，我们可以通过设置 gl_FragColor 的值来定义和改变图形的颜色。gl_FragColor 是 WebGL 片元着色器的内置变量，表示当前像素点颜色，它是一个用 RGBA 色值表示的四维向量数据。在上面的代码中，因为我们写入 vec4(1.0, 0.0, 0.0, 1.0) 对应的是红色，所以三角形是红色的。如果我们把这个值改成 vec4(0.0, 0.0, 1.0, 1.0)，那三角形就是蓝色。</p>
<p>我们要记住，不论这个三角形是大还是小，有几十个像素点还是上百万个像素点，GPU 都是同时处理每个像素点的。也就是说，图形中有多少个像素点，着色器程序在 GPU 中就会被同时执行多少次。</p>
<h4 id="顶点着色器的作用"><a href="#顶点着色器的作用" class="headerlink" title="顶点着色器的作用"></a>顶点着色器的作用</h4><p>顶点着色器大体上可以总结为两个作用：一是通过 gl_Position 设置顶点，二是通过定义 varying 变量，向片元着色器传递数据。这么说还是有点抽象，我们还是通过三角形的例子来具体理解一下。</p>
<h5 id="通过-gl-Position-设置顶点"><a href="#通过-gl-Position-设置顶点" class="headerlink" title="通过 gl_Position 设置顶点"></a>通过 gl_Position 设置顶点</h5><p>假如，我想把三角形的周长缩小为原始大小的一半，有两种处理方式法：一种是修改 points 数组的值，另一种做法是直接对顶点着色器数据进行处理。</p>
<p>我们不需要修改 points 数据，只需要在顶点着色器中，将 gl_Position = vec4(position, 1.0, 1.0); 修改为 gl_Position = vec4(position * 0.5, 1.0, 1.0);，代码如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">attribute vec2 position;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  gl_PointSize = 1.0;</span><br><span class="line">  gl_Position = vec4(position * 0.5, 1.0, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，三角形的周长就缩小为原来的一半了。在这个过程中，我们不需要遍历三角形的每一个顶点，只需要是利用 GPU 的并行特性，在顶点着色器中同时计算所有的顶点就可以了。</p>
<h5 id="向片元着色器传递数据"><a href="#向片元着色器传递数据" class="headerlink" title="向片元着色器传递数据"></a>向片元着色器传递数据</h5><p>除了计算顶点之外，顶点着色器还可以将数据通过 varying 变量传给片元着色器。然后，这些值会根据片元着色器的像素坐标与顶点像素坐标的相对位置做线性插值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">attribute vec2 position;</span><br><span class="line">varying vec3 color;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  gl_PointSize = 1.0;</span><br><span class="line">  color = vec3(0.5 + position * 0.5, 0.0);</span><br><span class="line">  gl_Position = vec4(position * 0.5, 1.0, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段代码中，我们修改了顶点着色器，定义了一个 color 变量，它是一个三维的向量。我们通过数学技巧将顶点的值映射为一个 RGB 颜色值</p>
<p>这样一来，顶点[-1,-1]被映射为[0,0,0]也就是黑色，顶点[0,1]被映射为[0.5, 1, 0]也就是浅绿色，顶点[1,-1]被映射为[1,0,0]也就是红色。这样一来，三个顶点就会有三个不同的颜色值。</p>
<p>然后我们将 color 通过 varying 变量传给片元着色器。片元着色器中的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">precision mediump float;</span><br><span class="line">varying vec3 color;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">  gl_FragColor = vec4(color, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，这个三角形是一个颜色均匀（线性）渐变的三角形，它的三个顶点的色值就是我们通过顶点着色器来设置的。而且你会发现，中间像素点的颜色是均匀过渡的。这就是因为 WebGL 在执行片元着色器程序的时候，顶点着色器传给片元着色器的变量，会根据片元着色器的像素坐标对变量进行线性插值。利用线性插值可以让像素点的颜色均匀渐变这一特点，我们就能绘制出颜色更丰富的图形了。</p>
<h2 id="数学篇"><a href="#数学篇" class="headerlink" title="数学篇"></a>数学篇</h2><p>令人头秃…</p>
<h2 id="视觉基础篇"><a href="#视觉基础篇" class="headerlink" title="视觉基础篇"></a>视觉基础篇</h2><h3 id="图形系统如何表示颜色？"><a href="#图形系统如何表示颜色？" class="headerlink" title="图形系统如何表示颜色？"></a>图形系统如何表示颜色？</h3><h4 id="RGB-和-RGBA-的颜色表示法"><a href="#RGB-和-RGBA-的颜色表示法" class="headerlink" title="RGB 和 RGBA 的颜色表示法"></a>RGB 和 RGBA 的颜色表示法</h4><p>因为 RGB(A) 颜色用两位十六进制数来表示每一个通道的色阶，所以每个通道一共有 256 阶，取值是 0 到 255。<br>因此，RGB 颜色是将人眼可见的颜色表示为红、绿、蓝三原色不同色阶的混合。</p>
<p>WebGL 的 shader 默认支持 RGBA。因为在 WebGL 的 shader 中，我们是使用一个四维向量来表示颜色的，向量的 r、g、b、a 分量分别表示红色、绿色、蓝色和 alpha 通道。不过和 CSS 的颜色表示稍有不同的是，WebGL 采用归一化的浮点数值，也就是说，WebGL 的颜色分量 r、g、b、a 的数值都是 0 到 1 之间的浮点数。</p>
<p>当要选择一组颜色给图表使用时，我们并不知道要以什么样的规则来配置颜色，才能让不同数据对应的图形之间的对比尽可能鲜明。因此，RGB 颜色对用户其实并不友好。</p>
<p>在需要动态构建视觉颜色效果的时候，我们很少直接选用 RGB 色值，而是使用其他的颜色表示形式。这其中，比较常用的就是 HSL 和 HSV 颜色表示形式。</p>
<h4 id="HSL-和-HSV-颜色"><a href="#HSL-和-HSV-颜色" class="headerlink" title="HSL 和 HSV 颜色"></a>HSL 和 HSV 颜色</h4><p>与 RGB 颜色以色阶表示颜色不同，HSL 和 HSV 用色相（Hue）、饱和度（Saturation）和亮度（Lightness）或明度（Value）来表示颜色。其中，Hue 是角度，取值范围是 0 到 360 度，饱和度和亮度 / 明度的值都是从 0 到 100%。</p>
<p>CSS 和 Canvas2D 都可以直接支持 HSL 颜色，只有 WebGL 需要做转换。</p>
<h4 id="CIE-Lab-和-CIE-Lch-颜色"><a href="#CIE-Lab-和-CIE-Lch-颜色" class="headerlink" title="CIE Lab 和 CIE Lch 颜色"></a>CIE Lab 和 CIE Lch 颜色</h4><p>CIE Lab 颜色空间简称 Lab，它其实就是一种符合人类感觉的色彩空间，它用 L 表示亮度，a 和 b 表示颜色对立度。RGB 值也可以 Lab 转换，但是转换规则比较复杂。</p>
<p>CIE Lch 和 CIE Lab 表示颜色的技术还比较新，所以目前我们也不会接触很多，但是因为它能呈现的色彩更贴近人眼的感知，所以我相信它会发展得很快。作为技术人，这些新技术，我们也要持续关注。</p>
<h4 id="Cubehelix-色盘"><a href="#Cubehelix-色盘" class="headerlink" title="Cubehelix 色盘"></a>Cubehelix 色盘</h4><p>Cubehelix 色盘（立方螺旋色盘）。简单来说，它的原理就是在 RGB 的立方中构建一段螺旋线，让色相随着亮度增加螺旋变换。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>RGB 用三原色的色阶来表示颜色，是最基础的颜色表示法，但是它对用户不够友好。而 HSL 和 HSV 是用色相、饱和度、亮度（明度）来表示颜色，对开发者比较友好，但是它的数值变换与人眼感知并不完全相符。</p>
<p>CIELab 和 CIELch 与 Cubehelix 色盘，这两种颜色表示法还比较新，在实际工作中使用得不是很多。其中，CIELab 和 CIELch 是与人眼感知相符的色彩空间表示法，已经被纳入 css-color level4 规范中。虽然还没有被浏览器支持，但是一些如 d3-color 这样的 JavaScript 库可以直接处理 Lab 颜色空间。而如果我们要呈现颜色随数据动态改变的效果，那 Cubehelix 色盘就是一种非常更合适的选择了。</p>
<h3 id="图案生成：如何生成重复图案、分形图案以及随机效果？"><a href="#图案生成：如何生成重复图案、分形图案以及随机效果？" class="headerlink" title="图案生成：如何生成重复图案、分形图案以及随机效果？"></a>图案生成：如何生成重复图案、分形图案以及随机效果？</h3><h4 id="如何绘制大批量重复图案"><a href="#如何绘制大批量重复图案" class="headerlink" title="如何绘制大批量重复图案"></a>如何绘制大批量重复图案</h4><h5 id="使用-background-image-来绘制重复图案"><a href="#使用-background-image-来绘制重复图案" class="headerlink" title="使用 background-image 来绘制重复图案"></a>使用 background-image 来绘制重复图案</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">canvas &#123;</span><br><span class="line">  background-image: linear-gradient(to right, transparent 90%, #ccc 0),</span><br><span class="line">    linear-gradient(to bottom, transparent 90%, #ccc 0);</span><br><span class="line">  background-size: 8px 8px, 8px 8px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CSS 的 linear-gradient 属性可以定义线性渐变，在这个例子里，to right 表示颜色过渡是从左到右的，其中 0% 到 90% 的区域是透明的，90% 到 100% 的区域是 #ccc 颜色。另外，在 linear-gradient 中定义颜色过渡的时候，如果后一个过渡颜色的区域值和前面相同，我们可以把它简单写为 0。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如上面的代码所示，我们一共给 background-image 设置了两个 linear-gradient，一个是横向的（to right），一个是纵向的（to bottom）。因为 css 的 background-repeat 默认值是 repeat，所以我们给背景设置一下 background-size。这样，我们利用浏览器自己的 background-repeat 机制，就可以实现我们想要的网格背景了。</span><br></pre></td></tr></table></figure>
<h5 id="使用-Shader-来绘制重复图案"><a href="#使用-Shader-来绘制重复图案" class="headerlink" title="使用 Shader 来绘制重复图案"></a>使用 Shader 来绘制重复图案</h5><p>它的优势在于，不管我们给 rows 取值多少，图案都是一次绘制出来的，并不会因为 rows 增加而消耗性能。所以，使用 Shader 绘制重复图案，不管绘制多么细腻，图案重复多少次，绘制消耗的时间几乎是常量，不会遇到性能瓶颈。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/学习/">学习</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/学习/">学习</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-react+" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/28/react+/" class="article-date">
      <time datetime="2022-08-27T16:00:00.000Z" itemprop="datePublished">2022-08-28</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/28/react+/">深入浅出react</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="系统深入学习基础知识"><a href="#系统深入学习基础知识" class="headerlink" title="系统深入学习基础知识"></a>系统深入学习基础知识</h2><h3 id="JSX-代码是如何“摇身一变”成为-DOM-的？"><a href="#JSX-代码是如何“摇身一变”成为-DOM-的？" class="headerlink" title="JSX 代码是如何“摇身一变”成为 DOM 的？"></a>JSX 代码是如何“摇身一变”成为 DOM 的？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">JSX 是 JavaScript 的一种语法扩展，它和模板语言很接近，但是它充分具备 JavaScript 的能力。</span><br><span class="line">JSX 会被编译为 React.createElement()， React.createElement() 将返回一个叫作“React Element”的 JS 对象。</span><br><span class="line">“编译”这个动作，是由 Babel 来完成的。</span><br><span class="line">Babel 是一个工具链，主要用于将 ECMAScript 2015+ 版本的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">比如说，ES2015+ 版本推出了一种名为“模板字符串”的新语法，这种语法在一些低版本的浏览器里并不兼容。下面是一段模板字符串的示例代码：</span><br><span class="line"></span><br><span class="line">var name = &quot;Guy Fieri&quot;;</span><br><span class="line"></span><br><span class="line">var place = &quot;Flavortown&quot;;</span><br><span class="line"></span><br><span class="line">`Hello $&#123;name&#125;, ready for $&#123;place&#125;?`;</span><br><span class="line"></span><br><span class="line">Babel 就可以帮我们把这段代码转换为大部分低版本浏览器也能够识别的 ES5 代码：</span><br><span class="line"></span><br><span class="line">var name = &quot;Guy Fieri&quot;;</span><br><span class="line"></span><br><span class="line">var place = &quot;Flavortown&quot;;</span><br><span class="line"></span><br><span class="line">&quot;Hello &quot;.concat(name, &quot;, ready for &quot;).concat(place, &quot;?&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">类似的，Babel 也具备将 JSX 语法转换为 JavaScript 代码的能力。</span><br><span class="line">JSX 的本质是React.createElement这个 JavaScript 调用的语法糖，这也就完美地呼应上了 React 官方给出的“JSX 充分具备 JavaScript 的能力”这句话。</span><br><span class="line">config：以对象形式传入，组件所有的属性都会以键值对的形式存储在 config 对象中。</span><br><span class="line">children：以对象形式传入，它记录的是组件标签之间嵌套的内容，也就是所谓的“子节点”“子元素”。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">JSX 是如何映射为 DOM 的：起底 createElement 源码</span><br><span class="line">createElement 有 3 个入参，这 3 个入参囊括了 React 创建一个元素所需要知道的全部信息。</span><br><span class="line">type：用于标识节点的类型。它可以是类似“h1”“div”这样的标准 HTML 标签字符串，也可以是 React 组件类型或 React fragment 类型。</span><br><span class="line"></span><br><span class="line">React.createElement(&quot;ul&quot;, &#123;</span><br><span class="line"></span><br><span class="line">  // 传入属性键值对</span><br><span class="line"></span><br><span class="line">  className: &quot;list&quot;</span><br><span class="line"></span><br><span class="line">   // 从第三个入参开始往后，传入的参数都是 children</span><br><span class="line"></span><br><span class="line">&#125;, React.createElement(&quot;li&quot;, &#123;</span><br><span class="line"></span><br><span class="line">  key: &quot;1&quot;</span><br><span class="line"></span><br><span class="line">&#125;, &quot;1&quot;), React.createElement(&quot;li&quot;, &#123;</span><br><span class="line"></span><br><span class="line">  key: &quot;2&quot;</span><br><span class="line"></span><br><span class="line">&#125;, &quot;2&quot;));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;ul className=&quot;list&quot;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;li key=&quot;1&quot;&gt;1&lt;/li&gt;</span><br><span class="line"></span><br><span class="line">  &lt;li key=&quot;2&quot;&gt;2&lt;/li&gt;</span><br><span class="line"></span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">createElement 执行到最后会 return 一个针对 ReactElement 的调用。</span><br><span class="line"></span><br><span class="line">const ReactElement = function(type, key, ref, self, source, owner, props) &#123;</span><br><span class="line"></span><br><span class="line">  const element = &#123;</span><br><span class="line"></span><br><span class="line">    // REACT_ELEMENT_TYPE是一个常量，用来标识该对象是一个ReactElement</span><br><span class="line"></span><br><span class="line">    $$typeof: REACT_ELEMENT_TYPE,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 内置属性赋值</span><br><span class="line"></span><br><span class="line">    type: type,</span><br><span class="line"></span><br><span class="line">    key: key,</span><br><span class="line"></span><br><span class="line">    ref: ref,</span><br><span class="line"></span><br><span class="line">    props: props,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 记录创造该元素的组件</span><br><span class="line"></span><br><span class="line">    _owner: owner,</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // </span><br><span class="line"></span><br><span class="line">  if (__DEV__) &#123;</span><br><span class="line"></span><br><span class="line">    // 这里是一些针对 __DEV__ 环境下的处理，对于大家理解主要逻辑意义不大，此处我直接省略掉，以免混淆视听</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  return element;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ReactElement 其实只做了一件事情，那就是“创建”，说得更精确一点，是“组装”：ReactElement 把传入的参数按照一定的规范，“组装”进了 element 对象里，并把它返回给了 React.createElement，最终 React.createElement 又把它交回到了开发者手中。</span><br><span class="line"></span><br><span class="line">ReactElement 对象实例，本质上是以 JavaScript 对象形式存在的对 DOM 的描述，也就是老生常谈的“虚拟 DOM”（准确地说，是虚拟 DOM 中的一个节点。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">既然是“虚拟 DOM”，那就意味着和渲染到页面上的真实 DOM 之间还有一些距离，这个“距离”，就是由大家喜闻乐见的ReactDOM.render方法来填补的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line"></span><br><span class="line">    // 需要渲染的元素（ReactElement）</span><br><span class="line"></span><br><span class="line">    element, </span><br><span class="line"></span><br><span class="line">    // 元素挂载的目标容器（一个真实DOM）</span><br><span class="line"></span><br><span class="line">    container,</span><br><span class="line"></span><br><span class="line">    // 回调函数，可选参数，可以用来处理渲染结束后的逻辑</span><br><span class="line"></span><br><span class="line">    [callback]</span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="为什么-React-16-要更改组件的生命周期？（上）"><a href="#为什么-React-16-要更改组件的生命周期？（上）" class="headerlink" title="为什么 React 16 要更改组件的生命周期？（上）"></a>为什么 React 16 要更改组件的生命周期？（上）</h3> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br></pre></td><td class="code"><pre><span class="line">虚拟 DOM：核心算法的基石</span><br><span class="line"> </span><br><span class="line">组件在初始化时，会通过调用生命周期中的 render 方法，生成虚拟 DOM，然后再通过调用 ReactDOM.render 方法，实现虚拟 DOM 到真实 DOM 的转换。</span><br><span class="line"> </span><br><span class="line">当组件更新时，会再次通过调用 render 方法生成新的虚拟 DOM，然后借助 diff（这是一个非常关键的算法，我将在“模块二：核心原理”重点讲解）定位出两次虚拟 DOM 的差异，从而针对发生变化的真实 DOM 作定向更新。</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">在 React 15 中，大家需要关注以下几个生命周期方法：</span><br><span class="line">constructor()</span><br><span class="line"></span><br><span class="line">componentWillReceiveProps()</span><br><span class="line"></span><br><span class="line">shouldComponentUpdate()</span><br><span class="line"></span><br><span class="line">componentWillMount()</span><br><span class="line"></span><br><span class="line">componentWillUpdate()</span><br><span class="line"></span><br><span class="line">componentDidUpdate()</span><br><span class="line"></span><br><span class="line">componentDidMount()</span><br><span class="line"></span><br><span class="line">render()</span><br><span class="line"></span><br><span class="line">componentWillUnmount()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import React from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">import ReactDOM from &quot;react-dom&quot;;</span><br><span class="line"></span><br><span class="line">// 定义子组件</span><br><span class="line"></span><br><span class="line">class LifeCycle extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">  constructor(props) &#123;</span><br><span class="line"></span><br><span class="line">    console.log(&quot;进入constructor&quot;);</span><br><span class="line"></span><br><span class="line">    super(props);</span><br><span class="line"></span><br><span class="line">    // state 可以在 constructor 里初始化</span><br><span class="line"></span><br><span class="line">    this.state = &#123; text: &quot;子组件的文本&quot; &#125;;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 初始化渲染时调用</span><br><span class="line"></span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line"></span><br><span class="line">    console.log(&quot;componentWillMount方法执行&quot;);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 初始化渲染时调用</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line"></span><br><span class="line">    console.log(&quot;componentDidMount方法执行&quot;);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 父组件修改组件的props时会调用</span><br><span class="line"></span><br><span class="line">  componentWillReceiveProps(nextProps) &#123;</span><br><span class="line"></span><br><span class="line">    console.log(&quot;componentWillReceiveProps方法执行&quot;);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 组件更新时调用</span><br><span class="line"></span><br><span class="line">  shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line"></span><br><span class="line">    console.log(&quot;shouldComponentUpdate方法执行&quot;);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 组件更新时调用</span><br><span class="line"></span><br><span class="line">  componentWillUpdate(nextProps, nextState) &#123;</span><br><span class="line"></span><br><span class="line">    console.log(&quot;componentWillUpdate方法执行&quot;);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 组件更新后调用</span><br><span class="line"></span><br><span class="line">  componentDidUpdate(preProps, preState) &#123;</span><br><span class="line"></span><br><span class="line">    console.log(&quot;componentDidUpdate方法执行&quot;);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 组件卸载时调用</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line"></span><br><span class="line">    console.log(&quot;子组件的componentWillUnmount方法执行&quot;);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 点击按钮，修改子组件文本内容的方法</span><br><span class="line"></span><br><span class="line">  changeText = () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    this.setState(&#123;</span><br><span class="line"></span><br><span class="line">      text: &quot;修改后的子组件文本&quot;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line"></span><br><span class="line">    console.log(&quot;render方法执行&quot;);</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line"></span><br><span class="line">      &lt;div className=&quot;container&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;button onClick=&#123;this.changeText&#125; className=&quot;changeText&quot;&gt;</span><br><span class="line"></span><br><span class="line">          修改子组件文本内容</span><br><span class="line"></span><br><span class="line">        &lt;/button&gt;</span><br><span class="line"></span><br><span class="line">        &lt;p className=&quot;textContent&quot;&gt;&#123;this.state.text&#125;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">        &lt;p className=&quot;fatherContent&quot;&gt;&#123;this.props.text&#125;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">      &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义 LifeCycle 组件的父组件</span><br><span class="line"></span><br><span class="line">class LifeCycleContainer extends React.Component &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // state 也可以像这样用属性声明的形式初始化</span><br><span class="line"></span><br><span class="line">  state = &#123;</span><br><span class="line"></span><br><span class="line">    text: &quot;父组件的文本&quot;,</span><br><span class="line"></span><br><span class="line">    hideChild: false</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  // 点击按钮，修改父组件文本的方法</span><br><span class="line"></span><br><span class="line">  changeText = () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    this.setState(&#123;</span><br><span class="line"></span><br><span class="line">      text: &quot;修改后的父组件文本&quot;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  // 点击按钮，隐藏（卸载）LifeCycle 组件的方法</span><br><span class="line"></span><br><span class="line">  hideChild = () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    this.setState(&#123;</span><br><span class="line"></span><br><span class="line">      hideChild: true</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line"></span><br><span class="line">      &lt;div className=&quot;fatherContainer&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;button onClick=&#123;this.changeText&#125; className=&quot;changeText&quot;&gt;</span><br><span class="line"></span><br><span class="line">          修改父组件文本内容</span><br><span class="line"></span><br><span class="line">        &lt;/button&gt;</span><br><span class="line"></span><br><span class="line">        &lt;button onClick=&#123;this.hideChild&#125; className=&quot;hideChild&quot;&gt;</span><br><span class="line"></span><br><span class="line">          隐藏子组件</span><br><span class="line"></span><br><span class="line">        &lt;/button&gt;</span><br><span class="line"></span><br><span class="line">        &#123;this.state.hideChild ? null : &lt;LifeCycle text=&#123;this.state.text&#125; /&gt;&#125;</span><br><span class="line"></span><br><span class="line">      &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;LifeCycleContainer /&gt;, document.getElementById(&quot;root&quot;));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">挂载过程在组件的一生中仅会发生一次，在这个过程中，组件被初始化，然后会被渲染到真实 DOM 里，完成所谓的“首次渲染”。</span><br><span class="line"></span><br><span class="line">componentWillMount、componentDidMount 方法同样只会在挂载阶段被调用一次。</span><br><span class="line">render 在执行过程中并不会去操作真实 DOM（也就是说不会渲染），它的职能是把需要渲染的内容返回出来。真实 DOM 的渲染工作，在挂载阶段是由 ReactDOM.render 来承接的。</span><br><span class="line">componentDidMount 方法在渲染结束后被触发，此时因为真实 DOM 已经挂载到了页面上，我们可以在这个生命周期里执行真实 DOM 相关的操作。此外，类似于异步请求、数据初始化这样的操作也大可以放在这个生命周期来做（侧面印证了 componentWillMount 真的很鸡肋）。</span><br><span class="line"></span><br><span class="line">组件的更新分为两种：一种是由父组件更新触发的更新；另一种是组件自身调用自己的 setState 触发的更新。</span><br><span class="line"></span><br><span class="line">componentReceiveProps 并不是由 props 的变化触发的，而是由父组件的更新触发的，这个结论，请你谨记。</span><br><span class="line">componentWillUpdate 会在 render 前被触发，它和 componentWillMount 类似，允许你在里面做一些不涉及真实 DOM 操作的准备工作；</span><br><span class="line">而 componentDidUpdate 则在组件更新完毕后被触发，和 componentDidMount 类似，这个生命周期也经常被用来处理 DOM 操作。</span><br><span class="line">此外，我们也常常将 componentDidUpdate 的执行作为子组件更新完毕的标志通知到父组件。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">React 组件会根据 shouldComponentUpdate 的返回值，来决定是否执行该方法之后的生命周期，进而决定是否对组件进行re-render（重渲染）。</span><br><span class="line">shouldComponentUpdate 的默认值为 true，也就是说“无条件 re-render”。</span><br><span class="line">在实际的开发中，我们往往通过手动往 shouldComponentUpdate 中填充判定逻辑，或者直接在项目中引入 PureComponent 等最佳实践，来实现“有条件的 re-render”。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">组件销毁的常见原因有以下两个。</span><br><span class="line"></span><br><span class="line">组件在父组件中被移除了：这种情况相对比较直观。</span><br><span class="line">组件中设置了 key 属性，父组件在 render 的过程中，发现 key 值和上一次不一致，那么这个组件就会被干掉。</span><br></pre></td></tr></table></figure>
<h3 id="为什么-React-16-要更改组件的生命周期？（下）"><a href="#为什么-React-16-要更改组件的生命周期？（下）" class="headerlink" title="为什么 React 16 要更改组件的生命周期？（下）"></a>为什么 React 16 要更改组件的生命周期？（下）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">import ReactDOM from &quot;react-dom&quot;;</span><br><span class="line"></span><br><span class="line">// 定义子组件</span><br><span class="line"></span><br><span class="line">class LifeCycle extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">  constructor(props) &#123;</span><br><span class="line"></span><br><span class="line">    console.log(&quot;进入constructor&quot;);</span><br><span class="line"></span><br><span class="line">    super(props);</span><br><span class="line"></span><br><span class="line">    // state 可以在 constructor 里初始化</span><br><span class="line"></span><br><span class="line">    this.state = &#123; text: &quot;子组件的文本&quot; &#125;;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 初始化/更新时调用</span><br><span class="line"></span><br><span class="line">  static getDerivedStateFromProps(props, state) &#123;</span><br><span class="line"></span><br><span class="line">    console.log(&quot;getDerivedStateFromProps方法执行&quot;);</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line"></span><br><span class="line">      fatherText: props.text</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 初始化渲染时调用</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line"></span><br><span class="line">    console.log(&quot;componentDidMount方法执行&quot;);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 组件更新时调用</span><br><span class="line"></span><br><span class="line">  shouldComponentUpdate(prevProps, nextState) &#123;</span><br><span class="line"></span><br><span class="line">    console.log(&quot;shouldComponentUpdate方法执行&quot;);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 组件更新时调用</span><br><span class="line"></span><br><span class="line">  getSnapshotBeforeUpdate(prevProps, prevState) &#123;</span><br><span class="line"></span><br><span class="line">    console.log(&quot;getSnapshotBeforeUpdate方法执行&quot;);</span><br><span class="line"></span><br><span class="line">    return &quot;haha&quot;;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 组件更新后调用</span><br><span class="line"></span><br><span class="line">  componentDidUpdate(preProps, preState, valueFromSnapshot) &#123;</span><br><span class="line"></span><br><span class="line">    console.log(&quot;componentDidUpdate方法执行&quot;);</span><br><span class="line"></span><br><span class="line">    console.log(&quot;从 getSnapshotBeforeUpdate 获取到的值是&quot;, valueFromSnapshot);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 组件卸载时调用</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line"></span><br><span class="line">    console.log(&quot;子组件的componentWillUnmount方法执行&quot;);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 点击按钮，修改子组件文本内容的方法</span><br><span class="line"></span><br><span class="line">  changeText = () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    this.setState(&#123;</span><br><span class="line"></span><br><span class="line">      text: &quot;修改后的子组件文本&quot;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line"></span><br><span class="line">    console.log(&quot;render方法执行&quot;);</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line"></span><br><span class="line">      &lt;div className=&quot;container&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;button onClick=&#123;this.changeText&#125; className=&quot;changeText&quot;&gt;</span><br><span class="line"></span><br><span class="line">          修改子组件文本内容</span><br><span class="line"></span><br><span class="line">        &lt;/button&gt;</span><br><span class="line"></span><br><span class="line">        &lt;p className=&quot;textContent&quot;&gt;&#123;this.state.text&#125;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">        &lt;p className=&quot;fatherContent&quot;&gt;&#123;this.props.text&#125;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">      &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义 LifeCycle 组件的父组件</span><br><span class="line"></span><br><span class="line">class LifeCycleContainer extends React.Component &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // state 也可以像这样用属性声明的形式初始化</span><br><span class="line"></span><br><span class="line">  state = &#123;</span><br><span class="line"></span><br><span class="line">    text: &quot;父组件的文本&quot;,</span><br><span class="line"></span><br><span class="line">    hideChild: false</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  // 点击按钮，修改父组件文本的方法</span><br><span class="line"></span><br><span class="line">  changeText = () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    this.setState(&#123;</span><br><span class="line"></span><br><span class="line">      text: &quot;修改后的父组件文本&quot;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  // 点击按钮，隐藏（卸载）LifeCycle 组件的方法</span><br><span class="line"></span><br><span class="line">  hideChild = () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    this.setState(&#123;</span><br><span class="line"></span><br><span class="line">      hideChild: true</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line"></span><br><span class="line">      &lt;div className=&quot;fatherContainer&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;button onClick=&#123;this.changeText&#125; className=&quot;changeText&quot;&gt;</span><br><span class="line"></span><br><span class="line">          修改父组件文本内容</span><br><span class="line"></span><br><span class="line">        &lt;/button&gt;</span><br><span class="line"></span><br><span class="line">        &lt;button onClick=&#123;this.hideChild&#125; className=&quot;hideChild&quot;&gt;</span><br><span class="line"></span><br><span class="line">          隐藏子组件</span><br><span class="line"></span><br><span class="line">        &lt;/button&gt;</span><br><span class="line"></span><br><span class="line">        &#123;this.state.hideChild ? null : &lt;LifeCycle text=&#123;this.state.text&#125; /&gt;&#125;</span><br><span class="line"></span><br><span class="line">      &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;LifeCycleContainer /&gt;, document.getElementById(&quot;root&quot;));</span><br></pre></td></tr></table></figure>
<p>React 15 生命周期和 React 16.3 生命周期在挂载阶段的主要差异在于，废弃了 componentWillMount，新增了 getDerivedStateFromProps。</p>
<p>React 16 对 render 方法也进行了一些改进。React 16 之前，render方法必须返回单个元素，而 React 16 允许我们返回元素数组和字符串。</p>
<p>getDerivedStateFromProps 不是 componentWillMount 的替代品<br>而 getDerivedStateFromProps 这个 API，其设计的初衷不是试图替换掉 componentWillMount，而是试图替换掉 componentWillReceiveProps，因此它有且仅有一个用途：使用 props 来派生/更新 state。</p>
<p>React 团队为了确保 getDerivedStateFromProps 这个生命周期的纯洁性，直接从命名层面约束了它的用途（getDerivedStateFromProps 直译过来就是“从 Props 里派生 State”）。</p>
<p>所以，如果你不是出于这个目的来使用 getDerivedStateFromProps，原则上来说都是不符合规范的。</p>
<p>值得一提的是，getDerivedStateFromProps 在更新和挂载两个阶段都会“出镜”（这点不同于仅在更新阶段出现的 componentWillReceiveProps）。</p>
<p>这是因为“派生 state”这种诉求不仅在 props 更新时存在，在 props 初始化的时候也是存在的。<br>React 16 以提供特定生命周期的形式，对这类诉求提供了更直接的支持。</p>
<p>static getDerivedStateFromProps(props, state)<br>第一个重点是最特别的一点：getDerivedStateFromProps 是一个静态方法。静态方法不依赖组件实例而存在，因此你在这个方法内部是访问不到 this 的。<br>第二个重点，该方法可以接收两个参数：props 和 state，它们分别代表当前组件接收到的来自父组件的 props 和当前组件自身的 state。<br>第三个重点，getDerivedStateFromProps 需要一个对象格式的返回值。如果你没有指定这个返回值，那么大概率会被 React 警告一番</p>
<p>getDerivedStateFromProps 的返回值之所以不可或缺，是因为 React 需要用这个返回值来更新（派生）组件的 state。因此当你确实不存在“使用 props 派生 state ”这个需求的时候，最好是直接省略掉这个生命周期方法的编写，否则一定记得给它 return 一个 null。<br>注意，getDerivedStateFromProps 方法对 state 的更新动作并非“覆盖”式的更新，而是针对某个属性的定向更新。</p>
<p>React 16.4 的挂载和卸载流程都是与 React 16.3 保持一致的，差异在于更新流程上：<br>在 React 16.4 中，任何因素触发的组件更新流程（包括由 this.setState 和 forceUpdate 触发的更新流程）都会触发 getDerivedStateFromProps；<br>而在 v 16.3 版本时，只有父组件的更新会触发该生命周期。<br>getDerivedStateFromProps 这个 API，它相对于早期的 componentWillReceiveProps 来说，正是做了“合理的减法”。而做这个减法的决心之强烈，从 getDerivedStateFromProps 直接被定义为 static 方法这件事上就可见一斑—— static 方法内部拿不到组件实例的 this，这就导致你无法在 getDerivedStateFromProps 里面做任何类似于 this.fetch()、不合理的 this.setState（会导致死循环的那种）这类可能会产生副作用的操作。</p>
<p>因此，getDerivedStateFromProps 生命周期替代 componentWillReceiveProps 的背后，是 React 16 在强制推行“只用 getDerivedStateFromProps 来完成 props 到 state 的映射”这一最佳实践。意在确保生命周期函数的行为更加可控可预测，从根源上帮开发者避免不合理的编程方式，避免生命周期的滥用；同时，也是在为新的 Fiber 架构铺路。</p>
<p><strong>消失的 componentWillUpdate 与新增的 getSnapshotBeforeUpdate</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getSnapshotBeforeUpdate(prevProps, prevState) &#123;</span><br><span class="line"></span><br><span class="line">  // ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法和 getDerivedStateFromProps 颇有几分神似，它们都强调了“我需要一个返回值”这回事。区别在于 getSnapshotBeforeUpdate 的返回值会作为第三个参数给到 componentDidUpdate。它的执行时机是在 render 方法之后，真实 DOM 更新之前。在这个阶段里，我们可以同时获取到更新前的真实 DOM 和更新前后的 state&amp;props 信息。</p>
<p>尽管在实际工作中，需要用到这么多信息的场景并不多，但在对于实现一些特殊的需求来说，没它还真的挺难办。这里我举一个非常有代表性的例子：实现一个内容会发生变化的滚动列表，要求根据滚动列表的内容是否发生变化，来决定是否要记录滚动条的当前位置。<br>这个需求的前半截要求我们对比更新前后的数据（感知变化），后半截则需要获取真实的 DOM 信息（获取位置），这时用 getSnapshotBeforeUpdate 来解决就再合适不过了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 组件更新时调用</span><br><span class="line"></span><br><span class="line">getSnapshotBeforeUpdate(prevProps, prevState) &#123;</span><br><span class="line"></span><br><span class="line">  console.log(&quot;getSnapshotBeforeUpdate方法执行&quot;);</span><br><span class="line"></span><br><span class="line">  return &quot;haha&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 组件更新后调用</span><br><span class="line"></span><br><span class="line">componentDidUpdate(prevProps, prevState, valueFromSnapshot) &#123;</span><br><span class="line"></span><br><span class="line">  console.log(&quot;componentDidUpdate方法执行&quot;);</span><br><span class="line"></span><br><span class="line">  console.log(&quot;从 getSnapshotBeforeUpdate 获取到的值是&quot;, valueFromSnapshot);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得一提的是，这个生命周期的设计初衷，是为了“与 componentDidUpdate 一起，涵盖过时的 componentWillUpdate 的所有用例”（引用自 React 官网）。<br>getSnapshotBeforeUpdate 要想发挥作用，离不开 componentDidUpdate 的配合。</p>
<p>那么换个角度想想，为什么 componentWillUpdate 就非死不可呢？说到底，还是因为它“挡了 Fiber 的路”。各位莫慌，咱们离真相越来越近了~</p>
<hr>
<p>Fiber 是 React 16 对 React 核心算法的一次重写。<br>Fiber 会使原本同步的渲染过程变成异步的。<br>在 React 16 之前，每当我们触发一次组件的更新，React 都会构建一棵新的虚拟 DOM 树，通过与上一次的虚拟 DOM 树进行 diff，实现对 DOM 的定向更新。这个过程，是一个递归的过程。</p>
<p>同步渲染的递归调用栈是非常深的，只有最底层的调用返回了，整个渲染过程才会开始逐层返回。<br>这个漫长且不可打断的更新过程，将会带来用户体验层面的巨大风险：同步渲染一旦开始，便会牢牢抓住主线程不放，直到递归彻底完成。<br>在这个过程中，浏览器没有办法处理任何渲染之外的事情，会进入一种无法处理用户交互的状态。<br>因此若渲染时间稍微长一点，页面就会面临卡顿甚至卡死的风险。</p>
<p>而 React 16 引入的 Fiber 架构，恰好能够解决掉这个风险：Fiber 会将一个大的更新任务拆解为许多个小任务。<br>每当执行完一个小任务时，渲染线程都会把主线程交回去，看看有没有优先级更高的工作要处理，确保不会出现其他任务被“饿死”的情况，进而避免同步渲染带来的卡顿。<br>在这个过程中，渲染线程不再“一去不回头”，而是可以被打断的，这就是所谓的“异步渲染”，</p>
<p>Fiber 架构的重要特征就是可以被打断的异步渲染模式。<br>但这个“打断”是有原则的，根据“能否被打断”这一标准，React 16 的生命周期被划分为了 render 和 commit 两个阶段，而 commit 阶段又被细分为了 pre-commit 和 commit。 </p>
<p>我们先来看下三个阶段各自有哪些特征<br>render 阶段：纯净且没有副作用，可能会被 React 暂停、终止或重新启动。<br>pre-commit 阶段：可以读取 DOM。<br>commit 阶段：可以使用 DOM，运行副作用，安排更新。<br>总的来说，render 阶段在执行过程中允许被打断，而 commit 阶段则总是同步执行的。</p>
<p>为什么这样设计呢？简单来说，由于 render 阶段的操作对用户来说其实是“不可见”的，所以就算打断再重启，对用户来说也是零感知。<br>而 commit 阶段的操作则涉及真实 DOM 的渲染，再狂的框架也不敢在用户眼皮子底下胡乱更改视图，所以这个过程必须用同步渲染来求稳。</p>
<p>在 Fiber 机制下，render 阶段是允许暂停、终止和重启的。<br>当一个任务执行到一半被打断后，下一次渲染线程抢回主动权时，这个任务被重启的形式是“重复执行一遍整个任务”而非“接着上次执行到的那行代码往下走”。<br>这就导致 render 阶段的生命周期都是有可能被重复执行的。</p>
<p>带着这个结论，我们再来看看 React 16 打算废弃的是哪些生命周期：<br>componentWillMount；<br>componentWillUpdate；<br>componentWillReceiveProps。</p>
<p>这些生命周期的共性，就是它们都处于 render 阶段，都可能重复被执行，而且由于这些 API 常年被滥用，它们在重复执行的过程中都存在着不可小觑的风险。</p>
<p>在“componentWill”开头的生命周期里，你习惯于做的事情可能包括但不限于:<br>setState()；<br>fetch 发起异步请求；<br>操作真实 DOM。</p>
<p>完全可以转移到其他生命周期（尤其是 componentDidxxx）里去做。<br>异步请求再怎么快也快不过（React 15 下）同步的生命周期。componentWillMount 结束后，render 会迅速地被触发，所以说首次渲染依然会在数据返回之前执行。<br>这样做不仅没有达到你预想的目的，还会导致服务端渲染场景下的冗余请求等额外问题，得不偿失。</p>
<p>在 Fiber 带来的异步渲染机制下，可能会导致非常严重的 Bug。<br>试想，假如你在 componentWillxxx 里发起了一个付款请求。由于 render 阶段里的生命周期都可以重复执行，在 componentWillxxx 被打断 + 重启多次后，就会发出多个付款请求。<br>比如说，这件商品单价只要 10 块钱，用户也只点击了一次付款。<br>但实际却可能因为 componentWillxxx 被打断 + 重启多次而多次调用付款接口，最终付了 50 块钱；<br>又或者你可能会习惯在 componentWillReceiveProps 里操作 DOM（比如说删除符合某个特征的元素），那么 componentWillReceiveProps 若是执行了两次，你可能就会一口气删掉两个符合该特征的元素。<br>结合上面的分析，我们再去思考 getDerivedStateFromProps 为何会在设计层面直接被约束为一个触碰不到 this 的静态方法，其背后的原因也就更加充分了——避免开发者触碰 this，就是在避免各种危险的骚操作。</p>
<p>即使你没有开启异步，React 15 下也有不少人能把自己“玩死”。<br>比如在 componentWillReceiveProps  和 componentWillUpdate 里滥用 setState 导致重复渲染死循环的，大家都懂哈（邪魅一笑）。</p>
<p>总的来说，React 16 改造生命周期的主要动机是为了配合 Fiber 架构带来的异步渲染机制。</p>
<h3 id="数据是如何在-React-组件之间流动的？（上）"><a href="#数据是如何在-React-组件之间流动的？（上）" class="headerlink" title="数据是如何在 React 组件之间流动的？（上）"></a>数据是如何在 React 组件之间流动的？（上）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br></pre></td><td class="code"><pre><span class="line">父-子组件通信</span><br><span class="line"></span><br><span class="line">子组件编码内容：</span><br><span class="line">function Child(props) &#123;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line"></span><br><span class="line">    &lt;div className=&quot;child&quot;&gt;</span><br><span class="line"></span><br><span class="line">      &lt;p&gt;&#123;`子组件所接收到的来自父组件的文本内容是：[$&#123;props.fatherText&#125;]`&#125;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">父组件编码内容：</span><br><span class="line">class Father extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">  // 初始化父组件的 state</span><br><span class="line"></span><br><span class="line">  state = &#123;</span><br><span class="line"></span><br><span class="line">    text: &quot;初始化的父组件的文本&quot;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  // 按钮的监听函数，用于更新 text 值</span><br><span class="line"></span><br><span class="line">  changeText = () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    this.setState(&#123;</span><br><span class="line"></span><br><span class="line">      text: &quot;改变后的父组件文本&quot;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  // 渲染父组件</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line"></span><br><span class="line">      &lt;div className=&quot;father&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;button onClick=&#123;this.changeText&#125;&gt;</span><br><span class="line"></span><br><span class="line">          点击修改父组件传入子组件的文本</span><br><span class="line"></span><br><span class="line">        &lt;/button&gt;</span><br><span class="line"></span><br><span class="line">        &#123;/* 引入子组件，并通过 props 下发具体的状态值实现父-子通信 */&#125;</span><br><span class="line"></span><br><span class="line">        &lt;Child fatherText=&#123;this.state.text&#125; /&gt;</span><br><span class="line"></span><br><span class="line">      &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">子-父组件通信</span><br><span class="line"></span><br><span class="line">考虑到 props 是单向的，子组件并不能直接将自己的数据塞给父组件，但 props 的形式也可以是多样的。</span><br><span class="line">假如父组件传递给子组件的是一个绑定了自身上下文的函数，那么子组件在调用该函数时，就可以将想要交给父组件的数据以函数入参的形式给出去，以此来间接地实现数据从子组件到父组件的流动。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Child extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">  // 初始化子组件的 state</span><br><span class="line"></span><br><span class="line">  state = &#123;</span><br><span class="line"></span><br><span class="line">    text: &apos;子组件的文本&apos;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 子组件的按钮监听函数</span><br><span class="line"></span><br><span class="line">  changeText = () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    // changeText 中，调用了父组件传入的 changeFatherText 方法</span><br><span class="line"></span><br><span class="line">    this.props.changeFatherText(this.state.text)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line"></span><br><span class="line">      &lt;div className=&quot;child&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &#123;/* 注意这里把修改父组件文本的动作放在了 Child 里 */&#125;</span><br><span class="line"></span><br><span class="line">        &lt;button onClick=&#123;this.changeText&#125;&gt;</span><br><span class="line"></span><br><span class="line">          点击更新父组件的文本</span><br><span class="line"></span><br><span class="line">        &lt;/button&gt;</span><br><span class="line"></span><br><span class="line">      &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Father extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">  // 初始化父组件的 state</span><br><span class="line"></span><br><span class="line">  state = &#123;</span><br><span class="line"></span><br><span class="line">    text: &quot;初始化的父组件的文本&quot;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  // 这个方法会作为 props 传给子组件，用于更新父组件 text 值。newText 正是开放给子组件的数据通信入口</span><br><span class="line"></span><br><span class="line">  changeText = (newText) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    this.setState(&#123;</span><br><span class="line"></span><br><span class="line">      text: newText</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  // 渲染父组件</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line"></span><br><span class="line">      &lt;div className=&quot;father&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;p&gt;&#123;`父组件的文本内容是：[$&#123;this.state.text&#125;]`&#125;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">        &#123;/* 引入子组件，并通过 props 中下发可传参的函数 实现子-父通信 */&#125;</span><br><span class="line"></span><br><span class="line">        &lt;Child</span><br><span class="line"></span><br><span class="line">          changeFatherText=&#123;this.changeText&#125;</span><br><span class="line"></span><br><span class="line">        /&gt;</span><br><span class="line"></span><br><span class="line">      &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">兄弟组件通信</span><br><span class="line"></span><br><span class="line">class NewChild extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">  state = &#123;</span><br><span class="line"></span><br><span class="line">    text: &quot;来自 newChild 的文本&quot;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  // NewChild 组件的按钮监听函数</span><br><span class="line"></span><br><span class="line">  changeText = () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    // changeText 中，调用了父组件传入的 changeFatherText 方法</span><br><span class="line"></span><br><span class="line">    this.props.changeFatherText(this.state.text);</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line"></span><br><span class="line">      &lt;div className=&quot;child&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &#123;/* 注意这里把修改父组件文本（同时也是 Child 组件的文本）的动作放在了 NewChild 里 */&#125;</span><br><span class="line"></span><br><span class="line">        &lt;button onClick=&#123;this.changeText&#125;&gt;点击更新 Child 组件的文本&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">      &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Father extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">  // 初始化父组件的 state</span><br><span class="line"></span><br><span class="line">  state = &#123;</span><br><span class="line"></span><br><span class="line">    text: &quot;初始化的父组件的文本&quot;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  // 传给 NewChild 组件按钮的监听函数，用于更新父组件 text 值（这个 text 值同时也是 Child 的 props）</span><br><span class="line"></span><br><span class="line">  changeText = (newText) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    this.setState(&#123;</span><br><span class="line"></span><br><span class="line">      text: newText</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  // 渲染父组件</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line"></span><br><span class="line">      &lt;div className=&quot;father&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &#123;/* 引入 Child 组件，并通过 props 中下发具体的状态值 实现父-子通信 */&#125;</span><br><span class="line"></span><br><span class="line">        &lt;Child fatherText=&#123;this.state.text&#125; /&gt;</span><br><span class="line"></span><br><span class="line">        &#123;/* 引入 NewChild 组件，并通过 props 中下发可传参的函数 实现子-父通信 */&#125;</span><br><span class="line"></span><br><span class="line">        &lt;NewChild changeFatherText=&#123;this.changeText&#125; /&gt;</span><br><span class="line"></span><br><span class="line">      &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>层层传递的优点是非常简单，用已有知识就能解决，但问题是会浪费很多代码，非常烦琐，中间作为桥梁的组件会引入很多不属于自己的属性。<br>短期来看，写代码的人会很痛苦；<br>长期来看，整个项目的维护成本都会变得非常高昂。因此，层层传递 props 要不得。</p>
<p><strong>利用“发布-订阅”模式驱动数据流</strong></p>
<p>“发布-订阅”模式可谓是解决通信类问题的“万金油”，在前端世界的应用非常广泛，比如：</p>
<ul>
<li>前两年爆火的 socket.io 模块，它就是一个典型的跨端发布-订阅模式的实现；</li>
<li>在 Node.js 中，许多原生模块也是以 EventEmitter 为基类实现的；</li>
<li>不过大家最为熟知的，应该还是 Vue.js 中作为常规操作被推而广之的“全局事件总线” EventBus</li>
</ul>
<p>发布-订阅机制早期最广泛的应用，应该是在浏览器的 DOM 事件中。  相信有过原生 JavaScript 开发经验的同学，对下面这样的用法都不会陌生：<br>target.addEventListener(type, listener, useCapture);<br>通过调用 addEventListener 方法，我们可以创建一个事件监听器，这个动作就是“订阅”。</p>
<p>比如我可以监听 click（点击）事件：el.addEventListener(“click”, func, false);<br>这样一来，当 click 事件被触发时，事件会被“发布”出去，进而触发监听这个事件的 func 函数。这就是一个最简单的发布-订阅案例。</p>
<p>使用发布-订阅模式的优点在于，监听事件的位置和触发事件的位置是不受限的，就算相隔十万八千里，只要它们在同一个上下文里，就能够彼此感知。<br>这个特性，太适合用来应对“任意组件通信”这种场景了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line">class myEventEmitter &#123;</span><br><span class="line"></span><br><span class="line">  constructor() &#123;</span><br><span class="line"></span><br><span class="line">    // eventMap 用来存储事件和监听函数之间的关系</span><br><span class="line"></span><br><span class="line">    this.eventMap = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // type 这里就代表事件的名称</span><br><span class="line"></span><br><span class="line">  on(type, handler) &#123;</span><br><span class="line"></span><br><span class="line">    // hanlder 必须是一个函数，如果不是直接报错</span><br><span class="line"></span><br><span class="line">    if (!(handler instanceof Function)) &#123;</span><br><span class="line"></span><br><span class="line">      throw new Error(&quot;哥 你错了 请传一个函数&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 判断 type 事件对应的队列是否存在</span><br><span class="line"></span><br><span class="line">    if (!this.eventMap[type]) &#123;</span><br><span class="line"></span><br><span class="line">      // 若不存在，新建该队列</span><br><span class="line"></span><br><span class="line">      this.eventMap[type] = [];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 若存在，直接往队列里推入 handler</span><br><span class="line"></span><br><span class="line">    this.eventMap[type].push(handler);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 别忘了我们前面说过触发时是可以携带数据的，params 就是数据的载体</span><br><span class="line"></span><br><span class="line">  emit(type, params) &#123;</span><br><span class="line"></span><br><span class="line">    // 假设该事件是有订阅的（对应的事件队列存在）</span><br><span class="line"></span><br><span class="line">    if (this.eventMap[type]) &#123;</span><br><span class="line"></span><br><span class="line">      // 将事件队列里的 handler 依次执行出队</span><br><span class="line"></span><br><span class="line">      this.eventMap[type].forEach((handler, index) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">        // 注意别忘了读取 params</span><br><span class="line"></span><br><span class="line">        handler(params);</span><br><span class="line"></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  off(type, handler) &#123;</span><br><span class="line"></span><br><span class="line">    if (this.eventMap[type]) &#123;</span><br><span class="line"></span><br><span class="line">      this.eventMap[type].splice(this.eventMap[type].indexOf(handler) &gt;&gt;&gt; 0, 1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 注意这个 myEvent 是提前实例化并挂载到全局的，此处不再重复示范实例化过程</span><br><span class="line"></span><br><span class="line">const globalEvent = window.myEvent</span><br><span class="line"></span><br><span class="line">class B extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">  // 这里省略掉其他业务逻辑</span><br><span class="line"></span><br><span class="line">  state = &#123;</span><br><span class="line"></span><br><span class="line">    newParams: &quot;&quot;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  handler = (params) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    this.setState(&#123;</span><br><span class="line"></span><br><span class="line">      newParams: params</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  bindHandler = () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    globalEvent.on(&quot;someEvent&quot;, this.handler);</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line"></span><br><span class="line">      &lt;div&gt;</span><br><span class="line"></span><br><span class="line">        &lt;button onClick=&#123;this.bindHandler&#125;&gt;点我监听A的动作&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">        &lt;div&gt;A传入的内容是[&#123;this.state.newParams&#125;]&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">      &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class A extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">  // 这里省略掉其他业务逻辑</span><br><span class="line"></span><br><span class="line">  state = &#123;</span><br><span class="line"></span><br><span class="line">    infoToB: &quot;哈哈哈哈我来自A&quot;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  reportToB = () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    // 这里的 infoToB 表示 A 自身状态中需要让 B 感知的那部分数据</span><br><span class="line"></span><br><span class="line">    globalEvent.emit(&quot;someEvent&quot;, this.state.infoToB);</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line"></span><br><span class="line">    return &lt;button onClick=&#123;this.reportToB&#125;&gt;点我把state传递给B&lt;/button&gt;;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数据是如何在-React-组件之间流动的？（下）"><a href="#数据是如何在-React-组件之间流动的？（下）" class="headerlink" title="数据是如何在 React 组件之间流动的？（下）"></a>数据是如何在 React 组件之间流动的？（下）</h3><p>Context API 是 React 官方提供的一种组件树全局通信的方式。<br>我们通过调用 React.createContext，可以创建出一组 Provider。Provider 作为数据的提供方，可以将数据下发给自身组件树中任意层级的 Consumer</p>
<p>注意：Cosumer 不仅能够读取到 Provider 下发的数据，还能读取到这些数据后续的更新。这意味着数据在生产者和消费者之间能够及时同步，这对 Context 这种模式来说至关重要。</p>
<p>Provider，可以理解为“数据的 Provider（提供者）”。<br>我们使用 Provider 对组件树中的根组件进行包裹，然后传入名为“value”的属性，这个 value 就是后续在组件树中流动的“数据”，它可以被 Consumer 消费。使用示例如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;Provider value=&#123;title: this.state.title, content: this.state.content&#125;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;Title /&gt;</span><br><span class="line"></span><br><span class="line">  &lt;Content /&gt;</span><br><span class="line"></span><br><span class="line"> &lt;/Provider&gt;</span><br></pre></td></tr></table></figure>
<p>Consumer，顾名思义就是“数据的消费者”，它可以读取 Provider 下发下来的数据。<br>其特点是需要接收一个函数作为子元素，这个函数需要返回一个组件。像这样： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Consumer&gt;</span><br><span class="line"></span><br><span class="line">  &#123;value =&gt; &lt;div&gt;&#123;value.title&#125;&lt;/div&gt;&#125;</span><br><span class="line"></span><br><span class="line">&lt;/Consumer&gt;</span><br></pre></td></tr></table></figure>
<p>注意，当 Consumer 没有对应的 Provider 时，value 参数会直接取创建 context 时传递给 createContext 的 defaultValue。</p>
<p><strong>从编码角度审视一遍“过时的” Context API 的用法</strong></p>
<p>首先映入眼帘的第一个问题是代码不够优雅：一眼望去，你很难迅速辨别出谁是 Provider、谁是 Consumer。<br>同时这琐碎的属性设置和 API 编写过程，也足够我们写代码的时候“喝一壶了”。<br>总而言之，从编码形态的角度来说，“过时的” Context API 和新 Context API 相去甚远。<br>不过，这还不是最要命的，最要命的弊端我们从编码层面暂时感知不出来，但是一旦你感知到它，麻烦就大了——前面我们特别提到过，“Cosumer 不仅能够读取到 Provider 下发的数据，还能够读取到这些数据后续的更新”。<br>数据在生产者和消费者之间的及时同步，这一点对于 Context 这种模式来说是至关重要的，但旧的 Conext API 无法保证这一点<br>如果组件提供的一个Context发生了变化，而中间父组件的 shouldComponentUpdate 返回 false，那么使用到该值的后代组件不会进行更新。<br>使用了 Context 的组件则完全失控，所以基本上没有办法能够可靠的更新 Context。</p>
<p>新的 Context API 改进了这一点：即便组件的 shouldComponentUpdate 返回 false，它仍然可以“穿透”组件继续向后代组件进行传播，进而确保了数据生产者和数据消费者之间数据的一致性。再加上更加“好看”的语义化的声明式写法，新版 Context API 终于顺利地摘掉了“试验性 API”的帽子，成了一种确实可行的 React 组件间通信解决方案。</p>
<p>对于简单的跨层级组件通信，我们可以使用发布-订阅模式或者 Context API 来搞定。<br>但是随着应用的复杂度不断提升，需要维护的状态越来越多，组件间的关系也越来越难以处理的时候，我们就需要请出 Redux 来帮忙了。<br>Redux 主要由三部分组成：store、reducer 和 action。<br>store 就好比组件群里的“群文件”，它是一个单一的数据源，而且是只读的；<br>action 人如其名，是“动作”的意思，它是对变化的描述。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const action = &#123;</span><br><span class="line"></span><br><span class="line">  type: &quot;ADD_ITEM&quot;,</span><br><span class="line"></span><br><span class="line">  payload: &apos;&lt;li&gt;text&lt;/li&gt;&apos;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>reducer 是一个函数，它负责对变化进行分发和处理， 最终将新的数据返回给 store。<br>对于组件来说，任何组件都可以通过约定的方式从 store 读取到全局的状态，任何组件也都可以通过合理地派发 action 来修改全局的状态。<br>Redux 通过提供一个统一的状态容器，使得数据能够自由而有序地在任意组件之间穿梭，这就是 Redux 实现组件间通信的思路。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 引入 redux</span><br><span class="line"></span><br><span class="line">import &#123; createStore &#125; from &apos;redux&apos;</span><br><span class="line"></span><br><span class="line">// 创建 store</span><br><span class="line"></span><br><span class="line">const store = createStore(</span><br><span class="line"></span><br><span class="line">    reducer,</span><br><span class="line"></span><br><span class="line">    initial_state,</span><br><span class="line"></span><br><span class="line">    applyMiddleware(middleware1, middleware2, ...)</span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>reducer 的作用是将新的 state 返回给 store<br>一个 reducer 一定是一个纯函数，它可以有各种各样的内在逻辑，但它最终一定要返回一个 state<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const reducer = (state, action) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    // 此处是各种样的 state处理逻辑</span><br><span class="line"></span><br><span class="line">    return new_state</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当我们基于某个 reducer 去创建 store 的时候，其实就是给这个 store 指定了一套更新规则<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 更新规则全都写在 reducer 里 </span><br><span class="line"></span><br><span class="line">const store = createStore(reducer)</span><br></pre></td></tr></table></figure></p>
<p>action 本身只是一个对象，要想让 reducer 感知到 action，还需要“派发 action”这个动作，这个动作是由 store.dispatch 完成的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createStore &#125; from &apos;redux&apos;</span><br><span class="line"></span><br><span class="line">// 创建 reducer</span><br><span class="line"></span><br><span class="line">const reducer = (state, action) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    // 此处是各种样的 state处理逻辑</span><br><span class="line"></span><br><span class="line">    return new_state</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 基于 reducer 创建 state</span><br><span class="line"></span><br><span class="line">const store = createStore(reducer)</span><br><span class="line"></span><br><span class="line">// 创建一个 action，这个 action 用 “ADD_ITEM” 来标识 </span><br><span class="line"></span><br><span class="line">const action = &#123;</span><br><span class="line"></span><br><span class="line">  type: &quot;ADD_ITEM&quot;,</span><br><span class="line"></span><br><span class="line">  payload: &apos;&lt;li&gt;text&lt;/li&gt;&apos;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用 dispatch 派发 action，action 会进入到 reducer 里触发对应的更新</span><br><span class="line"></span><br><span class="line">store.dispatch(action)</span><br></pre></td></tr></table></figure></p>
<h3 id="React-Hooks-设计动机与工作模式（上）"><a href="#React-Hooks-设计动机与工作模式（上）" class="headerlink" title="React-Hooks 设计动机与工作模式（上）"></a>React-Hooks 设计动机与工作模式（上）</h3><p><strong>何谓类组件（Class Component）</strong></p>
<p>所谓类组件，就是基于 ES6 Class 这种写法，通过继承 React.Component 得来的 React 组件。以下是一个典型的类组件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">class DemoClass extends React.Component &#123;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  // 初始化类组件的 state</span><br><span class="line"></span><br><span class="line">  state = &#123;</span><br><span class="line"></span><br><span class="line">    text: &quot;&quot;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  // 编写生命周期方法 didMount</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line"></span><br><span class="line">    // 省略业务逻辑</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 编写自定义的实例方法</span><br><span class="line"></span><br><span class="line">  changeText = (newText) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    // 更新 state</span><br><span class="line"></span><br><span class="line">    this.setState(&#123;</span><br><span class="line"></span><br><span class="line">      text: newText</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  // 编写生命周期方法 render</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line"></span><br><span class="line">      &lt;div className=&quot;demoClass&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;p&gt;&#123;this.state.text&#125;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">        &lt;button onClick=&#123;this.changeText&#125;&gt;点我修改&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">      &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>何谓函数组件/无状态组件（Function Component/Stateless Component）</strong></p>
<p>函数组件顾名思义，就是以函数的形态存在的 React 组件。早期并没有 React-Hooks 的加持，函数组件内部无法定义和维护 state，因此它还有一个别名叫“无状态组件”。以下是一个典型的函数组件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function DemoFunction(props) &#123;</span><br><span class="line"></span><br><span class="line">  const &#123; text &#125; = props</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line"></span><br><span class="line">    &lt;div className=&quot;demoFunction&quot;&gt;</span><br><span class="line"></span><br><span class="line">      &lt;p&gt;&#123;`function 组件所接收到的来自外界的文本内容是：[$&#123;text&#125;]`&#125;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数组件会捕获 render 内部的状态，这是两类组件最大的不同。</p>
<p>类组件和函数组件之间，是面向对象和函数式编程这两套不同的设计思想之间的差异。<br>说得更具体一点，函数组件更加契合 React 框架的设计理念。</p>
<p>Hooks 的本质：一套能够使函数组件更强大、更灵活的“钩子”</p>
<h3 id="React-Hooks-设计动机与工作模式（下）"><a href="#React-Hooks-设计动机与工作模式（下）" class="headerlink" title="React-Hooks 设计动机与工作模式（下）"></a>React-Hooks 设计动机与工作模式（下）</h3><p>函数组件相比于类组件来说，最显著的差异就是 state 和生命周期的缺失。useState 为函数组件引入了 state，而 useEffect 则在一定程度上弥补了生命周期的缺席。</p>
<p>每一次渲染后都执行的副作用：传入回调函数，不传依赖数组。调用形式如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useEffect(callBack)</span><br></pre></td></tr></table></figure></p>
<p>仅在挂载阶段执行一次的副作用：传入回调函数，且这个函数的返回值不是一个函数，同时传入一个空数组。调用形式如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">useEffect(()=&gt;&#123;</span><br><span class="line"></span><br><span class="line">  // 这里是业务逻辑 </span><br><span class="line"></span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure></p>
<p>仅在挂载阶段和卸载阶段执行的副作用：传入回调函数，且这个函数的返回值是一个函数，同时传入一个空数组。假如回调函数本身记为 A， 返回的函数记为 B，那么将在挂载阶段执行 A，卸载阶段执行 B。调用形式如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">useEffect(()=&gt;&#123;</span><br><span class="line"></span><br><span class="line">  // 这里是 A 的业务逻辑</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 返回一个函数记为 B</span><br><span class="line"></span><br><span class="line">  return ()=&gt;&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;, [])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这里需要注意，这种调用方式之所以会在卸载阶段去触发 B 函数的逻辑，是由 useEffect 的执行规则决定的：useEffect 回调中返回的函数被称为“清除函数”，当 React 识别到清除函数时，会在调用新的 effect 逻辑之前执行清除函数内部的逻辑。这个规律不会受第二个参数或者其他因素的影响，只要你在 useEffect 回调中返回了一个函数，它就会被作为清除函数来处理。</span><br></pre></td></tr></table></figure></p>
<p>每一次渲染都触发，且卸载阶段也会被触发的副作用：传入回调函数，且这个函数的返回值是一个函数，同时不传第二个参数。如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">useEffect(()=&gt;&#123;</span><br><span class="line"></span><br><span class="line">  // 这里是 A 的业务逻辑</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 返回一个函数记为 B</span><br><span class="line"></span><br><span class="line">  return ()=&gt;&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">上面这段代码就会使得 React 在每一次渲染都去触发 A 逻辑，并且在下一次 A 逻辑被触发之前去触发 B 逻辑。</span><br><span class="line"></span><br><span class="line">其实你只要记住，如果你有一段 effect 逻辑，需要在每次调用它之前对上一次的 effect 进行清理，那么把对应的清理逻辑写进 useEffect 回调的返回函数（上面示例中的 B 函数）里就行了。</span><br></pre></td></tr></table></figure></p>
<p>根据一定的依赖条件来触发的副作用：传入回调函数，同时传入一个非空的数组，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">useEffect(()=&gt;&#123;</span><br><span class="line"></span><br><span class="line">  // 这是回调函数的业务逻辑 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 若 xxx 是一个函数，则 xxx 会在组件每次因 num1、num2、num3 的改变而重新渲染时被触发</span><br><span class="line"></span><br><span class="line">  return xxx</span><br><span class="line"></span><br><span class="line">&#125;, [num1, num2, num3])</span><br></pre></td></tr></table></figure></p>
<p><strong>为什么需要 React-Hooks</strong></p>
<ul>
<li>告别难以理解的 Class；</li>
<li>解决业务逻辑难以拆分的问题；</li>
<li>使状态逻辑复用变得简单可行；</li>
<li>函数组件从设计思想上来看，更加契合 React 的理念。</li>
</ul>
<h2 id="刨根问底吃透“核心原理”"><a href="#刨根问底吃透“核心原理”" class="headerlink" title="刨根问底吃透“核心原理”"></a>刨根问底吃透“核心原理”</h2><h3 id="深入-React-Hooks-工作机制：“原则”的背后，是“原理”"><a href="#深入-React-Hooks-工作机制：“原则”的背后，是“原理”" class="headerlink" title="深入 React-Hooks 工作机制：“原则”的背后，是“原理”"></a>深入 React-Hooks 工作机制：“原则”的背后，是“原理”</h3><p>React 团队面向开发者给出了两条 React-Hooks 的使用原则，原则的内容如下：</p>
<ul>
<li>只在 React 函数中调用 Hook；</li>
<li>不要在循环、条件或嵌套函数中调用 Hook。</li>
</ul>
<p>原则 1 无须多言，React-Hooks 本身就是 React 组件的“钩子”，在普通函数里引入意义不大。我相信更多的人在原则 2 上栽过跟头，或者说至今仍然对它半信半疑。其实，原则 2 中强调的所有“不要”，都是在指向同一个目的，那就是要确保 Hooks 在每次渲染时都保持同样的执行顺序。 </p>
<p><strong>从源码调用流程看原理：Hooks 的正常运作，在底层依赖于顺序链表</strong></p>
<p>以 useState 为例，分析 React-Hooks 的调用链路</p>
<p>useState 触发的一系列操作最后会落到 mountState 里面去，所以我们重点需要关注的就是 mountState 做了什么事情。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">// 进入 mounState 逻辑</span><br><span class="line"></span><br><span class="line">function mountState(initialState) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 将新的 hook 对象追加进链表尾部</span><br><span class="line"></span><br><span class="line">  var hook = mountWorkInProgressHook();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // initialState 可以是一个回调，若是回调，则取回调执行后的值</span><br><span class="line"></span><br><span class="line">  if (typeof initialState === &apos;function&apos;) &#123;</span><br><span class="line"></span><br><span class="line">    // $FlowFixMe: Flow doesn&apos;t like mixed types</span><br><span class="line"></span><br><span class="line">    initialState = initialState();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 创建当前 hook 对象的更新队列，这一步主要是为了能够依序保留 dispatch</span><br><span class="line"></span><br><span class="line">  const queue = hook.queue = &#123;</span><br><span class="line"></span><br><span class="line">    last: null,</span><br><span class="line"></span><br><span class="line">    dispatch: null,</span><br><span class="line"></span><br><span class="line">    lastRenderedReducer: basicStateReducer,</span><br><span class="line"></span><br><span class="line">    lastRenderedState: (initialState: any),</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 将 initialState 作为一个“记忆值”存下来</span><br><span class="line"></span><br><span class="line">  hook.memoizedState = hook.baseState = initialState;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // dispatch 是由上下文中一个叫 dispatchAction 的方法创建的，这里不必纠结这个方法具体做了什么</span><br><span class="line"></span><br><span class="line">  var dispatch = queue.dispatch = dispatchAction.bind(null, currentlyRenderingFiber$1, queue);</span><br><span class="line"></span><br><span class="line">  // 返回目标数组，dispatch 其实就是示例中常常见到的 setXXX 这个函数，想不到吧？哈哈</span><br><span class="line"></span><br><span class="line">  return [hook.memoizedState, dispatch];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从这段源码中我们可以看出，mounState 的主要工作是初始化 Hooks。在整段源码中，最需要关注的是 mountWorkInProgressHook 方法，它为我们道出了 Hooks 背后的数据结构组织形式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">function mountWorkInProgressHook() &#123;</span><br><span class="line"></span><br><span class="line">  // 注意，单个 hook 是以对象的形式存在的</span><br><span class="line"></span><br><span class="line">  var hook = &#123;</span><br><span class="line"></span><br><span class="line">    memoizedState: null,</span><br><span class="line"></span><br><span class="line">    baseState: null,</span><br><span class="line"></span><br><span class="line">    baseQueue: null,</span><br><span class="line"></span><br><span class="line">    queue: null,</span><br><span class="line"></span><br><span class="line">    next: null</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  if (workInProgressHook === null) &#123;</span><br><span class="line"></span><br><span class="line">    // 这行代码每个 React 版本不太一样，但做的都是同一件事：将 hook 作为链表的头节点处理</span><br><span class="line"></span><br><span class="line">    firstWorkInProgressHook = workInProgressHook = hook;</span><br><span class="line"></span><br><span class="line">  &#125; else &#123;</span><br><span class="line"></span><br><span class="line">    // 若链表不为空，则将 hook 追加到链表尾部</span><br><span class="line"></span><br><span class="line">    workInProgressHook = workInProgressHook.next = hook;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 返回当前的 hook</span><br><span class="line"></span><br><span class="line">  return workInProgressHook;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到这里可以看出，hook 相关的所有信息收敛在一个 hook 对象里，而 hook 对象之间以单向链表的形式相互串联。</p>
<p>首次渲染和更新渲染的区别，在于调用的是 mountState，还是 updateState。mountState 做了什么，你已经非常清楚了；而 updateState 之后的操作链路，虽然涉及的代码有很多，但其实做的事情很容易理解：按顺序去遍历之前构建好的链表，取出对应的数据信息进行渲染。</p>
<p>hooks 的渲染是通过“依次遍历”来定位每个 hooks 内容的。如果前后两次读到的链表在顺序上出现差异，那么渲染的结果自然是不可控的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">// isMounted 用于记录是否已挂载（是否是首次渲染）</span><br><span class="line"></span><br><span class="line">let isMounted = false;</span><br><span class="line"></span><br><span class="line">function PersonalInfoComponent() &#123;</span><br><span class="line"></span><br><span class="line">  // 定义变量的逻辑不变</span><br><span class="line"></span><br><span class="line">  let name, age, career, setName, setCareer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 这里追加对 isMounted 的输出，这是一个 debug 性质的操作</span><br><span class="line"></span><br><span class="line">  console.log(&quot;isMounted is&quot;, isMounted);</span><br><span class="line"></span><br><span class="line">  // 这里追加 if 逻辑：只有在首次渲染（组件还未挂载）时，才获取 name、age 两个状态</span><br><span class="line"></span><br><span class="line">  if (!isMounted) &#123;</span><br><span class="line"></span><br><span class="line">    // eslint-disable-next-line</span><br><span class="line"></span><br><span class="line">    [name, setName] = useState(&quot;修言&quot;);</span><br><span class="line"></span><br><span class="line">    // eslint-disable-next-line</span><br><span class="line"></span><br><span class="line">    [age] = useState(&quot;99&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // if 内部的逻辑执行一次后，就将 isMounted 置为 true（说明已挂载，后续都不再是首次渲染了）</span><br><span class="line"></span><br><span class="line">    isMounted = true;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 对职业信息的获取逻辑不变</span><br><span class="line"></span><br><span class="line">  [career, setCareer] = useState(&quot;我是一个前端，爱吃小熊饼干&quot;);</span><br><span class="line"></span><br><span class="line">  // 这里追加对 career 的输出，这也是一个 debug 性质的操作</span><br><span class="line"></span><br><span class="line">  console.log(&quot;career&quot;, career);</span><br><span class="line"></span><br><span class="line">  // UI 逻辑的改动在于，name 和 age 成了可选的展示项，若值为空，则不展示</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line"></span><br><span class="line">    &lt;div className=&quot;personalInfo&quot;&gt;</span><br><span class="line"></span><br><span class="line">      &#123;name ? &lt;p&gt;姓名：&#123;name&#125;&lt;/p&gt; : null&#125;</span><br><span class="line"></span><br><span class="line">      &#123;age ? &lt;p&gt;年龄：&#123;age&#125;&lt;/p&gt; : null&#125;</span><br><span class="line"></span><br><span class="line">      &lt;p&gt;职业：&#123;career&#125;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">      &lt;button</span><br><span class="line"></span><br><span class="line">        onClick=&#123;() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">          setName(&quot;秀妍&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;&#125;</span><br><span class="line"></span><br><span class="line">      &gt;</span><br><span class="line"></span><br><span class="line">        修改姓名</span><br><span class="line"></span><br><span class="line">      &lt;/button&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default PersonalInfoComponent;</span><br></pre></td></tr></table></figure>
<p>从代码里面，我们可以提取出来的 useState 调用有三个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[name, setName] = useState(&quot;修言&quot;);</span><br><span class="line"></span><br><span class="line">[age] = useState(&quot;99&quot;);</span><br><span class="line"></span><br><span class="line">[career, setCareer] = useState(&quot;我是一个前端，爱吃小熊饼干&quot;);</span><br></pre></td></tr></table></figure></p>
<p>当首次渲染结束，进行二次渲染的时候，实际发生的 useState 调用只有一个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useState(&quot;我是一个前端，爱吃小熊饼干&quot;)</span><br></pre></td></tr></table></figure></p>
<p>updateState 会依次遍历链表、读取数据并渲染。注意这个过程就像从数组中依次取值一样，是完全按照顺序（或者说索引）来的。因此 React 不会看你命名的变量名是 career 还是别的什么，它只认你这一次 useState 调用，于是它难免会认为：喔，原来你想要的是第一个位置的 hook 啊。</p>
<p>如此一来，career 就自然而然地取到了链表头节点 hook 对象中的“秀妍”这个值。</p>
<h3 id="真正理解虚拟-DOM：React-选它，真的是为了性能吗？"><a href="#真正理解虚拟-DOM：React-选它，真的是为了性能吗？" class="headerlink" title="真正理解虚拟 DOM：React 选它，真的是为了性能吗？"></a>真正理解虚拟 DOM：React 选它，真的是为了性能吗？</h3><p> 虚拟 DOM（Virtual DOM）本质上是JS 和 DOM 之间的一个映射缓存，它在形态上表现为一个能够描述 DOM 结构及其属性信息的 JS 对象。</p>
<p>挂载阶段，React 将结合 JSX 的描述，构建出虚拟 DOM 树，然后通过 ReactDOM.render 实现虚拟 DOM 到真实 DOM 的映射（触发渲染流水线）；</p>
<p>更新阶段，页面的变化在作用于真实 DOM 之前，会先作用于虚拟 DOM，虚拟 DOM 将在 JS 层借助算法先对比出具体有哪些真实 DOM 需要被改变，然后再将这些改变作用于真实 DOM。</p>
<p>当 DOM 操作（渲染更新）比较频繁时，它会先将前后两次的虚拟 DOM 树进行对比，定位出具体需要更新的部分，生成一个“补丁集”，最后只把“补丁”打在需要更新的那部分真实 DOM 上，实现精准的“差量更新”。</p>
<p>JSX 本质不是模板，而是一种使用体验和模板相似的 JS 语法糖。</p>
<p>虚拟 DOM 并不一定会带来更好的性能，React 官方也从来没有把虚拟 DOM 作为性能层面的卖点对外输出过。虚拟 DOM 的优越之处在于，它能够在提供更爽、更高效的研发模式（也就是函数式的 UI 编程方式）的同时，仍然保持一个还不错的性能。</p>
<hr>
<p>模板渲染动态生成 HTML 字符串的过程本质是对字符串的拼接，对性能的消耗是有限的；而虚拟 DOM 的构建和 diff 过程逻辑则相对复杂，它不可避免地涉及递归、遍历等耗时操作。因此在 JS 行为这个层面，模板渲染胜出。</p>
<p>模板渲染是全量更新，而虚拟 DOM 是差量更新。</p>
<p>乍一看好像差量更新一定比全量更新高效，但你需要考虑这样一种情况：数据内容变化非常大（或者说整个发生了改变），促使差量更新计算出来的结果和全量更新极为接近（或者说完全一样）。</p>
<p>在这种情况下，DOM 更新的工作量基本一致，而虚拟 DOM 却伴随着开销更大的 JS 计算，此时会出现的一种现象就是模板渲染和虚拟 DOM 在整体性能上难分伯仲：若两者最终计算出的 DOM 更新内容完全一致，那么虚拟 DOM 大概率不敌模板渲染；但只要两者在最终 DOM 操作量上拉开那么一点点的差距，虚拟 DOM 就将具备战胜模板渲染的底气。因为虚拟 DOM 的劣势主要在于 JS 计算的耗时，而 DOM 操作的能耗和 JS 计算的能耗根本不在一个量级，极少量的 DOM 操作耗费的性能足以支撑大量的 JS 计算。</p>
<p>在实际的开发中，更加高频的场景是这样的：我每次 setState 的时候只修改少量的数据，比如一个对象中的某几个属性，再比如一个数组中的某几个元素。在这样的场景下，模板渲染和虚拟 DOM 之间 DOM 操作量级的差距就完全拉开了，虚拟 DOM 将在性能上具备绝对的优势。</p>
<hr>
<p>虚拟 DOM 的价值不在性能，而在别处。</p>
<p>那么虚拟 DOM 的价值到底是什么呢？</p>
<p>虚拟 DOM 解决的关键问题有以下两个。</p>
<ul>
<li>研发体验/研发效率的问题：这一点前面已经反复强调过，DOM 操作模式的每一次革新，背后都是前端对效率和体验的进一步追求。虚拟 DOM 的出现，为数据驱动视图这一思想提供了高度可用的载体，使得前端开发能够基于函数式 UI 的编程方式实现高效的声明式编程。</li>
<li>跨平台的问题：虚拟 DOM 是对真实渲染内容的一层抽象。若没有这一层抽象，那么视图层将和渲染平台紧密耦合在一起，为了描述同样的视图内容，你可能要分别在 Web 端和 Native 端写完全不同的两套甚至多套代码。但现在中间多了一层描述性的虚拟 DOM，它描述的东西可以是真实 DOM，也可以是iOS 界面、安卓界面、小程序……同一套虚拟 DOM，可以对接不同平台的渲染逻辑，从而实现“一次编码，多端运行”，如下图所示。其实说到底，跨平台也是研发提效的一种手段。</li>
</ul>
<hr>
<p>除了差量更新以外，“批量更新”也是虚拟 DOM 在性能方面所做的一个重要努力</p>
<p>在差量更新速度非常快的情况下（比如极短的时间里多次操作同一个 DOM），用户实际上只能看到最后一次更新的效果。这种场景下，前面几次的更新动作虽然意义不大，但都会触发重渲染流程，带来大量不必要的高耗能操作。  </p>
<p>这时就需要请 batch 来帮忙了，batch 的作用是缓冲每次生成的补丁集，它会把收集到的多个补丁集暂存到队列中，再将最终的结果交给渲染函数，最终实现集中化的 DOM 批量更新。</p>
<h3 id="React-中的“栈调和”（Stack-Reconciler）过程是怎样的？"><a href="#React-中的“栈调和”（Stack-Reconciler）过程是怎样的？" class="headerlink" title="React 中的“栈调和”（Stack Reconciler）过程是怎样的？"></a>React 中的“栈调和”（Stack Reconciler）过程是怎样的？</h3><p>Virtual DOM 是一种编程概念。在这个概念里，UI 以一种理想化的，或者说“虚拟的”表现形式被保存于内存中，并通过如 ReactDOM 等类库使之与“真实的” DOM 同步。这一过程叫作协调（调和）。</p>
<p>调和指的是将虚拟 DOM映射到真实 DOM 的过程。因此严格来说，调和过程并不能和 Diff 画等号。调和是“使一致”的过程，而 Diff 是“找不同”的过程，它只是“使一致”过程中的一个环节。</p>
<p>React 从大的板块上将源码划分为了 Core、Renderer 和 Reconciler 三部分。调和器所做的工作是一系列的，包括组件的挂载、卸载、更新等过程，其中更新过程涉及对 Diff 算法的调用。</p>
<p>所以说调和 !== Diff这个结论，是站得住脚的，如果你持有这个观点，说明你很专业，为你点赞！</p>
<p>但是！在如今大众的认知里，当我们讨论调和的时候，其实就是在讨论 Diff。</p>
<p>这样的认知也有其合理性，因为Diff 确实是调和过程中最具代表性的一环：根据 Diff 实现形式的不同，调和过程被划分为了以 React 15 为代表的“栈调和”以及 React 16 以来的“Fiber 调和”。在实际的面试过程中，当面试官抛出 Reconciliation 相关问题时，也多半是为了了解候选人对 Diff 的掌握程度。</p>
<hr>
<p>Diff 策略的设计思想</p>
<p>Diff 算法其实就是“找不同”的过程。在计算机科学领域，要想找出两个树结构之间的不同, 传统的计算方法是通过循环递归进行树节点的一一对比,  这个过程的算法复杂度是 O (n³) 。尽管这个算法本身已经是几代程序员持续优化的结果，但对计算能力有限的浏览器来说，O (n³) 仍然意味着一场性能灾难。</p>
<p>具体来说，若一张页面中有 100 个节点（这样的情况在实际开发中并不少见），1003 算下来就有十万次操作了，这还只是一次 Diff 的开销；若应用规模更大一点，维护 1000 个节点，那么操作次数将会直接攀升到 10 亿的量级。</p>
<ul>
<li>若两个组件属于同一个类型，那么它们将拥有相同的 DOM 树形结构；</li>
<li>处于同一层级的一组子节点，可用通过设置 key 作为唯一标识，从而维持各个节点在不同渲染过程中的稳定性。</li>
</ul>
<p>除了这两个“板上钉钉”的规律之外，还有一个和实践结合比较紧密的规律，它为 React 实现高效的 Diff 提供了灵感：DOM 节点之间的跨层级操作并不多，同层级操作是主流。</p>
<ul>
<li>Diff 算法性能突破的关键点在于“分层对比”；</li>
<li>类型一致的节点才有继续 Diff 的必要性；</li>
<li>key 属性的设置，可以帮我们尽可能重用同一层级内的节点。</li>
</ul>
<hr>
<p>结合“DOM 节点之间的跨层级操作并不多，同层级操作是主流”这一规律，React 的 Diff 过程直接放弃了跨层级的节点比较，它只针对相同层级的节点作对比。</p>
<p>需要注意的是：虽然栈调和将传统的树对比算法优化为了分层对比，但整个算法仍然是以递归的形式运转的，分层递归也是递归。</p>
<p>销毁 + 重建的代价是昂贵的，因此 React 官方也建议开发者不要做跨层级的操作，尽量保持 DOM 结构的稳定性。</p>
<hr>
<p>结合“若两个组件属于同一个类型，那么它们将拥有相同的 DOM 树形结构”这一规律，我们虽不能直接反推出“不同类型的组件 DOM 结构不同”，但在大部分的情况下，这个结论都是成立的。毕竟，实际开发中遇到两个 DOM 结构完全一致、而类型不一致的组件的概率确实太低了。</p>
<p>React 认为，只有同类型的组件，才有进一步对比的必要性；若参与 Diff 的两个组件类型不同，那么直接放弃比较，原地替换掉旧的节点</p>
<hr>
<p>key 是用来帮助 React 识别哪些内容被更改、添加或者删除。key 需要写在用数组渲染出来的元素内部，并且需要赋予其一个稳定的值。稳定在这里很重要，因为如果 key 值发生了变更，React 则会触发 UI 的重渲染。这是一个非常有用的特性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   A</span><br><span class="line"> / | \    </span><br><span class="line">B  D  E     </span><br><span class="line"></span><br><span class="line">    A</span><br><span class="line"> / / \ \</span><br><span class="line">B  c  D  E</span><br></pre></td></tr></table></figure></p>
<p>图中 A 组件在保持类型和其他属性均不变的情况下，在两个子节点（B 和 D）之间插入了一个新的节点（C）。按照已知的 Diff 原则，两棵树之间的 Diff 过程应该是这样的：</p>
<ul>
<li>首先对比位于第 1 层的节点，发现两棵树的节点类型是一致的（都是 A），于是进一步 Diff；</li>
<li>开始对比位于第 2 层的节点，第 1 个接受比较的是 B 这个位置，对比下来发现两棵树这个位置上的节点都是 B，没毛病，放过它；</li>
<li>第 2 个接受比较的是 D 这个位置，对比 D 和 C，发现前后的类型不一致，直接删掉 D 重建 C；</li>
<li>第 3 个接受比较的是 E 这个位置，对比 E 和 D，发现前后的类型不一致，直接删掉 E 重建 D；</li>
<li>最后接受“比较”的是树 2 的 E 节点这个位置，这个位置在树 1 里是空的，也就是说树 2 的E 是一个新增节点，所以新增一个 E。</li>
</ul>
<p>你看你看，奇怪的事情发生了：C、D、E 三个节点，其实都是可以直接拿来用的。原本新增 1 个节点就能搞定的事情，现在却又是删除又是重建地搞了半天，这也太蠢了吧？而且这个蠢操作和跨层级移动节点还不太一样，后者本来就属于低频操作，加以合理的最佳实践约束一下基本上可以完全规避掉；但图示的这种插入节点的形式，可是实打实的高频操作，你怎么躲也躲不过的。频繁增删节点必定拖垮性能，这时候就需要请出 key 属性来帮我们重用节点了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const todoItems = todos.map((todo) =&gt;</span><br><span class="line"></span><br><span class="line">  &lt;li key=&#123;todo.id&#125;&gt;</span><br><span class="line"></span><br><span class="line">    &#123;todo.text&#125;</span><br><span class="line"></span><br><span class="line">  &lt;/li&gt;</span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   A</span><br><span class="line"> / | \    </span><br><span class="line">B  D  E     </span><br><span class="line">0  1  2</span><br><span class="line"></span><br><span class="line">    A</span><br><span class="line"> / / \ \</span><br><span class="line">B  c  D  E</span><br><span class="line">0  3  1  2</span><br></pre></td></tr></table></figure>
<p>这个 key 就充当了每个节点的 ID（唯一标识），有了这个标识之后，当 C 被插入到 B 和 D 之间时，React 并不会再认为 C、D、E 这三个坑位都需要被重建——它会通过识别 ID，意识到 D 和 E 并没有发生变化（D 的 ID 仍然是 1，E 的 ID 仍然是 2），而只是被调整了顺序而已。接着，React 便能够轻松地重用它“追踪”到旧的节点，将 D 和 E 转移到新的位置，并完成对 C 的插入。这样一来，同层级下元素的操作成本便大大降低。</p>
<h3 id="setState-到底是同步的，还是异步的？"><a href="#setState-到底是同步的，还是异步的？" class="headerlink" title="setState 到底是同步的，还是异步的？"></a>setState 到底是同步的，还是异步的？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">import &quot;./styles.css&quot;;</span><br><span class="line"></span><br><span class="line">export default class App extends React.Component&#123;</span><br><span class="line"></span><br><span class="line">  state = &#123;</span><br><span class="line"></span><br><span class="line">    count: 0</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  increment = () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    console.log(&apos;increment setState前的count&apos;, this.state.count)</span><br><span class="line"></span><br><span class="line">    this.setState(&#123;</span><br><span class="line"></span><br><span class="line">      count: this.state.count + 1</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    console.log(&apos;increment setState后的count&apos;, this.state.count)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  triple = () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    console.log(&apos;triple setState前的count&apos;, this.state.count)</span><br><span class="line"></span><br><span class="line">    this.setState(&#123;</span><br><span class="line"></span><br><span class="line">      count: this.state.count + 1</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    this.setState(&#123;</span><br><span class="line"></span><br><span class="line">      count: this.state.count + 1</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    this.setState(&#123;</span><br><span class="line"></span><br><span class="line">      count: this.state.count + 1</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    console.log(&apos;triple setState后的count&apos;, this.state.count)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  reduce = () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">      console.log(&apos;reduce setState前的count&apos;, this.state.count)</span><br><span class="line"></span><br><span class="line">      this.setState(&#123;</span><br><span class="line"></span><br><span class="line">        count: this.state.count - 1</span><br><span class="line"></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      console.log(&apos;reduce setState后的count&apos;, this.state.count)</span><br><span class="line"></span><br><span class="line">    &#125;,0);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render()&#123;</span><br><span class="line"></span><br><span class="line">    return &lt;div&gt;</span><br><span class="line"></span><br><span class="line">      &lt;button onClick=&#123;this.increment&#125;&gt;点我增加&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">      &lt;button onClick=&#123;this.triple&#125;&gt;点我增加三倍&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">      &lt;button onClick=&#123;this.reduce&#125;&gt;点我减少&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>一个完整的更新流程，涉及了包括 re-render（重渲染） 在内的多个步骤。re-render 本身涉及对 DOM 的操作，它会带来较大的性能开销。假如说“一次 setState 就触发一个完整的更新流程”这个结论成立，那么每一次 setState 的调用都会触发一次 re-render，我们的视图很可能没刷新几次就卡死了。</p>
<p>在实际的 React 运行时中，setState 异步的实现方式有点类似于 Vue 的 $nextTick 和浏览器里的 Event-Loop：每来一个 setState，就把它塞进一个队列里“攒起来”。等时机成熟，再把“攒起来”的 state 结果做合并，最后只针对最新的 state 值走一次更新流程。这个过程，叫作“批量更新”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">this.setState(&#123;</span><br><span class="line"></span><br><span class="line">  count: this.state.count + 1    ===&gt;    入队，[count+1的任务]</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">this.setState(&#123;</span><br><span class="line"></span><br><span class="line">  count: this.state.count + 1    ===&gt;    入队，[count+1的任务，count+1的任务]</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">this.setState(&#123;</span><br><span class="line"></span><br><span class="line">  count: this.state.count + 1    ===&gt;    入队, [count+1的任务，count+1的任务, count+1的任务]</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">                                          ↓</span><br><span class="line"></span><br><span class="line">                                         合并 state，[count+1的任务]</span><br><span class="line"></span><br><span class="line">                                          ↓</span><br><span class="line"></span><br><span class="line">                                         执行 count+1的任务</span><br></pre></td></tr></table></figure></p>
<p>值得注意的是，只要我们的同步代码还在执行，“攒起来”这个动作就不会停止。（注：这里之所以多次 +1 最终只有一次生效，是因为在同一个方法中多次 setState 的合并动作不是单纯地将更新累加。比如这里对于相同属性的设置，React 只会为其保留最后一次的更新）。因此就算我们在 React 中写了这样一个 100 次的 setState 循环：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">test = () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  console.log(&apos;循环100次 setState前的count&apos;, this.state.count)</span><br><span class="line"></span><br><span class="line">  for(let i=0;i&lt;100;i++) &#123;</span><br><span class="line"></span><br><span class="line">    this.setState(&#123;</span><br><span class="line"></span><br><span class="line">      count: this.state.count + 1</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  console.log(&apos;循环100次 setState后的count&apos;, this.state.count)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure></p>
<p>并不是 setTimeout 改变了 setState，而是 setTimeout 帮助 setState “逃脱”了 React 对它的管控。只要是在 React 管控下的 setState，一定是异步的。</p>
<p>首先是 setState 入口函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ReactComponent.prototype.setState = function (partialState, callback) &#123;</span><br><span class="line"></span><br><span class="line">  this.updater.enqueueSetState(this, partialState);</span><br><span class="line"></span><br><span class="line">  if (callback) &#123;</span><br><span class="line"></span><br><span class="line">    this.updater.enqueueCallback(this, callback, &apos;setState&apos;);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>入口函数在这里就是充当一个分发器的角色，根据入参的不同，将其分发到不同的功能函数中去。这里我们以对象形式的入参为例，可以看到它直接调用了 this.updater.enqueueSetState 这个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">enqueueSetState: function (publicInstance, partialState) &#123;</span><br><span class="line"></span><br><span class="line">  // 根据 this 拿到对应的组件实例</span><br><span class="line"></span><br><span class="line">  var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, &apos;setState&apos;);</span><br><span class="line"></span><br><span class="line">  // 这个 queue 对应的就是一个组件实例的 state 数组</span><br><span class="line"></span><br><span class="line">  var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);</span><br><span class="line"></span><br><span class="line">  queue.push(partialState);</span><br><span class="line"></span><br><span class="line">  //  enqueueUpdate 用来处理当前的组件实例</span><br><span class="line"></span><br><span class="line">  enqueueUpdate(internalInstance);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>enqueueSetState 做了两件事：</p>
<ul>
<li>将新的 state 放进组件的状态队列里；</li>
<li>用 enqueueUpdate 来处理将要更新的实例对象。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function enqueueUpdate(component) &#123;</span><br><span class="line"></span><br><span class="line">  ensureInjected();</span><br><span class="line"></span><br><span class="line">  // 注意这一句是问题的关键，isBatchingUpdates标识着当前是否处于批量创建/更新组件的阶段</span><br><span class="line"></span><br><span class="line">  if (!batchingStrategy.isBatchingUpdates) &#123;</span><br><span class="line"></span><br><span class="line">    // 若当前没有处于批量创建/更新组件的阶段，则立即更新组件</span><br><span class="line"></span><br><span class="line">    batchingStrategy.batchedUpdates(enqueueUpdate, component);</span><br><span class="line"></span><br><span class="line">    return;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 否则，先把组件塞入 dirtyComponents 队列里，让它“再等等”</span><br><span class="line"></span><br><span class="line">  dirtyComponents.push(component);</span><br><span class="line"></span><br><span class="line">  if (component._updateBatchNumber == null) &#123;</span><br><span class="line"></span><br><span class="line">    component._updateBatchNumber = updateBatchNumber + 1;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 enqueueUpdate 非常有嚼头，它引出了一个关键的对象——batchingStrategy，该对象所具备的isBatchingUpdates属性直接决定了当下是要走更新流程，还是应该排队等待；其中的batchedUpdates 方法更是能够直接发起更新流程。由此我们可以大胆推测，batchingStrategy 或许正是 React 内部专门用于管控批量更新的对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"></span><br><span class="line"> * batchingStrategy源码</span><br><span class="line"></span><br><span class="line">**/</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">var ReactDefaultBatchingStrategy = &#123;</span><br><span class="line"></span><br><span class="line">  // 全局唯一的锁标识</span><br><span class="line"></span><br><span class="line">  isBatchingUpdates: false,</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  // 发起更新动作的方法</span><br><span class="line"></span><br><span class="line">  batchedUpdates: function(callback, a, b, c, d, e) &#123;</span><br><span class="line"></span><br><span class="line">    // 缓存锁变量</span><br><span class="line"></span><br><span class="line">    var alreadyBatchingStrategy = ReactDefaultBatchingStrategy. isBatchingUpdates</span><br><span class="line"></span><br><span class="line">    // 把锁“锁上”</span><br><span class="line"></span><br><span class="line">    ReactDefaultBatchingStrategy. isBatchingUpdates = true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    if (alreadyBatchingStrategy) &#123;</span><br><span class="line"></span><br><span class="line">      callback(a, b, c, d, e)</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">      // 启动事务，将 callback 放进事务里执行</span><br><span class="line"></span><br><span class="line">      transaction.perform(callback, null, a, b, c, d, e)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的“锁”，是指 React 全局唯一的 isBatchingUpdates 变量，isBatchingUpdates 的初始值是 false，意味着“当前并未进行任何批量更新操作”。每当 React 调用 batchedUpdate 去执行更新动作时，会先把这个锁给“锁上”（置为 true），表明“现在正处于批量更新过程中”。当锁被“锁上”的时候，任何需要更新的组件都只能暂时进入 dirtyComponents 里排队等候下一次的批量更新，而不能随意“插队”。此处体现的“任务锁”的思想，是 React 面对大量状态仍然能够实现有序分批处理的基石。</p>
<p><strong>理解 React 中的 Transaction（事务） 机制</strong></p>
<p>说白了，Transaction 就像是一个“壳子”，它首先会将目标函数用 wrapper（一组 initialize 及 close 方法称为一个 wrapper） 封装起来，同时需要使用 Transaction 类暴露的 perform 方法去执行它。如上面的注释所示，在 anyMethod 执行之前，perform 会先执行所有 wrapper 的 initialize 方法，执行完后，再执行所有 wrapper 的 close 方法。这就是 React 中的事务机制。</p>
<p>下面结合对事务机制的理解，我们继续来看在 ReactDefaultBatchingStrategy 这个对象。ReactDefaultBatchingStrategy 其实就是一个批量更新策略事务，它的 wrapper 有两个：FLUSH_BATCHED_UPDATES 和 RESET_BATCHED_UPDATES。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var RESET_BATCHED_UPDATES = &#123;</span><br><span class="line"></span><br><span class="line">  initialize: emptyFunction,</span><br><span class="line"></span><br><span class="line">  close: function () &#123;</span><br><span class="line"></span><br><span class="line">    ReactDefaultBatchingStrategy.isBatchingUpdates = false;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var FLUSH_BATCHED_UPDATES = &#123;</span><br><span class="line"></span><br><span class="line">  initialize: emptyFunction,</span><br><span class="line"></span><br><span class="line">  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];</span><br></pre></td></tr></table></figure></p>
<p>在callback执行完成之后,RESET_BATCHED_UPDATES将isBatchingUpdates置为false,FLUSH_BATCHED_UPDATES执行flushBatchedUpdates,然后里面会循环所有dirtyComponent,调用updateComponent来执行所有的生命周期方法(componentWillReceiveProps-&gt;shouldComponentUpdate-&gt;componentWillUpdate-&gt;render-&gt;componentDidUpdate),最后实现组件的更新</p>
<p>到这里，相信你对 isBatchingUpdates 管控下的批量更新机制已经了然于胸。但是 setState 为何会表现同步这个问题，似乎还是没有从当前展示出来的源码里得到根本上的回答。这是因为 batchedUpdates 这个方法，不仅仅会在 setState 之后才被调用。若我们在 React 源码中全局搜索 batchedUpdates，会发现调用它的地方很多，但与更新流有关的只有这两个地方<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// ReactMount.js</span><br><span class="line"></span><br><span class="line">_renderNewRootComponent: function( nextElement, container, shouldReuseMarkup, context ) &#123;</span><br><span class="line"></span><br><span class="line">  // 实例化组件</span><br><span class="line"></span><br><span class="line">  var componentInstance = instantiateReactComponent(nextElement);</span><br><span class="line"></span><br><span class="line">  // 初始渲染直接调用 batchedUpdates 进行同步渲染</span><br><span class="line"></span><br><span class="line">  ReactUpdates.batchedUpdates(</span><br><span class="line"></span><br><span class="line">    batchedMountComponentIntoNode,</span><br><span class="line"></span><br><span class="line">    componentInstance,</span><br><span class="line"></span><br><span class="line">    container,</span><br><span class="line"></span><br><span class="line">    shouldReuseMarkup,</span><br><span class="line"></span><br><span class="line">    context</span><br><span class="line"></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码是在首次渲染组件时会执行的一个方法，我们看到它内部调用了一次 batchedUpdates，这是因为在组件的渲染过程中，会按照顺序调用各个生命周期函数。开发者很有可能在声明周期函数中调用 setState。因此，我们需要通过开启 batch 来确保所有的更新都能够进入 dirtyComponents 里去，进而确保初始渲染流程中所有的 setState 都是生效的。</p>
<p>下面代码是 React 事件系统的一部分。当我们在组件上绑定了事件之后，事件中也有可能会触发 setState。为了确保每一次 setState 都有效，React 同样会在此处手动开启批量更新。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// ReactEventListener.js</span><br><span class="line"></span><br><span class="line">dispatchEvent: function (topLevelType, nativeEvent) &#123;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  try &#123;</span><br><span class="line"></span><br><span class="line">    // 处理事件</span><br><span class="line"></span><br><span class="line">    ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);</span><br><span class="line"></span><br><span class="line">  &#125; finally &#123;</span><br><span class="line"></span><br><span class="line">    TopLevelCallbackBookKeeping.release(bookKeeping);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>话说到这里，一切都变得明朗了起来：isBatchingUpdates 这个变量，在 React 的生命周期函数以及合成事件执行前，已经被 React 悄悄修改为了 true，这时我们所做的 setState 操作自然不会立即生效。当函数执行完毕后，事务的 close 方法会再把 isBatchingUpdates 改为 false。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">increment = () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  // 进来先锁上</span><br><span class="line"></span><br><span class="line">  isBatchingUpdates = true</span><br><span class="line"></span><br><span class="line">  console.log(&apos;increment setState前的count&apos;, this.state.count)</span><br><span class="line"></span><br><span class="line">  this.setState(&#123;</span><br><span class="line"></span><br><span class="line">    count: this.state.count + 1</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  console.log(&apos;increment setState后的count&apos;, this.state.count)</span><br><span class="line"></span><br><span class="line">  // 执行完函数再放开</span><br><span class="line"></span><br><span class="line">  isBatchingUpdates = false</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">reduce = () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  // 进来先锁上</span><br><span class="line"></span><br><span class="line">  isBatchingUpdates = true</span><br><span class="line"></span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    console.log(&apos;reduce setState前的count&apos;, this.state.count)</span><br><span class="line"></span><br><span class="line">    this.setState(&#123;</span><br><span class="line"></span><br><span class="line">      count: this.state.count - 1</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    console.log(&apos;reduce setState后的count&apos;, this.state.count)</span><br><span class="line"></span><br><span class="line">  &#125;,0);</span><br><span class="line"></span><br><span class="line">  // 执行完函数再放开</span><br><span class="line"></span><br><span class="line">  isBatchingUpdates = false</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会发现，咱们开头锁上的那个 isBatchingUpdates，对 setTimeout 内部的执行逻辑完全没有约束力。因为 isBatchingUpdates 是在同步代码中变化的，而 setTimeout 的逻辑是异步执行的。当 this.setState 调用真正发生的时候，isBatchingUpdates 早已经被重置为了 false，这就使得当前场景下的 setState 具备了立刻发起同步更新的能力。所以咱们前面说的没错——setState 并不是具备同步这种特性，只是在特定的情境下，它会从 React 的异步管控中“逃脱”掉。</p>
<hr>
<p>setState 并不是单纯同步/异步的，它的表现会因调用场景的不同而不同：在 React 钩子函数及合成事件中，它表现为异步；而在 setTimeout、setInterval 等函数中，包括在 DOM 原生事件中，它都表现为同步。这种差异，本质上是由 React 事务机制和批量更新机制的工作方式来决定的。</p>
<h3 id="如何理解-Fiber-架构的迭代动机与设计思想？"><a href="#如何理解-Fiber-架构的迭代动机与设计思想？" class="headerlink" title="如何理解 Fiber 架构的迭代动机与设计思想？"></a>如何理解 Fiber 架构的迭代动机与设计思想？</h3><p>对于多线程的浏览器来说，它除了要处理 JavaScript 线程以外，还需要处理包括事件系统、定时器/延时器、网络请求等各种各样的任务线程，这其中，自然也包括负责处理 DOM 的UI 渲染线程。而 JavaScript 线程是可以操作 DOM 的。</p>
<p>JavaScript 线程和渲染线程必须是互斥的：这两个线程不能够穿插执行，必须串行。当其中一个线程执行时，另一个线程只能挂起等待。</p>
<p>具有相似特征的还有事件线程，浏览器的 Event-Loop 机制决定了事件任务是由一个异步队列来维持的。当事件被触发时，对应的任务不会立刻被执行，而是由事件线程把它添加到任务队列的末尾，等待 JavaScript 的同步代码执行完毕后，在空闲的时间里执行出队。</p>
<p>在这样的机制下，若 JavaScript 线程长时间地占用了主线程，那么渲染层面的更新就不得不长时间地等待，界面长时间不更新，带给用户的体验就是所谓的“卡顿”。</p>
<hr>
<p>Stack Reconciler 所带来的一个无解的问题，正是JavaScript 对主线程的超时占用问题。</p>
<p>Stack Reconciler 是一个同步的递归过程。</p>
<p>栈调和机制下的 Diff 算法，其实是树的深度优先遍历的过程。而树的深度优先遍历，总是和递归脱不了关系。</p>
<p>这个过程的致命性在于它是同步的，不可以被打断。当处理结构相对复杂、体量相对庞大的虚拟 DOM 树时，Stack Reconciler 需要的调和时间会很长，这就意味着 JavaScript 线程将长时间地霸占主线程，进而导致我们上文中所描述的渲染卡顿/卡死、交互长时间无响应等问题。</p>
<hr>
<p>Fiber 是一个多义词。从架构角度来看，Fiber 是对 React 核心算法（即调和过程）的重写；从编码角度来看，Fiber 是 React 内部所定义的一种数据结构，它是 Fiber 树结构的节点单位，也就是 React 16 新架构下的“虚拟 DOM”；从工作流的角度来看，Fiber 节点保存了组件需要更新的状态和副作用，一个 Fiber 同时也对应着一个工作单元。</p>
<p>Fiber 架构的应用目的，按照 React 官方的说法，是实现“增量渲染”。所谓“增量渲染”，通俗来说就是把一个渲染任务分解为多个渲染任务，而后将其分散到多个帧里面。不过严格来说，增量渲染其实也只是一种手段，实现增量渲染的目的，是为了实现任务的可中断、可恢复，并给不同的任务赋予不同的优先级，最终达成更加顺滑的用户体验。</p>
<p>Fiber 架构核心：“可中断”“可恢复”与“优先级”</p>
<p>在这套架构模式下，更新的处理工作流变成了这样：首先，每个更新任务都会被赋予一个优先级。当更新任务抵达调度器时，高优先级的更新任务（记为 A）会更快地被调度进 Reconciler 层；此时若有新的更新任务（记为 B）抵达调度器，调度器会检查它的优先级，若发现 B 的优先级高于当前任务 A，那么当前处于 Reconciler 层的 A 任务就会被中断，调度器会将 B 任务推入 Reconciler 层。当 B 任务完成渲染后，新一轮的调度开始，之前被中断的 A 任务将会被重新推入 Reconciler 层，继续它的渲染之旅，这便是所谓“可恢复”。</p>
<hr>
<p><strong>Fiber 架构对生命周期的影响</strong><br>首先我们来看 React 15 中从 render 到 commit 的过程：<br>render开始=&gt;停不下来的递归计算(同步)=&gt;commit提交渲染</p>
<p>而在 React 16 中，render 到 commit 的过程变成了这样:<br>render开始=&gt;工作单元|工作单元|工作单元…(异步)=&gt;commit提交渲染</p>
<p>可以看出，新老两种架构对 React 生命周期的影响主要在 render 这个阶段，这个影响是通过增加 Scheduler 层和改写 Reconciler 层来实现的。</p>
<p>在 render 阶段，一个庞大的更新任务被分解为了一个个的工作单元，这些工作单元有着不同的优先级，React 可以根据优先级的高低去实现工作单元的打断和恢复。由于 render 阶段的操作对用户来说其实是“不可见”的，所以就算打断再重启，对用户来说也是 0 感知。但是，工作单元（也就是任务）的重启将会伴随着对部分生命周期的重复执行，这些生命周期是：</p>
<ul>
<li>componentWillMount</li>
<li>componentWillUpdate</li>
<li>shouldComponentUpdate</li>
<li>componentWillReceiveProps</li>
</ul>
<h3 id="ReactDOM-render-是如何串联渲染链路的？（上）"><a href="#ReactDOM-render-是如何串联渲染链路的？（上）" class="headerlink" title="ReactDOM.render 是如何串联渲染链路的？（上）"></a>ReactDOM.render 是如何串联渲染链路的？（上）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">import ReactDOM from &quot;react-dom&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line"></span><br><span class="line">      &lt;div className=&quot;App&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;div className=&quot;container&quot;&gt;</span><br><span class="line"></span><br><span class="line">          &lt;h1&gt;我是标题&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">          &lt;p&gt;我是第一段话&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">          &lt;p&gt;我是第二段话&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">      &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const rootElement = document.getElementById(&quot;root&quot;);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;App /&gt;, rootElement);</span><br></pre></td></tr></table></figure>
<p><strong>拆解 ReactDOM.render 调用栈——初始化阶段</strong></p>
<p>首先是 legacyRenderSubtreeIntoContainer 方法。在 ReactDOM.render 函数体中，以下面代码所示的姿势调用了它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return legacyRenderSubtreeIntoContainer(null, element, container, false, callback);</span><br></pre></td></tr></table></figure>
<p>而 legacyRenderSubtreeIntoContainer 的关键逻辑如下（解析在注释里）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">function legacyRenderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) &#123;</span><br><span class="line"></span><br><span class="line">  // container 对应的是我们传入的真实 DOM 对象</span><br><span class="line"></span><br><span class="line">  var root = container._reactRootContainer;</span><br><span class="line"></span><br><span class="line">  // 初始化 fiberRoot 对象</span><br><span class="line"></span><br><span class="line">  var fiberRoot;</span><br><span class="line"></span><br><span class="line">  // DOM 对象本身不存在 _reactRootContainer 属性，因此 root 为空</span><br><span class="line"></span><br><span class="line">  if (!root) &#123;</span><br><span class="line"></span><br><span class="line">    // 若 root 为空，则初始化 _reactRootContainer，并将其值赋值给 root</span><br><span class="line"></span><br><span class="line">    root = container._reactRootContainer = legacyCreateRootFromDOMContainer(container, forceHydrate);</span><br><span class="line"></span><br><span class="line">    // legacyCreateRootFromDOMContainer 创建出的对象会有一个 _internalRoot 属性，将其赋值给 fiberRoot</span><br><span class="line"></span><br><span class="line">    fiberRoot = root._internalRoot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 这里处理的是 ReactDOM.render 入参中的回调函数，你了解即可</span><br><span class="line"></span><br><span class="line">    if (typeof callback === &apos;function&apos;) &#123;</span><br><span class="line"></span><br><span class="line">      var originalCallback = callback;</span><br><span class="line"></span><br><span class="line">      callback = function () &#123;</span><br><span class="line"></span><br><span class="line">        var instance = getPublicRootInstance(fiberRoot);</span><br><span class="line"></span><br><span class="line">        originalCallback.call(instance);</span><br><span class="line"></span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">    &#125; // Initial mount should not be batched.</span><br><span class="line"></span><br><span class="line">    // 进入 unbatchedUpdates 方法</span><br><span class="line"></span><br><span class="line">    unbatchedUpdates(function () &#123;</span><br><span class="line"></span><br><span class="line">      updateContainer(children, fiberRoot, parentComponent, callback);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  &#125; else &#123;</span><br><span class="line"></span><br><span class="line">    // else 逻辑处理的是非首次渲染的情况（即更新），其逻辑除了跳过了初始化工作，与楼上基本一致</span><br><span class="line"></span><br><span class="line">    fiberRoot = root._internalRoot;</span><br><span class="line"></span><br><span class="line">    if (typeof callback === &apos;function&apos;) &#123;</span><br><span class="line"></span><br><span class="line">      var _originalCallback = callback;</span><br><span class="line"></span><br><span class="line">      callback = function () &#123;</span><br><span class="line"></span><br><span class="line">        var instance = getPublicRootInstance(fiberRoot);</span><br><span class="line"></span><br><span class="line">        _originalCallback.call(instance);</span><br><span class="line"></span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">    &#125; // Update</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    updateContainer(children, fiberRoot, parentComponent, callback);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return getPublicRootInstance(fiberRoot);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我为你总结一下首次渲染过程中 legacyRenderSubtreeIntoContainer 方法的主要逻辑链路：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">调用legacyCreateRootFromDOMContainer创建container._reactRootContainer对象,并赋值给root=&gt;将root上的_internalRoot属性赋值给fiberRoot=&gt;将fiberRoot与方法入参一起,传入updateContainer方法,形成回调=&gt;将updateContainer回调作为参数传入,调用unbatchedUpdates</span><br></pre></td></tr></table></figure>
<p>root 对象（container._reactRootContainer）上有一个 _internalRoot 属性，这个 _internalRoot 也就是 fiberRoot。fiberRoot 的本质是一个 FiberRootNode 对象，其中包含一个 current 属性，该属性同样需要划重点。</p>
<hr>
<p>或许你会对 current 对象包含的海量属性感到陌生和头大，但这并不妨碍你 Get 到“current 对象是一个 FiberNode 实例”这一点，而 FiberNode，正是 Fiber 节点对应的对象类型。current 对象是一个 Fiber 节点，不仅如此，它还是当前 Fiber 树的头部节点。</p>
<hr>
<p>其中，fiberRoot 的关联对象是真实 DOM 的容器节点；而 rootFiber 则作为虚拟 DOM 的根节点存在。这两个节点，将是后续整棵 Fiber 树构建的起点。</p>
<hr>
<p>接下来，fiberRoot 将和 ReactDOM.render 方法的其他入参一起，被传入 updateContainer 方法，从而形成一个回调。这个回调，正是接下来要调用的 unbatchedUpdates 方法的入参。我们一起看看 unbatchedUpdates 做了什么，下面代码是对 unbatchedUpdates 主体逻辑的提取：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">function unbatchedUpdates(fn, a) &#123;</span><br><span class="line"></span><br><span class="line">  // 这里是对上下文的处理，不必纠结</span><br><span class="line"></span><br><span class="line">  var prevExecutionContext = executionContext;</span><br><span class="line"></span><br><span class="line">  executionContext &amp;= ~BatchedContext;</span><br><span class="line"></span><br><span class="line">  executionContext |= LegacyUnbatchedContext;</span><br><span class="line"></span><br><span class="line">  try &#123;</span><br><span class="line"></span><br><span class="line">    // 重点在这里，直接调用了传入的回调函数 fn，对应当前链路中的 updateContainer 方法</span><br><span class="line"></span><br><span class="line">    return fn(a);</span><br><span class="line"></span><br><span class="line">  &#125; finally &#123;</span><br><span class="line"></span><br><span class="line">    // finally 逻辑里是对回调队列的处理，此处不用太关注</span><br><span class="line"></span><br><span class="line">    executionContext = prevExecutionContext;</span><br><span class="line"></span><br><span class="line">    if (executionContext === NoContext) &#123;</span><br><span class="line"></span><br><span class="line">      // Flush the immediate callbacks that were scheduled during this batch</span><br><span class="line"></span><br><span class="line">      resetRenderTimer();</span><br><span class="line"></span><br><span class="line">      flushSyncCallbackQueue();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 unbatchedUpdates 函数体里，当下你只需要 Get 到一个信息：它直接调用了传入的回调 fn。而在当前链路中，fn 是什么呢？fn 是一个针对 updateContainer 的调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">unbatchedUpdates(function () &#123;</span><br><span class="line"></span><br><span class="line">  updateContainer(children, fiberRoot, parentComponent, callback);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>接下来我们很有必要去看看 updateContainer 里面的逻辑。这里我将主体代码提取如下（解析在注释里，如果没有耐心读完可以直接看文字解读）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">function updateContainer(element, container, parentComponent, callback) &#123;</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 这是一个 event 相关的入参，此处不必关注</span><br><span class="line"></span><br><span class="line">  var eventTime = requestEventTime();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 这是一个比较关键的入参，lane 表示优先级</span><br><span class="line"></span><br><span class="line">  var lane = requestUpdateLane(current$1);</span><br><span class="line"></span><br><span class="line">  // 结合 lane（优先级）信息，创建 update 对象，一个 update 对象意味着一个更新</span><br><span class="line"></span><br><span class="line">  var update = createUpdate(eventTime, lane); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // update 的 payload 对应的是一个 React 元素</span><br><span class="line"></span><br><span class="line">  update.payload = &#123;</span><br><span class="line"></span><br><span class="line">    element: element</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 处理 callback，这个 callback 其实就是我们调用 ReactDOM.render 时传入的 callback</span><br><span class="line"></span><br><span class="line">  callback = callback === undefined ? null : callback;</span><br><span class="line"></span><br><span class="line">  if (callback !== null) &#123;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      if (typeof callback !== &apos;function&apos;) &#123;</span><br><span class="line"></span><br><span class="line">        error(&apos;render(...): Expected the last optional `callback` argument to be a &apos; + &apos;function. Instead received: %s.&apos;, callback);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    update.callback = callback;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 将 update 入队</span><br><span class="line"></span><br><span class="line">  enqueueUpdate(current$1, update);</span><br><span class="line"></span><br><span class="line">  // 调度 fiberRoot </span><br><span class="line"></span><br><span class="line">  scheduleUpdateOnFiber(current$1, lane, eventTime);</span><br><span class="line"></span><br><span class="line">  // 返回当前节点（fiberRoot）的优先级</span><br><span class="line"></span><br><span class="line">  return lane;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>updateContainer 的逻辑相对来说丰富了点，但大部分逻辑也是在干杂活，它做的最关键的事情可以总结为三件：</p>
<ul>
<li>请求当前 Fiber 节点的 lane（优先级）；</li>
<li>结合 lane（优先级），创建当前 Fiber 节点的 update 对象，并将其入队；</li>
<li>调度当前节点（rootFiber）。</li>
</ul>
<p>scheduleUpdateOnFiber 函数的任务是调度当前节点的更新。在这个函数中，会处理一系列与优先级、打断操作相关的逻辑。但是在 ReactDOM.render 发起的首次渲染链路中，这些意义都不大，因为这个渲染过程其实是同步的。</p>
<hr>
<p>performSyncWorkOnRoot直译过来就是“执行根节点的同步任务”，这里的“同步”二字需要注意，它明示了接下来即将开启的是一个同步的过程。这也正是为什么在整个渲染链路中，调度（Schedule）动作没有存在感的原因。</p>
<p>performSyncWorkOnRoot 是 render 阶段的起点，render 阶段的任务就是完成 Fiber 树的构建，它是整个渲染链路中最核心的一环。在异步渲染的模式下，render 阶段应该是一个可打断的异步过程</p>
<hr>
<p><strong>同步的 ReactDOM.render，异步的 ReactDOM.createRoot</strong></p>
<p>其实在 React 16，包括近期发布的 React 17 小版本中，React 都有以下 3 种启动方式：</p>
<ul>
<li>legacy 模式：ReactDOM.render(<app>, rootNode)。这是当前 React App 使用的方式，当前没有计划删除本模式，但是这个模式可能不支持这些新功能。</app></li>
<li>ReactDOM.createBlockingRoot(rootNode).render(<app>)。目前正在实验中，作为迁移到 concurrent 模式的第一个步骤。</app></li>
<li>ReactDOM.createRoot(rootNode).render(<app>)。目前在实验中，未来稳定之后，打算作为 React 的默认开发模式，这个模式开启了所有的新功能。</app></li>
</ul>
<p>在这 3 种模式中，我们常用的 ReactDOM.render 对应的是 legacy 模式，它实际触发的仍然是同步的渲染链路。blocking 模式可以理解为 legacy 和 concurrent 之间的一个过渡形态，之所以会有这个模式，是因为 React 官方希望能够提供渐进的迁移策略，帮助我们更加顺滑地过渡到 Concurrent 模式。blocking 在实际应用中是比较低频的一个模式，了解即可。</p>
<p>按照官方的说法，“长远来看，模式的数量会收敛，不用考虑不同的模式，但就目前而言，模式是一项重要的迁移策略，让每个人都能决定自己什么时候迁移，并按照自己的速度进行迁移”。由此可以看出，Concurrent 模式确实是 React 的终极目标，也是其创作团队使用 Fiber 架构重写核心算法的动机所在。</p>
<hr>
<p><strong>拓展：关于异步模式下的首次渲染链路</strong></p>
<p>当下，如果想要开启异步渲染，我们需要调用 ReactDOM.createRoot方法来启动应用。</p>
<p>其实，当前你看到的这个 render 调用链路，和 ReactDOM.render 的调用链路是非常相似的，主要的区别在 scheduleUpdateOnFiber 的这个判断里。</p>
<p>在异步渲染模式下，由于请求到的 lane 不再是 SyncLane（同步优先级），故不会再走到 performSyncWorkOnRoot 这个调用，而是会转而执行 else 中调度相关的逻辑。</p>
<p>这里有个点要给你点出来——React 是如何知道当前处于哪个模式的呢？我们可以以 requestUpdateLane 函数为例，下面是它局部的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function requestUpdateLane(fiber) &#123;</span><br><span class="line"></span><br><span class="line">  // 获取 mode 属性</span><br><span class="line"></span><br><span class="line">  var mode = fiber.mode;</span><br><span class="line"></span><br><span class="line">  // 结合 mode 属性判断当前的</span><br><span class="line"></span><br><span class="line">  if ((mode &amp; BlockingMode) === NoMode) &#123;</span><br><span class="line"></span><br><span class="line">    return SyncLane;</span><br><span class="line"></span><br><span class="line">  &#125; else if ((mode &amp; ConcurrentMode) === NoMode) &#123;</span><br><span class="line"></span><br><span class="line">    return getCurrentPriorityLevel() === ImmediatePriority$1 ? SyncLane : SyncBatchedLane;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">  return lane;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中需要注意 fiber节点上的 mode 属性：React 将会通过修改 mode 属性为不同的值，来标识当前处于哪个渲染模式；在执行过程中，也是通过判断这个属性，来区分不同的渲染模式。</p>
<p>因此不同的渲染模式在挂载阶段的差异，本质上来说并不是工作流的差异（其工作流涉及 初始化 → render → commit 这 3 个步骤），而是 mode 属性的差异。mode 属性决定着这个工作流是一气呵成（同步）的，还是分片执行（异步）的。</p>
<hr>
<p>在 React 16，包括已发布的 React 17 版本中，不管是否是 Concurrent，整个数据结构层面的设计、包括贯穿整个渲染链路的处理逻辑，已经完全用 Fiber 重构了一遍。站在这个角度来看，Fiber 架构在 React 中并不能够和异步渲染画严格的等号，它是一种同时兼容了同步渲染与异步渲染的设计。</p>
<h3 id="ReactDOM-render-是如何串联渲染链路的？（中）"><a href="#ReactDOM-render-是如何串联渲染链路的？（中）" class="headerlink" title="ReactDOM.render 是如何串联渲染链路的？（中）"></a>ReactDOM.render 是如何串联渲染链路的？（中）</h3><p><strong>拆解 ReactDOM.render 调用栈——render 阶段</strong></p>
<p>performSyncWorkOnRoot 标志着 render 阶段的开始，finishSyncRender 标志着 render 阶段的结束。这中间包含了大量的 beginWork、completeWork 调用栈，正是 render 的工作内容。</p>
<p>React 15 下的调和过程是一个递归的过程。而 Fiber 架构下的调和过程，虽然并不是依赖递归来实现的，但在 ReactDOM.render 触发的同步模式下，它仍然是一个深度优先搜索的过程。在这个过程中，beginWork 将创建新的 Fiber 节点，而 completeWork 则负责将 Fiber 节点映射为 DOM 节点。</p>
<hr>
<p><strong>workInProgress 节点的创建</strong></p>
<p>performSyncWorkOnRoot  是 render 阶段的起点，而这个函数最关键的地方在于它调用了 renderRootSync。</p>
<p>紧随其后的是 prepareFreshStack，这里不卖关子，prepareFreshStack 的作用是重置一个新的堆栈环境，其中最需要我们关注的步骤，就是对createWorkInProgress 的调用。以下我对 createWorkInProgress 的主要逻辑进行了提取（解析在注释里）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// 这里入参中的 current 传入的是现有树结构中的 rootFiber 对象</span><br><span class="line"></span><br><span class="line">function createWorkInProgress(current, pendingProps) &#123;</span><br><span class="line"></span><br><span class="line">  var workInProgress = current.alternate;</span><br><span class="line"></span><br><span class="line">  // ReactDOM.render 触发的首屏渲染将进入这个逻辑</span><br><span class="line"></span><br><span class="line">  if (workInProgress === null) &#123;</span><br><span class="line"></span><br><span class="line">    // 这是需要你关注的第一个点，workInProgress 是 createFiber 方法的返回值</span><br><span class="line"></span><br><span class="line">    workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode);</span><br><span class="line"></span><br><span class="line">    workInProgress.elementType = current.elementType;</span><br><span class="line"></span><br><span class="line">    workInProgress.type = current.type;</span><br><span class="line"></span><br><span class="line">    workInProgress.stateNode = current.stateNode;</span><br><span class="line"></span><br><span class="line">    // 这是需要你关注的第二个点，workInProgress 的 alternate 将指向 current</span><br><span class="line"></span><br><span class="line">    workInProgress.alternate = current;</span><br><span class="line"></span><br><span class="line">    // 这是需要你关注的第三个点，current 的 alternate 将反过来指向 workInProgress</span><br><span class="line"></span><br><span class="line">    current.alternate = workInProgress;</span><br><span class="line"></span><br><span class="line">  &#125; else &#123;</span><br><span class="line"></span><br><span class="line">    // else 的逻辑此处先不用关注</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 以下省略大量 workInProgress 对象的属性处理逻辑</span><br><span class="line"></span><br><span class="line">  // 返回 workInProgress 节点</span><br><span class="line"></span><br><span class="line">  return workInProgress;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先要声明的是，该函数中的 current 入参指的是现有树结构中的 rootFiber 对象。</p>
<p>重点如下：</p>
<ul>
<li>createWorkInProgress 将调用 createFiber，workInProgress是 createFiber 方法的返回值；</li>
<li>workInProgress 的 alternate 将指向 current；</li>
<li>current 的 alternate 将反过来指向 workInProgress。</li>
</ul>
<p>理解了这三点，你就会自然而然地想知道 workInProgress 的本体到底是什么样的，也就是createFiber 到底会返回什么。下面我们就看看 createFiber 的逻辑：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var createFiber = function (tag, pendingProps, key, mode) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  return new FiberNode(tag, pendingProps, key, mode);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>代码出奇的简单，但信息却给得很到位 —— createFiber 将创建一个 FiberNode 实例，而 FiberNode，上一讲已经讲过，它正是 Fiber 节点的类型。因此 workInProgress 就是一个 Fiber 节点。不仅如此，细心的你可能还会发现 workInProgress 的创建入参其实来源于 current，如下面代码所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode);</span><br></pre></td></tr></table></figure></p>
<p>实锤了，workInProgress 节点其实就是 current 节点（即 rootFiber）的副本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fiberRoot(FiberRootNode实例)====(current)=====&gt;rootFiber对象(FiberNode实例)&lt;=====(alternate)======&gt;rootFiber对象(FiberNode实例)</span><br></pre></td></tr></table></figure>
<p>完成了这个任务之后，就会进入 workLoopSync 的逻辑。这个 workLoopSync 函数也是个“人狠话不多”的主，它的逻辑同样是简洁明了的，如下所示（解析在注释里）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function workLoopSync() &#123;</span><br><span class="line"></span><br><span class="line">  // 若 workInProgress 不为空</span><br><span class="line"></span><br><span class="line">  while (workInProgress !== null) &#123;</span><br><span class="line"></span><br><span class="line">    // 针对它执行 performUnitOfWork 方法</span><br><span class="line"></span><br><span class="line">    performUnitOfWork(workInProgress);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>workLoopSync 做的事情就是通过 while 循环反复判断 workInProgress 是否为空，并在不为空的情况下针对它执行 performUnitOfWork 函数。</p>
<p>而 performUnitOfWork 函数将触发对 beginWork 的调用，进而实现对新 Fiber 节点的创建。若 beginWork 所创建的 Fiber 节点不为空，则 performUniOfWork 会用这个新的 Fiber 节点来更新 workInProgress 的值，为下一次循环做准备。</p>
<p>通过循环调用 performUnitOfWork 来触发 beginWork，新的 Fiber 节点就会被不断地创建。当 workInProgress 终于为空时，说明没有新的节点可以创建了，也就意味着已经完成对整棵 Fiber 树的构建。</p>
<p>在这个过程中，每一个被创建出来的新 Fiber 节点，都会一个一个挂载为最初那个 workInProgress 节点的后代节点。</p>
<hr>
<p><strong>beginWork 开启 Fiber 节点创建过程</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function beginWork(current, workInProgress, renderLanes) &#123;</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  //  current 节点不为空的情况下，会加一道辨识，看看是否有更新逻辑要处理</span><br><span class="line"></span><br><span class="line">  if (current !== null) &#123;</span><br><span class="line"></span><br><span class="line">    // 获取新旧 props</span><br><span class="line"></span><br><span class="line">    var oldProps = current.memoizedProps;</span><br><span class="line"></span><br><span class="line">    var newProps = workInProgress.pendingProps;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 若 props 更新或者上下文改变，则认为需要&quot;接受更新&quot;</span><br><span class="line"></span><br><span class="line">    if (oldProps !== newProps || hasContextChanged() || (</span><br><span class="line"></span><br><span class="line">     workInProgress.type !== current.type )) &#123;</span><br><span class="line"></span><br><span class="line">      // 打个更新标</span><br><span class="line"></span><br><span class="line">      didReceiveUpdate = true;</span><br><span class="line"></span><br><span class="line">    &#125; else if (xxx) &#123;</span><br><span class="line"></span><br><span class="line">      // 不需要更新的情况 A</span><br><span class="line"></span><br><span class="line">      return A</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">      if (需要更新的情况 B) &#123;</span><br><span class="line"></span><br><span class="line">        didReceiveUpdate = true;</span><br><span class="line"></span><br><span class="line">      &#125; else &#123;</span><br><span class="line"></span><br><span class="line">        // 不需要更新的其他情况，这里我们的首次渲染就将执行到这一行的逻辑</span><br><span class="line"></span><br><span class="line">        didReceiveUpdate = false;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125; else &#123;</span><br><span class="line"></span><br><span class="line">    didReceiveUpdate = false;</span><br><span class="line"></span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">  // 这坨 switch 是 beginWork 中的核心逻辑，原有的代码量相当大</span><br><span class="line"></span><br><span class="line">  switch (workInProgress.tag) &#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    // 这里省略掉大量形如&quot;case: xxx&quot;的逻辑</span><br><span class="line"></span><br><span class="line">    // 根节点将进入这个逻辑</span><br><span class="line"></span><br><span class="line">    case HostRoot:</span><br><span class="line"></span><br><span class="line">      return updateHostRoot(current, workInProgress, renderLanes)</span><br><span class="line"></span><br><span class="line">    // dom 标签对应的节点将进入这个逻辑</span><br><span class="line"></span><br><span class="line">    case HostComponent:</span><br><span class="line"></span><br><span class="line">      return updateHostComponent(current, workInProgress, renderLanes)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 文本节点将进入这个逻辑</span><br><span class="line"></span><br><span class="line">    case HostText:</span><br><span class="line"></span><br><span class="line">      return updateHostText(current, workInProgress)</span><br><span class="line"></span><br><span class="line">    ...... </span><br><span class="line"></span><br><span class="line">    // 这里省略掉大量形如&quot;case: xxx&quot;的逻辑</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 这里是错误兜底，处理 switch 匹配不上的情况</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      throw Error(</span><br><span class="line"></span><br><span class="line">        &quot;Unknown unit of work tag (&quot; +</span><br><span class="line"></span><br><span class="line">          workInProgress.tag +</span><br><span class="line"></span><br><span class="line">          &quot;). This error is likely caused by a bug in React. Please file an issue.&quot;</span><br><span class="line"></span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>beginWork 重点总结：</p>
<ul>
<li>beginWork 的入参是一对用 alternate 连接起来的 workInProgress 和 current 节点；</li>
<li>beginWork 的核心逻辑是根据 fiber 节点（workInProgress）的 tag 属性的不同，调用不同的节点创建函数。</li>
</ul>
<p>reconcileChildren 的源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function reconcileChildren(current, workInProgress, nextChildren, renderLanes) &#123;</span><br><span class="line"></span><br><span class="line">  // 判断 current 是否为 null</span><br><span class="line"></span><br><span class="line">  if (current === null) &#123;</span><br><span class="line"></span><br><span class="line">    // 若 current 为 null，则进入 mountChildFibers 的逻辑</span><br><span class="line"></span><br><span class="line">    workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderLanes);</span><br><span class="line"></span><br><span class="line">  &#125; else &#123;</span><br><span class="line"></span><br><span class="line">    // 若 current 不为 null，则进入 reconcileChildFibers 的逻辑</span><br><span class="line"></span><br><span class="line">    workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren, renderLanes);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从源码来看，reconcileChildren 也只是做逻辑的分发，具体的工作还要到 mountChildFibers 和 reconcileChildFibers 里去看。</p>
<p><strong>ChildReconciler，处理 Fiber 节点的幕后“操盘手”</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var reconcileChildFibers = ChildReconciler(true);</span><br><span class="line"></span><br><span class="line">var mountChildFibers = ChildReconciler(false);</span><br></pre></td></tr></table></figure>
<p>原来 reconcileChildFibers 和 mountChildFibers 不仅名字相似，出处也一致。它们都是 ChildReconciler 这个函数的返回值，仅仅存在入参上的区别。而 ChildReconciler，则是一个实打实的“庞然大物”，其内部的逻辑量堪比 N 个 beginWork。这里我将关键要素提取如下（解析在注释里）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">function ChildReconciler(shouldTrackSideEffects) &#123;</span><br><span class="line"></span><br><span class="line">  // 删除节点的逻辑</span><br><span class="line"></span><br><span class="line">  function deleteChild(returnFiber, childToDelete) &#123;</span><br><span class="line"></span><br><span class="line">    if (!shouldTrackSideEffects) &#123;</span><br><span class="line"></span><br><span class="line">      // Noop.</span><br><span class="line"></span><br><span class="line">      return;</span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    // 以下执行删除逻辑</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 单个节点的插入逻辑</span><br><span class="line"></span><br><span class="line">  function placeSingleChild(newFiber) &#123;</span><br><span class="line"></span><br><span class="line">    if (shouldTrackSideEffects &amp;&amp; newFiber.alternate === null) &#123;</span><br><span class="line"></span><br><span class="line">      newFiber.flags = Placement;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return newFiber;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 插入节点的逻辑</span><br><span class="line"></span><br><span class="line">  function placeChild(newFiber, lastPlacedIndex, newIndex) &#123;</span><br><span class="line"></span><br><span class="line">    newFiber.index = newIndex;</span><br><span class="line"></span><br><span class="line">    if (!shouldTrackSideEffects) &#123;</span><br><span class="line"></span><br><span class="line">      // Noop.</span><br><span class="line"></span><br><span class="line">      return lastPlacedIndex;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 以下执行插入逻辑</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">  // 此处省略一系列 updateXXX 的函数，它们用于处理 Fiber 节点的更新</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 处理不止一个子节点的情况</span><br><span class="line"></span><br><span class="line">  function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) &#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 此处省略一堆 reconcileXXXXX 形式的函数，它们负责处理具体的 reconcile 逻辑</span><br><span class="line"></span><br><span class="line">  function reconcileChildFibers(returnFiber, currentFirstChild, newChild, lanes) &#123;</span><br><span class="line"></span><br><span class="line">    // 这是一个逻辑分发器，它读取入参后，会经过一系列的条件判断，调用上方所定义的负责具体节点操作的函数</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 将总的 reconcileChildFibers 函数返回</span><br><span class="line"></span><br><span class="line">  return reconcileChildFibers;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>关键的入参 shouldTrackSideEffects，意为“是否需要追踪副作用”，因此 reconcileChildFibers 和 mountChildFibers 的不同，在于对副作用的处理不同；</li>
<li>ChildReconciler 中定义了大量如 placeXXX、deleteXXX、updateXXX、reconcileXXX 等这样的函数，这些函数覆盖了对 Fiber 节点的创建、增加、删除、修改等动作，将直接或间接地被 reconcileChildFibers 所调用；</li>
<li>ChildReconciler 的返回值是一个名为 reconcileChildFibers 的函数，这个函数是一个逻辑分发器，它将根据入参的不同，执行不同的 Fiber 节点操作，最终返回不同的目标 Fiber 节点。</li>
</ul>
<p>对于第 1 点，这里展开说说。对副作用的处理不同，到底是哪里不同？以 placeSingleChild 为例，以下是 placeSingleChild 的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function placeSingleChild(newFiber) &#123;</span><br><span class="line"></span><br><span class="line">  if (shouldTrackSideEffects &amp;&amp; newFiber.alternate === null) &#123;</span><br><span class="line"></span><br><span class="line">    newFiber.flags = Placement;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return newFiber;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，一旦判断 shouldTrackSideEffects 为 false，那么下面所有的逻辑都不执行了，直接返回。那如果执行下去会发生什么呢？简而言之就是给 Fiber 节点打上一个叫“flags”的标记，像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newFiber.flags = Placement;</span><br></pre></td></tr></table></figure>
<p><strong>小科普：flags 是什么</strong></p>
<p>由于这里我引用的是 v17.0.0 版本的源码，属性名已经变更为 flags，但在更早一些的版本中，这个属性名叫“effectTag”。在时下的社区讨论中，effectTag 这个命名更常见，也更语义化，因此下文我将以 “effectTag”代指“flags”。</p>
<p>Placement 这个 effectTag 的意义，是在渲染器执行时，也就是真实 DOM 渲染时，告诉渲染器：我这里需要新增 DOM 节点。 effectTag 记录的是副作用的类型，而所谓“副作用”，React 给出的定义是“数据获取、订阅或者修改 DOM”等动作。在这里，Placement 对应的显然是 DOM 相关的副作用操作。</p>
<p>像 Placement 这样的副作用标识，还有很多，它们均以二进制常量的形式存在。</p>
<p>rootFiber 作为 Fiber 树的根节点，它并没有一个确切的 ReactElement 与之映射。结合 JSX 结构来看，我们可以将其理解为是 JSX 中根组件的父节点。课时所给出的 Demo 中，组件编码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import React from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">import ReactDOM from &quot;react-dom&quot;;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line"></span><br><span class="line">      &lt;div className=&quot;App&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;div className=&quot;container&quot;&gt;</span><br><span class="line"></span><br><span class="line">          &lt;h1&gt;我是标题&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">          &lt;p&gt;我是第一段话&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">          &lt;p&gt;我是第二段话&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">      &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const rootElement = document.getElementById(&quot;root&quot;);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;App /&gt;, rootElement);</span><br></pre></td></tr></table></figure>
<p>可以看出，根组件是一个类型为 App 的函数组件，因此 rootFiber 就是 App 的父节点。</p>
<hr>
<p><strong>Fiber 树的构建过程</strong></p>
<p>研究节点创建的工作流，我们的切入点是workLoopSync这个函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function workLoopSync() &#123;</span><br><span class="line"></span><br><span class="line">  // 若 workInProgress 不为空</span><br><span class="line"></span><br><span class="line">  while (workInProgress !== null) &#123;</span><br><span class="line"></span><br><span class="line">    // 针对它执行 performUnitOfWork 方法</span><br><span class="line"></span><br><span class="line">    performUnitOfWork(workInProgress);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它会循环地调用 performUnitOfWork，而 performUnitOfWork，开篇我们已经点到过它，其主要工作是“通过调用 beginWork，来实现新 Fiber 节点的创建”；它还有一个次要工作，就是把新创建的这个 Fiber 节点的值更新到 workInProgress 变量里去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 新建 Fiber 节点</span><br><span class="line"></span><br><span class="line">next = beginWork$1(current, unitOfWork, subtreeRenderLanes);</span><br><span class="line"></span><br><span class="line">// 将新的 Fiber 节点赋值给 workInProgress</span><br><span class="line"></span><br><span class="line">if (next === null) &#123;</span><br><span class="line"></span><br><span class="line">  // If this doesn&apos;t spawn new work, complete the current work.</span><br><span class="line"></span><br><span class="line">  completeUnitOfWork(unitOfWork);</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">  workInProgress = next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如此便能够确保每次 performUnitOfWork 执行完毕后，当前的 workInProgress 都存储着下一个需要被处理的节点，从而为下一次的 workLoopSync 循环做好准备。</p>
<p>现在我在 workLoopSync 内部打个断点，尝试输出每一次获取到的 workInProgress 的值，workInProgress 值的变化过程如下</p>
<ul>
<li>rootFiber（当前 Fiber 树的根节点）</li>
<li>App FiberNode（App 函数组件对应的节点）</li>
<li>class 为 App 的 DOM 元素对应的节点</li>
<li>class 为 container 的 DOM 元素对应的节点</li>
<li>h1 标签对应的节点</li>
<li>第 1 个 p 标签对应的 FiberNode，内容为“我是第一段话”</li>
<li>第 2 个 p 标签对应的 FiberNode，内容为“我是第二段话”，</li>
</ul>
<p>结合这 7 个 FiberNode，再对照对照我们的 Demo：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function App() &#123;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line"></span><br><span class="line">      &lt;div className=&quot;App&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;div className=&quot;container&quot;&gt;</span><br><span class="line"></span><br><span class="line">          &lt;h1&gt;我是标题&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">          &lt;p&gt;我是第一段话&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">          &lt;p&gt;我是第二段话&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">      &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你会发现组件自上而下，每一个非文本类型的 ReactElement 都有了它对应的 Fiber 节点。</p>
<hr>
<p><strong>Fiber 节点间是如何连接的呢</strong></p>
<p>不同的 Fiber 节点之间，将通过 child、return、sibling 这 3 个属性建立关系，其中 child、return 记录的是父子节点关系，而 sibling 记录的则是兄弟节点关系。</p>
<p>这里我以 h1 这个元素对应的 Fiber 节点为例，可以看到，return 属性指向的是 class 为 container 的 div 节点，而 sibling 属性指向的是第 1 个 p 节点。结合 JSX 中的嵌套关系我们不难得知 ——FiberNode 实例中，return 指向的是当前 Fiber 节点的父节点，而 sibling 指向的是当前节点的第 1 个兄弟节点。</p>
<hr>
<p>注意，在分析 Fiber 树的构建过程时，我们选取了 beginWork 作为切入点，但整个 Fiber 树的构建过程中，并不是只有 beginWork 在工作。这其中，还穿插着 completeWork 的工作。只有将 completeWork 和 beginWork 放在一起来看，你才能够真正理解，Fiber 架构下的“深度优先遍历”到底是怎么一回事。</p>
<h3 id="ReactDOM-render-是如何串联渲染链路的？（下）"><a href="#ReactDOM-render-是如何串联渲染链路的？（下）" class="headerlink" title="ReactDOM.render 是如何串联渲染链路的？（下）"></a>ReactDOM.render 是如何串联渲染链路的？（下）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">import ReactDOM from &quot;react-dom&quot;;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line"></span><br><span class="line">    &lt;div className=&quot;App&quot;&gt;</span><br><span class="line"></span><br><span class="line">      &lt;div className=&quot;container&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;h1&gt;我是标题&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">        &lt;p&gt;我是第一段话&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">        &lt;p&gt;我是第二段话&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">      &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const rootElement = document.getElementById(&quot;root&quot;);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;App /&gt;, rootElement);</span><br></pre></td></tr></table></figure>
<p>completeUnitOfWork 是在 performUnitOfWork 中被调用的，那么 performUnitOfWork 是如何把握其调用时机的呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">function performUnitOfWork(unitOfWork) &#123;</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">  // 获取入参节点对应的 current 节点</span><br><span class="line"></span><br><span class="line">  var current = unitOfWork.alternate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  var next;</span><br><span class="line"></span><br><span class="line">  if (xxx) &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // 创建当前节点的子节点</span><br><span class="line"></span><br><span class="line">    next = beginWork$1(current, unitOfWork, subtreeRenderLanes);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">  &#125; else &#123;</span><br><span class="line"></span><br><span class="line">    // 创建当前节点的子节点</span><br><span class="line"></span><br><span class="line">    next = beginWork$1(current, unitOfWork, subtreeRenderLanes);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">  if (next === null) &#123;</span><br><span class="line"></span><br><span class="line">    // 调用 completeUnitOfWork</span><br><span class="line"></span><br><span class="line">    completeUnitOfWork(unitOfWork);</span><br><span class="line"></span><br><span class="line">  &#125; else &#123;</span><br><span class="line"></span><br><span class="line">    // 将当前节点更新为新创建出的 Fiber 节点</span><br><span class="line"></span><br><span class="line">    workInProgress = next;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>performUnitOfWork 每次会尝试调用 beginWork 来创建当前节点的子节点，若创建出的子节点为空（也就意味着当前节点不存在子 Fiber 节点），则说明当前节点是一个叶子节点。按照深度优先遍历的原则，当遍历到叶子节点时，“递”阶段就结束了，随之而来的是“归”的过程。因此这种情况下，就会调用 completeUnitOfWork，执行当前节点对应的 completeWork 逻辑。</p>
<p>按照深度优先遍历的原则，h1 确实将是第一个被遍历到的叶子节点。接下来我们就以 h1 为例，一起看看 completeWork 都围绕它做了哪些事情。</p>
<hr>
<p><strong>completeWork 的工作原理</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line">function completeWork(current, workInProgress, renderLanes) &#123;</span><br><span class="line"></span><br><span class="line">  // 取出 Fiber 节点的属性值，存储在 newProps 里</span><br><span class="line"></span><br><span class="line">  var newProps = workInProgress.pendingProps;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 根据 workInProgress 节点的 tag 属性的不同，决定要进入哪段逻辑</span><br><span class="line"></span><br><span class="line">  switch (workInProgress.tag) &#123;</span><br><span class="line"></span><br><span class="line">    case ......:</span><br><span class="line"></span><br><span class="line">      return null;</span><br><span class="line"></span><br><span class="line">    case ClassComponent:</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">        .....</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    case HostRoot:</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    // h1 节点的类型属于 HostComponent，因此这里为你讲解的是这段逻辑</span><br><span class="line"></span><br><span class="line">    case HostComponent:</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">        popHostContext(workInProgress);</span><br><span class="line"></span><br><span class="line">        var rootContainerInstance = getRootHostContainer();</span><br><span class="line"></span><br><span class="line">        var type = workInProgress.type;</span><br><span class="line"></span><br><span class="line">        // 判断 current 节点是否存在，因为目前是挂载阶段，因此 current 节点是不存在的</span><br><span class="line"></span><br><span class="line">        if (current !== null &amp;&amp; workInProgress.stateNode != null) &#123;</span><br><span class="line"></span><br><span class="line">          updateHostComponent$1(current, workInProgress, type, newProps, rootContainerInstance);</span><br><span class="line"></span><br><span class="line">          if (current.ref !== workInProgress.ref) &#123;</span><br><span class="line"></span><br><span class="line">            markRef$1(workInProgress);</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line"></span><br><span class="line">          // 这里首先是针对异常情况进行 return 处理</span><br><span class="line"></span><br><span class="line">          if (!newProps) &#123;</span><br><span class="line"></span><br><span class="line">            if (!(workInProgress.stateNode !== null)) &#123;</span><br><span class="line"></span><br><span class="line">              &#123;</span><br><span class="line"></span><br><span class="line">                throw Error(&quot;We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.&quot;);</span><br><span class="line"></span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">            &#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            return null;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          // 接下来就为 DOM 节点的创建做准备了</span><br><span class="line"></span><br><span class="line">          var currentHostContext = getHostContext();</span><br><span class="line"></span><br><span class="line">          // _wasHydrated 是一个与服务端渲染有关的值，这里不用关注</span><br><span class="line"></span><br><span class="line">          var _wasHydrated = popHydrationState(workInProgress);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          // 判断是否是服务端渲染</span><br><span class="line"></span><br><span class="line">          if (_wasHydrated) &#123;</span><br><span class="line"></span><br><span class="line">            // 这里不用关注，请你关注 else 里面的逻辑</span><br><span class="line"></span><br><span class="line">            if (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, currentHostContext)) &#123;</span><br><span class="line"></span><br><span class="line">              markUpdate(workInProgress);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          &#125; else &#123;</span><br><span class="line"></span><br><span class="line">            // 这一步很关键， createInstance 的作用是创建 DOM 节点</span><br><span class="line"></span><br><span class="line">            var instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress);</span><br><span class="line"></span><br><span class="line">            // appendAllChildren 会尝试把上一步创建好的 DOM 节点挂载到 DOM 树上去</span><br><span class="line"></span><br><span class="line">            appendAllChildren(instance, workInProgress, false, false);</span><br><span class="line"></span><br><span class="line">            // stateNode 用于存储当前 Fiber 节点对应的 DOM 节点</span><br><span class="line"></span><br><span class="line">            workInProgress.stateNode = instance; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            // finalizeInitialChildren 用来为 DOM 节点设置属性</span><br><span class="line"></span><br><span class="line">            if (finalizeInitialChildren(instance, type, newProps, rootContainerInstance)) &#123;</span><br><span class="line"></span><br><span class="line">              markUpdate(workInProgress);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          ......</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    case HostText:</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    case SuspenseComponent:</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    case HostPortal:</span><br><span class="line"></span><br><span class="line">      ......</span><br><span class="line"></span><br><span class="line">      return null;</span><br><span class="line"></span><br><span class="line">    case ContextProvider:</span><br><span class="line"></span><br><span class="line">      ......</span><br><span class="line"></span><br><span class="line">      return null;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      throw Error(&quot;Unknown unit of work tag (&quot; + workInProgress.tag + &quot;). This error is likely caused by a bug in React. Please file an issue.&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>completeWork 的核心逻辑是一段体量巨大的 switch 语句，在这段 switch 语句中，completeWork 将根据 workInProgress 节点的 tag 属性的不同，进入不同的 DOM 节点的创建、处理逻辑。</li>
<li>在 Demo 示例中，h1 节点的 tag 属性对应的类型应该是 HostComponent，也就是“原生 DOM 元素类型”。</li>
<li>completeWork 中的 current、 workInProgress 分别对应 Fiber 树上的节点，其中 workInProgress 树代表的是“当前正在 render 中的树”，而 current 树则代表“已经存在的树”。</li>
</ul>
<p>workInProgress 节点和 current 节点之间用 alternate 属性相互连接。在组件的挂载阶段，current 树只有一个 rootFiber 节点，并没有其他内容。因此 h1 这个 workInProgress 节点对应的 current 节点是 null。</p>
<p>捋顺思路后，我们直接来提取知识点。关于 completeWork，你需要明白以下几件事。</p>
<ul>
<li>用一句话来总结 completeWork 的工作内容：负责处理 Fiber 节点到 DOM 节点的映射逻辑。</li>
<li>completeWork 内部有 3 个关键动作：1.创建DOM 节点（CreateInstance）2.将 DOM 节点插入到 DOM 树中（AppendAllChildren）3.为 DOM 节点设置属性（FinalizeInitialChildren）</li>
<li>创建好的 DOM 节点会被赋值给 workInProgress 节点的 stateNode 属性。也就是说当我们想要定位一个 Fiber 对应的 DOM 节点时，访问它的 stateNode 属性就可以了。</li>
<li>将 DOM 节点插入到 DOM 树的操作是通过 appendAllChildren 函数来完成的。</li>
</ul>
<p>说是将 DOM 节点插入到 DOM 树里去，实际上是将子 Fiber 节点所对应的 DOM 节点挂载到其父 Fiber 节点所对应的 DOM 节点里去。比如说在本讲 Demo 所构建出的 Fiber 树中，h1 节点的父结点是 div，那么 h1 对应的 DOM 节点就理应被挂载到 div 对应的 DOM 节点里去。</p>
<p>那么如果执行 appendAllChildren 时，父级的 DOM 节点还不存在怎么办？</p>
<p>比如 h1 节点作为第一个进入 completeWork 的节点，它的父节点 div 对应的 DOM 就尚不存在。其实不存在也没关系，反正 h1 DOM 节点被创建后，会作为 h1 Fiber 节点的 stateNode 属性存在，丢不掉的。当父节点 div 进入 appendAllChildren 逻辑后，会逐个向下查找并添加自己的后代节点，这时候，h1 就会被它的父级 DOM 节点“收入囊中”啦~</p>
<hr>
<p><strong>completeUnitOfWork —— 开启收集 EffectList 的“大循环”</strong></p>
<ul>
<li>针对传入的当前节点，调用 completeWork，completeWork 的工作内容前面已经讲过，这一步应该是没有异议的；</li>
<li>将当前节点的副作用链（EffectList）插入到其父节点对应的副作用链（EffectList）中；</li>
<li>以当前节点为起点，循环遍历其兄弟节点及其父节点。当遍历到兄弟节点时，将 return 掉当前调用，触发兄弟节点对应的 performUnitOfWork 逻辑；而遍历到父节点时，则会直接进入下一轮循环，也就是重复 1、2 的逻辑。</li>
</ul>
<p>在理解副作用链之前，首先要理解 completeUnitOfWork 开启下一轮循环的原则，也就是步骤 3。步骤 3 相关的源码如下所示（解析在注释里）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">  // 这里省略步骤 1 和步骤 2 的逻辑 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 获取当前节点的兄弟节点</span><br><span class="line"></span><br><span class="line">  var siblingFiber = completedWork.sibling;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 若兄弟节点存在</span><br><span class="line"></span><br><span class="line">  if (siblingFiber !== null) &#123;</span><br><span class="line"></span><br><span class="line">    // 将 workInProgress 赋值为当前节点的兄弟节点</span><br><span class="line"></span><br><span class="line">    workInProgress = siblingFiber;</span><br><span class="line"></span><br><span class="line">    // 将正在进行的 completeUnitOfWork 逻辑 return 掉</span><br><span class="line"></span><br><span class="line">    return;</span><br><span class="line"></span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 若兄弟节点不存在，completeWork 会被赋值为 returnFiber，也就是当前节点的父节点</span><br><span class="line"></span><br><span class="line">  completedWork = returnFiber; </span><br><span class="line"></span><br><span class="line">    // 这一步与上一步是相辅相成的，上下文中要求 workInProgress 与 completedWork 保持一致</span><br><span class="line"></span><br><span class="line">  workInProgress = completedWork;</span><br><span class="line"></span><br><span class="line">&#125; while (completedWork !== null);</span><br></pre></td></tr></table></figure>
<p>步骤 3 是整个循环体的收尾工作，它会在当前节点相关的各种工作都做完之后执行。</p>
<p>当前节点处理完了，自然是去寻找下一个可以处理的节点。我们知道，当前的 Fiber 节点之所以会进入 completeWork，是因为“递无可递”了，才会进入“归”的逻辑，这就意味着当前 Fiber 要么没有 child 节点、要么 child 节点的 completeWork 早就执行过了。因此 child 节点不会是下次循环需要考虑的对象，下次循环只需要考虑兄弟节点（siblingFiber）和父节点（returnFiber）。</p>
<p>那么为什么在源码中，遇到兄弟节点会 return，遇到父节点才会进入下次循环呢？这里我以 h1 节点的节点关系为例进行说明。</p>
<p>结合前面的分析可知，h1 节点是递归过程中所触及的第一个叶子节点，也是其兄弟节点中被遍历到的第一个节点；而剩下的两个 p 节点，此时都还没有被遍历到，也就是说连 beginWork 都没有执行过。</p>
<p>因此对于 h1 节点的兄弟节点来说，当下的第一要务是回去从 beginWork 开始走起，直到 beginWork “递无可递”时，才能够执行 completeWork 的逻辑。beginWork 的调用是在 performUnitOfWork 里发生的，因此 completeUnitOfWork 一旦识别到当前节点的兄弟节点不为空，就会终止后续的逻辑，退回到上一层的 performUnitOfWork 里去。</p>
<p>值得注意的是，completeUnitOfWork 中处理兄弟节点和父节点的顺序是：先检查兄弟节点是否存在，若存在则优先处理兄弟节点；确认没有待处理的兄弟节点后，才转而处理父节点。这也就意味着，completeWork 的执行是严格自底向上的，子节点的 completeWork 总会先于父节点执行。</p>
<hr>
<p><strong>副作用链（effectList）的设计与实现</strong></p>
<p>无论是 beginWork 还是 completeWork，它们的应用对象都是 workInProgress 树上的节点。我们说 render 阶段是一个递归的过程，“递归”的对象，正是这棵 workInProgress 树</p>
<p>那么我们递归的目的是什么呢？或者说，render 阶段的工作目标是什么呢？</p>
<p>render 阶段的工作目标是找出界面中需要处理的更新。</p>
<p>在实际的操作中，并不是所有的节点上都会产生需要处理的更新。比如在挂载阶段，对整棵 workInProgress 递归完毕后，React 会发现实际只需要对 App 节点执行一个挂载操作就可以了；而在更新阶段，这种现象更为明显。</p>
<p>更新阶段与挂载阶段的主要区别在于更新阶段的 current 树不为空。</p>
<p>假如说我的某一次操作，仅仅对 p 节点产生了影响，那么对于渲染器来说，它理应只关注 p 节点这一处的更新。这时候问题就来了：怎样做才能让渲染器又快又好地定位到那些真正需要更新的节点呢？</p>
<p>在 render 阶段，我们通过艰难的递归过程来明确“p 节点这里有一处更新”这件事情。按照 React 的设计思路，render 阶段结束后，“找不同”这件事情其实也就告一段落了。commit 只负责实现更新，而不负责寻找更新，这就意味着我们必须找到一个办法能让 commit 阶段“坐享其成”，能直接拿到 render 阶段的工作成果。而这，正是副作用链（effectList）的价值所在。</p>
<hr>
<p>副作用链（effectList） 可以理解为 render 阶段“工作成果”的一个集合：每个 Fiber 节点都维护着一个属于它自己的 effectList，effectList 在数据结构上以链表的形式存在，链表内的每一个元素都是一个 Fiber 节点。这些 Fiber 节点需要满足两个共性：</p>
<ul>
<li>都是当前 Fiber 节点的后代节点</li>
<li>都有待处理的副作用</li>
</ul>
<p>没错，Fiber 节点的 effectList 里记录的并非它自身的更新，而是其需要更新的后代节点。带着这个结论，我们再来品品小节开头 completeUnitOfWork 中的“步骤 2”：</p>
<blockquote>
<p>将当前节点的副作用链（effectList）插入到其父节点对应的副作用链（effectList）中。</p>
</blockquote>
<p>咱们前面已经分析过，“completeWork 是自底向上执行的”，也就是说，子节点的 completeWork 总是比父节点先执行。试想，若每次处理到一个节点，都将当前节点的 effectList 插入到其父节点的 effectList 中。那么当所有节点的 completeWork 都执行完毕时，我是不是就可以从“终极父节点”，也就是 rootFiber 上，拿到一个存储了当前 Fiber 树所有 effect Fiber的“终极版”的 effectList 了？</p>
<p>把所有需要更新的 Fiber 节点单独串成一串链表，方便后续有针对性地对它们进行更新，这就是所谓的“收集副作用”的过程。</p>
<hr>
<p>首先我们要知道的是，这个 effectList 链表在 Fiber 节点中是通过 firstEffect 和 lastEffect 来维护的，其中 firstEffect 表示 effectList 的第一个节点，而 lastEffect 则记录最后一个节点。</p>
<p>对于挂载过程来说，我们唯一要做的就是把 App 组件挂载到界面上去，因此 App 后代节点们的 effectList 其实都是不存在的。effectList 只有在 App 的父节点（rootFiber）这才不为空。</p>
<p>那么 effectList 的创建逻辑又是怎样的呢？其实非常简单，只需要为 firstEffect 和 lastEffect 各赋值一个引用即可。以下是从 completeUnitOfWork 源码中提取出的相关逻辑（解析在注释里）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 若副作用类型的值大于“PerformedWork”，则说明这里存在一个需要记录的副作用</span><br><span class="line"></span><br><span class="line">if (flags &gt; PerformedWork) &#123;</span><br><span class="line"></span><br><span class="line">  // returnFiber 是当前节点的父节点</span><br><span class="line"></span><br><span class="line">  if (returnFiber.lastEffect !== null) &#123;</span><br><span class="line"></span><br><span class="line">    // 若父节点的 effectList 不为空，则将当前节点追加到 effectList 的末尾去</span><br><span class="line"></span><br><span class="line">    returnFiber.lastEffect.nextEffect = completedWork;</span><br><span class="line"></span><br><span class="line">  &#125; else &#123;</span><br><span class="line"></span><br><span class="line">    // 若父节点的 effectList 为空，则当前节点就是 effectList 的 firstEffect</span><br><span class="line"></span><br><span class="line">    returnFiber.firstEffect = completedWork;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 将 effectList 的 lastEffect 指针后移一位</span><br><span class="line"></span><br><span class="line">  returnFiber.lastEffect = completedWork;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中的 flags 咱们已经反复强调过了，它旧时的名字叫“effectTag”，是用来标识副作用类型的；而“completedWork”这个变量，在当前上下文中存储的就是“正在被执行 completeWork 相关逻辑”的节点；至于“PerformedWork”，它是一个值为 1 的常量，React 规定若 flags（又名 effectTag）的值小于等于 1，则不必提交到 commit 阶段。因此 completeUnitOfWork 只会对 flags 大于 PerformedWork 的 effect fiber 进行收集。</p>
<p>从流程上来说，commit 共分为 3 个阶段：before mutation、mutation、layout。</p>
<ul>
<li>before mutation 阶段，这个阶段 DOM 节点还没有被渲染到界面上去，过程中会触发 getSnapshotBeforeUpdate，也会处理 useEffect 钩子相关的调度逻辑。</li>
<li>mutation，这个阶段负责 DOM 节点的渲染。在渲染过程中，会遍历 effectList，根据 flags（effectTag）的不同，执行不同的 DOM 操作。</li>
<li>layout，这个阶段处理 DOM 渲染完毕之后的收尾逻辑。比如调用 componentDidMount/componentDidUpdate，调用 useLayoutEffect 钩子函数的回调等。除了这些之外，它还会把 fiberRoot 的 current 指针指向 workInProgress Fiber 树。</li>
</ul>
<h3 id="剖析-Fiber-架构下-Concurrent-模式的实现原理"><a href="#剖析-Fiber-架构下-Concurrent-模式的实现原理" class="headerlink" title="剖析 Fiber 架构下 Concurrent 模式的实现原理"></a>剖析 Fiber 架构下 Concurrent 模式的实现原理</h3><p><strong>current 树 与 workInProgress 树：“双缓冲”模式在 Fiber 架构下的实现</strong></p>
<p>在计算机图形领域，通过让图形硬件交替读取两套缓冲数据，可以实现画面的无缝切换，减少视觉效果上的抖动甚至卡顿。而在 React 中，双缓冲模式的主要利好，则是能够帮我们较大限度地实现 Fiber 节点的复用，从而减少性能方面的开销。</p>
<p>在 React 中，current 树与 workInProgress 树，两棵树可以对标“双缓冲”模式下的两套缓冲数据：当 current 树呈现在用户眼前时，所有的更新都会由 workInProgress 树来承接。workInProgress 树将会在用户看不到的地方（内存里）悄悄地完成所有改变，直到“灯光”打到它身上，也就是 current 指针指向它的时候，此时就意味着 commit 阶段已经执行完毕，workInProgress 树变成了那棵呈现在界面上的 current 树。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useState &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line"></span><br><span class="line">  const [state, setState] = useState(0)</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line"></span><br><span class="line">    &lt;div className=&quot;App&quot;&gt;</span><br><span class="line"></span><br><span class="line">      &lt;div onClick=&#123;() =&gt; &#123; setState(state + 1) &#125;&#125; className=&quot;container&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;p style=&#123;&#123; width: 128, textAlign: &apos;center&apos; &#125;&#125;&gt;</span><br><span class="line"></span><br><span class="line">          &#123;state&#125;</span><br><span class="line"></span><br><span class="line">        &lt;/p&gt;</span><br><span class="line"></span><br><span class="line">      &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure>
<p>每点击数字 0 一下，它的值就会 +1，这就是我们的更新动作。</p>
<hr>
<p>待 commit 阶段完成后，workInProgress 树对应的 DOM 树就被真正渲染到了页面上，此时 current 指针会指向 workInProgress 树。由于挂载是一个从无到有的过程，在这个过程中我们是在不断地创建新节点，因此还谈不上什么“节点复用”。节点复用要到更新过程中去看。</p>
<hr>
<p>现在我点击数字 0，触发一次更新。这次更新中， rootFiber 节点就会被复用。这段复用的逻辑在 beginWork 调用链路中的 createWorkInProgress 方法里。当检查到上一棵 current 树的 rootFiber 存在时，React 会直接复用这个节点，让它作为下一棵 workInProgress 的节点存在下去，也就是说会走进 createWorkInProgress 的 else 逻辑里去。如果它和目标的 workInProgress 节点之间存在差异，直接在该节点上修改属性、使其与目标节点一致即可，而不必再创建新的 Fiber 节点。</p>
<hr>
<p>同步模式下的更新链路与挂载链路的 render 阶段基本是一致的，都是通过 performSyncWorkOnRoot 来触发包括 beginWork、completeWork 在内的深度优先搜索过程。</p>
<p>其实，挂载可以理解为一种特殊的更新，ReactDOM.render 和 setState 一样，也是一种触发更新的姿势。在 React 中，ReactDOM.render、setState、useState 等方法都是可以触发更新的，这些方法发起的调用链路很相似，是因为它们最后“殊途同归”，都会通过创建 update 对象来进入同一套更新工作流。</p>
<hr>
<p><strong>update 的创建</strong></p>
<p>在点击数字后，点击相关的回调被执行，它首先触发的是 dispatchAction 这个方法，dispatchAction 中，会完成 update 对象的创建。</p>
<p>这里有一个点需要提示一下：dispatchAction 中，调度的是当前触发更新的节点，这一点和挂载过程需要区分开来。在挂载过程中，updateContainer 会直接调度根节点。其实，对于更新这种场景来说，大部分的更新动作确实都不是由根节点触发的，而 render 阶段的起点则是根节点。</p>
<hr>
<p><strong>scheduleUpdateOnFiber 如何区分同步还是异步？</strong></p>
<p>在异步渲染模式下，需要引起你注意的是 ensureRootIsScheduled 这个方法，该方法很关键，它将决定如何开启当前更新所对应的 render 阶段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">if (newCallbackPriority === SyncLanePriority) &#123;</span><br><span class="line"></span><br><span class="line">    // 同步更新的 render 入口</span><br><span class="line"></span><br><span class="line">    newCallbackNode = scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));</span><br><span class="line"></span><br><span class="line">  &#125; else &#123;</span><br><span class="line"></span><br><span class="line">    // 将当前任务的 lane 优先级转换为 scheduler 可理解的优先级</span><br><span class="line"></span><br><span class="line">    var schedulerPriorityLevel = lanePriorityToSchedulerPriority(newCallbackPriority);</span><br><span class="line"></span><br><span class="line">    // 异步更新的 render 入口</span><br><span class="line"></span><br><span class="line">    newCallbackNode = scheduleCallback(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root));</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>performSyncWorkOnRoot 和 performConcurrentWorkOnRoot 这两个方法：前者是同步更新模式下的 render 阶段入口；而后者是异步模式下的 render 阶段入口。</p>
<p>React 会以当前更新任务的优先级类型为依据，决定接下来是调度 performSyncWorkOnRoot 还是 performConcurrentWorkOnRoot。这里调度任务用到的函数分别是 scheduleSyncCallback 和 scheduleCallback，这两个函数在内部都是通过调用 unstable_scheduleCallback 方法来执行任务调度的。</p>
<hr>
<p><strong>Scheduler——“时间切片”与“优先级”的幕后推手</strong></p>
<p>Scheduler 从架构上来看，是 Fiber 架构分层中的“调度层”；从实现上来看，它并非一段内嵌的逻辑，而是一个与 react-dom 同级的文件夹，Fiber 架构下的异步渲染（即 Concurrent 模式）的核心特征分别是“时间切片”与“优先级调度”。而这两点，也正是 Scheduler 的核心能力。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line"></span><br><span class="line">  const arr = new Array(1000).fill(0)</span><br><span class="line"></span><br><span class="line">  const renderContent = arr.map(</span><br><span class="line"></span><br><span class="line">    (i, index) =&gt; &lt;p style=&#123;&#123; width: 128, textAlign: &apos;center&apos; &#125;&#125;&gt;&#123;`测试文本第$&#123;index&#125;行`&#125;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line"></span><br><span class="line">    &lt;div className=&quot;App&quot;&gt;</span><br><span class="line"></span><br><span class="line">      &lt;div className=&quot;container&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">          renderContent</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure>
<p>这个 Task 的执行时长在 130ms 以上，而浏览器的刷新频率为 60Hz，也就是说每 16.6ms 就会刷新一次。在这 16.6ms 里，除了 JS 线程外，渲染线程也是有工作要处理的，但超长的 Task 显然会挤占渲染线程的工作时间，引起“掉帧”，进而带来卡顿的风险</p>
<p>若将 ReactDOM.render 调用改为 createRoot 调用（即开启 Concurrent 模式），你会发现那一个不间断的 Task 长条（大任务），如今像是被“切”过了一样，已经变成了多个断断续续的 Task “短条”（小任务），单个短 Task 的执行时长是 5ms 左右。这些短 Task 的工作量加起来，和之前长 Task 工作量是一样的。但短 Task 之间留出的时间缝隙，却给了浏览器喘息的机会，这就是所谓的“时间切片”效果。</p>
<hr>
<p><strong>时间切片是如何实现的？</strong></p>
<p>在同步渲染中，循环创建 Fiber 节点、构建 Fiber 树的过程是由 workLoopSync 函数来触发的。在 workLoopSync 中，只要 workInProgress 不为空，while 循环就不会结束，它所触发的是一个同步的 performUnitOfWork 循环调用过程。</p>
<p>而在异步渲染模式下，这个循环是由 workLoopConcurrent 来开启的。workLoopConcurrent 的工作内容和 workLoopSync 非常相似，仅仅在循环判断上有一处不同</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function workLoopConcurrent()&#123;</span><br><span class="line">    while(workInProgress!==null&amp;&amp;shouldYield())&#123;</span><br><span class="line">        performUnitWork(workInProgress)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>shouldYield 直译过来的话是“需要让出”。顾名思义，当 shouldYield() 调用返回为 true 时，就说明当前需要对主线程进行让出了，此时 whille 循环的判断条件整体为 false，while 循环将不再继续。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var Scheduler_shouldYield = Scheduler.unstable_shouldYield,</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">var shouldYield = Scheduler_shouldYield;</span><br></pre></td></tr></table></figure>
<p>从这两行代码中我们可以看出，shouldYield 的本体其实是 Scheduler.unstable_shouldYield，也就是 Scheduler 包中导出的 unstable_shouldYield 方法，该方法本身比较简单。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    exports.unstable_shouldYield=function()&#123;</span><br><span class="line">        return exports.unstable_now()&gt;=deadline</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 unstable_now 这里实际取的就是 performance.now() 的值，即“当前时间”。那么 deadline 又是什么呢？它可以被理解为当前时间切片的到期时间，它的计算过程在 Scheduler 包中的 performWorkUntilDeadline 方法里可以找到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dealine=currentTime+yieldInterval</span><br></pre></td></tr></table></figure>
<p>在这行算式里，currentTime 是当前时间，yieldInterval 是时间切片的长度。注意，时间切片的长度并不是一个常量，它是由 React 根据浏览器的帧率大小计算所得出来的，与浏览器的性能有关。</p>
<hr>
<p>现在我们来总结一下时间切片的实现原理：React 会根据浏览器的帧率，计算出时间切片的大小，并结合当前时间计算出每一个切片的到期时间。在 workLoopConcurrent 中，while 循环每次执行前，会调用 shouldYield 函数来询问当前时间切片是否到期，若已到期，则结束循环、出让主线程的控制权。</p>
<hr>
<p><strong>优先级调度是如何实现的</strong></p>
<p>无论是 scheduleSyncCallback 还是 scheduleCallback，最终都是通过调用 unstable_scheduleCallback 来发起调度的。unstable_scheduleCallback 是 Scheduler 导出的一个核心方法，它将结合任务的优先级信息为其执行不同的调度逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function unstable_scheduleCallback(priorityLevel, callback, options) &#123;</span><br><span class="line"></span><br><span class="line">  // 获取当前时间</span><br><span class="line"></span><br><span class="line">  var currentTime = exports.unstable_now();</span><br><span class="line"></span><br><span class="line">  // 声明 startTime，startTime 是任务的预期开始时间</span><br><span class="line"></span><br><span class="line">  var startTime;</span><br><span class="line"></span><br><span class="line">  // 以下是对 options 入参的处理</span><br><span class="line"></span><br><span class="line">  if (typeof options === &apos;object&apos; &amp;&amp; options !== null) &#123;</span><br><span class="line"></span><br><span class="line">    var delay = options.delay;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 若入参规定了延迟时间，则累加延迟时间</span><br><span class="line"></span><br><span class="line">    if (typeof delay === &apos;number&apos; &amp;&amp; delay &gt; 0) &#123;</span><br><span class="line"></span><br><span class="line">      startTime = currentTime + delay;</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">      startTime = currentTime;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125; else &#123;</span><br><span class="line"></span><br><span class="line">    startTime = currentTime;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // timeout 是 expirationTime 的计算依据</span><br><span class="line"></span><br><span class="line">  var timeout;</span><br><span class="line"></span><br><span class="line">  // 根据 priorityLevel，确定 timeout 的值</span><br><span class="line"></span><br><span class="line">  switch (priorityLevel) &#123;</span><br><span class="line"></span><br><span class="line">    case ImmediatePriority:</span><br><span class="line"></span><br><span class="line">      timeout = IMMEDIATE_PRIORITY_TIMEOUT;</span><br><span class="line"></span><br><span class="line">      break;</span><br><span class="line"></span><br><span class="line">    case UserBlockingPriority:</span><br><span class="line"></span><br><span class="line">      timeout = USER_BLOCKING_PRIORITY_TIMEOUT;</span><br><span class="line"></span><br><span class="line">      break;</span><br><span class="line"></span><br><span class="line">    case IdlePriority:</span><br><span class="line"></span><br><span class="line">      timeout = IDLE_PRIORITY_TIMEOUT;</span><br><span class="line"></span><br><span class="line">      break;</span><br><span class="line"></span><br><span class="line">    case LowPriority:</span><br><span class="line"></span><br><span class="line">      timeout = LOW_PRIORITY_TIMEOUT;</span><br><span class="line"></span><br><span class="line">      break;</span><br><span class="line"></span><br><span class="line">    case NormalPriority:</span><br><span class="line"></span><br><span class="line">    default:</span><br><span class="line"></span><br><span class="line">      timeout = NORMAL_PRIORITY_TIMEOUT;</span><br><span class="line"></span><br><span class="line">      break;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 优先级越高，timout 越小，expirationTime 越小</span><br><span class="line"></span><br><span class="line">  var expirationTime = startTime + timeout;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 创建 task 对象</span><br><span class="line"></span><br><span class="line">  var newTask = &#123;</span><br><span class="line"></span><br><span class="line">    id: taskIdCounter++,</span><br><span class="line"></span><br><span class="line">    callback: callback,</span><br><span class="line"></span><br><span class="line">    priorityLevel: priorityLevel,</span><br><span class="line"></span><br><span class="line">    startTime: startTime,</span><br><span class="line"></span><br><span class="line">    expirationTime: expirationTime,</span><br><span class="line"></span><br><span class="line">    sortIndex: -1</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    newTask.isQueued = false;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 若当前时间小于开始时间，说明该任务可延时执行(未过期）</span><br><span class="line"></span><br><span class="line">  if (startTime &gt; currentTime) &#123;</span><br><span class="line"></span><br><span class="line">    // 将未过期任务推入 &quot;timerQueue&quot;</span><br><span class="line"></span><br><span class="line">    newTask.sortIndex = startTime;</span><br><span class="line"></span><br><span class="line">    push(timerQueue, newTask);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 若 taskQueue 中没有可执行的任务，而当前任务又是 timerQueue 中的第一个任务</span><br><span class="line"></span><br><span class="line">    if (peek(taskQueue) === null &amp;&amp; newTask === peek(timerQueue)) &#123;</span><br><span class="line"></span><br><span class="line">      ......</span><br><span class="line"></span><br><span class="line">          // 那么就派发一个延时任务，这个延时任务用于检查当前任务是否过期</span><br><span class="line"></span><br><span class="line">      requestHostTimeout(handleTimeout, startTime - currentTime);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125; else &#123;</span><br><span class="line"></span><br><span class="line">    // else 里处理的是当前时间大于 startTime 的情况，说明这个任务已过期</span><br><span class="line"></span><br><span class="line">    newTask.sortIndex = expirationTime;</span><br><span class="line"></span><br><span class="line">    // 过期的任务会被推入 taskQueue</span><br><span class="line"></span><br><span class="line">    push(taskQueue, newTask);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 执行 taskQueue 中的任务</span><br><span class="line"></span><br><span class="line">    requestHostCallback(flushWork);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return newTask;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>unstable_scheduleCallback 的主要工作是针对当前任务创建一个 task，然后结合 startTime 信息将这个 task 推入 timerQueue 或 taskQueue，最后根据 timerQueue 和 taskQueue 的情况，执行延时任务或即时任务。</p>
<p>要想理解这个过程，首先要搞清楚以下几个概念。</p>
<ul>
<li>startTime：任务的开始时间。</li>
<li>expirationTime：这是一个和优先级相关的值，expirationTime 越小，任务的优先级就越高。</li>
<li>timerQueue：一个以 startTime 为排序依据的小顶堆，它存储的是 startTime 大于当前时间（也就是待执行）的任务。</li>
<li>taskQueue：一个以 expirationTime 为排序依据的小顶堆，它存储的是 startTime 小于当前时间（也就是已过期）的任务。</li>
</ul>
<p>堆是一种特殊的完全二叉树。如果对一棵完全二叉树来说，它每个结点的结点值都不大于其左右孩子的结点值，这样的完全二叉树就叫“小顶堆”。小顶堆自身特有的插入和删除逻辑，决定了无论我们怎么增删小顶堆的元素，其根节点一定是所有元素中值最小的一个节点。这样的性质，使得小顶堆经常被用于实现优先队列。</p>
<p>结合小顶堆的特性，我们再来看源码中涉及 timerQueue 和 taskQueue 的操作，这段代码同时也是整个 unstable_scheduleCallback 方法中的核心逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 若当前时间小于开始时间，说明该任务可延时执行(未过期）</span><br><span class="line"></span><br><span class="line">  if (startTime &gt; currentTime) &#123;</span><br><span class="line"></span><br><span class="line">    // 将未过期任务推入 &quot;timerQueue&quot;</span><br><span class="line"></span><br><span class="line">    newTask.sortIndex = startTime;</span><br><span class="line"></span><br><span class="line">    push(timerQueue, newTask);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 若 taskQueue 中没有可执行的任务，而当前任务又是 timerQueue 中的第一个任务</span><br><span class="line"></span><br><span class="line">    if (peek(taskQueue) === null &amp;&amp; newTask === peek(timerQueue)) &#123;</span><br><span class="line"></span><br><span class="line">      ......</span><br><span class="line"></span><br><span class="line">          // 那么就派发一个延时任务，这个延时任务用于将过期的 task 加入 taskQueue 队列</span><br><span class="line"></span><br><span class="line">      requestHostTimeout(handleTimeout, startTime - currentTime);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125; else &#123;</span><br><span class="line"></span><br><span class="line">    // else 里处理的是当前时间大于 startTime 的情况，说明这个任务已过期</span><br><span class="line"></span><br><span class="line">    newTask.sortIndex = expirationTime;</span><br><span class="line"></span><br><span class="line">    // 过期的任务会被推入 taskQueue</span><br><span class="line"></span><br><span class="line">    push(taskQueue, newTask);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 执行 taskQueue 中的任务</span><br><span class="line"></span><br><span class="line">    requestHostCallback(flushWork);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>若判断当前任务是待执行任务，那么该任务会在 sortIndex 属性被赋值为 startTime 后，被推入 timerQueue。随后，会进入这样的一段判断逻辑</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 若 taskQueue 中没有可执行的任务，而当前任务又是 timerQueue 中的第一个任务</span><br><span class="line"></span><br><span class="line">if (peek(taskQueue) === null &amp;&amp; newTask === peek(timerQueue)) &#123;</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">    // 那么就派发一个延时任务，这个延时任务用于将过期的 task 加入 taskQueue 队列</span><br><span class="line"></span><br><span class="line">  requestHostTimeout(handleTimeout, startTime - currentTime);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要理解这段逻辑，首先需要理解 peek(xxx) 做了什么：peek() 的入参是一个小顶堆，它将取出这个小顶堆的堆顶元素。</p>
<p>taskQueue 里存储的是已过期的任务，peek(taskQueue) 取出的任务若为空，则说明 taskQueue 为空、当前并没有已过期任务。在没有已过期任务的情况下，会进一步判断 timerQueue，也就是未过期任务队列里的情况。</p>
<p>而通过前面的科普，大家已经知道了小顶堆是一个相对有序的数据结构。timerQueue 作为一个小顶堆，它的排序依据其实正是 sortIndex 属性的大小。这里的 sortIndex 属性取值为 startTime，意味着小顶堆的堆顶任务一定是整个 timerQueue 堆结构里 startTime 最小的任务，也就是需要最早被执行的未过期任务。</p>
<p>若当前任务（newTask）就是 timerQueue 中需要最早被执行的未过期任务，那么 unstable_scheduleCallback 会通过调用 requestHostTimeout，为当前任务发起一个延时调用。</p>
<p>注意，这个延时调用（也就是 handleTimeout）并不会直接调度执行当前任务——它的作用是在当前任务到期后，将其从 timerQueue 中取出，加入 taskQueue 中，然后触发对 flushWork 的调用。真正的调度执行过程是在 flushWork 中进行的。flushWork 中将调用 workLoop，workLoop 会逐一执行 taskQueue 中的任务，直到调度过程被暂停（时间片用尽）或任务全部被清空。</p>
<hr>
<p>与 timerQueue 不同的是，taskQueue 是一个以 expirationTime 为 sortIndex（排序依据）的小顶堆。对于已过期任务，React 在将其推入 taskQueue 后，会通过 requestHostCallback(flushWork) 发起一个针对 flushWork 的即时任务，而 flushWork 会执行 taskQueue 中过期的任务。</p>
<hr>
<p>从 React 17.0.0 源码来看，当下 React 发起 Task 调度的姿势有两个：setTimeout、MessageChannel。在宿主环境不支持 MessageChannel 的情况下，会降级到 setTimeout。但不管是 setTimeout 还是 MessageChannel，它们发起的都是异步任务。</p>
<p>因此  requestHostCallback 发起的“即时任务”最早也要等到下一次事件循环才能够执行。“即时”仅仅意味它相对于“延时任务”来说，不需要等待指定的时间间隔，并不意味着同步调用。</p>
<h3 id="特别的事件系统：React-事件与-DOM-事件有何不同？"><a href="#特别的事件系统：React-事件与-DOM-事件有何不同？" class="headerlink" title="特别的事件系统：React 事件与 DOM 事件有何不同？"></a>特别的事件系统：React 事件与 DOM 事件有何不同？</h3><p>React 有着自成一派的事件系统，它和 DOM 原生事件系统不一样。</p>
<p><strong>回顾原生 DOM 下的事件流</strong></p>
<p>在浏览器中，我们通过事件监听来实现 JS 和 HTML 之间的交互。一个页面往往会被绑定许许多多的事件，而页面接收事件的顺序，就是事件流。</p>
<p>W3C 标准约定了一个事件的传播过程要经过以下 3 个阶段：</p>
<ul>
<li>事件捕获阶段</li>
<li>目标阶段</li>
<li>事件冒泡阶段</li>
</ul>
<p>当事件被触发时，首先经历的是一个捕获过程：事件会从最外层的元素开始“穿梭”，逐层“穿梭”到最内层元素，这个过程会持续到事件抵达它目标的元素（也就是真正触发这个事件的元素）为止；此时事件流就切换到了“目标阶段”——事件被目标元素所接收；然后事件会被“回弹”，进入到冒泡阶段——它会沿着来时的路“逆流而上”，一层一层再走回去。</p>
<p><strong>DOM 事件流下的性能优化思路：事件委托</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"></span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line"></span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">  &lt;ul id=&quot;poem&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;li&gt;床前明月光&lt;/li&gt;</span><br><span class="line"></span><br><span class="line">    &lt;li&gt;疑是地上霜&lt;/li&gt;</span><br><span class="line"></span><br><span class="line">    &lt;li&gt;举头望明月&lt;/li&gt;</span><br><span class="line"></span><br><span class="line">    &lt;li&gt;低头思故乡&lt;/li&gt;</span><br><span class="line"></span><br><span class="line">    &lt;li&gt;锄禾日当午&lt;/li&gt;</span><br><span class="line"></span><br><span class="line">    &lt;li&gt;汗滴禾下土&lt;/li&gt;</span><br><span class="line"></span><br><span class="line">    &lt;li&gt;谁知盘中餐&lt;/li&gt;</span><br><span class="line"></span><br><span class="line">    &lt;li&gt;粒粒皆辛苦&lt;/li&gt;</span><br><span class="line"></span><br><span class="line">    &lt;li&gt;背不动了&lt;/li&gt;</span><br><span class="line"></span><br><span class="line">    &lt;li&gt;我背不动了&lt;/li&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">  // 获取 li 列表</span><br><span class="line"></span><br><span class="line">  var liList = document.getElementsByTagName(&apos;li&apos;)</span><br><span class="line"></span><br><span class="line">  // 逐个安装监听函数</span><br><span class="line"></span><br><span class="line">  for (var i = 0; i &lt; liList.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">    liList[i].addEventListener(&apos;click&apos;, function (e) &#123;</span><br><span class="line"></span><br><span class="line">      console.log(e.target.innerHTML)</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var ul = document.getElementById(&apos;poem&apos;)</span><br><span class="line"></span><br><span class="line">ul.addEventListener(&apos;click&apos;, function(e)&#123;</span><br><span class="line"></span><br><span class="line">  console.log(e.target.innerHTML)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>像这样利用事件的冒泡特性，把多个子元素的同一类型的监听逻辑，合并到父元素上通过一个监听函数来管理的行为，就是事件委托。通过事件委托，我们可以减少内存开销、简化注册步骤，大大提高开发效率。</p>
<p>这绝妙的事件委托，正是 React合成事件的灵感源泉。</p>
<hr>
<p><strong>React 事件系统是如何工作的</strong></p>
<p>React 的事件系统沿袭了事件委托的思想。在 React 中，除了少数特殊的不可冒泡的事件（比如媒体类型的事件）无法被事件系统处理外，绝大部分的事件都不会被绑定在具体的元素上，而是统一被绑定在页面的 document 上。当事件在具体的 DOM 节点上被触发后，最终都会冒泡到 document 上，document 上所绑定的统一事件处理程序会将事件分发到具体的组件实例。</p>
<p>在分发事件之前，React 首先会对事件进行包装，把原生 DOM 事件包装成合成事件。</p>
<hr>
<p>合成事件是 React 自定义的事件对象，它符合W3C规范，在底层抹平了不同浏览器的差异，在上层面向开发者暴露统一的、稳定的、与 DOM 原生事件相同的事件接口。开发者们由此便不必再关注烦琐的兼容性问题，可以专注于业务逻辑的开发。</p>
<p>虽然合成事件并不是原生 DOM 事件，但它保存了原生 DOM 事件的引用。当你需要访问原生 DOM 事件对象时，可以通过合成事件对象的 e.nativeEvent 属性获取到它</p>
<hr>
<p><strong>React 事件系统工作流拆解</strong></p>
<p>事件的绑定是在组件的挂载过程中完成的，具体来说，是在 completeWork 中完成的。</p>
<p>completeWork 内部有三个关键动作：创建 DOM 节点（createInstance）、将 DOM 节点插入到 DOM 树中（appendAllChildren）、为 DOM 节点设置属性（finalizeInitialChildren）。</p>
<hr>
<p>其中“为 DOM 节点设置属性”这个环节，会遍历 FiberNode 的 props key。当遍历到事件相关的 props 时，就会触发事件的注册链路。</p>
<p>事件的注册过程是由 ensureListeningTo 函数开启的。在 ensureListeningTo 中，会尝试获取当前 DOM 结构中的根节点（这里指的是 document 对象），然后通过调用 legacyListenToEvent，将统一的事件监听函数注册到 document 上面。</p>
<p>listenerMap 是在 legacyListenToEvent 里创建/获取的一个数据结构，它将记录当前 document 已经监听了哪些事件。在 legacyListenToTopLevelEvent 逻辑的起点，会首先判断 listenerMap.has(topLevelType) 这个条件是否为 true。</p>
<p>这里插播一个小的前置知识：topLevelType 在 legacyListenToTopLevelEvent 的函数上下文中代表事件的类型，比如说我尝试监听的是一个点击事件，那么 topLevelType 的值就会是 click。</p>
<p>若事件系统识别到 listenerMap.has(topLevelType) 为 true，也就是当前这个事件 document 已经监听过了，那么就会直接跳过对这个事件的处理，否则才会进入具体的事件监听逻辑。如此一来，即便我们在 React 项目中多次调用了对同一个事件的监听，也只会在 document 上触发一次注册。</p>
<p>为什么针对同一个事件，即便可能会存在多个回调，document 也只需要注册一次监听？因为 React最终注册到 document 上的并不是某一个 DOM 节点上对应的具体回调逻辑，而是一个统一的事件分发函数。</p>
<p>最终注册到 document 上的是一个统一的事件分发函数，这个函数到底长啥样？listener 本体是一个名为 dispatchDiscreteEvent 的函数。事实上，根据情况的不同，listener 可能是以下 3 个函数中的任意一个：</p>
<ul>
<li>dispatchDiscreteEvent</li>
<li>dispatchUserBlockingUpdate</li>
<li>dispatchEvent</li>
</ul>
<p>dispatchDiscreteEvent 和 dispatchUserBlockingUpdate 的不同，主要体现在对优先级的处理上，对事件分发动作倒没什么影响。无论是 dispatchDiscreteEvent 还是 dispatchUserBlockingUpdate，它们最后都是通过调用 dispatchEvent 来执行事件分发的。因此可以认为，最后绑定到 document 上的这个统一的事件分发函数，其实就是 dispatchEvent。</p>
<hr>
<p>事件触发的本质是对 dispatchEvent 函数的调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">事件触发，冒泡至document=&gt;执行dispatchEvent=&gt;创建事件对应的合成事件对象(SyntheticEvent)=&gt;收集事件在捕获阶段所波及的回调函数和对应的节点实例=&gt;收集事件在冒泡阶段所波及的回调函数和对应的节点实例=&gt;将前两步收集的回调按顺序执行，执行时SyntheticEvent会作为入参传入每个回调</span><br></pre></td></tr></table></figure>
<p><strong>事件回调的收集与执行</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">import &#123; useState &#125; from &apos;react&apos;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line"></span><br><span class="line">  const [state, setState] = useState(0)</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line"></span><br><span class="line">    &lt;div className=&quot;App&quot;&gt;</span><br><span class="line"></span><br><span class="line">      &lt;div id=&quot;container&quot; onClickCapture=&#123;() =&gt; console.log(&apos;捕获经过 div&apos;)&#125; onClick=&#123;() =&gt; console.log(&apos;冒泡经过 div&apos;)&#125; className=&quot;container&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;p style=&#123;&#123; width: 128, textAlign: &apos;center&apos; &#125;&#125;&gt;</span><br><span class="line"></span><br><span class="line">          &#123;state&#125;</span><br><span class="line"></span><br><span class="line">        &lt;/p&gt;</span><br><span class="line"></span><br><span class="line">        &lt;button style=&#123;&#123; width: 128 &#125;&#125; onClick=&#123;() =&gt; &#123; setState(state + 1) &#125;&#125;&gt;点击+1&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">      &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure>
<p>界面中渲染出来的是一行数字文本和一个按钮，每点击一下按钮，数字文本会 +1。在 JSX 结构中，监听点击事件的除了 button 按钮外，还有 id 为 container 的 div 元素，这个 div 元素同时监听了点击事件的冒泡和捕获。</p>
<p>首先我们来看收集过程对应的源码逻辑，这部分逻辑在 traverseTwoPhase 函数中，源码如下（解析在注释里）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">function traverseTwoPhase(inst, fn, arg) &#123;</span><br><span class="line"></span><br><span class="line">  // 定义一个 path 数组</span><br><span class="line"></span><br><span class="line">  var path = [];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  while (inst) &#123;</span><br><span class="line"></span><br><span class="line">    // 将当前节点收集进 path 数组</span><br><span class="line"></span><br><span class="line">    path.push(inst);</span><br><span class="line"></span><br><span class="line">    // 向上收集 tag===HostComponent 的父节点</span><br><span class="line"></span><br><span class="line">    inst = getParent(inst);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var i;</span><br><span class="line"></span><br><span class="line">  // 从后往前，收集 path 数组中会参与捕获过程的节点与对应回调</span><br><span class="line"></span><br><span class="line">  for (i = path.length; i-- &gt; 0;) &#123;</span><br><span class="line"></span><br><span class="line">    fn(path[i], &apos;captured&apos;, arg);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 从前往后，收集 path 数组中会参与冒泡过程的节点与对应回调</span><br><span class="line"></span><br><span class="line">  for (i = 0; i &lt; path.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">    fn(path[i], &apos;bubbled&apos;, arg);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>traverseTwoPhase 函数做了以下三件事情。</p>
<ul>
<li>循环收集符合条件的父节点，存进 path 数组中，traverseTwoPhase会以当前节点（触发事件的目标节点）为起点，不断向上寻找 tag===HostComponent 的父节点，并将这些节点按顺序收集进 path 数组中。其中 tag===HostComponent 这个条件是在 getParent() 函数中管控的。为什么一定要求 tag===HostComponent 呢？前面介绍渲染链路时，我们曾经讲过，HostComponent 是 DOM 元素对应的 Fiber 节点类型。此处限制 tag===HostComponent，也就是说只收集 DOM 元素对应的 Fiber 节点。之所以这样做，是因为浏览器只认识 DOM 节点，浏览器事件也只会在 DOM 节点之间传播，收集其他节点是没有意义的。button 节点是事件触发的起点，在它的父节点中，符合 tag===HostComponent 这个条件的只有 div#container 和 div.App</li>
<li>模拟事件在捕获阶段的传播顺序，收集捕获阶段相关的节点实例与回调函数。接下来，traverseTwoPhase 会从后往前遍历 path 数组，模拟事件的捕获顺序，收集事件在捕获阶段对应的回调与实例。前面咱们说 path 数组是从子节点出发，向上收集得来的。所以说path 数组中子节点在前，祖先节点在后。从后往前遍历 path 数组，其实就是从父节点往下遍历子节点，直至遍历到目标节点的过程，这个遍历顺序和事件在捕获阶段的传播顺序是一致的。在遍历的过程中，fn 函数会对每个节点的回调情况进行检查，若该节点上对应当前事件的捕获回调不为空，那么节点实例会被收集到合成事件的 _dispatchInstances 属性（也就是 SyntheticEvent._dispatchInstances）中去，事件回调则会被收集到合成事件的 _dispatchListeners 属性（也就是 SyntheticEvent._dispatchListeners） 中去，等待后续的执行。</li>
<li>模拟事件在冒泡阶段的传播顺序，收集冒泡阶段相关的节点实例与回调函数。捕获阶段的工作完成后，traverseTwoPhase 会从后往前遍历 path 数组，模拟事件的冒泡顺序，收集事件在捕获阶段对应的回调与实例。这个过程和步骤 2 基本是一样的，唯一的区别是对 path 数组的倒序遍历变成了正序遍历。节点实例和事件回调同样会分别被收集到 SyntheticEvent._dispatchInstances 和 SyntheticEvent._dispatchListeners 中去。</li>
</ul>
<hr>
<p>这样一来，我们在事件回调的执行阶段，只需要按照顺序执行 SyntheticEvent._dispatchListeners 数组中的回调函数，就能够一口气模拟出整个完整的 DOM 事件流，也就是 “捕获-目标-冒泡”这三个阶段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">_dispatchInstances</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line"> div.container,</span><br><span class="line"> button,</span><br><span class="line"> div.container,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_dispatchListeners </span><br><span class="line"></span><br><span class="line">[</span><br><span class="line"> ()=&gt;console.log(&apos;捕获经过 div&apos;),</span><br><span class="line"> ()=&gt;&#123;setState()state+1&#125;,</span><br><span class="line"> ()=&gt;console.log(&apos;冒泡经过 div&apos;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>可以看出，_dispatchInstances 和 _dispatchListeners 两个数组中的元素是严格的一一对应关系，这确保了在回调的执行阶段，我们可以简单地通过索引来将实例与监听函数关联起来，实现事件委托的效果。同时，两个数组中元素的排序，完美地契合了 DOM 标准中“捕获-目标-冒泡”这三个阶段的事件传播顺序，真是妙啊！</p>
<h2 id="“周边生态”帮你拓宽技术视野"><a href="#“周边生态”帮你拓宽技术视野" class="headerlink" title="“周边生态”帮你拓宽技术视野"></a>“周边生态”帮你拓宽技术视野</h2><h3 id="揭秘-Redux-设计思想与工作原理（上）"><a href="#揭秘-Redux-设计思想与工作原理（上）" class="headerlink" title="揭秘 Redux 设计思想与工作原理（上）"></a>揭秘 Redux 设计思想与工作原理（上）</h3><p>Redux 的设计在很大程度上受益于 Flux 架构，我们可以认为 Redux 是 Flux 的一种实现形式（虽然它并不严格遵循 Flux 的设定），理解 Flux 将帮助你更好地从抽象层面把握 Redux。</p>
<p>Flux 并不是一个具体的框架，它是一套由 Facebook 技术团队提出的应用架构，这套架构约束的是应用处理数据的模式。在 Flux 架构中，一个应用将被拆分为以下 4 个部分。</p>
<ul>
<li>View（视图层）：用户界面。该用户界面可以是以任何形式实现出来的，React 组件是一种形式，Vue、Angular 也完全 OK。Flux 架构与 React 之间并不存在耦合关系。</li>
<li>Action（动作）：也可以理解为视图层发出的“消息”，它会触发应用状态的改变。</li>
<li>Dispatcher（派发器）：它负责对 action 进行分发。</li>
<li>Store（数据层）：它是存储应用状态的“仓库”，此外还会定义修改状态的逻辑。store 的变化最终会映射到 view 层上去。</li>
</ul>
<p>一个典型的 Flux 工作流是这样的：用户与 View 之间产生交互，通过 View 发起一个 Action；Dispatcher 会把这个 Action 派发给 Store，通知 Store 进行相应的状态更新。Store 状态更新完成后，会进一步通知 View 去更新界面。</p>
<hr>
<p>Flux 的核心特征是单向数据流，双向数据流最为典型的代表就是前端场景下的 MVC 架构。除了允许用户通过 View 层交互来触发流程以外，MVC 架构还有另外一种形式，即允许用户通过直接触发 Controller 逻辑来触发流程。</p>
<p>在 MVC 应用中，会涉及这 3 个部分：</p>
<ul>
<li>Model（模型），程序需要操作的数据或信息；</li>
<li>View（视图），用户界面；</li>
<li>Controller（控制器），用于连接 View 和 Model，管理 Model 与 View 之间的逻辑。</li>
</ul>
<p>事实上，在许多服务端的 MVC 应用中，数据流确实能够保持单向。但是在前端场景下，实际的 MVC 应用要复杂不少，前端应用/框架往往出于交互的需要，允许 View 和 Model 直接通信。这就允许了双向数据流的存在。当业务复杂度较高时，数据流会变得非常混乱。</p>
<p>Flux 最核心的地方在于严格的单向数据流，在单向数据流下，状态的变化是可预测的。如果 store 中的数据发生了变化，那么有且仅有一个原因，那就是由 Dispatcher 派发 Action 来触发的。这样一来，就从根本上避免了混乱的数据关系，使整个流程变得清晰简单。</p>
<hr>
<p>Redux 主要由 3 部分组成：Store、Reducer 和 Action。</p>
<ul>
<li>Store：它是一个单一的数据源，而且是只读的。</li>
<li>Action 人如其名，是“动作”的意思，它是对变化的描述。</li>
<li>Reducer 是一个函数，它负责对变化进行分发和处理，最终将新的数据返回给 Store。</li>
</ul>
<p>在 Redux 的整个工作过程中，数据流是严格单向的。如果你想对数据进行修改，只有一种途径：派发 Action。Action 会被 Reducer 读取，Reducer 将根据 Action 内容的不同执行不同的计算逻辑，最终生成新的 state（状态），这个新的 state 会更新到 Store 对象里，进而驱动视图层面作出对应的改变。</p>
<h3 id="揭秘-Redux-设计思想与工作原理（下）"><a href="#揭秘-Redux-设计思想与工作原理（下）" class="headerlink" title="揭秘 Redux 设计思想与工作原理（下）"></a>揭秘 Redux 设计思想与工作原理（下）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">  // 执行 reducer 前，先“上锁”，标记当前已经存在 dispatch 执行流程</span><br><span class="line"></span><br><span class="line">  isDispatching = true</span><br><span class="line"></span><br><span class="line">  // 调用 reducer，计算新的 state </span><br><span class="line"></span><br><span class="line">  currentState = currentReducer(currentState, action)</span><br><span class="line"></span><br><span class="line">&#125; finally &#123;</span><br><span class="line"></span><br><span class="line">  // 执行结束后，把&quot;锁&quot;打开，允许再次进行 dispatch </span><br><span class="line"></span><br><span class="line">  isDispatching = false</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>reducer 的本质是 store 的更新规则，它指定了应用状态的变化如何响应 action 并发送到 store。这段代码中调用 reducer，传入 currentState 和 action。</p>
<p>在调用 reducer 之前，Redux 首先会将 isDispatching 变量置为 true，待 reducer 执行完毕后，再将 isDispatching 变量置为 false。</p>
<hr>
<p>subscribe 接收一个 Function 类型的 listener 作为入参，它的返回内容恰恰就是这个 listener 对应的解绑函数。你可以通过下面这段示例代码简单把握一下 subscribe 的使用姿势：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function handleChange() &#123;</span><br><span class="line"></span><br><span class="line">  // 函数逻辑</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const unsubscribe = store.subscribe(handleChange)</span><br><span class="line"></span><br><span class="line">unsubscribe()</span><br></pre></td></tr></table></figure>
<p>我们可以在 store 对象创建成功后，通过调用 store.subscribe 来注册监听函数，也可以通过调用 subscribe 的返回函数来解绑监听函数，监听函数是用 listeners 数组来维护的；当dispatch action 发生时，Redux 会在 reducer 执行完毕后，将 listeners 数组中的监听函数逐个执行。这就是 subscribe 与 Redux 主流程之间的关系。</p>
<hr>
<p><strong>currentListeners 数组用于确保监听函数执行过程的稳定性</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 定义监听函数 A</span><br><span class="line"></span><br><span class="line">function listenerA() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 订阅 A，并获取 A 的解绑函数</span><br><span class="line"></span><br><span class="line">const unSubscribeA = store.subscribe(listenerA)</span><br><span class="line"></span><br><span class="line">// 定义监听函数 B</span><br><span class="line"></span><br><span class="line">function listenerB() &#123;</span><br><span class="line"></span><br><span class="line">  // 在 B 中解绑 A</span><br><span class="line"></span><br><span class="line">  unSubscribeA()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义监听函数 C</span><br><span class="line"></span><br><span class="line">function listenerC() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 订阅 B</span><br><span class="line"></span><br><span class="line">store.subscribe(listenerB)</span><br><span class="line"></span><br><span class="line">// 订阅 C</span><br><span class="line"></span><br><span class="line">store.subscribe(listenerC)</span><br></pre></td></tr></table></figure>
<p>在这个 Demo 执行完毕后，nextListeners 数组的内容是 A、B、C 3 个 listener：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[listenerA,  listenerB, listenerC]</span><br></pre></td></tr></table></figure>
<p>接下来若调用 dispatch，则会执行下面这段触发订阅的逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 触发订阅</span><br><span class="line"></span><br><span class="line">const listeners = (currentListeners = nextListeners);</span><br><span class="line"></span><br><span class="line">for (let i = 0; i &lt; listeners.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">  const listener = listeners[i];</span><br><span class="line"></span><br><span class="line">  listener();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 for 循环执行到索引 i = 1 处，也就是对应的 listener 为 listenerB 时，问题就会出现：listenerB 中执行了 unSubscribeA 这个动作。</p>
<p>假如说不存在 currentListeners，那么也就意味着不需要 ensureCanMutateNextListeners 这个动作。若没有 ensureCanMutateNextListeners，unsubscribeA() 执行完之后，listenerA 会同时从 listeners 数组和 nextListeners 数组中消失（因为两者指向的是同一个引用），那么 listeners 数组此时只剩下两个元素 listenerB 和 listenerC，变成这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[listenerB, listenerC]</span><br></pre></td></tr></table></figure>
<p>listeners 数组的长度改变了，但 for 循环却不会感知这一点，它将无情地继续循环下去。之前执行到 i = 1 处，listener = listeners[1] ，也就是说 listener === listenerB；下一步理应执行到 i = 2 处，但此时 listeners[2] 已经是 undefined 了，原本应该出现在这个索引位上的 listenerC，此时因为数组长度的变化，被前置到了 i = 1 处！这样一来，undefined 就会代替 listenerC 被执行，进而引发函数异常。</p>
<p>这可怎么办呢？答案当然是将 nextListeners 与当前正在执行中的 listeners 剥离开来，将两者指向不同的引用。这也正是 ensureCanMutateNextListeners 所做的事情。</p>
<p>在示例的这种场景下，ensureCanMutateNextListeners 执行前，listeners、currentListeners 和 nextListeners 之间的关系是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listeners === currentListeners === nextListeners</span><br></pre></td></tr></table></figure>
<p>而 ensureCanMutateNextListeners 执行后，nextListeners 就会被剥离出去：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">nextListeners = currentListeners.slice()</span><br><span class="line"></span><br><span class="line">listeners === currentListeners !== nextListeners</span><br></pre></td></tr></table></figure>
<p>这样一来，nextListeners 上的任何改变，都无法再影响正在执行中的 listeners 了。currentListeners 在此处的作用，就是为了记录下当前正在工作中的 listeners 数组的引用，将它与可能发生改变的 nextListeners 区分开来，以确保监听函数在执行过程中的稳定性。</p>
<h3 id="从-Redux-中间件实现原理切入，理解“面向切面编程”"><a href="#从-Redux-中间件实现原理切入，理解“面向切面编程”" class="headerlink" title="从 Redux 中间件实现原理切入，理解“面向切面编程”"></a>从 Redux 中间件实现原理切入，理解“面向切面编程”</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 引入 redux</span><br><span class="line"></span><br><span class="line">import &#123; createStore, applyMiddleware &#125; from &apos;redux&apos;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">// 创建 store</span><br><span class="line"></span><br><span class="line">const store = createStore(</span><br><span class="line"></span><br><span class="line">    reducer,</span><br><span class="line"></span><br><span class="line">    initial_state,</span><br><span class="line"></span><br><span class="line">    applyMiddleware(middleware1, middleware2, ...)</span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>在针对 Redux 源码主流程的分析中，我们不难看出这样一个规律——Redux 源码中只有同步操作，也就是说当我们 dispatch action 时，state 会被立即更新。</p>
<p>那如果想要在 Redux 中引入异步数据流，该怎么办呢？Redux 官方给出的建议是使用中间件来增强 createStore。支持异步数据流的 Redux 中间件有很多，其中最适合用来快速上手的应该就是 redux-thunk了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 引入 redux-thunk</span><br><span class="line"></span><br><span class="line">import thunkMiddleware from &apos;redux-thunk&apos;</span><br><span class="line"></span><br><span class="line">import reducer from &apos;./reducers&apos;</span><br><span class="line"></span><br><span class="line">// 将中间件用 applyMiddleware 包装后传入</span><br><span class="line"></span><br><span class="line">const store = createStore(reducer, applyMiddleware(thunkMiddleware))</span><br></pre></td></tr></table></figure>
<p>redux-thunk 带来的改变非常好理解，它允许我们以函数的形式派发一个 action，像这样（解析在注释里）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">// axios 是一个用于发起异步请求的库</span><br><span class="line"></span><br><span class="line">import axios from &apos;axios&apos; </span><br><span class="line"></span><br><span class="line">// 引入 createStore 和 applyMiddleware</span><br><span class="line"></span><br><span class="line">import &#123; createStore, applyMiddleware &#125; from &apos;redux&apos;;</span><br><span class="line"></span><br><span class="line">// 引入 redux-thunk</span><br><span class="line"></span><br><span class="line">import thunk from &apos;redux-thunk&apos;;</span><br><span class="line"></span><br><span class="line">// 引入 reducer</span><br><span class="line"></span><br><span class="line">import reducer from &apos;./reducers&apos;;</span><br><span class="line"></span><br><span class="line">// 创建一个有 thunk 中间件加持的 store 对象</span><br><span class="line"></span><br><span class="line">const store = createStore(</span><br><span class="line"></span><br><span class="line">  reducer,</span><br><span class="line"></span><br><span class="line">  applyMiddleware(thunk)</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// 用于发起付款请求，并处理请求结果。由于涉及资金，我们希望感知请求的发送和响应的返回</span><br><span class="line"></span><br><span class="line">// 入参是付款相关的信息（包括用户账密、金额等）</span><br><span class="line"></span><br><span class="line">// 注意 payMoney 的返回值仍然是一个函数</span><br><span class="line"></span><br><span class="line">const payMoney = (payInfo) =&gt; (dispatch) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  // 付款前发出准备信号</span><br><span class="line"></span><br><span class="line">  dispatch(&#123; type: &apos;payStart&apos; &#125;)</span><br><span class="line"></span><br><span class="line">  fetch().then(res =&gt; &#123; dispatch()&#125;)</span><br><span class="line"></span><br><span class="line">  return axios.post(&apos;/api/payMoney&apos;, &#123;</span><br><span class="line"></span><br><span class="line">    payInfo</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  .then(function (response) &#123;</span><br><span class="line"></span><br><span class="line">    console.log(response);</span><br><span class="line"></span><br><span class="line">    // 付款成功信号</span><br><span class="line"></span><br><span class="line">    dispatch(&#123; type: &apos;paySuccess&apos; &#125;)</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  .catch(function (error) &#123;</span><br><span class="line"></span><br><span class="line">    console.log(error);</span><br><span class="line"></span><br><span class="line">    // 付款失败信号</span><br><span class="line"></span><br><span class="line">    dispatch(&#123; type: &apos;payError&apos; &#125;)</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 支付信息，入参</span><br><span class="line"></span><br><span class="line">const payInfo = &#123;</span><br><span class="line"></span><br><span class="line">  userName: xxx,</span><br><span class="line"></span><br><span class="line">  password: xxx,</span><br><span class="line"></span><br><span class="line">  count: xxx,</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// dispatch 一个 action，注意这个 action 是一个函数</span><br><span class="line"></span><br><span class="line">store.dispatch(payMoney(payInfo));</span><br></pre></td></tr></table></figure>
<p>对于 Redux 中间件的工作模式，你需要牢牢把握以下两点：</p>
<ul>
<li>中间件的执行时机，即 action 被分发之后、reducer 触发之前；</li>
<li>中间件的执行前提，即 applyMiddleware 将会对 dispatch 函数进行改写，使得 dispatch 在触发 reducer 之前，会首先执行对 Redux 中间件的链式调用。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// createThunkMiddleware 用于创建 thunk</span><br><span class="line"></span><br><span class="line">function createThunkMiddleware(extraArgument) &#123;</span><br><span class="line"></span><br><span class="line">  // 返回值是一个 thunk，它是一个函数</span><br><span class="line"></span><br><span class="line">  return (&#123; dispatch, getState &#125;) =&gt; (next) =&gt; (action) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    // thunk 若感知到 action 是一个函数，就会执行 action</span><br><span class="line"></span><br><span class="line">    if (typeof action === &apos;function&apos;) &#123;</span><br><span class="line"></span><br><span class="line">      return action(dispatch, getState, extraArgument);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 若 action 不是一个函数，则不处理，直接放过</span><br><span class="line"></span><br><span class="line">    return next(action);</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const thunk = createThunkMiddleware();</span><br><span class="line"></span><br><span class="line">thunk.withExtraArgument = createThunkMiddleware;</span><br><span class="line"></span><br><span class="line">export default thunk;</span><br></pre></td></tr></table></figure>
<p>redux-thunk 主要做的事情，就是在拦截到 action 以后，会去检查它是否是一个函数。若 action 是一个函数，那么 redux-thunk 就会执行它并且返回执行结果；若 action 不是一个函数，那么它就不是 redux-thunk 的处理目标，直接调用 next，告诉 Redux “我这边的工作做完了”，工作流就可以继续往下走了。</p>
<p>Redux 中间件是通过调用 applyMiddleware 来引入的，因此我们先看看 applyMiddleware 的源码（解析在注释里）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">// applyMiddlerware 会使用“...”运算符将入参收敛为一个数组</span><br><span class="line"></span><br><span class="line">export default function applyMiddleware(...middlewares) &#123;</span><br><span class="line"></span><br><span class="line">  // 它返回的是一个接收 createStore 为入参的函数</span><br><span class="line"></span><br><span class="line">  return createStore =&gt; (...args) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    // 首先调用 createStore，创建一个 store</span><br><span class="line"></span><br><span class="line">    const store = createStore(...args)</span><br><span class="line"></span><br><span class="line">    let dispatch = () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">      throw new Error(</span><br><span class="line"></span><br><span class="line">        `Dispatching while constructing your middleware is not allowed. ` +</span><br><span class="line"></span><br><span class="line">          `Other middleware would not be applied to this dispatch.`</span><br><span class="line"></span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // middlewareAPI 是中间件的入参</span><br><span class="line"></span><br><span class="line">    const middlewareAPI = &#123;</span><br><span class="line"></span><br><span class="line">      getState: store.getState,</span><br><span class="line"></span><br><span class="line">      dispatch: (...args) =&gt; dispatch(...args)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 遍历中间件数组，调用每个中间件，并且传入 middlewareAPI 作为入参，得到目标函数数组 chain</span><br><span class="line"></span><br><span class="line">    const chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))</span><br><span class="line"></span><br><span class="line">    // 改写原有的 dispatch：将 chain 中的函数按照顺序“组合”起来，调用最终组合出来的函数，传入 dispatch 作为入参</span><br><span class="line"></span><br><span class="line">    dispatch = compose(...chain)(store.dispatch)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 返回一个新的 store 对象，这个 store 对象的 dispatch 已经被改写过了</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line"></span><br><span class="line">      ...store,</span><br><span class="line"></span><br><span class="line">      dispatch</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段源码中，我们着重需要搞清楚的是以下几个问题：</p>
<ul>
<li>applyMiddleware 返回了一个什么样的函数？这个函数是如何与 createStore 配合工作的？</li>
<li>dispatch 函数是如何被改写的？</li>
<li>compose 函数是如何组合中间件的？</li>
</ul>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// middlewareAPI 是中间件的入参</span><br><span class="line"></span><br><span class="line">const middlewareAPI = &#123;</span><br><span class="line"></span><br><span class="line">  getState: store.getState,</span><br><span class="line"></span><br><span class="line">  dispatch: (...args) =&gt; dispatch(...args)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 遍历中间件数组，调用每个中间件，并且传入 middlewareAPI 作为入参，得到目标函数数组 chain</span><br><span class="line"></span><br><span class="line">const chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))</span><br><span class="line"></span><br><span class="line">// 改写原有的 dispatch：将 chain 中的函数按照顺序“组合”起来，调用最终组合出来的函数，传入 dispatch 作为入参</span><br><span class="line"></span><br><span class="line">dispatch = compose(...chain)(store.dispatch)</span><br></pre></td></tr></table></figure>
<p>thunk 中间件是 createThunkMiddleware 的返回值，createThunkMiddleware 返回的是这样的一个函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// createThunkMiddleware 用于创建 thunk</span><br><span class="line"></span><br><span class="line">function createThunkMiddleware(extraArgument) &#123;</span><br><span class="line"></span><br><span class="line">  // 返回值是一个 thunk，它是一个函数</span><br><span class="line"></span><br><span class="line">  return (&#123; dispatch, getState &#125;) =&gt; (next) =&gt; (action) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    // thunk 若感知到 action 是一个函数，就会执行 action</span><br><span class="line"></span><br><span class="line">    if (typeof action === &apos;function&apos;) &#123;</span><br><span class="line"></span><br><span class="line">      return action(dispatch, getState, extraArgument);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 若 action 不是一个函数，则不处理，直接放过</span><br><span class="line"></span><br><span class="line">    return next(action);</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const thunk = createThunkMiddleware();</span><br></pre></td></tr></table></figure>
<p>该函数的返回值仍然是一个函数，显然它是一个高阶函数。事实上，按照约定，所有的 Redux 中间件都必须是高阶函数。在高阶函数中，我们习惯于将原函数称为“外层函数”，将 return 出来的函数称为“内层函数”。</p>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// compose 会首先利用“...”运算符将入参收敛为数组格式</span><br><span class="line"></span><br><span class="line">export default function compose(...funcs) &#123;</span><br><span class="line"></span><br><span class="line">  // 处理数组为空的边界情况</span><br><span class="line"></span><br><span class="line">  if (funcs.length === 0) &#123;</span><br><span class="line"></span><br><span class="line">    return arg =&gt; arg</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 若只有一个函数，也就谈不上组合，直接返回</span><br><span class="line"></span><br><span class="line">  if (funcs.length === 1) &#123;</span><br><span class="line"></span><br><span class="line">    return funcs[0]</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 若有多个函数，那么调用 reduce 方法来实现函数的组合</span><br><span class="line"></span><br><span class="line">  return funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>中间件与面向切面编程</strong></p>
<p>AOP（面向切面）这个概念可能很多同学都不太了解，大家相对熟悉的应该是 OOP（面向对象）。而 AOP 的存在，恰恰是为了解决 OOP 的局限性，我们可以将 AOP 看作是对 OOP 的一种补充。</p>
<p>在 OOP 模式下，当我们想要拓展一个类的逻辑时，最常见的思路就是继承：class A 继承 class B，class B 继承 class C……这样一层一层将逻辑向下传递。</p>
<p>当我们想要为某几个类追加一段共同的逻辑时，可以通过修改它们共同的父类来实现，这无疑会使得公共类越来越臃肿，可我们也确实没有什么更好的办法——总不能任这些公共逻辑散落在不同的业务逻辑里吧？那将会引发更加严重的代码冗余及耦合问题。</p>
<p>怎么办呢？“面向切面”来救场！</p>
<hr>
<p>此时考虑这样一个需求：要求在每个 Action 被派发之后，打出一个 console.log 记录“action 被派发了”这个动作，也就是我们常说的“日志追溯”。这个需求的通用性很强、业务属性很弱，因此不适合与任何的业务逻辑耦合在一起。那我们就可以以 “切面”这种形式，把它与业务逻辑剥离开来：扩展功能在工作流中的执行节点，可以视为一个单独“切点”；我们把扩展功能的逻辑放到这个“切点”上来，形成的就是一个可以拦截前序逻辑的“切面”</p>
<p>“切面”与业务逻辑是分离的，因此 AOP 是一种典型的 “非侵入式”的逻辑扩充思路。</p>
<p>在日常开发中，像“日志追溯”“异步工作流处理”“性能打点”这类和业务逻辑关系不大的功能，我们都可以考虑把它们抽到“切面”中去做。</p>
<h3 id="从-React-Router-切入，系统学习前端路由解决方案"><a href="#从-React-Router-切入，系统学习前端路由解决方案" class="headerlink" title="从 React-Router 切入，系统学习前端路由解决方案"></a>从 React-Router 切入，系统学习前端路由解决方案</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">// 引入 React-Router 中的相关组件</span><br><span class="line"></span><br><span class="line">import &#123; BrowserRouter as Router, Route, Link &#125; from &quot;react-router-dom&quot;;</span><br><span class="line"></span><br><span class="line">// 导出目标组件</span><br><span class="line"></span><br><span class="line">const BasicExample = () =&gt; (</span><br><span class="line"></span><br><span class="line">  // 组件最外层用 Router 包裹</span><br><span class="line"></span><br><span class="line">  &lt;Router&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div&gt;</span><br><span class="line"></span><br><span class="line">      &lt;ul&gt;</span><br><span class="line"></span><br><span class="line">        &lt;li&gt;</span><br><span class="line"></span><br><span class="line">          // 具体的标签用 Link 包裹</span><br><span class="line"></span><br><span class="line">          &lt;Link to=&quot;/&quot;&gt;Home&lt;/Link&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/li&gt;</span><br><span class="line"></span><br><span class="line">        &lt;li&gt;</span><br><span class="line"></span><br><span class="line">          // 具体的标签用 Link 包裹</span><br><span class="line"></span><br><span class="line">          &lt;Link to=&quot;/about&quot;&gt;About&lt;/Link&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/li&gt;</span><br><span class="line"></span><br><span class="line">        &lt;li&gt;</span><br><span class="line"></span><br><span class="line">          // 具体的标签用 Link 包裹</span><br><span class="line"></span><br><span class="line">          &lt;Link to=&quot;/dashboard&quot;&gt;Dashboard&lt;/Link&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/li&gt;</span><br><span class="line"></span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">      &lt;hr /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      // Route 是用于声明路由映射到应用程序的组件层</span><br><span class="line"></span><br><span class="line">      &lt;Route exact path=&quot;/&quot; component=&#123;Home&#125; /&gt;</span><br><span class="line"></span><br><span class="line">      &lt;Route path=&quot;/about&quot; component=&#123;About&#125; /&gt;</span><br><span class="line"></span><br><span class="line">      &lt;Route path=&quot;/dashboard&quot; component=&#123;Dashboard&#125; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/Router&gt;</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// Home 组件的定义</span><br><span class="line"></span><br><span class="line">const Home = () =&gt; (</span><br><span class="line"></span><br><span class="line">  &lt;div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;h2&gt;Home&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// About 组件的定义</span><br><span class="line"></span><br><span class="line">const About = () =&gt; (</span><br><span class="line"></span><br><span class="line">  &lt;div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;h2&gt;About&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// Dashboard 的定义</span><br><span class="line"></span><br><span class="line">const Dashboard = () =&gt; (</span><br><span class="line"></span><br><span class="line">  &lt;div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;h2&gt;Dashboard&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export default BasicExample;</span><br></pre></td></tr></table></figure>
<p>React-Router 支持我们使用 hash（对应 HashRouter）和 browser（对应 BrowserRouter） 两种路由规则。</p>
<ul>
<li>BrowserRouter 是使用 HTML 5 的 history API 来控制路由跳转的。</li>
<li>HashRouter 是通过 URL 的 hash 属性来控制路由跳转的。</li>
</ul>
<h2 id="“生产实践”通用法则"><a href="#“生产实践”通用法则" class="headerlink" title="“生产实践”通用法则"></a>“生产实践”通用法则</h2><h3 id="思路拓展：如何打造高性能的-React-应用？"><a href="#思路拓展：如何打造高性能的-React-应用？" class="headerlink" title="思路拓展：如何打造高性能的 React 应用？"></a>思路拓展：如何打造高性能的 React 应用？</h3><p>最关键的 3 个思路：</p>
<ul>
<li>使用 shouldComponentUpdate 规避冗余的更新逻辑</li>
<li>PureComponent + Immutable.js</li>
<li>React.memo 与 useMemo</li>
</ul>
<hr>
<p>使用 shouldComponentUpdate 来调停不必要的更新，避免无意义的 re-render 发生，这是 React 组件中最基本的性能优化手段，也是最重要的手段。</p>
<hr>
<p>PureComponent 与 Component 的区别点，就在于它内置了对 shouldComponentUpdate 的实现：PureComponent 将会在 shouldComponentUpdate 中对组件更新前后的 props 和 state 进行浅比较，并根据浅比较的结果，决定是否需要继续更新流程。</p>
<p>“浅比较”将针对值类型数据对比其值是否相等，而针对数组、对象等引用类型的数据则对比其引用是否相等。</p>
<p>在值类型数据这种场景下，PureComponent 可以说是战无不胜。但是如果数据类型为引用类型，那么这种基于浅比较的判断逻辑就会带来这样两个风险：</p>
<ul>
<li>若数据内容没变，但是引用变了，那么浅比较仍然会认为“数据发生了变化”，进而触发一次不必要的更新，导致过度渲染；</li>
<li>若数据内容变了，但是引用没变，那么浅比较则会认为“数据没有发生变化”，进而阻断一次更新，导致不渲染。</li>
</ul>
<p>怎么办呢？Immutable.js 来帮忙！</p>
<hr>
<p>Immutable 直译过来是“不可变的”，顾名思义，Immutable.js 是对“不可变值”这一思想的贯彻实践。它在 2014 年被 Facebook 团队推出，Facebook 给它的定位是“实现持久性数据结构的库”。所谓“持久性数据”，指的是这个数据只要被创建出来了，就不能被更改。我们对当前数据的任何修改动作，都会导致一个新的对象的返回。这就将数据内容的变化和数据的引用严格地关联了起来，使得“变化”无处遁形。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 引入 immutable 库里的 Map 对象，它用于创建对象</span><br><span class="line"></span><br><span class="line">import &#123; Map &#125; from &apos;immutable&apos;</span><br><span class="line"></span><br><span class="line">// 初始化一个对象 baseMap</span><br><span class="line"></span><br><span class="line">const baseMap = Map(&#123;</span><br><span class="line"></span><br><span class="line">  name: &apos;修言&apos;,</span><br><span class="line"></span><br><span class="line">  career: &apos;前端&apos;,</span><br><span class="line"></span><br><span class="line">  age: 99</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 使用 immutable 暴露的 Api 来修改 baseMap 的内容</span><br><span class="line"></span><br><span class="line">const changedMap = baseMap.set(&#123;</span><br><span class="line"></span><br><span class="line">  age: 100</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 我们会发现修改 baseMap 后将会返回一个新的对象，这个对象的引用和 baseMap 是不同的</span><br><span class="line"></span><br><span class="line">console.log(&apos;baseMap === changedMap&apos;, baseMap === changedMap)</span><br></pre></td></tr></table></figure>
<p>值得注意的是，由于 Immutable.js 存在一定的学习成本，并不是所有场景下都可以作为最优解被团队采纳。因此，一些团队也会基于 PureComonent 和 Immutable.js 去打造将两者结合的公共类，通过改写 setState 来提升研发体验，这也是不错的思路。</p>
<hr>
<p><strong>React.memo：“函数版”shouldComponentUpdate/PureComponent</strong></p>
<p>React.memo 是 React 导出的一个顶层函数，它本质上是一个高阶组件，负责对函数组件进行包装。基本的调用姿势如下面代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">// 定义一个函数组件</span><br><span class="line"></span><br><span class="line">function FunctionDemo(props) &#123;</span><br><span class="line"></span><br><span class="line">  return xxx</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// areEqual 函数是 memo 的第二个入参，我们之前放在 shouldComponentUpdate 里面的逻辑就可以转移至此处</span><br><span class="line"></span><br><span class="line">function areEqual(prevProps, nextProps) &#123;</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line"></span><br><span class="line">  return true if passing nextProps to render would return</span><br><span class="line"></span><br><span class="line">  the same result as passing prevProps to render,</span><br><span class="line"></span><br><span class="line">  otherwise return false</span><br><span class="line"></span><br><span class="line">  */</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用 React.memo 来包装函数组件</span><br><span class="line"></span><br><span class="line">export default React.memo(FunctionDemo, areEqual);</span><br></pre></td></tr></table></figure>
<p>React.memo 会帮我们“记住”函数组件的渲染结果，在组件前后两次 props 对比结果一致的情况下，它会直接复用最近一次渲染的结果。如果我们的组件在相同的 props 下会渲染相同的结果，那么使用 React.memo 来包装它将是个不错的选择。</p>
<p>从示例中我们可以看出，React.memo 接收两个参数，第一个参数是我们需要渲染的目标组件，第二个参数 areEqual 则用来承接 props 的对比逻辑。之前我们在 shouldComponentUpdate 里面做的事情，现在就可以放在 areEqual 里来做。</p>
<p>这里的 areEqual 函数是一个可选参数，当我们不传入 areEqual 时，React.memo 也可以工作，此时它的作用就类似于 PureComponent——React.memo 会自动为你的组件执行 props 的浅比较逻辑。</p>
<p><strong>useMemo：更加“精细”的 memo</strong></p>
<p>简而言之，React.memo 控制是否需要重渲染一个组件，而 useMemo 控制的则是是否需要重复执行某一段逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]);</span><br></pre></td></tr></table></figure>
<h3 id="跟-React-学设计模式：掌握编程“套路”，打造高质量应用"><a href="#跟-React-学设计模式：掌握编程“套路”，打造高质量应用" class="headerlink" title="跟 React 学设计模式：掌握编程“套路”，打造高质量应用"></a>跟 React 学设计模式：掌握编程“套路”，打造高质量应用</h3><p>在 React 设计模式中，最重要、也是最为大家所津津乐道的几个模式分别是：</p>
<ul>
<li>高阶组件（HOC）</li>
<li>Render Props</li>
<li>剥离有状态组件与无状态组件</li>
</ul>
<p>这些形态各异的 React 设计模式虽然实现思路有所不同，但本质上基本都是为了实现这样一个终极目标——以尽可能优雅的姿态，实现组件逻辑的复用。</p>
<hr>
<p><strong>高阶组件（HOC）：最经典的组件逻辑复用方式</strong></p>
<p>高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。——React 官方</p>
<p>高阶组件（Higher Order Components）在概念上沿袭了高阶函数（Higher-Order Function）。</p>
<p>这里我们再复习一下高阶函数的概念：接收函数作为输入，或者输出另一个函数的一类函数，就是高阶函数。</p>
<p>相应的，高阶组件指的就是参数为组件，返回值为新组件的函数。没错，高阶组件本质上是一个函数。下面是一个简单的高阶组件示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const withProps = (WrappedComponent) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    const targetComponent = (props) =&gt; (</span><br><span class="line"></span><br><span class="line">        &lt;div className=&quot;wrapper-container&quot;&gt;</span><br><span class="line"></span><br><span class="line">            &lt;WrappedComponent &#123;...props&#125; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    return targetComponent;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 假设 checkUserAccess 已经在 utils 文件中被封装为了一段独立的逻辑</span><br><span class="line"></span><br><span class="line">import checkUserAccess from &apos;./utils</span><br><span class="line"></span><br><span class="line">// 用高阶组件包裹目标组件</span><br><span class="line"></span><br><span class="line">const withCheckAccess = (WrappedComponent) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    // 这部分是通用的逻辑：判断用户身份是否合法</span><br><span class="line"></span><br><span class="line">    const isAccessible = checkUserAccess()  </span><br><span class="line"></span><br><span class="line">    // 将 isAccessible（是否合法） 这个信息传递给目标组件</span><br><span class="line"></span><br><span class="line">    const targetComponent = (props) =&gt; (</span><br><span class="line"></span><br><span class="line">        &lt;div className=&quot;wrapper-container&quot;&gt;</span><br><span class="line"></span><br><span class="line">            &lt;WrappedComponent &#123;...props&#125; isAccessible=&#123;isAccessible&#125; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    return targetComponent;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Render Props：逻辑复用的另一种思路</strong></p>
<p>术语“render prop”是指一种在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术。——React 官方</p>
<p>render props 是 React 中复用组件逻辑的另一种思路，它在实现上和高阶组件有异曲同工之妙——两者都是把通用的逻辑提取到某一处。区别主要在于使用层面，高阶组件的使用姿势是用“函数”包裹“组件”，而 render props 恰恰相反，它强调的是用“组件”包裹“函数”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;  </span><br><span class="line"></span><br><span class="line">const RenderChildren = (props) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  return(</span><br><span class="line"></span><br><span class="line">     &lt;React.Fragment&gt;</span><br><span class="line"></span><br><span class="line">        &#123;props.children(props)&#125;</span><br><span class="line"></span><br><span class="line">     &lt;/React.Fragment&gt;</span><br><span class="line"></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>RenderChildren 将渲染它所有的子组件。从这段代码里，你需要把握住两个要点：</p>
<ul>
<li>render props 的载体应该是一个React 组件，这一点是与高阶组件不同的（高阶组件本质是函数）；</li>
<li>render props 组件正常工作的前提是它的子组件需要以函数形式存在。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// 假设 checkUserAccess 已经在 utils 文件中被封装为了一段独立的逻辑</span><br><span class="line"></span><br><span class="line">import checkUserAccess from &apos;./utils</span><br><span class="line"></span><br><span class="line">// 定义 render props 组件</span><br><span class="line"></span><br><span class="line">const CheckAccess = (props) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    // 这部分是通用的逻辑：判断用户身份是否合法</span><br><span class="line"></span><br><span class="line">    const isAccessible = checkUserAccess()  </span><br><span class="line"></span><br><span class="line">    // 将 isAccessible（是否合法） 这个信息传递给目标组件</span><br><span class="line"></span><br><span class="line">    return &lt;React.Fragment&gt;</span><br><span class="line"></span><br><span class="line">        &#123;props.children(&#123; ...props, isAccessible &#125;)&#125;</span><br><span class="line"></span><br><span class="line">      &lt;/React.Fragment&gt;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;CheckAccess&gt;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    (props) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">      const &#123; isAccessible &#125; = props;</span><br><span class="line"></span><br><span class="line">      return &lt;ChildComponent &#123;...props&#125; isAccessible=&#123;isAccessible&#125; /&gt;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&lt;/CheckAccess&gt;</span><br></pre></td></tr></table></figure>
<p>但其实，对于  render props 这种模式来说，函数并不一定要作为子组件传入，它也可以以任意属性名传入，只要 render props 组件可以感知到它就行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// 假设 checkUserAccess 已经在 utils 文件中被封装为了一段独立的逻辑</span><br><span class="line"></span><br><span class="line">import checkUserAccess from &apos;./utils</span><br><span class="line"></span><br><span class="line">// 定义 render props 组件</span><br><span class="line"></span><br><span class="line">const CheckAccess = (props) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    // 这部分是通用的逻辑：判断用户身份是否合法</span><br><span class="line"></span><br><span class="line">    const isAccessible = checkUserAccess()  </span><br><span class="line"></span><br><span class="line">    // 将 isAccessible（是否合法） 这个信息传递给目标组件</span><br><span class="line"></span><br><span class="line">    return &lt;React.Fragment&gt;</span><br><span class="line"></span><br><span class="line">        &#123;props.checkTaget(&#123; ...props, isAccessible &#125;)&#125;</span><br><span class="line"></span><br><span class="line">      &lt;/React.Fragment&gt;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;CheckAccess</span><br><span class="line"></span><br><span class="line">    checkTaget=&#123;(props) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">      const &#123; isAccessible &#125; = props;</span><br><span class="line"></span><br><span class="line">      return &lt;ChildComponent &#123;...props&#125; isAccessible=&#123;isAccessible&#125; /&gt;</span><br><span class="line"></span><br><span class="line">    &#125;&#125;</span><br><span class="line"></span><br><span class="line">  /&gt;</span><br></pre></td></tr></table></figure>
<p>render props 和高阶组件一个非常重要的区别，在于对数据的处理上：在高阶组件中，目标组件对于数据的获取没有主动权，数据的分发逻辑全部收敛在高阶组件的内部；而在 render props 中，除了父组件可以对数据进行分发处理之外，子组件也可以选择性地对数据进行接收。</p>
<p>事实上，在软件设计模式中，有一个非常重要的原则，叫“开放封闭原则”。一个好的模式，应该尽可能做到对拓展开放，对修改封闭。</p>
<p>当我们发现 withCheckAccess 的内部逻辑需要频繁地跟随需求的变化而变化时，此时就应该提高警惕了，因为这已经违反了“对修改封闭”这一原则。</p>
<p>处理同样的需求，render props 就能够在保全“开放封闭”原则的基础上，帮我们达到目的。</p>
<hr>
<p><strong>有状态组件与无状态组件：“单一职责”原则在组件设计模式中的实践</strong></p>
<p>就 React 来说，无论是高阶组件，还是 render props，两者的出现都是为了弥补类组件在“逻辑复用”这个层面的不灵活性。它们各自都有着自己的不足，这些不足包括但不限于以下几点：</p>
<ul>
<li>嵌套地狱问题，当嵌套层级过多后，数据源的追溯会变得十分困难</li>
<li>较高的学习成本</li>
<li>props 属性命名冲突问题</li>
</ul>
<p>总体来看，“HOC/render props+类组件”这种研发模式，还是不够到位。当设计模式解决不了问题时，我们本能地需要从编程模式上寻找答案。于是便有了如今大家在 React 中所看到的 “函数式编程”对“面向对象”的补充（并且大有替代之势），有了今天我们所看到的“一切皆可 Hooks”的大趋势。</p>
<p>现在，当我们想要去复用一段逻辑时，第一反应肯定不是“高阶函数”或者“render props”，而应该是“自定义 Hook”。Hooks 能够很好地规避掉旧时类组件中各种设计模式带来的弊端，比如说它不存在嵌套地狱，允许属性重命名、允许我们在任何需要它的地方引入并访问目标状态等。</p>
<h2 id="聊聊-React-17，谈谈学习前端框架的心法"><a href="#聊聊-React-17，谈谈学习前端框架的心法" class="headerlink" title="聊聊 React 17，谈谈学习前端框架的心法"></a>聊聊 React 17，谈谈学习前端框架的心法</h2><p>React 17 中没有新特性，这是由它的定位决定的。React 17 的定位是后续 18、19 等更新版本的“基石”，它是一个“承上启下”的版本，用官方的说法来说，“React v17 开启了 React 渐进式升级的新篇章”。</p>
<p>事实上，React 17 中仍然有不少值得我们关注的用户侧改变，个人认为最重要的是以下三点：</p>
<ul>
<li>新的 JSX 转换逻辑</li>
<li>事件系统重构</li>
<li>Lane 模型的引入</li>
</ul>
<hr>
<p><strong>重构 JSX 转换逻辑</strong></p>
<p>在过去，如果我们在 React 项目中写入下面这样的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function MyComponent() &#123;</span><br><span class="line"></span><br><span class="line">  return &lt;p&gt;这是我的组件&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>React 是会报错的，原因是 React 中对 JSX 代码的转换依赖的是 React.createElement 这个函数。因此但凡我们在代码中包含了 JSX，那么就必须在文件中引入 React，像下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">function MyComponent() &#123;</span><br><span class="line"></span><br><span class="line">  return &lt;p&gt;这是我的组件&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而 React 17 则允许我们在不引入 React 的情况下直接使用 JSX。这是因为在 React 17 中，编译器会自动帮我们引入 JSX 的解析器，也就是说像下面这样一段逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function MyComponent() &#123;</span><br><span class="line"></span><br><span class="line">  return &lt;p&gt;这是我的组件&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会被编译器转换成这个样子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123;jsx as _jsx&#125; from &apos;react/jsx-runtime&apos;;</span><br><span class="line"></span><br><span class="line">function MyComponent() &#123;</span><br><span class="line"></span><br><span class="line">  return _jsx(&apos;p&apos;, &#123; children: &apos;这是我的组件&apos; &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>事件系统重构</strong></p>
<p>事件系统在 React 17 中的重构要从以下两个方面来看：</p>
<ul>
<li>卸掉历史包袱</li>
<li>拥抱新的潮流</li>
</ul>
<hr>
<blockquote>
<p>卸掉历史包袱：放弃利用 document 来做事件的中心化管控</p>
</blockquote>
<p>document 是整个文档树的根节点，操作 document 带来的影响范围实在是太大了，这将会使事情变得更加不可控。</p>
<p>document 是一个全局的概念，而组件只是全局的一个部分。由 React 组件引入的 React 事件系统，理论上看和组件绑在一起是最合适的，不应该将影响范围扩大到全局。</p>
<p>在 React 17 中，React 团队终于正面解决了这个问题：事件的中心化管控不会再全部依赖 document，管控相关的逻辑被转移到了每个 React 组件自己的容器 DOM 节点中。比如说我们在 ID 为 root 的 DOM 节点下挂载了一个 React 组件，像下面代码这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const rootElement = document.getElementById(&quot;root&quot;);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;App /&gt;, rootElement);</span><br></pre></td></tr></table></figure>
<p>那么事件管控相关的逻辑就会被安装到 root 节点上去。这样一来， React 组件就能够自己玩自己的，再也无法对全局的事件流构成威胁了。</p>
<blockquote>
<p>拥抱新的潮流：放弃事件池</p>
</blockquote>
<p>在 React 17 之前，合成事件对象会被放进一个叫作“事件池”的地方统一管理。这样做的目的是能够实现事件对象的复用，进而提高性能：每当事件处理函数执行完毕后，其对应的合成事件对象内部的所有属性都会被置空，意在为下一次被复用做准备。这也就意味着事件逻辑一旦执行完毕，我们就拿不到事件对象了，React 官方给出的这个例子就很能说明问题，请看下面这个代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function handleChange(e) &#123;</span><br><span class="line"></span><br><span class="line">  // This won&apos;t work because the event object gets reused.</span><br><span class="line"></span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    console.log(e.target.value); // Too late!</span><br><span class="line"></span><br><span class="line">  &#125;, 100);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>异步执行的 setTimeout 回调会在 handleChange 这个事件处理函数执行完毕后执行，因此它拿不到想要的那个事件对象 e。</p>
<p>事件池的这个设计，虽然利好了性能，却整懵了用户。很多人只有在写过无数 Bug 之后，才会后知后觉地发现，要想拿到目标事件对象，必须显式地告诉 React——我永远需要它，也就是调用 e.persist() 函数，像下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function handleChange(e) &#123;</span><br><span class="line"></span><br><span class="line">  // Prevents React from resetting its properties:</span><br><span class="line"></span><br><span class="line">  e.persist();</span><br><span class="line"></span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    console.log(e.target.value); // Works</span><br><span class="line"></span><br><span class="line">  &#125;, 100);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在旧版本中，React 这样做在很大程度上是希望能能够对部分性能一般的老浏览器进行向下兼容。</p>
<p>但随着时代的发展，如今市面上的浏览器虽不能说是性能绝佳，但基本上也不会因为事件池里的对象多几个少几个就给你表演内存泄漏。因此，React 17 拥抱了新时代的潮流，重新在研发体验和向下兼容性能之间做了选择，这一次，它选择了前者——放弃事件池，为每一个合成事件创建新的对象。</p>
<p>因此在 React 17 中，我们不需要 e.persist()，也可以随时随地访问我们想要的事件对象。</p>
<blockquote>
<p>Lane 模型的引入</p>
</blockquote>
<p>React 16 中处理优先级采用的是 expirationTime 模型。</p>
<p>expirationTime 模型使用 expirationTime（一个时间长度） 来描述任务的优先级；而 Lane 模型则使用二进制数来表示任务的优先级。</p>
<p>lane 模型通过将不同优先级赋值给一个位，通过 31 位的位运算来操作优先级。</p>
<p>Lane 模型提供了一个新的优先级排序的思路，相对于 expirationTime 来说，它对优先级的处理会更细腻，能够覆盖更多的边界条件。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/学习/">学习</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/学习/">学习</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-vue3" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/01/01/vue3/" class="article-date">
      <time datetime="2021-12-31T16:00:00.000Z" itemprop="datePublished">2022-01-01</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/01/01/vue3/">玩转vue3全家桶</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="宏观视角：从前端框架发展史聊聊为什么要学-Vue-3？"><a href="#宏观视角：从前端框架发展史聊聊为什么要学-Vue-3？" class="headerlink" title="宏观视角：从前端框架发展史聊聊为什么要学 Vue 3？"></a>宏观视角：从前端框架发展史聊聊为什么要学 Vue 3？</h2><h3 id="Vue-与-React-框架的对比"><a href="#Vue-与-React-框架的对比" class="headerlink" title="Vue 与 React 框架的对比"></a>Vue 与 React 框架的对比</h3><p>在 Vue 框架下，如果数据变了，那框架会主动告诉你修改了哪些数据；而 React 的数据变化后，我们只能通过新老数据的计算 Diff 来得知数据的变化。</p>
<p>对于 Vue 来说，它的一个核心就是“响应式”，也就是数据变化后，会主动通知我们。响应式数据新建 Watcher 监听，本身就比较损耗性能，项目大了之后每个数据都有一个 watcher 会影响性能。对于 React 的虚拟 DOM 的 Diff 计算逻辑来说，如果虚拟 DOM 树过于庞大，使得计算时间大于 16.6ms，那么就可能会造成性能的卡顿。</p>
<p>React 为了突破性能瓶颈，借鉴了操作系统时间分片的概念，引入了 Fiber 架构。通俗来说，就是把整个虚拟 DOM 树微观化，变成链表，然后我们利用浏览器的空闲时间计算 Diff。一旦浏览器有需求，我们可以把没计算完的任务放在一旁，把主进程控制权还给浏览器，等待浏览器下次空闲。这种架构虽然没有减少运算量，但是巧妙地利用空闲实现计算，解决了卡顿的问题。高性能的动画要求是 60fps，也就是 1 秒要渲染 60 次，每一帧的时间就是 16.6 毫秒，在这 16.6 毫秒里，浏览器自己的渲染更新任务执行后，会有一部分的空闲时间，这段时间我们就用来计算 Diff。等到下一帧任务来了，我们就把控制权还给浏览器，让它继续去更新和渲染，等待空闲时间再继续计算，这样就不会导致卡顿。</p>
<p>Vue 1 的问题在于响应式数据过多，这样会带来内存占用过多的问题。所以 Vue 2 大胆引入虚拟 DOM 来解决响应式数据过多的问题。这个解决方案使用虚拟 DOM 解决了响应式数据过多的内存占用问题，又良好地规避了 React 中虚拟 DOM 的问题， 还通过虚拟 DOM 给 Vue 带来了跨端的能力。响应式数据是主动推送变化，虚拟 DOM 是被动计算数据的 Diff，一个推一个拉，它们看起来是两个方向的技术，但被 Vue 2 很好地融合在一起，采用的方式就是组件级别的划分。对于 Vue 2 来说，组件之间的变化，可以通过响应式来通知更新。组件内部的数据变化，则通过虚拟 DOM 去更新页面。这样就把响应式的监听器，控制在了组件级别，而虚拟 DOM 的量级，也控制在了组件的大小。这个方案也体现了 Vue 一直以来坚持的中庸的设计思想。</p>
<p>除了响应式和虚拟 DOM 这个维度，Vue 和 React 还有一些理念和路线的不同，在模板的书写上，也走出了 template 和 JSX 两个路线。</p>
<p>React 的世界里只有 JSX，最终 JSX 都会在 Compiler 那一层，也就是工程化那里编译成 JS 来执行，所以 React 最终拥有了全部 JS 的动态性，这也导致了 React 的 API 一直很少，只有 state、hooks、Component 几个概念，主要都是 JavaScript 本身的语法和特性。</p>
<p>而 Vue 的世界默认是 template，也就是语法是限定死的，比如 v-if 和 v-for 等语法。有了这些写法的规矩后，我们可以在上线前做很多优化。Vue 3 很优秀的一个点，就是在虚拟 DOM 的静态标记上做到了极致，让静态的部分越过虚拟 DOM 的计算，真正做到了按需更新，很好的提高了性能。</p>
<p>在模板的书写上，除了 Vue 和 React 走出的 template 和 JSX 两个路线，还出现了 Svelte 这种框架，没有虚拟 DOM 的库，直接把模板编译成原生 DOM，几乎没有 Runtime，所有的逻辑都在 Compiler 层优化，算是另外一个极致。</p>
<p>在你看来，Vue 需不需要 React 的 Fiber 呢？<br>最早 Vue3 的提案其实是包含时间切片方案的，最后废弃的主要原因，是时间切片解决的的问题，Vue3 基本碰不到：<br>Vue3 把虚拟 Dom 控制在组件级别，组件之间使用响应式，这就让 Vue3 的虚拟 Dom 不会过于庞大<br>Vue3 虚拟 Dom 的静态标记和自动缓存功能，让静态的节点和属性可以直接绕过 Diff 逻辑，也大大减少了虚拟 Dom 的 Diff 事件<br>时间切片也会带来额外的系统复杂性<br>所以引入时间切片对于 Vue3 来说投入产出比不太理想，在后来的讨论中，Vue3 的时间切片方案就被废弃了</p>
<h2 id="新特性：初探-Vue-3-新特性"><a href="#新特性：初探-Vue-3-新特性" class="headerlink" title="新特性：初探 Vue 3 新特性"></a>新特性：初探 Vue 3 新特性</h2><p>下面列举了一些 Vue 2 常见的缺陷，你可以对照你的实际开发经验，看看是否也遇到过这些问题：<br>从开发维护的角度看，Vue 2 是使用 Flow.js 来做类型校验。但现在 Flow.js 已经停止维护了，整个社区都在全面使用 TypeScript 来构建基础库，Vue 团队也不例外。<br>从社区的二次开发难度来说，Vue 2 内部运行时，是直接执行浏览器 API 的。但这样就会在 Vue 2 的跨端方案中带来问题，要么直接进入 Vue 源码中，和 Vue 一起维护，比如 Vue 2 中你就能见到 Weex 的文件夹。<br>从我们普通开发者的角度来说，Vue 2 响应式并不是真正意义上的代理，而是基于 Object.defineProperty() 实现的。<br>这个 API 并不是代理，而是对某个属性进行拦截，所以有很多缺陷，比如：删除数据就无法监听，需要 $delete 等 API 辅助才能监听到。并且，Option API 在组织代码较多组件的时候不易维护。对于 Option API 来说，所有的 methods、computed 都在一个对象里配置，这对小应用来说还好。但代码超过 300 行的时候，新增或者修改一个功能，就需要不停地在 data，methods 里跳转写代码，我称之为上下反复横跳。</p>
<h3 id="响应式系统"><a href="#响应式系统" class="headerlink" title="响应式系统"></a>响应式系统</h3><p>Vue 2 的响应式机制是基于 Object.defineProperty() 这个 API 实现的，此外，Vue 还使用了 Proxy，这两者看起来都像是对数据的读写进行拦截，但是 defineProperty 是拦截具体某个属性，Proxy 才是真正的“代理”。</p>
<h3 id="自定义渲染器"><a href="#自定义渲染器" class="headerlink" title="自定义渲染器"></a>自定义渲染器</h3><p>Vue 2 内部所有的模块都是揉在一起的，这样做会导致不好扩展的问题，刚才我也提到了这一点。Vue 3 是怎么解决这个问题的呢？那就是拆包，使用最近流行的 monorepo 管理方式，响应式、编译和运行时全部独立了。</p>
<p>在 Vue 3 的组织架构中，响应式独立了出来。而 Vue 2 的响应式只服务于 Vue，Vue 3 的响应式就和 Vue 解耦了，你甚至可以在 Node.js 和 React 中使用响应式。</p>
<p>渲染的逻辑也拆成了平台无关渲染逻辑和浏览器渲染 API 两部分 。</p>
<h3 id="全部模块使用-TypeScript-重构"><a href="#全部模块使用-TypeScript-重构" class="headerlink" title="全部模块使用 TypeScript 重构"></a>全部模块使用 TypeScript 重构</h3><p>类型系统带来了更方便的提示，并且让我们的代码能够更健壮。</p>
<p>Vue 2 那个时代基本只有两个技术选型，Facebook 家的 Flow.js 和微软家的 TypeScript。Vue 2 选 Flow.js 没问题，但是现在 Flow.js 被抛弃了。Vue 3 选择了 TypeScript，TypeScript 官方也对使用 TypeScript 开发 Vue 3 项目的团队也更加友好。</p>
<h3 id="Composition-API-组合语法"><a href="#Composition-API-组合语法" class="headerlink" title="Composition API 组合语法"></a>Composition API 组合语法</h3><p>Options API 的写法也有几个很严重的问题：<br>由于所有数据都挂载在 this 之上，因而 Options API 的写法对 TypeScript 的类型推导很不友好，并且这样也不好做 Tree-shaking 清理代码。<br>新增功能基本都得修改 data、method 等配置，并且代码上 300 行之后，会经常上下反复横跳，开发很痛苦。<br>代码不好复用，Vue 2 的组件很难抽离通用逻辑，只能使用 mixin，还会带来命名冲突的问题。</p>
<p>Composition API 后，虽然看起来烦琐了一些，但是带来了诸多好处：<br>所有 API 都是 import 引入的。用到的功能都 import 进来，对 Tree-shaking 很友好，我的例子里没用到功能，打包的时候会被清理掉 ，减小包的大小。<br>不再上下反复横跳，我们可以把一个功能模块的 methods、data 都放在一起书写，维护更轻松。<br>代码方便复用，可以把一个功能所有的 methods、data 封装在一个独立的函数里，复用代码非常容易。<br>Composition API 新增的 return 等语句，在实际项目中使用 <code>&lt;script setup&gt;</code> 特性可以清除， 我们后续项目中都会用到这样的操作。</p>
<h3 id="新的组件"><a href="#新的组件" class="headerlink" title="新的组件"></a>新的组件</h3><p>Fragment: Vue 3 组件不再要求有一个唯一的根节点，清除了很多无用的占位 div。<br>Teleport: 允许组件渲染在别的元素内，主要开发弹窗组件的时候特别有用。<br>Suspense: 异步组件，更方便开发有异步请求的组件。</p>
<h3 id="新一代工程化工具-Vite"><a href="#新一代工程化工具-Vite" class="headerlink" title="新一代工程化工具 Vite"></a>新一代工程化工具 Vite</h3><p>Vite 主要提升的是开发的体验，Webpack 等工程化工具的原理，就是根据你的 import 依赖逻辑，形成一个依赖图，然后调用对应的处理工具，把整个项目打包后，放在内存里再启动调试。</p>
<p>具体来说，在调试环境下，我们不需要全部预打包，只是把你首页依赖的文件，依次通过网络请求去获取，整个开发体验得到巨大提升，做到了复杂项目的秒级调试和热更新。</p>
<h2 id="巧妙的响应式：深入理解-Vue-3-的响应式机制"><a href="#巧妙的响应式：深入理解-Vue-3-的响应式机制" class="headerlink" title="巧妙的响应式：深入理解 Vue 3 的响应式机制"></a>巧妙的响应式：深入理解 Vue 3 的响应式机制</h2><p>Vue 中用过三种响应式解决方案，分别是 defineProperty、Proxy 和 value setter。</p>
<p>有了 Proxy 后，响应式机制就比较完备了。但是在 Vue 3 中还有另一个响应式实现的逻辑，就是利用对象的 get 和 set 函数来进行监听，这种响应式的实现方式，只能拦截某一个属性的修改，这也是 Vue 3 中 ref 这个 API 的实现。在下面的代码中，我们拦截了 count 的 value 属性，并且拦截了 set 操作，也能实现类似的功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let getDouble = n =&gt; n * 2</span><br><span class="line">let _value = 1</span><br><span class="line">double = getDouble(_value)</span><br><span class="line"></span><br><span class="line">let count = &#123;</span><br><span class="line">  get value() &#123;</span><br><span class="line">    return _value</span><br><span class="line">  &#125;,</span><br><span class="line">  set value(val) &#123;</span><br><span class="line">    _value = val</span><br><span class="line">    double = getDouble(_value)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(count.value,double)</span><br><span class="line">count.value = 2</span><br><span class="line">console.log(count.value,double)</span><br></pre></td></tr></table></figure>
<h2 id="数据流：如何使用-Vuex-设计你的数据流"><a href="#数据流：如何使用-Vuex-设计你的数据流" class="headerlink" title="数据流：如何使用 Vuex 设计你的数据流"></a>数据流：如何使用 Vuex 设计你的数据流</h2><p>对于一个数据，如果只是组件内部使用就是用 ref 管理；如果我们需要跨组件，跨页面共享的时候，我们就需要把数据从 Vue 的组件内部抽离出来，放在 Vuex 中去管理。</p>
<h3 id="手写迷你-Vuex"><a href="#手写迷你-Vuex" class="headerlink" title="手写迷你 Vuex"></a>手写迷你 Vuex</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import &#123; inject, reactive &#125; from &apos;vue&apos;</span><br><span class="line"></span><br><span class="line">const STORE_KEY = &apos;__store__&apos;</span><br><span class="line">function useStore() &#123;</span><br><span class="line">  return inject(STORE_KEY)</span><br><span class="line">&#125;</span><br><span class="line">function createStore(options) &#123;</span><br><span class="line">  return new Store(options)</span><br><span class="line">&#125;</span><br><span class="line">class Store &#123;</span><br><span class="line">  constructor(options) &#123;</span><br><span class="line">    this._state = reactive(&#123;</span><br><span class="line">      data: options.state()</span><br><span class="line">    &#125;)</span><br><span class="line">    this._mutations = options.mutations</span><br><span class="line">  &#125;</span><br><span class="line">  get state() &#123;</span><br><span class="line">       return this._state.data</span><br><span class="line">  &#125;</span><br><span class="line">  commit = (type, payload) =&gt; &#123;</span><br><span class="line">  const entry = this._mutations[type]</span><br><span class="line">  entry &amp;&amp; entry(this.state, payload)</span><br><span class="line">  &#125;</span><br><span class="line">  // main.js入口处app.use(store)的时候，会执行这个函数</span><br><span class="line">  install(app) &#123; app.provide(STORE_KEY, this) &#125;</span><br><span class="line">&#125;</span><br><span class="line">export &#123; createStore, useStore &#125;</span><br></pre></td></tr></table></figure>
<h2 id="路由：新一代-vue-router-带来什么变化"><a href="#路由：新一代-vue-router-带来什么变化" class="headerlink" title="路由：新一代 vue-router 带来什么变化"></a>路由：新一代 vue-router 带来什么变化</h2><h3 id="手写迷你-vue-router"><a href="#手写迷你-vue-router" class="headerlink" title="手写迷你 vue-router"></a>手写迷你 vue-router</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import &#123;ref,inject&#125; from &apos;vue&apos;</span><br><span class="line">import RouterLink from &apos;./RouterLink.vue&apos;</span><br><span class="line">import RouterView from &apos;./RouterView.vue&apos;</span><br><span class="line">const ROUTER_KEY = &apos;__router__&apos;</span><br><span class="line"></span><br><span class="line">function createRouter(options)&#123;</span><br><span class="line">    return new Router(options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function useRouter()&#123;</span><br><span class="line">    return inject(ROUTER_KEY)</span><br><span class="line">&#125;</span><br><span class="line">function createWebHashHistory()&#123;</span><br><span class="line">    function bindEvents(fn)&#123;</span><br><span class="line">        window.addEventListener(&apos;hashchange&apos;,fn)</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;</span><br><span class="line">        bindEvents,</span><br><span class="line">        url:window.location.hash.slice(1) || &apos;/&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Router&#123;</span><br><span class="line">    constructor(options)&#123;</span><br><span class="line">        this.history = options.history</span><br><span class="line">        this.routes = options.routes</span><br><span class="line">        this.current = ref(this.history.url)</span><br><span class="line"></span><br><span class="line">        this.history.bindEvents(()=&gt;&#123;</span><br><span class="line">            this.current.value = window.location.hash.slice(1)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    install(app)&#123;</span><br><span class="line">        app.provide(ROUTER_KEY,this)</span><br><span class="line">        app.component(&quot;router-link&quot;,RouterLink)</span><br><span class="line">        app.component(&quot;router-view&quot;,RouterView)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export &#123;createRouter,createWebHashHistory,useRouter&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;component :is=&quot;comp&quot;&gt;&lt;/component&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line"></span><br><span class="line">import &#123;computed &#125; from &apos;vue&apos;</span><br><span class="line">import &#123; useRouter &#125; from &apos;../router/index&apos;</span><br><span class="line"></span><br><span class="line">let router = useRouter()</span><br><span class="line"></span><br><span class="line">const comp = computed(()=&gt;&#123;</span><br><span class="line">    const route = router.routes.find(</span><br><span class="line">        (route) =&gt; route.path === router.current.value</span><br><span class="line">    )</span><br><span class="line">    return route?route.component : null</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="什么是好的项目？"><a href="#什么是好的项目？" class="headerlink" title="什么是好的项目？"></a>什么是好的项目？</h2><h3 id="给项目骨干开发者的优化建议"><a href="#给项目骨干开发者的优化建议" class="headerlink" title="给项目骨干开发者的优化建议"></a>给项目骨干开发者的优化建议</h3><p>首先你会发现，一旦团队项目里多个项目之间的配置或者规范不同步，那么每个项目的配置都需要手动修改，而这很浪费时间。所以，你可以发起了一个团队的脚手架项目，把项目中的代码规范、Vite 配置，log 等等都集成在脚手架内部，通过这样的方式，可以提高项目的启动效率，这算是一个亮点。</p>
<p>然后，很多时候，公司多个项目之间会有代码复用和组件复用的需求。这时，你就可以再发起一个基础组件库的项目，做出一个类似 Element3 的基础组件库，并且发布在公司的 npm 服务之上，提供给全公司前端使用。为了让大家用这个组件库的时候能放心，你可以给组件库实现完备的文档系统以及超过 90% 的单测覆盖率，这也能够作为你的亮点。</p>
<p>前端项目的上线需要和后端服务器打交道，为了提高发布和部署的效率，你可以发起了一个 CI/CD 的项目，利用 GitHub 的 action 机制，可以把整个发布过程自动化，并且还可以一键回滚。这样日常开发的需求变更是非常快的，每一个流程的自动化都能够提高团队整体的研发效率。而且这个 CI/CD 系统里还需要能够解决需求频繁变更的问题，以及版本迭代的需求，这些优化项的解决，都能够让整个项目更稳定地交付。</p>
<p>你还可以复盘你现在负责的业务类型，如果你负责营销组，那么面对繁多的营销页面时，你可以搭建一个 Low Code 系统，让运营同学和产品同学自己通过拖拽的方式配置出营销页面。在这个过程中，你需要解决搭建系统时的一系列问题，比如：如何设计物料系统、如何实现跨端搭建系统等等。</p>
<p>然后从项目运行性能和稳定性的角度来看，我们可以制定项目的性能指标，开发项目的性能监控系统，来实时监控客户端的性能，当页面有严重的性能问题或者报错的时候，能够及时通知我们。并且除了常见的性能优化策略之外，我们还可以分析用户访问日志，提前预测用户可能访问的页面，从而做路由级别的预加载等等。</p>
<p>作为项目负责人来说，你要能够在整体上推动项目向前，提高团队整体的研发效率就是你做的项目最大的亮点。</p>
<p>其实面试官问你做过什么项目，目的就是想通过你做的项目，挖掘出你的技术亮点，所以不要一句“我做过 XXX 项目”一闪而过，我们可以尝试使用 STAR 原则去描述项目。所谓 STAR 原则，即 Situation（情景）、Task（任务）、Action（行动）和 Result（结果）四个英文单词的首字母组合，也就是你在什么情景下、遇见了什么任务、做了什么动作，拿到了怎样的结果，结果中最好还能带上数字展示，这样你的项目的描述就会很饱满。</p>
<h2 id="如何打包发布你的-Vue-3-应用？"><a href="#如何打包发布你的-Vue-3-应用？" class="headerlink" title="如何打包发布你的 Vue 3 应用？"></a>如何打包发布你的 Vue 3 应用？</h2><p>首先，我们需要一台独立的机器去进行打包和构建的操作，这台机器需要独立于所有开发环境，这样做是为了保证打包环境的稳定；之后，在部署任务启动的时候，我们需要拉取远程的代码，并且切换到需要部署的分支，然后锁定 Node 版本进行依赖安装、单元测试、ESLint 等代码检查工作；最后，在这台机器上，执行经过编译产出的打包后的代码，并打包上传代码到 CDN 和静态服务器。当然了，完成这些操作之后，还要能通过脚本自动通过内部沟通软件通知团队项目构建的结果。</p>
<p>为了减少上线时，部署操作对用户造成的影响，我们需要先选择一部分用户去做灰度测试，也就是说，上线后的项目的访问权限，暂时只对这些用户开放。或者，你也可以做一些 AB 测试，比如给北京的同学推送 Vue 课，给上海的同学推荐 React 课等等。我们需要做的，就是把不同版本的代码分开打包，互不干涉。之后，我们再设计部署的机器和机房去适配不同的用户。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">name: 打包应用的actions</span><br><span class="line">on:</span><br><span class="line">  push: # 监听代码时间</span><br><span class="line">    branches:</span><br><span class="line">      - master  # master分支代码推送的时候激活当前action</span><br><span class="line">jobs:</span><br><span class="line">  build:</span><br><span class="line">    # runs-on 操作系统</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    steps:</span><br><span class="line">      - name: 迁出代码</span><br><span class="line">        uses: actions/checkout@master</span><br><span class="line">      # 安装Node</span><br><span class="line">      - name: 安装Node</span><br><span class="line">        uses: actions/setup-node@v1</span><br><span class="line">        with:</span><br><span class="line">          node-version: 14.7.6</span><br><span class="line">      # 安装依赖</span><br><span class="line">      - name: 安装依赖</span><br><span class="line">        run: npm install</span><br><span class="line">      # 打包</span><br><span class="line">      - name: 打包</span><br><span class="line">        run: npm run build</span><br></pre></td></tr></table></figure>
<p>然后，我们需要配置上线服务器和 GitHub Actions 服务器的信任关系，通过 SSH 密钥可以实现免登录直接部署。我们直接把 build 之后的代码打包压缩，通过 SSH 直接上传到服务器上，并且要进行代码文件版本的管理，就完成了代码的部署。</p>
<h2 id="如何设计你自己的通用组件库？"><a href="#如何设计你自己的通用组件库？" class="headerlink" title="如何设计你自己的通用组件库？"></a>如何设计你自己的通用组件库？</h2><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>husky 这个库可以很方便地帮助我们设置 Git 的钩子函数，可以允许我们在代码提交之前进行代码质量的监测。<br>下面的代码中，我们首先安装和初始化了 husky，然后我们使用 npx husky add 命令新增了 commit-msg 钩子，husky 会在我们执行 git commit 提交代码的时候执行 node scripts/verifyCommit 命令来校验 commit 信息格式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">npm install -D husky # 安装husky</span><br><span class="line">npx husky install    # 初始化husky</span><br><span class="line"># 新增commit msg钩子</span><br><span class="line">npx husky add .husky/commit-msg &quot;node scripts/verifyCommit.js&quot;</span><br></pre></td></tr></table></figure>
<p>然后我们来到项目目录下的 verifyCommit 文件。在下面的代码中，我们先去 .git/COMMIT_EDITMSG 文件中读取了 commit 提交的信息，然后使用了正则去校验提交信息的格式。如果 commit 的信息不符合要求，会直接报错并且终止代码的提交。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const msg = require(&apos;fs&apos;)</span><br><span class="line">  .readFileSync(&apos;.git/COMMIT_EDITMSG&apos;, &apos;utf-8&apos;)</span><br><span class="line">  .trim()</span><br><span class="line"></span><br><span class="line">const commitRE = /^(revert: )?(feat|fix|docs|dx|style|refactor|perf|test|workflow|build|ci|chore|types|wip|release)(\(.+\))?: .&#123;1,50&#125;/</span><br><span class="line">const mergeRe = /^(Merge pull request|Merge branch)/</span><br><span class="line">if (!commitRE.test(msg)) &#123;</span><br><span class="line">  if(!mergeRe.test(msg))&#123;</span><br><span class="line">    console.log(&apos;git commit信息校验不通过&apos;)</span><br><span class="line"></span><br><span class="line">    console.error(`git commit的信息格式不对, 需要使用 title(scope): desc的格式</span><br><span class="line">      比如 fix: xxbug</span><br><span class="line">      feat(test): add new</span><br><span class="line">      具体校验逻辑看 scripts/verifyCommit.js</span><br><span class="line">    `)</span><br><span class="line">    process.exit(1)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;else&#123;</span><br><span class="line">  console.log(&apos;git commit信息校验通过&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就确保在 GitHub 中的提交日志都符合 type(scope): message 的格式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">feat: 新功能</span><br><span class="line">fix: 修改 bug</span><br><span class="line">docs: 文档</span><br><span class="line">perf: 性能相关</span><br><span class="line">refactor: 代码重构（就是不影响使用，内部结构的调整）</span><br><span class="line">test: 测试用例</span><br><span class="line">style: 样式修改</span><br><span class="line">workflow: 工作流</span><br><span class="line">build: 项目打包构建相关的配置修改</span><br><span class="line">ci: 持续集成相关</span><br><span class="line">revert: 恢复上一次提交（回滚）</span><br><span class="line">wip: work in progress 工作中 还没完成</span><br><span class="line">chore: 其他修改（不在上述类型中的修改）</span><br><span class="line">release: 发版</span><br><span class="line">deps: 依赖相关的修改</span><br></pre></td></tr></table></figure>
<p>commit-msg 是代码执行提交的时候执行的，我们还可以使用代码执行之前的钩子 pre-commit 去执行 ESLint 代码格式。这样我们在执行 git commit 的同时，就会首先进行 ESLint 校验，然后执行 commit 的 log 信息格式检查，全部通过后代码才能提交至 Git，这也是现在业界通用的解决方案。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">npx husky add .husky/pre-commit &quot;npm run lint&quot;</span><br></pre></td></tr></table></figure>
<h3 id="布局组件"><a href="#布局组件" class="headerlink" title="布局组件"></a>布局组件</h3><p>我们可以参考 Element3 组件列表页面，这里的组件分成了基础组件、表单组件、数据组件、通知组件、导航组件和其他组件几个类型，这些类型基本覆盖了组件库的适用场景，项目中的业务组件也是由这些类型组件拼接而来的。</p>
<p>我们在 src/styles 下面新建 mixin.scss。在下面的代码中，我们定义了 namespace 变量为 el，使用 Mixin 注册一个可以重复使用的模块 b，可以通过传进来的 block 生成新的变量 $B，并且变量会渲染在 class 上，并且注册了 when 可以新增 class 选择器，实现多个 class 的样式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">// bem</span><br><span class="line"></span><br><span class="line">$namespace: &apos;el&apos;;</span><br><span class="line">@mixin b($block) &#123;</span><br><span class="line">  $B: $namespace + &apos;-&apos; + $block !global;</span><br><span class="line">  .#&#123;$B&#125; &#123;</span><br><span class="line">    @content;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 添加ben后缀啥的</span><br><span class="line">@mixin when($state) &#123;</span><br><span class="line">  @at-root &#123;</span><br><span class="line">    &amp;.#&#123;$state-prefix + $state&#125; &#123;</span><br><span class="line">      @content;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;style lang=&quot;scss&quot;&gt;</span><br><span class="line">@import &apos;../styles/mixin&apos;;</span><br><span class="line">@include b(container) &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  flex-direction: row;</span><br><span class="line">  flex: 1;</span><br><span class="line">  flex-basis: auto;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">  min-width: 0;</span><br><span class="line">  @include when(vertical) &#123;</span><br><span class="line">    flex-direction: column;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.el-container &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  flex-direction: row;</span><br><span class="line">  flex: 1;</span><br><span class="line">  flex-basis: auto;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">  min-width: 0;</span><br><span class="line">&#125;</span><br><span class="line">.el-container.is-vertical &#123;</span><br><span class="line">  flex-direction: column;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import &#123;App&#125; from &apos;vue&apos;</span><br><span class="line">import ElContainer from &apos;./Container.vue&apos;</span><br><span class="line">import ElHeader from &apos;./Header.vue&apos;</span><br><span class="line">import ElFooter from &apos;./Footer.vue&apos;</span><br><span class="line">import ElAside from &apos;./Aside.vue&apos;</span><br><span class="line">import ElMain from &apos;./Main.vue&apos;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  install(app:App)&#123;</span><br><span class="line">    app.component(ElContainer.name,ElContainer)</span><br><span class="line">    app.component(ElHeader.name,ElHeader)</span><br><span class="line">    app.component(ElFooter.name,ElFooter)</span><br><span class="line">    app.component(ElAside.name,ElAside)</span><br><span class="line">    app.component(ElMain.name,ElMain)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="如何使用-TDD-开发一个组件？"><a href="#如何使用-TDD-开发一个组件？" class="headerlink" title="如何使用 TDD 开发一个组件？"></a>如何使用 TDD 开发一个组件？</h2><p>我们选择 Facebook 出品的 Jest 作为我们组件库的测试代码，Jest 是现在做测试的最佳选择了，因为它内置了断言、测试覆盖率等功能。<br>通过命令行执行下面的命令，vue-jest 和 @vue/test-utils 是测试 Vue 组件必备的库，然后安装 babel 相关的库，最后安装 Jest 适配 TypeScript 的库。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">npm install -D jest@26 vue-jest@next @vue/test-utils@next</span><br><span class="line">npm install -D babel-jest@26 @babel/core @babel/preset-env</span><br><span class="line">npm install -D ts-jest@26 @babel/preset-typescript @types/jest</span><br></pre></td></tr></table></figure>
<p>安装完毕后，我们要在根目录下新建.babel.config.js。下面的配置目的是让 babel 解析到 Node 和 TypeScript 环境下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  presets: [</span><br><span class="line">    [&apos;@babel/preset-env&apos;, &#123; targets: &#123; node: &apos;current&apos; &#125; &#125;],</span><br><span class="line">    &apos;@babel/preset-typescript&apos;,</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们还需要新建 jest.config.js，用来配置 jest 的测试行为。不同格式的文件需要使用不同命令来配置，对于.vue 文件我们使用 vue-jest，对于.js 或者.jsx 结果的文件，我们就要使用 babel-jest，而对于.ts 结尾的文件我们使用 ts-jest，然后匹配文件名是 xx.spec.js。这里请注意，Jest 只会执行.spec.js 结尾的文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  transform: &#123;</span><br><span class="line">    // .vue文件用 vue-jest 处理</span><br><span class="line">    &apos;^.+\\.vue$&apos;: &apos;vue-jest&apos;,</span><br><span class="line">    // .js或者.jsx用 babel-jest处理</span><br><span class="line">    &apos;^.+\\.jsx?$&apos;: &apos;babel-jest&apos;,</span><br><span class="line">    //.ts文件用ts-jest处理</span><br><span class="line">    &apos;^.+\\.ts$&apos;: &apos;ts-jest&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  testMatch: [&apos;**/?(*.)+(spec).[jt]s?(x)&apos;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后配置 package.json，在 scrips 配置下面新增 test 命令，即可启动 Jest。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;dev&quot;: &quot;vite&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;vue-tsc --noEmit &amp;&amp; vite build&quot;,</span><br><span class="line">    &quot;serve&quot;: &quot;vite preview&quot;,</span><br><span class="line">    &quot;lint&quot;: &quot;eslint --fix --ext .js,vue src/&quot;,</span><br><span class="line">    &quot;test&quot;: &quot;jest&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="如何实现-Vue-的跨端渲染-？"><a href="#如何实现-Vue-的跨端渲染-？" class="headerlink" title="如何实现 Vue 的跨端渲染 ？"></a>如何实现 Vue 的跨端渲染 ？</h2><h3 id="什么是渲染器"><a href="#什么是渲染器" class="headerlink" title="什么是渲染器"></a>什么是渲染器</h3><p>我们都知道，Vue 内部的组件是以虚拟 dom 形式存在的。下面的代码就是一个很常见的虚拟 Dom，用对象的方式去描述一个项目。相比 dom 标签相比，这种形式可以让整个 Vue 项目脱离浏览器的限制，更方便地实现 Vuejs 的跨端。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  tag: &apos;div&apos;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    id: &apos;app&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  children: [</span><br><span class="line">    &#123;</span><br><span class="line">      tag: Container,</span><br><span class="line">      props: &#123;</span><br><span class="line">        className: &apos;el-container&apos;</span><br><span class="line">      &#125;,</span><br><span class="line">      children: [</span><br><span class="line">        &apos;哈喽小老弟!!!&apos;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>渲染器是围绕虚拟 Dom 存在的。在浏览器中，我们把虚拟 Dom 渲染成真实的 Dom 对象，Vue 源码内部把一个框架里所有和平台相关的操作，抽离成了独立的方法。所以，我们只需要实现下面这些方法，就可以实现 Vue 3 在一个平台的渲染。</p>
<p>首先用 createElement 创建标签，还有用 createText 创建文本。创建之后就需要用 insert 新增元素，通过 remove 删除元素，通过 setText 更新文本和 patchProps 修改属性。然后再实现 parentNode、nextSibling 等方法实现节点的查找关系。完成这些工作，理论上就可以在一个平台内实现一个应用了。</p>
<p>在 Vue 3 中的 runtime-core 模块，就对外暴露了这些接口，runtime-core 内部基于这些函数实现了整个 Vue 内部的所有操作，然后在 runtime-dom 中传入以上所有方法。</p>
<p>下面的代码就是 Vue 代码提供浏览器端操作的函数，这些 DOM 编程接口完成了浏览器端增加、添加和删除操作，这些 API 都是浏览器端独有的，如果一个框架强依赖于这些函数，那就只能在浏览器端运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">export const nodeOps: Omit&lt;RendererOptions&lt;Node, Element&gt;, &apos;patchProp&apos;&gt; = &#123;</span><br><span class="line">  //插入元素</span><br><span class="line">  insert: (child, parent, anchor) =&gt; &#123;</span><br><span class="line">    parent.insertBefore(child, anchor || null)</span><br><span class="line">  &#125;,</span><br><span class="line">  // 删除元素</span><br><span class="line">  remove: child =&gt; &#123;</span><br><span class="line">    const parent = child.parentNode</span><br><span class="line">    if (parent) &#123;</span><br><span class="line">      parent.removeChild(child)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 创建元素</span><br><span class="line">  createElement: (tag, isSVG, is, props): Element =&gt; &#123;</span><br><span class="line">    const el = isSVG</span><br><span class="line">      ? doc.createElementNS(svgNS, tag)</span><br><span class="line">      : doc.createElement(tag, is ? &#123; is &#125; : undefined)</span><br><span class="line"></span><br><span class="line">    if (tag === &apos;select&apos; &amp;&amp; props &amp;&amp; props.multiple != null) &#123;</span><br><span class="line">      ;(el as HTMLSelectElement).setAttribute(&apos;multiple&apos;, props.multiple)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return el</span><br><span class="line">  &#125;</span><br><span class="line">  //...其他操作函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在后面的代码中，我们通过 createRenderer 函数区创建了一个渲染器。通过参数 options 获取增删改查所有的函数以后，在内部的 render、mount、patch 等函数中，需要去渲染一个元素的时候，就可以通过 option.createElement 和 option.insert 来实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">export default function createRenderer(options) &#123;</span><br><span class="line">  const &#123;</span><br><span class="line">      insert: hostInsert,</span><br><span class="line">      remove: hostRemove,</span><br><span class="line">      patchProp: hostPatchProp,</span><br><span class="line">      createElement: hostCreateElement,</span><br><span class="line">      createText: hostCreateText,</span><br><span class="line">      createComment: hostCreateComment,</span><br><span class="line">      setText: hostSetText,</span><br><span class="line">      setElementText: hostSetElementText,</span><br><span class="line">      parentNode: hostParentNode,</span><br><span class="line">      nextSibling: hostNextSibling,</span><br><span class="line">      setScopeId: hostSetScopeId = NOOP,</span><br><span class="line">      cloneNode: hostCloneNode,</span><br><span class="line">      insertStaticContent: hostInsertStaticContent</span><br><span class="line">   &#125; = options</span><br><span class="line"></span><br><span class="line">  function render(vnode, container) &#123;  &#125;</span><br><span class="line"></span><br><span class="line">  function mount(vnode, container, isSVG, refNode) &#123;  &#125;</span><br><span class="line"></span><br><span class="line">  function mountElement(vnode, container, isSVG, refNode) &#123;  &#125;</span><br><span class="line"></span><br><span class="line">  function mountText(vnode, container) &#123;  &#125;</span><br><span class="line"></span><br><span class="line">  function patch(prevVNode, nextVNode, container) &#123;  &#125;</span><br><span class="line"></span><br><span class="line">  function replaceVNode(prevVNode, nextVNode, container) &#123;  &#125;</span><br><span class="line">  function patchElement(prevVNode, nextVNode, container) &#123;  &#125;</span><br><span class="line">  function patchChildren(</span><br><span class="line">    prevChildFlags,</span><br><span class="line">    nextChildFlags,</span><br><span class="line">    prevChildren,</span><br><span class="line">    nextChildren,</span><br><span class="line">    container</span><br><span class="line">  ) &#123;  &#125;</span><br><span class="line"></span><br><span class="line">  function patchText(prevVNode, nextVNode) &#123;  &#125;</span><br><span class="line">  function patchComponent(prevVNode, nextVNode, container) &#123;  &#125;</span><br><span class="line"></span><br><span class="line">  return &#123; render &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在每个函数实现的内部，比如 mountElement，我们之前的实现方式是调用浏览器的 API 创建。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function mountElement(vnode, container, isSVG, refNode) &#123;</span><br><span class="line">  const el = isSVG</span><br><span class="line">    ? document.createElementNS(....)</span><br><span class="line">    : document.createElement(vnode.tag)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对比一下，经过渲染器抽离之后，内部的 mountElement 就会把所有 document 的操作全部换成 options 传递进来的 hostCreate 函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function mountElement(vnode, container, isSVG, refNode) &#123;</span><br><span class="line">  const el = hostCreateElement(vnode.tag, isSVG)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们使用后面的代码创建一个具体平台的渲染器，这也是 Vue 3 中的 runtime-dom 包主要做的事。了解了 Vue 中自定义渲染器的实现方式后，我们还可以基于 Vue 3 的 runtime-core 包封装其他平台的渲染器，让其他平台也能使用 Vue 内部的响应式和组件化等优秀的特性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const &#123; render &#125; = createRenderer(&#123;</span><br><span class="line">  nodeOps: &#123;</span><br><span class="line">    createElement() &#123;   &#125;,</span><br><span class="line">    createText() &#123;   &#125;</span><br><span class="line">    // more...</span><br><span class="line">  &#125;,</span><br><span class="line">  patchData</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="自定义渲染"><a href="#自定义渲染" class="headerlink" title="自定义渲染"></a>自定义渲染</h3><p>自定义渲染器让 Vue 脱离了浏览器的限制，我们只需要实现平台内部的增删改查函数后，就可以直接对接 Vue 3。比方说，我们可以把 Vue 渲染到小程序平台；也可以渲染到 Canvas，实现 vue 3-canvas，把虚拟 dom 渲染成 Canvas；甚至还可以尝试把 Vue 3 渲染到 three.js 中，在 3D 世界使用响应式开发。</p>
<p>自定义渲染器的原理，就是把所有的增删改查操作暴露出去，使用的时候不需要知道内部的实现细节，我们只需要针对每个平台使用不同的 API 即可。</p>
<p>自定义渲染器也代表着适配器设计模式的一个实践。除了自定义渲染器 API 的学习，我们也要反思一下自己现在负责的项目中，有哪些地方为了不同的接口或者平台写了太多的判断代码，是否也可以使用类似自定义渲染器的逻辑和模式，把多个组件、平台、接口之间不同的操作方式封装成一个核心模块，去进行单独函数的扩展。</p>
<p>比如下面的代码中，我们对 three.js 进行一个渲染的尝试。它的实现逻辑和 Canvas 比较类似，通过对于对象的维护和 draw 函数实现最终的绘制。在 draw 函数内部，我们调用 three.js 的操作方法去创建 camera，sence，geometry 等概念，最后对外暴露 three.js 的 createApp 函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import &#123; createRenderer &#125; from &apos;@vue/runtime-core&apos;</span><br><span class="line">import * as THREE from &apos;three&apos;</span><br><span class="line">import &#123;nextTick&#125; from &apos;@vue/runtime-core&apos;</span><br><span class="line"></span><br><span class="line">let renderer</span><br><span class="line"></span><br><span class="line">function draw(obj) &#123;</span><br><span class="line">    const &#123;camera,cameraPos, scene, geometry,geometryArg,material,mesh,meshY,meshX&#125; = obj</span><br><span class="line">    if([camera,cameraPos, scene, geometry,geometryArg,material,mesh,meshY,meshX].filter(v=&gt;v).length&lt;9)&#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    let cameraObj = new THREE[camera]( 40, window.innerWidth / window.innerHeight, 0.1, 10 )</span><br><span class="line">    Object.assign(cameraObj.position,cameraPos)</span><br><span class="line"></span><br><span class="line">    let sceneObj = new THREE[scene]()</span><br><span class="line"></span><br><span class="line">    let geometryObj = new THREE[geometry]( ...geometryArg)</span><br><span class="line">    let materialObj = new THREE[material]()</span><br><span class="line"></span><br><span class="line">    let meshObj = new THREE[mesh]( geometryObj, materialObj )</span><br><span class="line">    meshObj.rotation.x = meshX</span><br><span class="line">    meshObj.rotation.y = meshY</span><br><span class="line">    sceneObj.add( meshObj )</span><br><span class="line">    renderer.render( sceneObj, cameraObj );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const &#123; createApp: originCa &#125; = createRenderer(&#123;</span><br><span class="line">  insert: (child, parent, anchor) =&gt; &#123;</span><br><span class="line">    if(parent.domElement)&#123;</span><br><span class="line">        draw(child)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  createElement(type, isSVG, isCustom) &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      type</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  setElementText(node, text) &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  patchProp(el, key, prev, next) &#123;</span><br><span class="line">    el[key] = next</span><br><span class="line">    draw(el)</span><br><span class="line">  &#125;,</span><br><span class="line">  parentNode: node =&gt; node,</span><br><span class="line">  nextSibling: node =&gt; node,</span><br><span class="line">  createText: text =&gt; text,</span><br><span class="line">  remove:node=&gt;node</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">function createApp(...args) &#123;</span><br><span class="line">  const app = originCa(...args)</span><br><span class="line">  return &#123;</span><br><span class="line">    mount(selector) &#123;</span><br><span class="line">        renderer = new THREE.WebGLRenderer( &#123; antialias: true &#125; );</span><br><span class="line">        renderer.setSize( window.innerWidth, window.innerHeight );</span><br><span class="line">        document.body.appendChild( renderer.domElement );</span><br><span class="line">        app.mount(renderer)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export &#123; createApp &#125;</span><br></pre></td></tr></table></figure>
<p>然后我们在 App.vue 中，使用下面的代码渲染出一个立方体，并且通过 ref 响应式对象控制立方体偏移的监督，再通过 setInterval 实现立方体的动画</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div</span><br><span class="line">        camera=&quot;PerspectiveCamera&quot;</span><br><span class="line">        :cameraPos=&#123;z:1&#125;</span><br><span class="line">        scene=&quot;Scene&quot;</span><br><span class="line">        geometry=&quot;BoxGeometry&quot;</span><br><span class="line">        :geometryArg=&quot;[0.2,0.2,0.2]&quot;</span><br><span class="line">        material=&quot;MeshNormalMaterial&quot;</span><br><span class="line">        mesh=&quot;Mesh&quot;</span><br><span class="line">        :meshY=&quot;y&quot;</span><br><span class="line">        :meshX=&quot;x&quot;</span><br><span class="line">    &gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123;ref&#125; from &apos;vue&apos;</span><br><span class="line">export default &#123;</span><br><span class="line">    setup()&#123;</span><br><span class="line">        const y = ref(0.3)</span><br><span class="line">        const x = ref(0.3)</span><br><span class="line">        setInterval(()=&gt;&#123;</span><br><span class="line">            y.value+=0.3</span><br><span class="line">            x.value+=0.5</span><br><span class="line">        &#125;,100)</span><br><span class="line">        return &#123;y,x&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="万能的面试题，怎么手写响应式系统"><a href="#万能的面试题，怎么手写响应式系统" class="headerlink" title="万能的面试题，怎么手写响应式系统"></a>万能的面试题，怎么手写响应式系统</h2><h3 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h3><p>响应式机制可以自动收集系统中数据的依赖，并且在修改数据之后自动执行更新，极大提高开发的效率。</p>
<p>响应式机制的主要功能就是，可以把普通的 JavaScript 对象封装成为响应式对象，拦截数据的获取和修改操作，实现依赖数据的自动化更新。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const &#123;effect, reactive&#125; = require(&apos;@vue/reactivity&apos;)</span><br><span class="line"></span><br><span class="line">let dummy</span><br><span class="line">const counter = reactive(&#123; num1: 1, num2: 2 &#125;)</span><br><span class="line">effect(() =&gt; &#123;</span><br><span class="line">  dummy = counter.num1 + counter.num2</span><br><span class="line">  console.log(dummy)// 每次counter.num1修改都会打印日志</span><br><span class="line">&#125;)</span><br><span class="line">setInterval(()=&gt;&#123;</span><br><span class="line">  counter.num1++</span><br><span class="line">&#125;,1000)</span><br><span class="line"></span><br><span class="line">在 effect 中获取 counter.num1 和 counter.num2 的时候，就会触发 counter 的 get 拦截函数；get 函数，会把当前的 effect 函数注册到一个全局的依赖地图中去。这样 counter.num1 在修改的时候，就会触发 set 拦截函数，去依赖地图中找到注册的 effect 函数，然后执行。</span><br></pre></td></tr></table></figure>
<h3 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">export function reactive(target) &#123;</span><br><span class="line">  if (typeof target!==&apos;object&apos;) &#123;</span><br><span class="line">    console.warn(`reactive  $&#123;target&#125; 必须是一个对象`);</span><br><span class="line">    return target</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return new Proxy(target, mutableHandlers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="mutableHandles"><a href="#mutableHandles" class="headerlink" title="mutableHandles"></a>mutableHandles</h3><p>我们使用 createGetter 和 createSetters 来创建 set 和 get 函数，mutableHandles 就是配置了 set 和 get 的对象返回。<br>get 中直接返回读取的数据，这里的 Reflect.get 和 target[key]实现的结果是一致的；并且返回值是对象的话，还会嵌套执行 reactive，并且调用 track 函数收集依赖。<br>set 中调用 trigger 函数，执行 track 收集的依赖。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const get = createGetter();</span><br><span class="line">const set = createSetter();</span><br><span class="line"></span><br><span class="line">function createGetter(shallow = false) &#123;</span><br><span class="line">  return function get(target, key, receiver) &#123;</span><br><span class="line">    const res = Reflect.get(target, key, receiver)</span><br><span class="line">    track(target, &quot;get&quot;, key)</span><br><span class="line">    if (isObject(res)) &#123;</span><br><span class="line">      // 值也是对象的话，需要嵌套调用reactive</span><br><span class="line">      // res就是target[key]</span><br><span class="line">      // 浅层代理，不需要嵌套</span><br><span class="line">      return shallow ? res : reactive(res)</span><br><span class="line">    &#125;</span><br><span class="line">    return res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createSetter() &#123;</span><br><span class="line">  return function set(target, key, value, receiver) &#123;</span><br><span class="line">    const result = Reflect.set(target, key, value, receiver)</span><br><span class="line">    // 在触发 set 的时候进行触发依赖</span><br><span class="line">    trigger(target, &quot;set&quot;, key)</span><br><span class="line">    return result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export const mutableHandles = &#123;</span><br><span class="line">  get,</span><br><span class="line">  set,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="track"><a href="#track" class="headerlink" title="track"></a>track</h3><p>在 track 函数中，我们可以使用一个巨大的 targetMap 去存储依赖关系。map 的 key 是我们要代理的 target 对象，值还是一个 depsMap，存储这每一个 key 依赖的函数，每一个 key 都可以依赖多个 effect。上面的代码执行完成，depsMap 中就有了 num1 和 num2 两个依赖。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">targetMap = &#123;</span><br><span class="line"> target： &#123;</span><br><span class="line">   key1: [回调函数1，回调函数2],</span><br><span class="line">   key2: [回调函数3，回调函数4],</span><br><span class="line"> &#125;  ,</span><br><span class="line">  target1： &#123;</span><br><span class="line">   key3: [回调函数5]</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const targetMap = new WeakMap()</span><br><span class="line"></span><br><span class="line">export function track(target, type, key) &#123;</span><br><span class="line"></span><br><span class="line">  // console.log(`触发 track -&gt; target: $&#123;target&#125; type:$&#123;type&#125; key:$&#123;key&#125;`)</span><br><span class="line"></span><br><span class="line">  // 1. 先基于 target 找到对应的 dep</span><br><span class="line">  // 如果是第一次的话，那么就需要初始化</span><br><span class="line">  // &#123;</span><br><span class="line">  //   target1: &#123;//depsmap</span><br><span class="line">  //     key:[effect1,effect2]</span><br><span class="line">  //   &#125;</span><br><span class="line">  // &#125;</span><br><span class="line">  let depsMap = targetMap.get(target)</span><br><span class="line">  if (!depsMap) &#123;</span><br><span class="line">    // 初始化 depsMap 的逻辑</span><br><span class="line">    // depsMap = new Map()</span><br><span class="line">    // targetMap.set(target, depsMap)</span><br><span class="line">    // 上面两行可以简写成下面的</span><br><span class="line">    targetMap.set(target, (depsMap = new Map()))</span><br><span class="line">  &#125;</span><br><span class="line">  let deps = depsMap.get(key)</span><br><span class="line">  if (!deps) &#123;</span><br><span class="line">    deps = new Set()</span><br><span class="line">  &#125;</span><br><span class="line">  if (!deps.has(activeEffect) &amp;&amp; activeEffect) &#123;</span><br><span class="line">    // 防止重复注册</span><br><span class="line">    deps.add(activeEffect)</span><br><span class="line">  &#125;</span><br><span class="line">  depsMap.set(key, deps)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="trigger"><a href="#trigger" class="headerlink" title="trigger"></a>trigger</h3><p>有了上面 targetMap 的实现机制，trigger 函数实现的思路就是从 targetMap 中，根据 target 和 key 找到对应的依赖函数集合 deps，然后遍历 deps 执行依赖函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">export function trigger(target, type, key) &#123;</span><br><span class="line">  // console.log(`触发 trigger -&gt; target:  type:$&#123;type&#125; key:$&#123;key&#125;`)</span><br><span class="line">  // 从targetMap中找到触发的函数，执行他</span><br><span class="line">  const depsMap = targetMap.get(target)</span><br><span class="line">  if (!depsMap) &#123;</span><br><span class="line">    // 没找到依赖</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  const deps = depsMap.get(key)</span><br><span class="line">  if (!deps) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  deps.forEach((effectFn) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    if (effectFn.scheduler) &#123;</span><br><span class="line">      effectFn.scheduler()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      effectFn()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="effect"><a href="#effect" class="headerlink" title="effect"></a>effect</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">export function effect(fn, options = &#123;&#125;) &#123;</span><br><span class="line">  // effect嵌套，通过队列管理</span><br><span class="line">  const effectFn = () =&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      activeEffect = effectFn</span><br><span class="line">      //fn执行的时候，内部读取响应式数据的时候，就能在get配置里读取到activeEffect</span><br><span class="line">      return fn()</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      activeEffect = null</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (!options.lazy) &#123;</span><br><span class="line">    //没有配置lazy 直接执行</span><br><span class="line">    effectFn()</span><br><span class="line">  &#125;</span><br><span class="line">  effectFn.scheduler = options.scheduler // 调度时机 watchEffect回用到</span><br><span class="line">  return effectFn</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>ref 的执行逻辑要比 reactive 要简单一些，不需要使用 Proxy 代理语法，直接使用对象语法的 getter 和 setter 配置，监听 value 属性即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">export function ref(val) &#123;</span><br><span class="line">  if (isRef(val)) &#123;</span><br><span class="line">    return val</span><br><span class="line">  &#125;</span><br><span class="line">  return new RefImpl(val)</span><br><span class="line">&#125;</span><br><span class="line">export function isRef(val) &#123;</span><br><span class="line">  return !!(val &amp;&amp; val.__isRef)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ref就是利用面向对象的getter和setters进行track和trigget</span><br><span class="line">class RefImpl &#123;</span><br><span class="line">  constructor(val) &#123;</span><br><span class="line">    this.__isRef = true</span><br><span class="line">    this._val = convert(val)</span><br><span class="line">  &#125;</span><br><span class="line">  get value() &#123;</span><br><span class="line">    track(this, &apos;value&apos;)</span><br><span class="line">    return this._val</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  set value(val) &#123;</span><br><span class="line">    if (val !== this._val) &#123;</span><br><span class="line">      this._val = convert(val)</span><br><span class="line">      trigger(this, &apos;value&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ref也可以支持复杂数据结构</span><br><span class="line">function convert(val) &#123;</span><br><span class="line">  return isObject(val) ? reactive(val) : val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你能很直观地看到，ref 函数实现的相对简单很多，只是利用面向对象的 getter 和 setter 拦截了 value 属性的读写，这也是为什么我们需要操作 ref 对象的 value 属性的原因。<br>值得一提的是，ref 也可以包裹复杂的数据结构，内部会直接调用 reactive 来实现。</p>
<h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><p>Vue 中的 computed 计算属性也是一种特殊的 effect 函数<br>computed 可以传递一个函数或者对象，实现计算属性的读取和修改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">export function computed(getterOrOptions) &#123;</span><br><span class="line">  // getterOrOptions可以是函数，也可以是一个对象，支持get和set</span><br><span class="line">  // 还记得清单应用里的全选checkbox就是一个对象配置的computed</span><br><span class="line">  let getter, setter</span><br><span class="line">  if (typeof getterOrOptions === &apos;function&apos;) &#123;</span><br><span class="line">    getter = getterOrOptions</span><br><span class="line">    setter = () =&gt; &#123;</span><br><span class="line">      console.warn(&apos;计算属性不能修改&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    getter = getterOrOptions.get</span><br><span class="line">    setter = getterOrOptions.set</span><br><span class="line">  &#125;</span><br><span class="line">  return new ComputedRefImpl(getter, setter)</span><br><span class="line">&#125;</span><br><span class="line">class ComputedRefImpl &#123;</span><br><span class="line">  constructor(getter, setter) &#123;</span><br><span class="line">    this._setter = setter</span><br><span class="line">    this._val = undefined</span><br><span class="line">    this._dirty = true</span><br><span class="line">    // computed就是一个特殊的effect，设置lazy和执行时机</span><br><span class="line">    this.effect = effect(getter, &#123;</span><br><span class="line">      lazy: true,</span><br><span class="line">      scheduler: () =&gt; &#123;</span><br><span class="line">        if (!this._dirty) &#123;</span><br><span class="line">          this._dirty = true</span><br><span class="line">          trigger(this, &apos;value&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  get value() &#123;</span><br><span class="line">    track(this, &apos;value&apos;)</span><br><span class="line">    if (this._dirty) &#123;</span><br><span class="line">      this._dirty = false</span><br><span class="line">      this._val = this.effect()</span><br><span class="line">    &#125;</span><br><span class="line">    return this._val</span><br><span class="line">  &#125;</span><br><span class="line">  set value(val) &#123;</span><br><span class="line">    this._setter(val)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行时：Vue-在浏览器里是怎么跑起来的？"><a href="#运行时：Vue-在浏览器里是怎么跑起来的？" class="headerlink" title="运行时：Vue 在浏览器里是怎么跑起来的？"></a>运行时：Vue 在浏览器里是怎么跑起来的？</h2><h3 id="首次渲染"><a href="#首次渲染" class="headerlink" title="首次渲染"></a>首次渲染</h3><p>想要启动一个 Vue 项目，只需要从 Vue 中引入 createApp，传入 App 组件，并且调用 createApp 返回的 App 实例的 mount 方法，就实现了项目的启动。这个时候 Vue 也完成了首次渲染。<br>所以 createApp 就是项目的初始化渲染入口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">export const createApp = ((...args) =&gt; &#123;</span><br><span class="line">  const app = ensureRenderer().createApp(...args)</span><br><span class="line">  const &#123; mount &#125; = app</span><br><span class="line">  // 重写mount</span><br><span class="line">  app.mount = (containerOrSelector: Element | ShadowRoot | string): any =&gt; &#123;</span><br><span class="line">    const container = normalizeContainer(containerOrSelector)</span><br><span class="line">    if (!container) return</span><br><span class="line"></span><br><span class="line">    const component = app._component</span><br><span class="line">    if (!isFunction(component) &amp;&amp; !component.render &amp;&amp; !component.template) &#123;</span><br><span class="line">      component.template = container.innerHTML</span><br><span class="line">    &#125;</span><br><span class="line">    container.innerHTML = &apos;&apos;</span><br><span class="line">    const proxy = mount(container, false, container instanceof SVGElement)</span><br><span class="line">    if (container instanceof Element) &#123;</span><br><span class="line">      container.removeAttribute(&apos;v-cloak&apos;)</span><br><span class="line">      container.setAttribute(&apos;data-v-app&apos;, &apos;&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    return proxy</span><br><span class="line">  &#125;</span><br><span class="line">  return app</span><br><span class="line">&#125;)</span><br><span class="line">function normalizeContainer(container)&#123;</span><br><span class="line">  if (isString(container)) &#123;</span><br><span class="line">    const res = document.querySelector(container)</span><br><span class="line">  &#125;</span><br><span class="line">  return container</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 ensureRenderer 函数，内部通过 createRenderer 函数，创建了一个浏览器的渲染器，并且缓存了渲染器 renderer，这种使用闭包做缓存的方式，你在日常开发中也可以借鉴这种思路。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 浏览器dom操作</span><br><span class="line">import &#123; nodeOps &#125; from &apos;./nodeOps&apos;</span><br><span class="line">// 浏览器dom属性更新</span><br><span class="line">import &#123; patchProp &#125; from &apos;./patchProp&apos;</span><br><span class="line">import &#123; createRenderer &#125; from &apos;@vue/runtime-core&apos;</span><br><span class="line">const rendererOptions = extend(&#123; patchProp &#125;, nodeOps)</span><br><span class="line"></span><br><span class="line">let renderer: Renderer&lt;Element | ShadowRoot&gt; | HydrationRenderer</span><br><span class="line"></span><br><span class="line">function ensureRenderer() &#123;</span><br><span class="line">  return (</span><br><span class="line">    renderer ||</span><br><span class="line">    (renderer = createRenderer&lt;Node, Element | ShadowRoot&gt;(rendererOptions))</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>createRenderer 是调用 baseCreateRenderer 创建的，baseCreateRenderer 首先获取了平台上所有的 insert、remove 函数，这些函数都是 nodeOps 传递进来的，然后定义了一些 patch、mount、unmount 函数，通过名字我们不难猜出，这就是 Vue 中更新、渲染组件的工具函数，比如 mountElement 就是渲染 DOM 元素、mountComponent 就是渲染组件 updateComponent 就是更新组件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">export function createRenderer&lt;</span><br><span class="line">  HostNode = RendererNode,</span><br><span class="line">  HostElement = RendererElement</span><br><span class="line">&gt;(options: RendererOptions&lt;HostNode, HostElement&gt;) &#123;</span><br><span class="line">  return baseCreateRenderer&lt;HostNode, HostElement&gt;(options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function baseCreateRenderer()&#123;</span><br><span class="line">    const &#123;</span><br><span class="line">    insert: hostInsert,</span><br><span class="line">    remove: hostRemove,</span><br><span class="line">    patchProp: hostPatchProp,</span><br><span class="line">    createElement: hostCreateElement,</span><br><span class="line">    createText: hostCreateText,</span><br><span class="line">    createComment: hostCreateComment,</span><br><span class="line">    setText: hostSetText,</span><br><span class="line">    setElementText: hostSetElementText,</span><br><span class="line">    parentNode: hostParentNode,</span><br><span class="line">    nextSibling: hostNextSibling,</span><br><span class="line">    setScopeId: hostSetScopeId = NOOP,</span><br><span class="line">    cloneNode: hostCloneNode,</span><br><span class="line">    insertStaticContent: hostInsertStaticContent</span><br><span class="line">  &#125; = options</span><br><span class="line">  const patch = ()=&gt;... //一个函数</span><br><span class="line">  const processText = ()=&gt;...</span><br><span class="line">  const processCommentNode = ()=&gt;...</span><br><span class="line">  const processElement = ()=&gt;...</span><br><span class="line">  const mountElement = ()=&gt;...</span><br><span class="line">  const mountChildren = ()=&gt;...</span><br><span class="line">  const patchElement = ()=&gt;...</span><br><span class="line">  const patchBlockChildren = ()=&gt;...</span><br><span class="line">  const patchProps = ()=&gt;...</span><br><span class="line">  const processComponent = ()=&gt;...</span><br><span class="line">  const mountComponent = ()=&gt;...</span><br><span class="line">  const updateComponent = ()=&gt;...</span><br><span class="line">  const setupRenderEffect = ()=&gt;...</span><br><span class="line">  const patchChildren = ()=&gt;...</span><br><span class="line">  const patchKeyedChildren = ()=&gt;...</span><br><span class="line">  const unmount = ()=&gt;...</span><br><span class="line">  const unmountComponent = ()=&gt;...</span><br><span class="line">  const unmountComponent = ()=&gt;...</span><br><span class="line">  const unmountComponent = ()=&gt;...</span><br><span class="line">  const unmountComponent = ()=&gt;...</span><br><span class="line">  const render: RootRenderFunction = (vnode, container, isSVG) =&gt; &#123;</span><br><span class="line">    if (vnode == null) &#123;</span><br><span class="line">      if (container._vnode) &#123;</span><br><span class="line">        unmount(container._vnode, null, null, true)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      patch(container._vnode || null, vnode, container, null, null, null, isSVG)</span><br><span class="line">    &#125;</span><br><span class="line">    flushPostFlushCbs()</span><br><span class="line">    container._vnode = vnode</span><br><span class="line">  &#125;</span><br><span class="line">  return &#123;</span><br><span class="line">    render,</span><br><span class="line">    hydrate,</span><br><span class="line">    createApp: createAppAPI(render, hydrate)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后返回的 createApp 方法，实际上是 createAPI 的返回值，并且给 createAPI 传递了 render 方法。render 方法内部很简单，就是判断 container 容器上有没有 _vnode 属性，如果有的话就执行 unmount 方法，没有的话就执行 patch 方法，最后把 vnode 信息存储在 container._vnode 上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">export function createAppAPI&lt;HostElement&gt;(</span><br><span class="line">  render: RootRenderFunction,</span><br><span class="line">  hydrate?: RootHydrateFunction</span><br><span class="line">): CreateAppFunction&lt;HostElement&gt; &#123;</span><br><span class="line">  return function createApp(rootComponent, rootProps = null) &#123;</span><br><span class="line">    const context = createAppContext()</span><br><span class="line">    let isMounted = false</span><br><span class="line"></span><br><span class="line">    const app: App = (context.app = &#123;</span><br><span class="line">      _context: context,</span><br><span class="line">      _instance: null,</span><br><span class="line">      use(plugin: Plugin, ...options: any[]) ,</span><br><span class="line">      component(name: string, component?: Component): any &#123;</span><br><span class="line">        if (!component) &#123;</span><br><span class="line">          return context.components[name]</span><br><span class="line">        &#125;</span><br><span class="line">        context.components[name] = component</span><br><span class="line">        return app</span><br><span class="line">      &#125;,</span><br><span class="line">      directive(name: string, directive?: Directive)</span><br><span class="line">      mount(</span><br><span class="line">        rootContainer: HostElement,</span><br><span class="line">        isHydrate?: boolean,</span><br><span class="line">        isSVG?: boolean</span><br><span class="line">      ): any &#123;</span><br><span class="line">        if (!isMounted) &#123;</span><br><span class="line">          const vnode = createVNode(</span><br><span class="line">            rootComponent as ConcreteComponent,</span><br><span class="line">            rootProps</span><br><span class="line">          )</span><br><span class="line">          vnode.appContext = context</span><br><span class="line">          // 核心的逻辑</span><br><span class="line">          if (isHydrate &amp;&amp; hydrate) &#123;</span><br><span class="line">            hydrate(vnode as VNode&lt;Node, Element&gt;, rootContainer as any)</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            render(vnode, rootContainer, isSVG)</span><br><span class="line">          &#125;</span><br><span class="line">          return getExposeProxy(vnode.component!) || vnode.component!.proxy</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      provide(key, value) &#123;</span><br><span class="line">        context.provides[key as string] = value</span><br><span class="line">        return app</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    return app</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="patch-函数"><a href="#patch-函数" class="headerlink" title="patch 函数"></a>patch 函数</h3><p>其中 n1 是上次渲染的虚拟 DOM，n2 是下次要渲染的虚拟 DOM。</p>
<p>首先可以把 n1 和 n2 做一次判断，如果虚拟 DOM 的节点类型不同，就直接 unmount 之前的节点。因为比如之前是 Button 组件，现在要渲染 Container 组件，就没有计算 diff 的必要，直接把 Button 组件销毁再渲染 Container 即可。</p>
<p>如果 n1 和 n2 类型相同，比如都是 Button 组件或者都是 div 标签，我们需要判断具体的类型再去执行不同的函数，比如 processText、processFragment、processElement 以及 processComponent 等函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const patch: PatchFn = (</span><br><span class="line">  n1,</span><br><span class="line">  n2,</span><br><span class="line">  container,</span><br><span class="line">  anchor = null,</span><br><span class="line">  parentComponent = null,</span><br><span class="line">  parentSuspense = null,</span><br><span class="line">  isSVG = false,</span><br><span class="line">  slotScopeIds = null,</span><br><span class="line">  optimized = __DEV__ &amp;&amp; isHmrUpdating ? false : !!n2.dynamicChildren</span><br><span class="line">) =&gt; &#123;</span><br><span class="line">  // 两次虚拟dom完全一样 啥也不用干</span><br><span class="line">  if (n1 === n2) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  // 虚拟dom节点类型不一样， unmount老的虚拟dom，并且n1赋值null</span><br><span class="line">  if (n1 &amp;&amp; !isSameVNodeType(n1, n2)) &#123;</span><br><span class="line">    anchor = getNextHostNode(n1)</span><br><span class="line">    unmount(n1, parentComponent, parentSuspense, true)</span><br><span class="line">    n1 = null</span><br><span class="line">  &#125;</span><br><span class="line">  // n2是要渲染的虚拟dom，我们获取type，ref和shapeFlag</span><br><span class="line">  const &#123; type, ref, shapeFlag &#125; = n2</span><br><span class="line">  switch (type) &#123;</span><br><span class="line">    case Text:</span><br><span class="line">      // 文本</span><br><span class="line">      processText(n1, n2, container, anchor)</span><br><span class="line">      break</span><br><span class="line">    case Comment:</span><br><span class="line">      // 注释</span><br><span class="line">      processCommentNode(n1, n2, container, anchor)</span><br><span class="line">      break</span><br><span class="line">    case Static:</span><br><span class="line">      // 静态节点</span><br><span class="line">      if (n1 == null) &#123;</span><br><span class="line">        mountStaticNode(n2, container, anchor, isSVG)</span><br><span class="line">      &#125; else if (__DEV__) &#123;</span><br><span class="line">        patchStaticNode(n1, n2, container, isSVG)</span><br><span class="line">      &#125;</span><br><span class="line">      break</span><br><span class="line">    case Fragment:</span><br><span class="line">      processFragment(</span><br><span class="line">        n1,</span><br><span class="line">        n2,</span><br><span class="line">        container,</span><br><span class="line">        anchor,</span><br><span class="line">        parentComponent,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        isSVG,</span><br><span class="line">        slotScopeIds,</span><br><span class="line">        optimized</span><br><span class="line">      )</span><br><span class="line">      break</span><br><span class="line">    default:</span><br><span class="line">      // 运运算判断操作类型</span><br><span class="line">      if (shapeFlag &amp; ShapeFlags.ELEMENT) &#123;</span><br><span class="line">        // html标签</span><br><span class="line">        processElement(</span><br><span class="line">          n1,</span><br><span class="line">          n2,</span><br><span class="line">          container,</span><br><span class="line">          anchor,</span><br><span class="line">          parentComponent,</span><br><span class="line">          parentSuspense,</span><br><span class="line">          isSVG,</span><br><span class="line">          slotScopeIds,</span><br><span class="line">          optimized</span><br><span class="line">        )</span><br><span class="line">      &#125; else if (shapeFlag &amp; ShapeFlags.COMPONENT) &#123;</span><br><span class="line">        // 组件</span><br><span class="line">        processComponent(</span><br><span class="line">          n1,</span><br><span class="line">          n2,</span><br><span class="line">          container,</span><br><span class="line">          anchor,</span><br><span class="line">          parentComponent,</span><br><span class="line">          parentSuspense,</span><br><span class="line">          isSVG,</span><br><span class="line">          slotScopeIds,</span><br><span class="line">          optimized</span><br><span class="line">        )</span><br><span class="line">      &#125; else if (shapeFlag &amp; ShapeFlags.TELEPORT) &#123;</span><br><span class="line">        ;(type as typeof TeleportImpl).process(</span><br><span class="line">          n1 as TeleportVNode,</span><br><span class="line">          n2 as TeleportVNode,</span><br><span class="line">          container,</span><br><span class="line">          anchor,</span><br><span class="line">          parentComponent,</span><br><span class="line">          parentSuspense,</span><br><span class="line">          isSVG,</span><br><span class="line">          slotScopeIds,</span><br><span class="line">          optimized,</span><br><span class="line">          internals</span><br><span class="line">        )</span><br><span class="line">      &#125; else if (__FEATURE_SUSPENSE__ &amp;&amp; shapeFlag &amp; ShapeFlags.SUSPENSE) &#123;</span><br><span class="line">        ;(type as typeof SuspenseImpl).process(</span><br><span class="line">          n1,</span><br><span class="line">          n2,</span><br><span class="line">          container,</span><br><span class="line">          anchor,</span><br><span class="line">          parentComponent,</span><br><span class="line">          parentSuspense,</span><br><span class="line">          isSVG,</span><br><span class="line">          slotScopeIds,</span><br><span class="line">          optimized,</span><br><span class="line">          internals</span><br><span class="line">        )</span><br><span class="line">      &#125; else if (__DEV__) &#123;</span><br><span class="line">        warn(&apos;Invalid VNode type:&apos;, type, `($&#123;typeof type&#125;)`)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // set ref</span><br><span class="line">  if (ref != null &amp;&amp; parentComponent) &#123;</span><br><span class="line">    setRef(ref, n1 &amp;&amp; n1.ref, parentSuspense, n2 || n1, !n2)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们首次渲染的 App 是一个组件，所以要执行的就是 processComponent 方法。</p>
<h3 id="processComponent-方法"><a href="#processComponent-方法" class="headerlink" title="processComponent 方法"></a>processComponent 方法</h3><p>那我们继续进入到 processComponent 代码内部，看下面的代码。首次渲染的时候，n1 就是 null，所以会执行 mountComponent；如果是更新组件的时候，n1 就是上次渲染的 vdom，需要执行 updateComponent。</p>
<p>进入 mountComponent 函数中，可以看到 mountComponent 函数内部会对组件的类型进行一系列的判断，还有一些对 Vue 2 的兼容代码，核心的渲染逻辑就是 setupComponent 函数和 setupRenderEffect 函数。</p>
<h3 id="setupComponent"><a href="#setupComponent" class="headerlink" title="setupComponent"></a>setupComponent</h3><p>内部先初始化了 props 和 slots，并且执行 setupStatefulComponent 创建组件，而这个函数内部从 component 中获取 setup 属性，也就是 script setup 内部实现的函数，就进入到我们组件内部的 reactive、ref 等函数实现的逻辑了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">export function setupComponent(</span><br><span class="line">  instance: ComponentInternalInstance,</span><br><span class="line">  isSSR = false</span><br><span class="line">) &#123;</span><br><span class="line">  isInSSRComponentSetup = isSSR</span><br><span class="line"></span><br><span class="line">  const &#123; props, children &#125; = instance.vnode</span><br><span class="line">  const isStateful = isStatefulComponent(instance)</span><br><span class="line">  initProps(instance, props, isStateful, isSSR)</span><br><span class="line">  initSlots(instance, children)</span><br><span class="line"></span><br><span class="line">  const setupResult = isStateful</span><br><span class="line">    ? setupStatefulComponent(instance, isSSR)</span><br><span class="line">    : undefined</span><br><span class="line">  isInSSRComponentSetup = false</span><br><span class="line">  return setupResult</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function setupStatefulComponent(</span><br><span class="line">  instance: ComponentInternalInstance,</span><br><span class="line">  isSSR: boolean</span><br><span class="line">) &#123;</span><br><span class="line">  const Component = instance.type as ComponentOptions</span><br><span class="line">  // 执行setup</span><br><span class="line">  const &#123; setup &#125; = Component</span><br><span class="line">  if (setup) &#123;</span><br><span class="line">    const setupContext = (instance.setupContext =</span><br><span class="line">      setup.length &gt; 1 ? createSetupContext(instance) : null)</span><br><span class="line"></span><br><span class="line">    setCurrentInstance(instance)</span><br><span class="line">    pauseTracking()</span><br><span class="line">    const setupResult = callWithErrorHandling(</span><br><span class="line">      setup,</span><br><span class="line">      instance,</span><br><span class="line">      ErrorCodes.SETUP_FUNCTION,</span><br><span class="line">      [instance.props, setupContext]</span><br><span class="line">    )</span><br><span class="line">    if (isPromise(setupResult)) &#123;</span><br><span class="line">      setupResult.then(unsetCurrentInstance, unsetCurrentInstance)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      handleSetupResult(instance, setupResult, isSSR)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    finishComponentSetup(instance, isSSR)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function callWithErrorHandling(</span><br><span class="line">  fn: Function,</span><br><span class="line">  instance: ComponentInternalInstance | null,</span><br><span class="line">  type: ErrorTypes,</span><br><span class="line">  args?: unknown[]</span><br><span class="line">) &#123;</span><br><span class="line">  let res</span><br><span class="line">  try &#123;</span><br><span class="line">    res = args ? fn(...args) : fn()</span><br><span class="line">  &#125; catch (err) &#123;</span><br><span class="line">    handleError(err, instance, type)</span><br><span class="line">  &#125;</span><br><span class="line">  return res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="setupRenderEffect"><a href="#setupRenderEffect" class="headerlink" title="setupRenderEffect"></a>setupRenderEffect</h3><p>在下面的核心代码中，我们通过 ReactiveEffect 创建了 effect 函数，这个概念上一讲我们手写过，然后执行 instance.update 赋值为 effect.run 方法，这样结合 setup 内部的 ref 和 reactive 绑定的数据，数据修改之后，就会触发 update 方法的执行，内部就会 componentUpdateFn，内部进行递归的 patch 调用执行每个组件内部的 update 方法实现组件的更新。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">if (!instance.isMounted) &#123;</span><br><span class="line">     patch(</span><br><span class="line">        null,</span><br><span class="line">        subTree,</span><br><span class="line">        container,</span><br><span class="line">        anchor,</span><br><span class="line">        instance,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        isSVG</span><br><span class="line">      )</span><br><span class="line">&#125;else&#123;</span><br><span class="line">  // updateComponent</span><br><span class="line">&#125;</span><br><span class="line">// create reactive effect for rendering</span><br><span class="line">const effect = new ReactiveEffect(</span><br><span class="line">  componentUpdateFn,</span><br><span class="line">  () =&gt; queueJob(instance.update),</span><br><span class="line">  instance.scope // track it in component&apos;s effect scope</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const update = (instance.update = effect.run.bind(effect) as SchedulerJob)</span><br><span class="line">update.id = instance.uid</span><br><span class="line"></span><br><span class="line">update()</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Vue 通过 createApp 创建应用，并且执行返回的 mount 方法实现在浏览器中的挂载，在 createApp 中，通过传递浏览器平台的操作方法 nodeOps 创建了浏览器的渲染器 renderer。</p>
<p>首次执行 Vue 项目的时候，通过 patch 实现组件的渲染，patch 函数内部根据节点的不同类型，去分别执行 processElement、processComponent、processText 等方法去递归处理不同类型的节点，最终通过 setupComponent 执行组件的 setup 函数，setupRenderEffect 中使用响应式的 effect 函数监听数据的变化。</p>
<h2 id="虚拟-DOM（上）：如何通过虚拟-DOM-更新页面？"><a href="#虚拟-DOM（上）：如何通过虚拟-DOM-更新页面？" class="headerlink" title="虚拟 DOM（上）：如何通过虚拟 DOM 更新页面？"></a>虚拟 DOM（上）：如何通过虚拟 DOM 更新页面？</h2><p>Vue 项目的首次渲染流程，在 mountComponent 中注册了 effect 函数，这样，在组件数据有更新的时候，就会通知到组件的 update 方法进行更新。</p>
<p>Vue 内部的虚拟 DOM，也就是 vnode，就是一个对象，通过 type、props、children 等属性描述整个节点</p>
<p>Vue 源码中的实现首次渲染和更新的逻辑都写在一起，我们在递归的时候如果对一个标签实现更新和渲染，就可以用一个函数实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const componentUpdateFn = ()=&gt;&#123;</span><br><span class="line">  if (!instance.isMounted) &#123;</span><br><span class="line">      //首次渲染</span><br><span class="line">      instance,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        isSVG</span><br><span class="line">      )</span><br><span class="line">      。。。</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    let &#123; next, bu, u, parent, vnode &#125; = instance</span><br><span class="line">    if (next) &#123;</span><br><span class="line">      next.el = vnode.el</span><br><span class="line">      updateComponentPreRender(instance, next, optimized)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      next = vnode</span><br><span class="line">    &#125;</span><br><span class="line">    const nextTree = renderComponentRoot(instance)</span><br><span class="line">      patch(</span><br><span class="line">        prevTree,</span><br><span class="line">        nextTree,</span><br><span class="line">        // parent may have changed if it&apos;s in a teleport</span><br><span class="line">        hostParentNode(prevTree.el!)!,</span><br><span class="line">        // anchor may have changed if it&apos;s in a fragment</span><br><span class="line">        getNextHostNode(prevTree),</span><br><span class="line">        instance,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        isSVG</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 注册effect函数</span><br><span class="line">const effect = new ReactiveEffect(</span><br><span class="line">  componentUpdateFn,</span><br><span class="line">  () =&gt; queueJob(instance.update),</span><br><span class="line">  instance.scope // track it in component&apos;s effect scope</span><br><span class="line">)</span><br><span class="line">const update = (instance.update = effect.run.bind(effect) as S      chedulerJob)</span><br><span class="line">update()</span><br><span class="line"></span><br><span class="line">  const updateComponentPreRender = (</span><br><span class="line">    instance: ComponentInternalInstance,</span><br><span class="line">    nextVNode: VNode,</span><br><span class="line">    optimized: boolean</span><br><span class="line">  ) =&gt; &#123;</span><br><span class="line">    nextVNode.component = instance</span><br><span class="line">    const prevProps = instance.vnode.props</span><br><span class="line">    instance.vnode = nextVNode</span><br><span class="line">    instance.next = null</span><br><span class="line">    updateProps(instance, nextVNode.props, prevProps, optimized)</span><br><span class="line">    updateSlots(instance, nextVNode.children, optimized)</span><br><span class="line"></span><br><span class="line">    pauseTracking()</span><br><span class="line">    // props update may have triggered pre-flush watchers.</span><br><span class="line">    // flush them before the render update.</span><br><span class="line">    flushPreFlushCbs(undefined, instance.update)</span><br><span class="line">    resetTracking()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="patch-函数-1"><a href="#patch-函数-1" class="headerlink" title="patch 函数"></a>patch 函数</h3><p>在 patch 函数中，会针对不同的组件类型执行不同的函数，组件我们会执行 processComponent，HTML 标签我们会执行 processElement</p>
<p>由于更新之后不是首次渲染了，patch 函数内部会执行 updateComponent，看下面的 updateComponent 函数内部，shouldUpdateComponent 会判断组件是否需要更新，实际执行的是 instance.update</p>
<p>组件的子元素是由 HTML 标签和组件构成，组件内部的递归处理最终也是对 HTML 标签的处理，所以，最后组件的更新都会进入到 processElement 内部的 patchElement 函数中。</p>
<h3 id="patchElement-函数"><a href="#patchElement-函数" class="headerlink" title="patchElement 函数"></a>patchElement 函数</h3><p>在函数 patchElement 中我们主要就做两件事，更新节点自己的属性和更新子元素。</p>
<h4 id="节点自身属性的更新"><a href="#节点自身属性的更新" class="headerlink" title="节点自身属性的更新"></a>节点自身属性的更新</h4><p>先看自身属性的更新，这里就能体现出 Vue 3 中性能优化的思想，通过 patchFlag 可以做到按需更新：<br>如果标记了 FULL_PROPS，就直接调用 patchProps。<br>如果标记了 CLASS，说明节点只有 class 属性是动态的，其他的 style 等属性都不需要进行判断和 DOM 操作。</p>
<p>Vue 3 的虚拟 DOM 真正做到了按需更新，这也是相比于 React 的一个优势。</p>
<h4 id="子元素的更新"><a href="#子元素的更新" class="headerlink" title="子元素的更新"></a>子元素的更新</h4><p>子元素的更新是 patchChildren 函数负责的，这个函数也是虚拟 DOM 中难度最高的一个函数。</p>
<p>首先我们把子元素分成了文本、数组和空三个状态，新老子元素分别是这三种状态的一个，构成了不同的执行逻辑。这样 patchChildren 内部大致有五种情况需要处理：<br>如果新的子元素是空， 老的子元素不为空，直接卸载 unmount 即可。<br>如果新的子元素不为空，老的子元素是空，直接创建加载即可。<br>如果新的子元素是文本，老的子元素如果是数组就需要全部 unmount，是文本的话就需要执行 hostSetElementText。<br>如果新的子元素是数组，比如是使用 v-for 渲染出来的列表，老的子元素如果是空或者文本，直接 unmount 后，渲染新的数组即可。<br>最复杂的情况就是新的子元素和老的子元素都是数组。</p>
<p>最朴实无华的思路就是把老的子元素全部 unmount，新的子元素全部 mount，这样虽然可以实现功能，但是没法复用已经存在的 DOM 元素，比如我们只是在数组中间新增了一个数据，全部 DOM 都销毁就有点太可惜了。</p>
<p>所以，我们需要判断出可以复用的 DOM 元素，如果一个虚拟 DOM 没有改动或者属性变了，不需要完全销毁重建，而是更新一下属性，最大化减少 DOM 的操作，这个任务就会交给 patchKeyedChildren 函数去完成。</p>
<p>patchKeyedChildren 函数，做的事情就是尽可能高效地把老的子元素更新成新的子元素，如何高效复用老的子元素中的 DOM 元素是 patchKeyedChildren 函数的难点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const patchChildren: PatchChildrenFn = (</span><br><span class="line">  n1,</span><br><span class="line">  n2,</span><br><span class="line">  container,</span><br><span class="line">  anchor,</span><br><span class="line">  parentComponent,</span><br><span class="line">  parentSuspense,</span><br><span class="line">  isSVG,</span><br><span class="line">  slotScopeIds,</span><br><span class="line">  optimized = false</span><br><span class="line">) =&gt; &#123;</span><br><span class="line">  const c1 = n1 &amp;&amp; n1.children</span><br><span class="line">  const prevShapeFlag = n1 ? n1.shapeFlag : 0</span><br><span class="line">  const c2 = n2.children</span><br><span class="line"></span><br><span class="line">  const &#123; patchFlag, shapeFlag &#125; = n2</span><br><span class="line">  // fast path</span><br><span class="line">  if (patchFlag &gt; 0) &#123;</span><br><span class="line">    if (patchFlag &amp; PatchFlags.KEYED_FRAGMENT) &#123;</span><br><span class="line">      // this could be either fully-keyed or mixed (some keyed some not)</span><br><span class="line">      // presence of patchFlag means children are guaranteed to be arrays</span><br><span class="line">      patchKeyedChildren(</span><br><span class="line">        c1 as VNode[],</span><br><span class="line">        c2 as VNodeArrayChildren,</span><br><span class="line">        container,</span><br><span class="line">        anchor,</span><br><span class="line">        parentComponent,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        isSVG,</span><br><span class="line">        slotScopeIds,</span><br><span class="line">        optimized</span><br><span class="line">      )</span><br><span class="line">      return</span><br><span class="line">    &#125; else if (patchFlag &amp; PatchFlags.UNKEYED_FRAGMENT) &#123;</span><br><span class="line">      // unkeyed</span><br><span class="line">      patchUnkeyedChildren(</span><br><span class="line">        c1 as VNode[],</span><br><span class="line">        c2 as VNodeArrayChildren,</span><br><span class="line">        container,</span><br><span class="line">        anchor,</span><br><span class="line">        parentComponent,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        isSVG,</span><br><span class="line">        slotScopeIds,</span><br><span class="line">        optimized</span><br><span class="line">      )</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // children has 3 possibilities: text, array or no children.</span><br><span class="line">  if (shapeFlag &amp; ShapeFlags.TEXT_CHILDREN) &#123;</span><br><span class="line">    // text children fast path</span><br><span class="line">    if (prevShapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) &#123;</span><br><span class="line">      unmountChildren(c1 as VNode[], parentComponent, parentSuspense)</span><br><span class="line">    &#125;</span><br><span class="line">    if (c2 !== c1) &#123;</span><br><span class="line">      hostSetElementText(container, c2 as string)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    if (prevShapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) &#123;</span><br><span class="line">      // prev children was array</span><br><span class="line">      if (shapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) &#123;</span><br><span class="line">        // two arrays, cannot assume anything, do full diff</span><br><span class="line">        patchKeyedChildren(</span><br><span class="line">          c1 as VNode[],</span><br><span class="line">          c2 as VNodeArrayChildren,</span><br><span class="line">          container,</span><br><span class="line">          anchor,</span><br><span class="line">          parentComponent,</span><br><span class="line">          parentSuspense,</span><br><span class="line">          isSVG,</span><br><span class="line">          slotScopeIds,</span><br><span class="line">          optimized</span><br><span class="line">        )</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        // no new children, just unmount old</span><br><span class="line">        unmountChildren(c1 as VNode[], parentComponent, parentSuspense, true)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // prev children was text OR null</span><br><span class="line">      // new children is array OR null</span><br><span class="line">      if (prevShapeFlag &amp; ShapeFlags.TEXT_CHILDREN) &#123;</span><br><span class="line">        hostSetElementText(container, &apos;&apos;)</span><br><span class="line">      &#125;</span><br><span class="line">      // mount new if array</span><br><span class="line">      if (shapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) &#123;</span><br><span class="line">        mountChildren(</span><br><span class="line">          c2 as VNodeArrayChildren,</span><br><span class="line">          container,</span><br><span class="line">          anchor,</span><br><span class="line">          parentComponent,</span><br><span class="line">          parentSuspense,</span><br><span class="line">          isSVG,</span><br><span class="line">          slotScopeIds,</span><br><span class="line">          optimized</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="patchChildren"><a href="#patchChildren" class="headerlink" title="patchChildren"></a>patchChildren</h3><p>最后就剩下 patchChildren 的实现了，这也是各类虚拟 DOM 框架中最难实现的函数，我们需要实现一个高效的更新算法，能够使用尽可能少的更新次数，来实现从老的子元素到新的子元素的更新。</p>
<p>举个例子，类似体育课站队的时候，大家一开始站一排，但是顺序是乱的，我们需要尽快把队伍按照个头左低右高排列。</p>
<p>在 React 中，这种场景的处理逻辑是先进行循环，使用的是单侧插入的算法，我们在排队的时候挨个对比，如果你站我右边，并且个头比我高一点，说明咱俩的相对位置和最终队伍的位置是一致的，暂时不需要变化，如果你比我个头矮，就需要去我左边找到一个正确的位置插队进去。<br>由于都只向单侧插入，最后我们就会把所有的节点移动到正确的位置之上，这就是 React15 框架内虚拟节点 diff 的逻辑，初步实现了 DOM 的复用；而 Vue 2 借鉴了 snabbdom 的算法，在此基础上做了第一层双端对比的优化。</p>
<p>首先 Web 场景之下对一个数组元素的操作，很少有直接全部替换的，比如我们操作一个表格，大概率是更关心表格某一行的一个字段、新增一行、删除一行，或者是对表格某个字段进行排序，所以我们可以从纯算法的场景之中加入实际应用的场景。</p>
<p>如果我们只是在表格里新增一行，那么可以不要一开始就开始循环，而是可以先进行节点的预判。</p>
<p>比如，在下面的例子中，新的节点就是在老的节点中新增和删除了几个元素，我们在循环之前，先进行头部元素的判断。在这个例子里，可以预判出头部元素的 a、b、c、d 是一样的节点，说明节点不需要重新创建，我们只需要进行属性的更新，然后进行队尾元素的预判，可以判断出 g 和 h 元素也是一样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">a b c d e f g h</span><br><span class="line">a b c d i f j g h</span><br></pre></td></tr></table></figure>
<p>这样我们虚拟 DOM diff 的逻辑就变成了下面的结构, 现在只需要比较 ef 和 ifg 的区别</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(a b c d) e f (g h)</span><br><span class="line">(a b c d) i f j (g h)</span><br></pre></td></tr></table></figure>
<p>相比于之前的对比场景，我们需要遍历的运算量就大大减小了。</p>
<p>双端对比的原理大致就是这样。</p>
<p>想让一个队伍尽快按照个头排好序，如果能够计算出，在队伍中，个头从低到高依次递增的最多的队列，让这些人站在原地不动，其余人穿插到他们中间，就可以最大化减少人员的移动，这就是一个最长底层子序列的算法问题。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>Vue 响应式驱动了组件之间的数据通信机制，数据更新之后，组件会执行 intance.update 方法，update 方法内部执行 patch 方法进行新老子树的 diff 计算。</p>
<p>在更新函数中，主要做了两件事，pathProps 更新节点自身的属性，这里面使用了 pathFlags 做到了按需更新；patchChildren 执行子元素的更新。其中 patch 函数内部会只对节点内部的动态属性做更新，这种按需更新的机制是 Vue 性能优秀的一个原因。</p>
<p>函数内部针对新老子元素不同的状态，执行不同的逻辑。根据子元素是否为空或者数组，以及新元素是否为空或者数组，分别执行对应的删除或者 mount 逻辑，其中最复杂的就是新的子元素和老的子元素都是数组。</p>
<p>为了最大化减少 DOM 操作，patchKeyedChildren 使用了最长递增子序列来实现，并且相比于 React 的虚拟 DOM diff，新增了双端的预先判断 + 最长递增子序列算法来实现，这也是 Vue 性能比较优秀的另外一个原因。</p>
<h2 id="虚拟-DOM（下）：想看懂虚拟-DOM-算法，先刷个算法题"><a href="#虚拟-DOM（下）：想看懂虚拟-DOM-算法，先刷个算法题" class="headerlink" title="虚拟 DOM（下）：想看懂虚拟 DOM 算法，先刷个算法题"></a>虚拟 DOM（下）：想看懂虚拟 DOM 算法，先刷个算法题</h2><p>将讲到如何使用位运算来实现 Vue 中的按需更新，让静态的节点可以越过虚拟 DOM 的计算逻辑，并且使用计算最长递增子序列的方式，来实现队伍的高效排序。</p>
<h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(13).toString(2) // 1101</span><br><span class="line"></span><br><span class="line">0 &amp; 0  // 0</span><br><span class="line">0 &amp; 1  // 0</span><br><span class="line">1 &amp; 0  // 0</span><br><span class="line">1 &amp; 1  // 1</span><br><span class="line"></span><br><span class="line">0 | 0  // 0</span><br><span class="line">0 | 1  // 1</span><br><span class="line">1 | 0  // 1</span><br><span class="line">1 | 1  // 1</span><br><span class="line"></span><br><span class="line">1 &lt;&lt; 2 // 1左移动两位，就是100</span><br></pre></td></tr></table></figure>
<p>二进制中，我们每个位置只能是 0 或者 1 这两个值，&amp; 和 | 的概念和 JavaScript 中的 &amp;&amp; 和 || 保持一致。两个二进制的 &amp; 运算就是只有两个二进制位置都是 1 的时候，结果是 1，其余情况运算结果都是 0；| 是按位置进行“或”运算，只有两个二进制位置都是 0 的时候，结果是 0，其余情况运算结果都是 1；并且，还可以通过左移 &lt;&lt; 和右移 &gt;&gt; 操作符，实现乘以 2 和除以 2 的效果。</p>
<p>由于这些都是在二进制上的计算，运算的性能通常会比字符串和数字的计算性能要好，这也是很多框架内部使用位运算的原因。</p>
<h4 id="为什么位运算性能更好"><a href="#为什么位运算性能更好" class="headerlink" title="为什么位运算性能更好"></a>为什么位运算性能更好</h4><p>我们来做一下 LeetCode231 题，题目描述很简单，判断数字 n 是不是 2 的幂次方，也就是说，判断数字 n 是不是 2 的整次方，比如 2、4、8。我们可以很轻松地写出 JavaScript 的解答，n 一直除以 2，如果有余数就是 false，否则就是 true：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var isPowerOfTwo = function(n) &#123;</span><br><span class="line">    if(n === 1) return true</span><br><span class="line">    while( n &gt; 2 )&#123;</span><br><span class="line">        n = n / 2</span><br><span class="line">        if(n % 2 !== 0) return false</span><br><span class="line">    &#125;</span><br><span class="line">    return n===2</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>2 的幂次方就是数字 1 左移动若干次，其余位置全部都是 0，所以 n-1 就是最高位变成 0，其余位置都变成 1，就像十进制里的 10000-1 = 9999。这样，n 和 n-1 每个二进制位的数字都不一样，我们可以很轻松地用按位“与”来判断这个题的答案，如果 n&amp;n-1 是 0 的话，数字 n 就符合 2 的整次幂的特点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">16</span><br><span class="line">10000</span><br><span class="line">16-1 = 15</span><br><span class="line">01111</span><br><span class="line">16&amp;15 == 0</span><br><span class="line"></span><br><span class="line">var isPowerOfTwo = function(n) &#123;</span><br><span class="line">    return n&gt;0 &amp;&amp; (n &amp; (n - 1)) === 0</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>所以我们使用位运算提高了代码的整体性能。</p>
<h4 id="如何运用位运算"><a href="#如何运用位运算" class="headerlink" title="如何运用位运算"></a>如何运用位运算</h4><p>比如，一个节点如果 TEXT 和 STYLE 都需要修改，我们只需要使用 | 运算符就可以得到 flag1 的权限表示，这就是为什么 Vue 3 中针对虚拟 DOM 类型以及虚拟 DOM 需要动态计算 diff 的树形都做了标记，你可以在 Vue 3 的源码中看到下面的配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const PatchFlags = &#123;</span><br><span class="line">  TEXT:1,      // 0001</span><br><span class="line">  CLASS: 1&lt;&lt;1, // 0010</span><br><span class="line">  STYLE:1&lt;&lt;2,  // 0100</span><br><span class="line">  PROPS:1&lt;&lt;3   // 1000</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const flag1 = PatchFlags.TEXT | PatchFlags.STYLE // 0101</span><br><span class="line"></span><br><span class="line">// 权限校验</span><br><span class="line"></span><br><span class="line">flag1 &amp; PatchFlags.TEXT  // 有权限，结果大于1</span><br><span class="line">flag1 &amp; PatchFlags.CLASS //没有权限 是0</span><br></pre></td></tr></table></figure>
<h3 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h3><p>我们看 LeetCode 第 300 题，题目描述如下, 需要在数组中找到最长底层的自序列长度：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给你一个整数数组 nums，找到其中最长严格递增子序列的长度。</span><br><span class="line"></span><br><span class="line">子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。</span><br><span class="line">例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</span><br><span class="line"></span><br><span class="line">=</span><br><span class="line">输入：nums = [10,9,2,5,3,7,101,18]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</span><br></pre></td></tr></table></figure>
<p>首先我们可以使用动态规划的思路，通过每一步的递推，使用 dp 数组，记录出每一步操作的最优解，最后得到全局最优解。<br>在这个例子中，我们可以把 dp[i]定义成 nums[0]到 nums[i]这个区间内，数组的最长递增子序列的长度，并且 dp 数组的初始值设为 1。<br>从左边向右递推，如果 nums[i+1]&gt;nums[i]，dp[i+1]就等于 dp[i]+1；如果 nums[i+1] &lt; nums[i]，就什么都不需要干，这样我们在遍历的过程中，就能根据数组当前位置之前的最长递增子序列长度推导出 i+1 位置的最长递增子序列长度。所以可以得到如下解法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">const lengthOfLIS = function(nums) &#123;</span><br><span class="line">    let n = nums.length;</span><br><span class="line">    if (n == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    let dp = new Array(n).fill(1);</span><br><span class="line">    for (let i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (let j = 0; j &lt; i; j++) &#123;</span><br><span class="line">            if (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                dp[i] = Math.max(dp[i], dp[j] + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return Math.max(...dp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于我们需要两层循环，所以这个解法的时间复杂度是 n 的平方，这个解法其实已经不错了，但是还有更优秀的解法，也就是 Vue 3 中用到的算法：贪心 + 二分。</p>
<h4 id="贪心-二分"><a href="#贪心-二分" class="headerlink" title="贪心 + 二分"></a>贪心 + 二分</h4><p>我们可以创建一个 arr 数组，用来保存这种策略下的最长递增子序列。<br>如果当前遍历的 nums[i]大于 arr 的最后一个元素，也就是大于 arr 的最大值时，我们把 nums[i]追加到后面即可，否则我们就在 arr 中寻找一个第一个大于 num[i]的数字并替换它。因为是 arr 是递增的数列，所以在寻找插入位置的时候，我们可以使用二分查找的方式，把整个算法的复杂度变成 O(nlgn)。</p>
<p>下面的代码就是贪心 + 二分的解法，我们可以得到正确的最长递增子序列的长度：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">const lengthOfLIS = function(nums) &#123;</span><br><span class="line">    let len = nums.length</span><br><span class="line">    if (len &lt;= 1) &#123;</span><br><span class="line">        return len</span><br><span class="line">    &#125;</span><br><span class="line">    let arr = [nums[0]]</span><br><span class="line">    for (let i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        // nums[i] 大于 arr 尾元素时，直接追加到后面，递增序列长度+1</span><br><span class="line">        if (nums[i] &gt; arr[arr.length - 1]) &#123;</span><br><span class="line">            arr.push(nums[i])</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 否则，查找递增子序列中第一个大于numsp[i]的元素 替换它</span><br><span class="line">            // 递增序列，可以使用二分查找</span><br><span class="line">            let left = 0</span><br><span class="line">            let right = arr.length - 1</span><br><span class="line">            while (left &lt; right) &#123;</span><br><span class="line">                let mid = (left + right) &gt;&gt; 1</span><br><span class="line">                if (arr[mid] &lt; nums[i]) &#123;</span><br><span class="line">                    left = mid + 1</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    right = mid</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[left] = nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr.length</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但是贪心 + 二分的这种解法，现在只能得到最长递增子序列的长度，但是最后得到的 arr 并不一定是最长递增子序列，因为我们移动的 num[i]位置可能会不正确，只是得到的数组长度是正确的，所以我们需要对这个算法改造一下，把整个数组复制一份之后，最后也能得到正确的最长递增子序列。</p>
<p>具体代码怎么写呢？我们来到 Vue 3 的 renderer.ts 文件中，函数 getSquenece 就是用来生成最长递增子序列，看下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// https://en.wikipedia.org/wiki/Longest_increasing_subsequence</span><br><span class="line">  function getSequence(arr: number[]): number[] &#123;</span><br><span class="line">    const p = arr.slice() //赋值一份arr</span><br><span class="line">    const result = [0]</span><br><span class="line">    let i, j, u, v, c</span><br><span class="line">    const len = arr.length</span><br><span class="line">    for (i = 0; i &lt; len; i++) &#123;</span><br><span class="line">      const arrI = arr[i]</span><br><span class="line">      if (arrI !== 0) &#123;</span><br><span class="line">        j = result[result.length - 1]</span><br><span class="line">        if (arr[j] &lt; arrI) &#123;</span><br><span class="line">          p[i] = j  // 存储在result最后一个索引的值</span><br><span class="line">          result.push(i)</span><br><span class="line">          continue</span><br><span class="line">        &#125;</span><br><span class="line">        u = 0</span><br><span class="line">        v = result.length - 1</span><br><span class="line">          // 二分查找，查找比arrI小的节点，更新result的值</span><br><span class="line">        while (u &lt; v) &#123;</span><br><span class="line">          c = (u + v) &gt;&gt; 1</span><br><span class="line">          if (arr[result[c]] &lt; arrI) &#123;</span><br><span class="line">            u = c + 1</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            v = c</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (arrI &lt; arr[result[u]]) &#123;</span><br><span class="line">          if (u &gt; 0) &#123;</span><br><span class="line">              //索引存储 有一丢丢复杂</span><br><span class="line">            p[i] = result[u - 1]</span><br><span class="line">          &#125;</span><br><span class="line">          result[u] = i</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    u = result.length</span><br><span class="line">    v = result[u - 1]</span><br><span class="line">      // 查找数组p 找到最终的索引</span><br><span class="line">    while (u-- &gt; 0) &#123;</span><br><span class="line">      result[u] = v</span><br><span class="line">      v = p[v]</span><br><span class="line">    &#125;</span><br><span class="line">    return result</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这段代码就是 Vue 3 里的实现，result 存储的就是长度是 i 的递增子序列最小末位置的索引，最后计算出最长递增子序列。</p>
<p>我们得到 increasingNewIndexSequence 队列后，再去遍历数组进行 patch 操作就可以实现完整的 diff 流程了。</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>首先我们分析了 Vue 3 中虚拟 DOM diff 中的静态标记功能，标记后通过位运算，可以快速判断出一个节点的类型是 HTML 标签还是 Vue 组件，然后去执行不同的操作方法；在节点更新的流程中，也可以通过位运算的方式确定需要更新的范围。</p>
<p>位运算就是通过二进制上的与和或运算，能够高效地进行权限的判断，我们在工作中如果涉及权限的判断，也可以借鉴类似的思路，Linux 中的读写权限也是通过位运算的方式来实现的。</p>
<p>patchKeyedChildren 的核心逻辑就是在进行双端对比后，对无法预判的序列计算出最长递增子序列之后，我们通过编译数组，对其余的元素进行 patch 或者 move 的操作，完整实现了虚拟 DOM 的 diff。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/学习/">学习</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/学习/">学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网站/">网站</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/资源/">资源</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-interview" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2021/09/01/interview/" class="article-date">
      <time datetime="2021-08-31T16:00:00.000Z" itemprop="datePublished">2021-09-01</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/09/01/interview/">起个名字真难</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="前端基础"><a href="#前端基础" class="headerlink" title="前端基础"></a>前端基础</h2><h3 id="http-https"><a href="#http-https" class="headerlink" title="http/https"></a>http/https</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line">1.http: 超文本传输协议，是一个客户端和服务器端请求和应答的标准</span><br><span class="line">可靠传输。这个特点显而易见，因为 HTTP 协议是基于 TCP/IP 的，而 TCP 本身是一个“可靠”的传输协议，所以 HTTP 自然也就继承了这个特性，能够在请求方和应答方之间“可靠”地传输数据。</span><br><span class="line">应用层协议。HTTP 几乎可以传递一切东西，满足各种需求，称得上是一个“万能”的协议。</span><br><span class="line">我们可以再对比一下 UDP 协议，不过它是无连接也无状态的，顺序发包乱序收包，数据包发出去后就不管了，收到后也不会顺序整理。而 HTTP 是有连接无状态，顺序发包顺序收包，按照收发的顺序管理报文。</span><br><span class="line"></span><br><span class="line">2.https: 是以安全为目标的 HTTP 通道，简单讲是 HTTP 的安全版，即 HTTP 下加入 SSL层</span><br><span class="line">SSL/TLS，它是一个负责加密通信的安全协议，建立在 TCP/IP 之上，所以也是个可靠的传输协议</span><br><span class="line">SSL 的全称是“Secure Socket Layer”，由网景公司发明，当发展到 3.0 时被标准化，改名为 TLS，即“Transport Layer Security”，</span><br><span class="line">但由于历史的原因还是有很多人称之为 SSL/TLS，或者直接简称为 SSL。</span><br><span class="line"></span><br><span class="line">TLS 协议的组成</span><br><span class="line">TLS 包含几个子协议，你也可以理解为它是由几个不同职责的模块组成，比较常用的有记录协议、警报协议、握手协议、变更密码规范协议等。</span><br><span class="line">记录协议（Record Protocol）规定了 TLS 收发数据的基本单位,所有的其他子协议都需要通过记录协议发出。</span><br><span class="line">警报协议（Alert Protocol）的职责是向对方发出警报信息，有点像是 HTTP 协议里的状态码。</span><br><span class="line">握手协议（Handshake Protocol）是 TLS 里最复杂的子协议，浏览器和服务器会在握手过程中协商 TLS 版本号、随机数、密码套件等信息，然后交换证书和密钥参数，最终双方协商得到会话密钥，用于后续的混合加密系统。</span><br><span class="line">变更密码规范协议（Change Cipher Spec Protocol），它非常简单，就是一个“通知”，告诉对方，后续的数据都将使用加密保护。那么反过来，在它之前，数据都是明文的。</span><br><span class="line"></span><br><span class="line">ECDHE 握手过程</span><br><span class="line">在 TCP 建立连接之后，浏览器会首先发一个“Client Hello”消息，也就是跟服务器“打招呼”。里面有客户端的版本号、支持的密码套件，还有一个随机数（Client Random），用于后续生成会话密钥。这个的意思就是：“我这边有这些这些信息，你看看哪些是能用的，关键的随机数可得留着。”</span><br><span class="line">作为“礼尚往来”，服务器收到“Client Hello”后，会返回一个“Server Hello”消息。把版本号对一下，也给出一个随机数（Server Random），然后从客户端的列表里选一个作为本次通信使用的密码套件，在这里它选择了“TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384”。这个的意思就是：“版本号对上了，可以加密，你的密码套件挺多，我选一个最合适的吧，用椭圆曲线加 RSA、AES、SHA384。我也给你一个随机数，你也得留着。”</span><br><span class="line">然后，服务器为了证明自己的身份，就把证书也发给了客户端（Server Certificate）。</span><br><span class="line">接下来是一个关键的操作，因为服务器选择了 ECDHE 算法，所以它会在证书后发送“Server Key Exchange”消息，里面是椭圆曲线的公钥（Server Params），用来实现密钥交换算法，再加上自己的私钥签名认证。这相当于说：“刚才我选的密码套件有点复杂，所以再给你个算法的参数，和刚才的随机数一样有用，别丢了。为了防止别人冒充，我又盖了个章。”</span><br><span class="line">这样第一个消息往返就结束了（两个 TCP 包），结果是客户端和服务器通过明文共享了三个信息：Client Random、Server Random 和 Server Params。</span><br><span class="line">客户端这时也拿到了服务器的证书，那这个证书是不是真实有效的呢？开始走证书链逐级验证，确认证书的真实性，再用证书公钥验证签名，就确认了服务器的身份：“刚才跟我打招呼的不是骗子，可以接着往下走。”</span><br><span class="line">然后，客户端按照密码套件的要求，也生成一个椭圆曲线的公钥（Client Params），用“Client Key Exchange”消息发给服务器。</span><br><span class="line">现在客户端和服务器手里都拿到了密钥交换算法的两个参数（Client Params、Server Params），就用 ECDHE 算法一阵算，算出了一个新的东西，叫“Pre-Master”，其实也是一个随机数。</span><br><span class="line">现在客户端和服务器手里有了三个随机数：Client Random、Server Random 和 Pre-Master。用这三个作为原始材料，就可以生成用于加密会话的主密钥，叫“Master Secret”。而黑客因为拿不到“Pre-Master”，所以也就得不到主密钥。</span><br><span class="line">为什么非得这么麻烦，非要三个随机数呢？这就必须说 TLS 的设计者考虑得非常周到了，他们不信任客户端或服务器伪随机数的可靠性，为了保证真正的“完全随机”“不可预测”，把三个不可靠的随机数混合起来，那么“随机”的程度就非常高了，足够让黑客难以猜测。</span><br><span class="line">主密钥有 48 字节，但它也不是最终用于通信的会话密钥，还会再用 PRF 扩展出更多的密钥，比如客户端发送用的会话密钥（client_write_key）、服务器发送用的会话密钥（server_write_key）等等，避免只用一个密钥带来的安全隐患。</span><br><span class="line">有了主密钥和派生的会话密钥，握手就快结束了。客户端发一个“Change Cipher Spec”，然后再发一个“Finished”消息，把之前所有发送的数据做个摘要，再加密一下，让服务器做个验证。意思就是告诉服务器：“后面都改用对称算法加密通信了啊，用的就是打招呼时说的 AES，加密对不对还得你测一下。”</span><br><span class="line">服务器也是同样的操作，发“Change Cipher Spec”和“Finished”消息，双方都验证加密解密 OK，握手正式结束，后面就收发被加密的 HTTP 请求和响应了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RSA 握手过程</span><br><span class="line">RSA 握手过程大体的流程没有变，只是“Pre-Master”不再需要用算法生成，而是客户端直接生成随机数，然后用服务器的公钥加密，通过“Client Key Exchange”消息发给服务器。服务器再用私钥解密，这样双方也实现了共享三个随机数，就可以生成主密钥。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3.HTTP/1.0增加了 HEAD、POST 等新方法；</span><br><span class="line">增加了响应状态码，标记可能的错误原因；</span><br><span class="line">引入了协议版本号概念；</span><br><span class="line">引入了 HTTP Header（头部）的概念，让 HTTP 处理请求和响应更加灵活；</span><br><span class="line">传输的数据不再仅限于文本。</span><br><span class="line"></span><br><span class="line">4.HTTP/1.1 主要的变更点有：</span><br><span class="line">增加了 PUT、DELETE 等新的方法；</span><br><span class="line">增加了缓存管理和控制；</span><br><span class="line">明确了连接管理，允许持久连接；</span><br><span class="line">允许响应数据分块（chunked），利于传输大文件；</span><br><span class="line"></span><br><span class="line">TTP/1.1 中的连接都会默认启用长连接。不需要用什么特殊的头字段指定，只要向服务器发送了第一次请求，后续的请求都会重复利用第一次打开的 TCP 连接，也就是长连接，在这个连接上收发数据。</span><br><span class="line">请求头里明确地要求使用长连接机制，使用的字段是 Connection，值是“keep-alive”。</span><br><span class="line">TCP 连接长时间不关闭，服务器必须在内存里保存它的状态，这就占用了服务器的资源。如果有大量的空闲长连接只连不发，就会很快耗尽服务器的资源，导致服务器无法为真正有需要的用户提供服务。</span><br><span class="line">服务器端通常不会主动关闭连接，但也可以使用一些策略。拿 Nginx 来举例，它有两种方式：</span><br><span class="line">使用“keepalive_timeout”指令，设置长连接的超时时间，如果在一段时间内连接上没有任何数据收发就主动断开连接，避免空闲连接占用系统资源。</span><br><span class="line">使用“keepalive_requests”指令，设置长连接上可发送的最大请求次数。比如设置成 1000，那么当 Nginx 在这个连接上处理了 1000 个请求后，也会主动断开连接。</span><br><span class="line">另外，客户端和服务器都可以在报文里附加通用头字段“Keep-Alive: timeout=value”，限定长连接的超时时间。但这个字段的约束力并不强，通信的双方可能并不会遵守，所以不太常见。</span><br><span class="line"></span><br><span class="line">队头阻塞</span><br><span class="line">因为 HTTP 规定报文必须是“一发一收”，这就形成了一个先进先出的“串行”队列。队列里的请求没有轻重缓急的优先级，只有入队的先后顺序，排在最前面的请求被最优先处理。</span><br><span class="line">如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本。</span><br><span class="line"></span><br><span class="line">性能优化 </span><br><span class="line">“域名分片”（domain sharding）技术，还是用数量来解决质量的思路。HTTP 协议和浏览器不是限制并发连接数量吗？好，那我就多开几个域名，比如 shard1.diamonds.com、shard2.diamonds.com，而这些域名都指向同一台服务器 www.diamonds.com，这样实际长连接的数量就又上去了，真是“美滋滋”。不过实在是有点“上有政策，下有对策”的味道。</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">5.HTTP/2在高度兼容 HTTP/1.1 的同时在性能改善方面做了很大努力，主要的特点有：</span><br><span class="line">二进制协议，不再是纯文本；</span><br><span class="line">可发起多个请求，废弃了 1.1 里的管道；</span><br><span class="line">使用专用算法压缩头部，减少数据传输量；</span><br><span class="line">允许服务器主动向客户端推送数据；</span><br><span class="line">增强了安全性，“事实上”要求加密通信。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">头部压缩</span><br><span class="line">HTTP/1 里可以用头字段“Content-Encoding”指定 Body 的编码方式，比如用 gzip 压缩来节约带宽，但报文的另一个组成部分——Header 却被无视了，没有针对它的优化手段。</span><br><span class="line">由于报文 Header 一般会携带“User Agent”“Cookie”“Accept”“Server”等许多固定的头字段，多达几百字节甚至上千字节，但 Body 却经常只有几十字节（比如 GET 请求、204/301/304 响应），成了不折不扣的“大头儿子”。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">二进制格式</span><br><span class="line">它把 TCP 协议的部分特性挪到了应用层，把原来的“Header+Body”的消息“打散”为数个小片的二进制“帧”（Frame），用“HEADERS”帧存放头数据、“DATA”帧存放实体数据。</span><br><span class="line"></span><br><span class="line">虚拟的“流”</span><br><span class="line">HTTP/2 为此定义了一个“流”（Stream）的概念，它是二进制帧的双向传输序列，同一个消息往返的帧会分配一个唯一的流 ID。你可以把它想象成是一个虚拟的“数据流”，在里面流动的是一串有先后顺序的数据帧，这些数据帧按照次序组装起来就是 HTTP/1 里的请求报文和响应报文。</span><br><span class="line">因为“流”是虚拟的，实际上并不存在，所以 HTTP/2 就可以在一个 TCP 连接上用“流”同时发送多个“碎片化”的消息，这就是常说的“多路复用”（ Multiplexing）——多个往返通信都复用一个连接来处理。</span><br><span class="line">HTTP/2 还在一定程度上改变了传统的“请求 - 应答”工作模式，服务器不再是完全被动地响应请求，也可以新建“流”主动向客户端发送消息。比如，在浏览器刚请求 HTML 的时候就提前把可能会用到的 JS、CSS 文件发给客户端，减少等待的延迟，这被称为“服务器推送”（Server Push，也叫 Cache Push）。</span><br><span class="line">为了区分“加密”和“明文”这两个不同的版本，HTTP/2 协议定义了两个字符串标识符：“h2”表示加密的 HTTP/2，“h2c”表示明文的 HTTP/2，多出的那个字母“c”的意思是“clear text”。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">6.HTTP/3 HTTP over QUIC</span><br><span class="line">HTTP/2 虽然使用“帧”“流”“多路复用”，没有了“队头阻塞”，但这些手段都是在应用层里，而在下层，也就是 TCP 协议里，还是会发生“队头阻塞”。</span><br><span class="line">TCP 为了保证可靠传输，有个特别的“丢包重传”机制，丢失的包必须要等待重新传输确认，其他的包即使已经收到了，也只能放在缓冲区里，上层的应用拿不出来，只能“干着急”。</span><br><span class="line"></span><br><span class="line">客户端用 TCP 发送了三个包，但服务器所在的操作系统只收到了后两个包，第一个包丢了。那么内核里的 TCP 协议栈就只能把已经收到的包暂存起来，“停下”等着客户端重传那个丢失的包，这样就又出现了“队头阻塞”。</span><br><span class="line">由于这种“队头阻塞”是 TCP 协议固有的，所以 HTTP/2 即使设计出再多的“花样”也无法解决。</span><br><span class="line"></span><br><span class="line">HTTP/3 有一个关键的改变，那就是它把下层的 TCP“抽掉”了，换成了 UDP。因为 UDP 是无序的，包之间没有依赖关系，所以就从根本上解决了“队头阻塞”。</span><br><span class="line">UDP 是一个简单、不可靠的传输协议，只是对 IP 协议的一层很薄的包装，和 TCP 相比，它实际应用的较少。不过正是因为它简单，不需要建连和断连，通信成本低，也就非常灵活、高效，“可塑性”很强。</span><br><span class="line">所以，QUIC 就选定了 UDP，在它之上把 TCP 的那一套连接管理、拥塞窗口、流量控制等“搬”了过来，“去其糟粕，取其精华”，打造出了一个全新的可靠传输协议，可以认为是“新时代的 TCP”。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">QUIC 的特点</span><br><span class="line">QUIC 基于 UDP，而 UDP 是“无连接”的，根本就不需要“握手”和“挥手”，所以天生就要比 TCP 快。</span><br><span class="line">就像 TCP 在 IP 的基础上实现了可靠传输一样，QUIC 也基于 UDP 实现了可靠传输，保证数据一定能够抵达目的地。它还引入了类似 HTTP/2 的“流”和“多路复用”，单个“流”是有序的，可能会因为丢包而阻塞，但其他“流”不会受到影响。</span><br><span class="line">但 QUIC 并不是建立在 TLS 之上，而是内部“包含”了 TLS。它使用自己的帧“接管”了 TLS 里的“记录”，握手消息、警报消息都不使用 TLS 记录，直接封装成 QUIC 的帧发送，省掉了一次开销。</span><br><span class="line"></span><br><span class="line">HTTP/3 没有指定默认端口号，需要用 HTTP/2 的扩展帧“Alt-Svc”来发现。</span><br><span class="line">QUIC 内含了 TLS1.3，只能加密通信，支持 0-RTT 快速建连；</span><br><span class="line">QUIC 是一个新的传输层协议，建立在 UDP 之上，实现了可靠传输；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">7.正向代理：靠近客户端，代表客户端向服务器发送请求</span><br><span class="line">反向代理：靠近服务器端，代表服务器响应客户端的请求；</span><br><span class="line">CDN，实际上就是一种代理，它代替源站服务器响应客户端的请求，通常扮演着透明代理和反向代理的角色。</span><br><span class="line"></span><br><span class="line">8.1××：提示信息，表示目前是协议处理的中间状态，还需要后续的操作；</span><br><span class="line">2××：成功，报文已经收到并被正确处理；</span><br><span class="line">“204 No Content”是另一个很常见的成功状态码，它的含义与“200 OK”基本相同，但响应头后没有 body 数据。</span><br><span class="line">“206 Partial Content”是 HTTP 分块下载或断点续传的基础，在客户端发送“范围请求”、要求获取资源的部分数据时出现，它与 200 一样，也是服务器成功处理了请求，但 body 里的数据不是资源的全部，而是其中的一部分。状态码 206 通常还会伴随着头字段“Content-Range”，表示响应报文里 body 数据的具体范围，供客户端确认，</span><br><span class="line">例如“Content-Range: bytes 0-99/2000”，意思是此次获取的是总计 2000 个字节的前 100 个字节。</span><br><span class="line">3××：重定向，资源位置发生变动，需要客户端重新发送请求；</span><br><span class="line">“301 Moved Permanently”俗称“永久重定向”，含义是此次请求的资源已经不存在了，需要改用新的 URI 再次访问。</span><br><span class="line">比如，你的网站升级到了 HTTPS，原来的 HTTP 不打算用了，这就是“永久”的，所以要配置 301 跳转，把所有的 HTTP 流量都切换到 HTTPS。</span><br><span class="line">“302 Found”，曾经的描述短语是“Moved Temporarily”，俗称“临时重定向”，意思是请求的资源还在，但需要暂时用另一个 URI 来访问。301 和 302 都会在响应头里使用字段 Location 指明后续要跳转的 URI，最终的效果很相似，浏览器都会重定向到新的 URI。两者的根本区别在于语义，一个是“永久”，一个是“临时”，所以在场景、用法上差距很大。</span><br><span class="line">比如，今天夜里网站后台要系统维护，服务暂时不可用，这就属于“临时”的，可以配置成 302 跳转，把流量临时切换到一个静态通知页面，浏览器看到这个 302 就知道这只是暂时的情况，不会做缓存优化，第二天还会访问原来的地址。</span><br><span class="line">“304 Not Modified” 是一个比较有意思的状态码，它用于 If-Modified-Since 等条件请求，表示资源未修改，用于缓存控制。它不具有通常的跳转含义，但可以理解成“重定向已到缓存的文件”（即“缓存重定向”）。</span><br><span class="line">4××：客户端错误，请求报文有误，服务器无法处理；</span><br><span class="line">400 Bad Request”是一个通用的错误码，只是一个笼统的错误，客户端看到 400 只会是“一头雾水”“不知所措”。</span><br><span class="line">所以，在开发 Web 应用时应当尽量避免给客户端返回 400，而是要用其他更有明确含义的状态码。</span><br><span class="line">413 Request Entity Too Large：请求报文里的 body 太大；</span><br><span class="line">414 Request-URI Too Long：请求行里的 URI 太大；</span><br><span class="line">5××：服务器错误，服务器在处理请求时内部发生了错误</span><br><span class="line">“500 Internal Server Error”与 400 类似，也是一个通用的错误码，服务器究竟发生了什么错误我们是不知道的。不过对于服务器来说这应该算是好事，通常不应该把服务器内部的详细信息，例如出错的函数调用栈告诉外界。虽然不利于调试，但能够防止黑客的窥探或者分析。</span><br><span class="line">“502 Bad Gateway”通常是服务器作为网关或者代理时返回的错误码，表示服务器自身工作正常，访问后端服务器时发生了错误，但具体的错误原因也是不知道的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">9.MIME 是一个很大的标准规范，但 HTTP 只“顺手牵羊”取了其中的一部分，用来标记 body 的数据类型，这就是我们平常总能听到的“MIME type”。</span><br><span class="line">text：即文本格式的可读数据，我们最熟悉的应该就是 text/html 了，表示超文本文档，此外还有纯文本 text/plain、样式表 text/css 等。</span><br><span class="line">image：即图像文件，有 image/gif、image/jpeg、image/png 等。</span><br><span class="line">audio/video：音频和视频数据，例如 audio/mpeg、video/mp4 等。</span><br><span class="line">application：数据格式不固定，可能是文本也可能是二进制，必须由上层应用程序来解释。常见的有 application/json，application/javascript、application/pdf 等，另外，如果实在是不知道数据是什么类型，像刚才说的“黑盒”，就会是 application/octet-stream，即不透明的二进制数据。</span><br><span class="line"></span><br><span class="line">10.为了节约带宽，有时候还会压缩数据，Encoding type”，告诉数据是用的什么编码格式</span><br><span class="line">常用的只有下面三种：</span><br><span class="line">gzip：GNU zip 压缩格式，也是互联网上最流行的压缩格式；</span><br><span class="line">deflate：zlib（deflate）压缩格式，流行程度仅次于 gzip；</span><br><span class="line">br：一种专门为 HTTP 优化的新压缩算法（Brotli）。</span><br><span class="line"></span><br><span class="line">11.范围请求不是 Web 服务器必备的功能，可以实现也可以不实现，所以服务器必须在响应头里使用字段“Accept-Ranges: bytes”明确告知客户端：“我是支持范围请求的”。</span><br><span class="line">请求头 Range 是 HTTP 范围请求的专用字段，格式是“bytes=x-y”，其中的 x 和 y 是以字节为单位的数据范围。要注意 x、y 表示的是“偏移量”，范围必须从 0 计数，例如前 10 个字节表示为“0-9”，第二个 10 字节表示为“10-19”，而“0-10”实际上是前 11 个字节。</span><br><span class="line">服务器收到 Range 字段后，需要做四件事。</span><br><span class="line">第一，它必须检查范围是否合法，比如文件只有 100 个字节，但请求“200-300”，这就是范围越界了。服务器就会返回状态码 416，意思是“你的范围请求有误，我无法处理，请再检查一下”。</span><br><span class="line">第二，如果范围正确，服务器就可以根据 Range 头计算偏移量，读取文件的片段了，返回状态码“206 Partial Content”，和 200 的意思差不多，但表示 body 只是原数据的一部分。</span><br><span class="line">第三，服务器要添加一个响应头字段 Content-Range，告诉片段的实际偏移量和资源的总大小，格式是“bytes x-y/length”，与 Range 头区别在没有“=”，范围后多了总长度。例如，对于“0-10”的范围请求，值就是“bytes 0-10/100”。</span><br><span class="line">不仅看视频的拖拽进度需要范围请求，常用的下载工具里的多段下载、断点续传也是基于它实现的，要点是：</span><br><span class="line">先发个 HEAD，看服务器是否支持范围请求，同时获取文件的大小；</span><br><span class="line">开 N 个线程，每个线程使用 Range 字段划分出各自负责下载的片段，发请求传输数据；</span><br><span class="line">下载意外中断也不怕，不必重头再来一遍，只要根据上次的下载记录，用 Range 请求剩下的那一部分就可以了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">12.Cookie 的安全性</span><br><span class="line">属性“HttpOnly”会告诉浏览器，此 Cookie 只能通过浏览器 HTTP 协议传输，禁止其他方式访问，浏览器的 JS 引擎就会禁用 document.cookie 等一切相关的 API，脚本攻击也就无从谈起了。</span><br><span class="line">另一个属性“SameSite”可以防范“跨站请求伪造”（XSRF）攻击，设置成“SameSite=Strict”可以严格限定 Cookie 不能随着跳转链接跨站发送，而“SameSite=Lax”则略宽松一点，允许 GET/HEAD 等安全方法，但禁止 POST 跨站发送。</span><br><span class="line">还有一个属性叫“Secure”，表示这个 Cookie 仅能用 HTTPS 协议加密传输，明文的 HTTP 协议会禁止发送。但 Cookie 本身不是加密的，浏览器里还是以明文的形式存在。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">13.客户端的缓存控制</span><br><span class="line">当你点“刷新”按钮的时候，协商缓存</span><br><span class="line">Ctrl+F5 的“强制刷新”又是什么样的呢？请求头里面没有if-modified-since/if-none-match字段</span><br><span class="line"></span><br><span class="line">14.加密</span><br><span class="line">对称加密</span><br><span class="line">加密和解密时使用的密钥都是同一个，是“对称”的。只要保证了密钥的安全，那整个通信过程就可以说具有了机密性。</span><br><span class="line"></span><br><span class="line">非对称加密</span><br><span class="line">它有两个密钥，一个叫“公钥”（public key），一个叫“私钥”（private key）。两个密钥是不同的，“不对称”，公钥可以公开给任何人使用，而私钥必须严格保密。</span><br><span class="line">公钥和私钥有个特别的“单向”性，虽然都可以用来加密解密，但公钥加密后只能用私钥解密，反过来，私钥加密后也只能用公钥解密。</span><br><span class="line"></span><br><span class="line">混合加密</span><br><span class="line">在通信刚开始的时候使用非对称算法，比如 RSA、ECDHE，首先解决密钥交换的问题。</span><br><span class="line">然后用随机数产生对称算法使用的“会话密钥”（session key），再用公钥加密。</span><br></pre></td></tr></table></figure>
<h3 id="从输入URL到页面展示，这中间发生了什么？"><a href="#从输入URL到页面展示，这中间发生了什么？" class="headerlink" title="从输入URL到页面展示，这中间发生了什么？"></a>从输入URL到页面展示，这中间发生了什么？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1.URL 请求过程</span><br><span class="line">浏览器进程会通过进程间通信（IPC）把 URL 请求发送至网络进程，网络进程接收到 URL 请求后，会在这里发起真正的 URL 请求流程。</span><br><span class="line">网络进程会查找本地缓存是否缓存了该资源。如果有缓存资源，那么直接返回资源给浏览器进程；如果在缓存中没有查找到资源，那么直接进入网络请求流程。</span><br><span class="line">请求前的第一步是要进行 DNS 解析，以获取请求域名的服务器 IP 地址。如果请求协议是 HTTPS，那么还需要建立 TLS 连接。</span><br><span class="line">接下来就是利用 IP 地址和服务器建立 TCP 连接。连接建立之后，浏览器端会构建请求行、请求头等信息，并把和该域名相关的 Cookie 等数据附加到请求头中，然后向服务器发送构建的请求信息。</span><br><span class="line">服务器接收到请求信息后，会根据请求信息生成响应数据（包括响应行、响应头和响应体等信息），并发给网络进程。等网络进程接收了响应行和响应头之后，就开始解析响应头的内容了。</span><br><span class="line">在接收到服务器返回的响应头后，网络进程开始解析响应头，如果发现返回的状态码是 301 或者 302，那么说明服务器需要浏览器重定向到其他 URL。这时网络进程会从响应头的 Location 字段里面读取重定向的地址，然后再发起新的 HTTP 或者 HTTPS 请求，一切又重头开始了。</span><br><span class="line">在导航过程中，如果服务器响应行的状态码包含了 301、302 一类的跳转信息，浏览器会跳转到新的地址继续导航；如果响应行是 200，那么表示浏览器可以继续处理该请求。</span><br><span class="line">Content-Type 是 HTTP 头中一个非常重要的字段， 它告诉浏览器服务器返回的响应体数据是什么类型，然后浏览器会根据 Content-Type 的值来决定如何显示响应体的内容。</span><br><span class="line">Content-Type 的值是 application/octet-stream，显示数据是字节流类型的，通常情况下，浏览器会按照下载类型来处理该请求。</span><br><span class="line">如果 Content-Type 字段的值被浏览器判断为下载类型，那么该请求会被提交给浏览器的下载管理器，同时该 URL 请求的导航流程就此结束。但如果是 HTML，那么浏览器则会继续进行导航流程。由于 Chrome 的页面渲染是运行在渲染进程中的，所以接下来就需要准备渲染进程了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.渲染进程</span><br><span class="line">默认情况下，Chrome 会为每个页面分配一个渲染进程，也就是说，每打开一个新页面就会配套创建一个新的渲染进程。但是，也有一些例外，在某些情况下，浏览器会让多个页面直接运行在同一个渲染进程中。</span><br><span class="line">那什么情况下多个页面会同时运行在一个渲染进程中呢？</span><br><span class="line">https://time.diamonds.org</span><br><span class="line">https://www.diamonds.org</span><br><span class="line">https://www.diamonds.org:8080</span><br><span class="line">它们都是属于同一站点，因为它们的协议都是 HTTPS，而且根域名也都是 diamonds.org。</span><br><span class="line">Chrome 的默认策略是，每个标签对应一个渲染进程。但如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程。官方把这个默认策略叫 process-per-site-instance。</span><br><span class="line">总结来说，打开一个新页面采用的渲染进程策略就是：</span><br><span class="line">通常情况下，打开新的页面都会使用单独的渲染进程；如果从 A 页面打开 B 页面，且 A 和 B 都属于同一站点的话，那么 B 页面复用 A 页面的渲染进程；</span><br><span class="line">如果是其他情况，浏览器进程则会为 B 创建一个新的渲染进程。</span><br><span class="line">渲染进程准备好之后，还不能立即进入文档解析状态，因为此时的文档数据还在网络进程中，并没有提交给渲染进程，所以下一步就进入了提交文档阶段。</span><br><span class="line"></span><br><span class="line">所谓提交文档，就是指浏览器进程将网络进程接收到的 HTML 数据提交给渲染进程，具体流程是这样的：</span><br><span class="line">首先当浏览器进程接收到网络进程的响应头数据之后，便向渲染进程发起“提交文档”的消息；</span><br><span class="line">渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”；</span><br><span class="line">等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程；</span><br><span class="line">浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。</span><br><span class="line">这也就解释了为什么在浏览器的地址栏里面输入了一个地址后，之前的页面没有立马消失，而是要加载一会儿才会更新页面。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3.渲染流程</span><br><span class="line">按照渲染的时间顺序，流水线可分为如下几个子阶段：构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成。</span><br><span class="line"></span><br><span class="line">构建 DOM 树</span><br><span class="line">为什么要构建 DOM 树呢？这是因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM 树。</span><br><span class="line"></span><br><span class="line">样式计算（Recalculate Style）</span><br><span class="line">样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式，这个阶段大体可分为三步来完成。</span><br><span class="line">把 CSS 转换为浏览器能够理解的结构</span><br><span class="line">和 HTML 文件一样，浏览器也是无法直接理解这些纯文本的 CSS 样式，所以当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets。</span><br><span class="line">body &#123; font-size: 2em &#125;  =&gt; body &#123; font-size: 32px &#125;</span><br><span class="line">p &#123;color:blue;&#125;  =&gt; p &#123;rgba(0,0,255)&#125;</span><br><span class="line">span  &#123;display: none&#125;</span><br><span class="line">div &#123;font-weight: bold&#125;  =&gt; div &#123;font-weight: 700)&#125;</span><br><span class="line">div  p &#123;color:green;&#125; =&gt; div &#123;rgba(0,128,0)&#125;</span><br><span class="line">div &#123;color:red; &#125;  =&gt; div &#123;rgba(255,0,0)&#125;</span><br><span class="line">可以看到上面的 CSS 文本中有很多属性值，如 2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。</span><br><span class="line">首先是 CSS 继承。CSS 继承就是每个 DOM 节点都包含有父节点的样式。</span><br><span class="line">样式计算过程中的第二个规则是样式层叠。层叠是 CSS 的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法。它在 CSS 处于核心地位，CSS 的全称“层叠样式表”正是强调了这一点。</span><br><span class="line">总之，样式计算阶段的目的是为了计算出 DOM 节点中每个元素的具体样式，在计算过程中需要遵守 CSS 的继承和层叠两个规则。这个阶段最终输出的内容是每个 DOM 节点的样式，并被保存在 ComputedStyle 的结构内。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">布局阶段</span><br><span class="line">有 DOM 树和 DOM 树中元素的样式，但这还不足以显示页面，因为我们还不知道 DOM 元素的几何位置信息。那么接下来就需要计算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做布局。</span><br><span class="line">Chrome 在布局阶段需要完成两个任务：创建布局树和布局计算。</span><br><span class="line">创建布局树</span><br><span class="line">DOM 树还含有很多不可见的元素，比如 head 标签，还有使用了 display:none 属性的元素。所以在显示之前，我们还要额外地构建一棵只包含可见元素布局树。</span><br><span class="line">DOM 树中所有不可见的节点都没有包含到布局树中。</span><br><span class="line">布局计算</span><br><span class="line">在执行布局操作的时候，会把布局运算的结果重新写回布局树中，所以布局树既是输入内容也是输出内容，这是布局阶段一个不合理的地方，因为在布局阶段并没有清晰地将输入内容和输出内容区分开来。</span><br><span class="line">针对这个问题，Chrome 团队正在重构布局代码，下一代布局系统叫 LayoutNG，试图更清晰地分离输入和输出，从而让新设计的布局算法更加简单。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">分层</span><br><span class="line">浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。</span><br><span class="line">通常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层</span><br><span class="line">拥有层叠上下文属性的元素会被提升为单独的一层。页面是个二维平面，但是层叠上下文能够让 HTML 元素具有三维概念，这些 HTML 元素按照自身属性的优先级分布在垂直于这个二维平面的 z 轴上。</span><br><span class="line">明确定位属性的元素、定义透明属性的元素、使用 CSS 滤镜的元素等，都拥有层叠上下文属性。</span><br><span class="line">需要剪裁（clip）的地方也会被创建为图层。</span><br><span class="line"></span><br><span class="line">图层绘制</span><br><span class="line">在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制</span><br><span class="line"></span><br><span class="line">栅格化（raster）操作</span><br><span class="line">绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。</span><br><span class="line">当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程</span><br><span class="line">通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做视口（viewport）。</span><br><span class="line">在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。基于这个原因，合成线程会将图层划分为图块（tile）。</span><br><span class="line">合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的</span><br><span class="line">通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。GPU 操作是运行在 GPU 进程中，如果栅格化操作使用了 GPU，那么最终生成位图的操作是在 GPU 中完成的，这就涉及到了跨进程操作</span><br><span class="line">渲染进程把生成图块的指令发送给 GPU，然后在 GPU 中执行生成图块的位图，并保存在 GPU 的内存中</span><br><span class="line"></span><br><span class="line">合成和显示</span><br><span class="line">一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。</span><br><span class="line">浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">渲染总结</span><br><span class="line">一个完整的渲染流程大致可总结为如下：</span><br><span class="line">渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。</span><br><span class="line">渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。</span><br><span class="line">创建布局树，并计算元素的布局信息。</span><br><span class="line">对布局树进行分层，并生成分层树。</span><br><span class="line">为每个图层生成绘制列表，并将其提交到合成线程。</span><br><span class="line">合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。</span><br><span class="line">合成线程发送绘制图块命令 DrawQuad 给浏览器进程。</span><br><span class="line">浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">相关概念</span><br><span class="line">更新了元素的几何属性（重排）</span><br><span class="line">如果你通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。</span><br><span class="line">无疑，重排需要更新完整的渲染流水线，所以开销也是最大的。</span><br><span class="line">更新元素的绘制属性（重绘）</span><br><span class="line">如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。</span><br><span class="line">相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。</span><br><span class="line">直接合成阶段</span><br><span class="line">使用 CSS 的 transform 来实现动画效果，可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。</span><br><span class="line">这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，</span><br><span class="line">所以相对于重绘和重排，合成能大大提升绘制效率。</span><br></pre></td></tr></table></figure>
<h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line">// 常见宏任务：setTimeout()/setInterval()/setImmediate()/点击和键盘事件/...</span><br><span class="line">// 常见微任务：promise.then()/promise.catch()/new MutationObserver()/process.nextTick()</span><br><span class="line"></span><br><span class="line">// ------------------</span><br><span class="line">// node环境</span><br><span class="line">// timers:执行setTimeout与setInterval回调</span><br><span class="line">// pending callbacks:执行系统操作的回调，例如tcp、udp</span><br><span class="line">// idle,prepare:只在系统内部调用</span><br><span class="line">// poll:执行与I/O相关的回调,轮询等待新的链接和请求等事件。V8 引擎将 JS 代码解析并传入 Libuv 引擎后首先进入此阶段。如果此阶段任务队列已经执行完了，则进入 check 阶段执行 setImmediate 回调（如果有 setImmediate），或等待新的任务进来（如果没有 setImmediate）。在等待新的任务时，如果有 timers 计时到期，则会直接进入 timers 阶段。此阶段可能会阻塞等待。</span><br><span class="line">// check:执行setImmediate中的回调</span><br><span class="line">// close callbacks:执行close事件的回调</span><br><span class="line">// ----------------------------------</span><br><span class="line"></span><br><span class="line">// Nodejs完整事件环</span><br><span class="line">// 执行同步代码，将不同任务添加至相应的队列</span><br><span class="line">// 所有同步代码执行完成后会去执行满足条件的微任务</span><br><span class="line">// 所有微任务代码执行完会执行timer队列中满足得宏任务</span><br><span class="line">// timers中所有宏任务执行完成后就会依次切换队列（在完成队列切换之前会先清空微任务代码）</span><br><span class="line"></span><br><span class="line">// ------------------------------------------</span><br><span class="line"></span><br><span class="line">// 浏览器、node环境</span><br><span class="line">// 任务队列数不同</span><br><span class="line">// 微任务执行时机不同：二者都会在同步代码执行完毕后执行微任务、浏览器平台下每当一个宏任务执行完毕后就会清空微任务、node环境下在事件队列切换时会去清空微任务队列(新版node（NodeJS 11 ）与浏览器保持一致)</span><br><span class="line">// 微任务优先级：浏览器环境微任务存放于事件队列，先进先出、node环境中process.nextTick先于promise.then执行</span><br><span class="line"></span><br><span class="line">// -------------------------------------</span><br><span class="line"></span><br><span class="line">// setTimeout(()=&gt;&#123;&#125;,0)  不稳定，会产生延时     // timers</span><br><span class="line">// setImmediate(()=&gt;&#123;&#125;)                         // check</span><br><span class="line"></span><br><span class="line">// fs.readFile(&apos;./test.js&apos;,()=&gt;&#123;     // poll</span><br><span class="line">// setTimeout(()=&gt;&#123;&#125;,0)</span><br><span class="line">// setImmediate(()=&gt;&#123;&#125;)</span><br><span class="line">// &#125;)</span><br><span class="line"></span><br><span class="line">// -------------------------------</span><br><span class="line"></span><br><span class="line">// setTimeout(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">//     console.log(&apos;timeout&apos;);</span><br><span class="line"></span><br><span class="line">// &#125;, 0);</span><br><span class="line"></span><br><span class="line">// Promise.resolve().then(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">//     console.error(&apos;promise&apos;)</span><br><span class="line"></span><br><span class="line">// &#125;)</span><br><span class="line"></span><br><span class="line">// process.nextTick(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">//     console.error(&apos;nextTick&apos;)</span><br><span class="line"></span><br><span class="line">// &#125;)</span><br><span class="line"></span><br><span class="line">// // 输出：nextTick、promise、timeout</span><br><span class="line"></span><br><span class="line">// ----------------------</span><br><span class="line">// setTimeout(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">//   console.log(&apos;timeout&apos;);</span><br><span class="line"></span><br><span class="line">// &#125;, 0);</span><br><span class="line"></span><br><span class="line">// setImmediate(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">//   console.log(&apos;setImmediate&apos;);</span><br><span class="line"></span><br><span class="line">// &#125;);</span><br><span class="line"></span><br><span class="line">// // 输出：timeout、 setImmediate</span><br><span class="line"></span><br><span class="line">// 分析上面代码，第一轮循环后，分别将 setTimeout  和 setImmediate 加入了各自阶段的任务队列。</span><br><span class="line">// 第二轮循环首先进入timers 阶段，执行定时器队列回调，然后 pending callbacks和poll 阶段没有任务，</span><br><span class="line">// 因此进入check 阶段执行 setImmediate 回调。所以最后输出为“timeout”、“setImmediate”。</span><br><span class="line">// 当然这里还有种理论上的极端情况，就是第一轮循环结束后耗时很短，导致 setTimeout 的计时还没结束，此时第二轮循环则会先执行 setImmediate 回调。</span><br><span class="line"></span><br><span class="line">// ----------------------------------</span><br><span class="line">// const fs = require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">// fs.readFile(__filename, (data) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">//     console.log(&apos;readFile&apos;);</span><br><span class="line"></span><br><span class="line">//     setTimeout(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">//         console.log(&apos;timeout&apos;);</span><br><span class="line"></span><br><span class="line">//     &#125;, 0);</span><br><span class="line"></span><br><span class="line">//     setImmediate(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">//         console.log(&apos;setImmediate&apos;);</span><br><span class="line"></span><br><span class="line">//     &#125;);</span><br><span class="line"></span><br><span class="line">// &#125;);</span><br><span class="line"></span><br><span class="line">// // 输出：readFile、setImmediate、timeout</span><br><span class="line"></span><br><span class="line">// 如上面代码所示：</span><br><span class="line"></span><br><span class="line">// 第一轮循环没有需要执行的异步任务队列；</span><br><span class="line"></span><br><span class="line">// 第二轮循环 timers 等阶段都没有任务，只有 poll 阶段有 I/O 回调任务，即输出“readFile”；</span><br><span class="line"></span><br><span class="line">// 参考前面事件阶段的说明，接下来，poll 阶段会检测如果有 setImmediate 的任务队列则进入 check 阶段，否则再进行判断，如果有定时器任务回调，则回到 timers 阶段，所以应该进入 check 阶段执行 setImmediate，输出“setImmediate”；</span><br><span class="line"></span><br><span class="line">// 然后进入最后的 close callbacks 阶段，本次循环结束；</span><br><span class="line"></span><br><span class="line">// 最后进行第三轮循环，进入 timers 阶段，输出“timeout”。</span><br><span class="line"></span><br><span class="line">// 所以最终输出“setImmediate”在“timeout”之前。可见这两者的执行顺序与当前执行的阶段有关系。</span><br><span class="line"></span><br><span class="line">//浏览器事件循环</span><br><span class="line">//--------------------</span><br><span class="line">// JavaScript 引擎首先从宏任务队列（macrotask queue）中取出第一个任务；</span><br><span class="line">// 执行完毕后，再将微任务（microtask queue）中的所有任务取出，按照顺序分别全部执行（这里包括不仅指开始执行时队列里的微任务），如果在这一步过程中产生新的微任务，也需要执行；</span><br><span class="line">// 然后再从宏任务队列中取下一个，执行完毕后，再次将 microtask queue 中的全部取出，循环往复，直到两个 queue 中的任务都取完。</span><br><span class="line">// 总结起来就是：一次 Eventloop 循环会处理一个宏任务和所有这次循环中产生的微任务。</span><br><span class="line"></span><br><span class="line">// 各种浏览器事件同时触发时，肯定有一个先来后到的排队问题。决定这些事件如何排队触发的机制，就是事件循环。这个排队行为以 JavaScript 开发者的角度来看，主要是分成两个队列：</span><br><span class="line">// 一个是 JavaScript 外部的队列。外部的队列主要是浏览器协调的各类事件的队列，标准文件中称之为 Task Queue。下文中为了方便理解统一称为外部队列。</span><br><span class="line">// 另一个是 JavaScript 内部的队列。这部分主要是 JavaScript 内部执行的任务队列，标准中称之为 Microtask Queue。下文中为了方便理解统一称为内部队列。</span><br><span class="line">// 值得注意的是，虽然为了好理解我们管这个叫队列 (Queue)，但是本质上是有序集合 (Set)，因为传统的队列都是先进先出（FIFO）的，而这里的队列则不然，排到最前面但是没有满足条件也是不会执行的（比如外部队列里只有一个 setTimeout 的定时任务，但是时间还没有到，没有满足条件也不会把他出列来执行）。</span><br><span class="line"></span><br><span class="line">//外部队列</span><br><span class="line">// 外部队列（Task Queue 关于 Task，常有人称它为 Marcotask (宏任务)，但 HTML 标准中没有这种说法。），顾名思义就是 JavaScript 外部的事件的队列，这里我们可以先列举一下浏览器中这些外部事件源（Task Source），他们主要有：</span><br><span class="line">// DOM 操作 (页面渲染)</span><br><span class="line">// 用户交互 (鼠标、键盘)</span><br><span class="line">// 网络请求 (Ajax 等)</span><br><span class="line">// History API 操作</span><br><span class="line">// 定时器 (setTimeout 等)</span><br><span class="line">// HTML 标准中明确指出一个事件循环由一个或多个外部队列，而每一个外部事件源都有一个对应的外部队列。不同事件源的队列可以有不同的优先级（例如在网络事件和用户交互之间，浏览器可以优先处理鼠标行为，从而让用户感觉更加流程）。</span><br><span class="line">// scripts 执行也是一个事件，我们只要归类一下就会发现 JavaScript 的执行也是一个浏览器发起的外部事件。</span><br><span class="line"></span><br><span class="line">//内部队列</span><br><span class="line"></span><br><span class="line">// 内部队列（Microtask Queue），即 JavaScript 语言内部的事件队列，在 HTML 标准中，并没有明确规定这个队列的事件源，通常认为有以下几种：</span><br><span class="line">// Promise 的成功 (.then) 与失败 (.catch)</span><br><span class="line">// MutationObserver</span><br><span class="line">// Object.observe (已废弃)</span><br><span class="line"></span><br><span class="line">//node事件循环</span><br><span class="line">// 除了把 Eventloop 的宏任务细分到不同阶段外。node 还引入了一个新的任务队列 Process.nextTick()。</span><br><span class="line">// 可以认为，Process.nextTick() 会在上述各个阶段结束时，在进入下一个阶段之前立即执行（优先级甚至超过 microtask 队列）。</span><br><span class="line"></span><br><span class="line">//EventLoop 对渲染的影响</span><br><span class="line">// 浏览器作为一个复杂的应用是多线程工作的，除了运行 JS 的线程外，还有渲染线程、定时器触发线程、HTTP 请求线程，等等。JS 线程可以读取并且修改 DOM，而渲染线程也需要读取 DOM，这是一个典型的多线程竞争临界资源的问题。所以浏览器就把这两个线程设计成互斥的，即同时只能有一个线程在执行。</span><br><span class="line">//requestAnimationFrame 不是 Eventloop 里的宏任务，或者说它并不在 Eventloop 的生命周期里，只是浏览器又开放的一个在渲染之前发生的新的 hook。</span><br><span class="line">//当宏任务队列中没有任务可以处理时，浏览器可能存在“空闲状态”。这段空闲时间可以被 requestIdlecallback 利用起来执行一些优先级不高、不必立即执行的任务,当然为了防止浏览器一直处于繁忙状态，导致 requestIdlecallback 可能永远无法执行回调，它还提供了一个额外的 timeout 参数，为这个任务设置一个截止时间。浏览器就可以根据这个截止时间规划这个任务的执行。</span><br><span class="line"></span><br><span class="line">//async function async1() &#123;</span><br><span class="line">//  console.log(&quot;async1 start&quot;);</span><br><span class="line"></span><br><span class="line">//  await async2();</span><br><span class="line">  //await 后面方法的返回值决定了await下面代码的执行顺序</span><br><span class="line">//  console.log(&quot;async1 end&quot;);</span><br><span class="line">//&#125;</span><br><span class="line">//async function async2() &#123;</span><br><span class="line">  //1.async2()返回非promise时，await下面的代码在本次事件循环微任务执行之前执行</span><br><span class="line">  // setTimeout(() =&gt; &#123;</span><br><span class="line">  //   console.log(&quot;async2&quot;);</span><br><span class="line">  // &#125;);</span><br><span class="line">  //2.async2()返回非promise时，如果存在微任务，await下面的代码在本次事件循环微任务执行之前该微任务之后执行</span><br><span class="line">  // new Promise(function (resolve) &#123;</span><br><span class="line">  //   resolve();</span><br><span class="line">  // &#125;).then(function () &#123;</span><br><span class="line">  //   console.log(&quot;async2&quot;);</span><br><span class="line">  // &#125;);</span><br><span class="line">  //3.async2()返回promise时，是异步操作,await下面的代码在本次事件循环之后执行</span><br><span class="line">  // return new Promise(function (resolve) &#123;</span><br><span class="line">  //   resolve();</span><br><span class="line">  // &#125;).then(function () &#123;</span><br><span class="line">  //   console.log(&quot;async2&quot;);</span><br><span class="line">  // &#125;);</span><br><span class="line">  //4.同步代码直接执行</span><br><span class="line">  //console.log(&quot;async2&quot;);</span><br><span class="line">//&#125;</span><br></pre></td></tr></table></figure>
<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//  在 V8 中会把堆分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象。</span><br><span class="line">//  新生区通常只支持 1～8M 的容量，而老生区支持的容量就大很多了。对于这两块区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。</span><br><span class="line">//  副垃圾回收器，主要负责新生代的垃圾回收。主垃圾回收器，主要负责老生代的垃圾回收。</span><br><span class="line"></span><br><span class="line">// 副垃圾回收器</span><br><span class="line">// 副垃圾回收器主要负责新生区的垃圾回收。而通常情况下，大多数小的对象都会被分配到新生区，所以说这个区域虽然不大，但是垃圾回收还是比较频繁的。</span><br><span class="line">// 新生代中用 Scavenge 算法来处理。所谓 Scavenge 算法，是把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域</span><br><span class="line">// 新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。</span><br><span class="line">// 在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。</span><br><span class="line">// 完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时这种角色翻转的操作还能让新生代中的这两块区域无限重复使用下去。</span><br><span class="line">// 由于新生代中采用的 Scavenge 算法，所以每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域。但复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以为了执行效率，一般新生区的空间会被设置得比较小。</span><br><span class="line">// 也正是因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JavaScript 引擎采用了对象晋升策略，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。</span><br><span class="line"></span><br><span class="line">// 主垃圾回收器</span><br><span class="line">// 主垃圾回收器主要负责老生区中的垃圾回收。除了新生区中晋升的对象，一些大的对象会直接被分配到老生区。因此老生区中的对象有两个特点，一个是对象占用空间大，另一个是对象存活时间长。</span><br><span class="line">// 由于老生区的对象比较大，若要在老生区中使用 Scavenge 算法进行垃圾回收，复制这些大的对象将会花费比较多的时间，从而导致回收执行效率不高，同时还会浪费一半的空间。因而，主垃圾回收器是采用标记 - 清除（Mark-Sweep）的算法进行垃圾回收的。</span><br><span class="line">// 首先是标记过程阶段。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。</span><br><span class="line">// 接下来就是垃圾的清除过程。它和副垃圾回收器的垃圾清除过程完全不同</span><br><span class="line">// 对一块内存多次执行标记 - 清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存，于是又产生了另外一种算法——标记 - 整理（Mark-Compact），这个标记过程仍然与标记 - 清除算法里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</span><br><span class="line"></span><br><span class="line">//全停顿;</span><br><span class="line">// 由于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做全停顿（Stop-The-World）。</span><br><span class="line">// 比如堆中的数据有 1.5GB，V8 实现一次完整的垃圾回收需要 1 秒以上的时间，这也是由于垃圾回收而引起 JavaScript 线程暂停执行的时间，若是这样的时间花销，那么应用的性能和响应能力都会直线下降。</span><br><span class="line">// 在 V8 新生代的垃圾回收中，因其空间较小，且存活对象较少，所以全停顿的影响不大</span><br><span class="line">// 老生代就不一样了。如果在执行垃圾回收的过程中，占用主线程时间过久，主线程是不能做其他事情的。比如页面正在执行一个 JavaScript 动画，因为垃圾回收器在工作，就会导致这个动画在这 200 毫秒内无法执行的，这将会造成页面的卡顿现象。</span><br><span class="line">// 为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为增量标记（Incremental Marking）算法</span><br><span class="line">// 使用增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的 JavaScript 任务中间执行，这样当执行上述动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了。</span><br><span class="line"></span><br><span class="line">// 内存泄漏的场景：</span><br><span class="line">// 过多的缓存未释放；</span><br><span class="line">// 闭包太多未释放；</span><br><span class="line">// 定时器或者回调太多未释放；</span><br><span class="line">// 太多无效的 DOM 未释放；</span><br><span class="line">// 全局变量太多未被发现。</span><br></pre></td></tr></table></figure>
<h3 id="前端异常"><a href="#前端异常" class="headerlink" title="前端异常"></a>前端异常</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">//try...catch  语法错误，异步错误都无法捕获</span><br><span class="line">//window.onerror  语法错误无法捕获，异步错误可以捕获   只有返回值为true时，异常才不会向上抛出。最好先于js脚本执行，否则有些异常无法捕获。</span><br><span class="line">//window.addEventListener(&apos;error&apos;) 可以处理资源加载异常  需要在捕获阶段执行。  最好先于资源执行，否则异常可能无法捕获。</span><br><span class="line">//window.addEventListener(&apos;unhandledrejection&apos;) 全局捕获promise的异常</span><br><span class="line">//Promise Catch  promise异常最好通过catch方法进行捕获</span><br><span class="line">//iframe 异常 window.frames[0].onerror</span><br><span class="line">//Script error 一般情况，如果出现 Script error 这样的错误，基本上可以确定是跨域问题。这时候，是不会有其他太多辅助信息的，但是解决思路无非如下：跨源资源共享机制( CORS )：我们为 script 标签添加 crossOrigin 属性。</span><br><span class="line">//崩溃和卡顿  可以使用 Service Worker 来实现网页崩溃的监控：</span><br><span class="line">//VUE errorHandler</span><br><span class="line">//React 异常捕获  在React，可以使用ErrorBoundary组件包括业务组件的方式进行异常捕获，配合React 16.0+新出的componentDidCatch API，可以实现统一的异常捕获和日志上报。</span><br><span class="line"></span><br><span class="line">//数据上报</span><br><span class="line">// 如果数据上报接口与业务系统使用同一域名，浏览器对请求并发量有限制，所以存在网络资源竞争的可能性。</span><br><span class="line">// 浏览器通常在页面卸载时会忽略异步ajax请求，如果需要必须进行数据请求，一般在unload或者beforeunload事件中创建同步ajax请求，以此延迟页面卸载。从用户侧角度，就是页面跳转变慢。</span><br><span class="line">// Beacon 接口用来调度向 Web 服务器发送的异步非阻塞请求。</span><br><span class="line">// Beacon 请求使用 HTTP POST方法，并且不需要有响应。</span><br><span class="line">// Beacon 请求能确保在页面触发 unload 之前完成初始化。 通俗的讲就是，Beacon可将数据异步发送至服务端，且能够保证在页面卸载完成前发送请求（解决ajax页面卸载会终止请求的问题）。</span><br><span class="line"></span><br><span class="line">// Beacon 接口满足了分析和诊断代码的需要，这些代码通常会尝试在卸载文档之前将数据发送到 web服务器。发送数据的任何过早时机都可能导致错失收集数据的机会。但是，确保在卸载文档期间发送数据是开发人员难以做到的。</span><br><span class="line">// 用户代理通常会忽略卸载文档处理程序中的异步 XMLHttpRequests 请求。若要解决此问题，为了分析和诊断代码，通常会在 unload 事件或 beforeunload 事件中创建同步 XMLHttpRequest 请求以提交数据。同步 XMLHttpRequest 请求强制浏览器延迟卸载文档，并使下一个页面跳转看起来较慢。下一页面没有任何办法来避免这种页面加载性能不佳的感觉。</span><br><span class="line">// 其他技术也可以用来确保提交数据。其中一种技术是通过创建 Image 元素并在卸载文档处理程序中设置其 src 属性来延迟卸载以提交数据。由于大多数用户代理会延迟文档卸载，以完成挂起的图片加载，因此可以在卸载过程中提交数据。另一种方法是在卸载处理程序中创建一个无操作循环，花费数秒以延迟卸载并将数据提交到服务器。</span><br><span class="line">// 但是上述技术不仅代表了较差的编码模式，其中一些还是不可靠的，会导致下一个导航的页面加载性能较差的感觉。信标 API 提供了解决这些问题的标准方法。</span><br><span class="line"></span><br><span class="line">// navigator.sendBeacon(url, data);</span><br><span class="line">// 其中 data 参数是可选的，它的类型可以为 ArrayBufferView, Blob, DOMString 或者 FormData。如果浏览器成功地将 beacon 请求加入到待发送的队列里，这个方法将会返回 true ，否则将会返回 false</span><br><span class="line"></span><br><span class="line">// 使用Beacon时需要后台需要使用post方法接收参数，考虑到跨域问题，后台还需要改造接口配置CORS。同时请求头必须满足CORS-safelisted request-header，其中content-type的类型必须为application/x-www-form-urlencoded, multipart/form-data, 或者text/plain。</span><br><span class="line"></span><br><span class="line">// type ContentType = &apos;application/x-www-form-urlencoded&apos; | &apos;multipart/form-data&apos; | &apos;text/plain&apos;;</span><br><span class="line"></span><br><span class="line">// const serilizeParams = (params: object) =&gt; &#123;</span><br><span class="line">//     return window.btoa(JSON.stringify(params))</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">// function sendBeacon(url: string, params: object) &#123;</span><br><span class="line">//   const formData = new FormData()</span><br><span class="line">//   formData.append(&apos;params&apos;, serilizeParams(params))</span><br><span class="line">//   navigator.sendBeacon(url, formData)</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">// sendBeacon的兼容性问题是不可避免的，不过可以充分利用大部分浏览器会在页面卸载前完成图片的加载的特性，通过在页面添加img的方式上报数据。</span><br><span class="line"></span><br><span class="line">// function sendImage(url: string, params: object) &#123;</span><br><span class="line">//   const img = new Image()</span><br><span class="line"></span><br><span class="line">//   img.style.display = &apos;none&apos;</span><br><span class="line"></span><br><span class="line">//   const removeImage = function() &#123;</span><br><span class="line">//     img.parentNode.removeChild(img)</span><br><span class="line">//   &#125;</span><br><span class="line"></span><br><span class="line">//   img.onload = removeImage</span><br><span class="line">//   img.onerror = removeImage</span><br><span class="line"></span><br><span class="line">//   img.src = `$&#123;url&#125;?params=$&#123;serilizeParams(params)&#125;`</span><br><span class="line"></span><br><span class="line">//   document.body.appendChild(img)</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">// 由于img图片为get请求方式，不同服务器针对uri的长度有限制，长度超过限制时会出现HTTP 414错误，所以还要注意上报频率，减少一次性上传的属性过多。</span><br></pre></td></tr></table></figure>
<h3 id="js编译执行"><a href="#js编译执行" class="headerlink" title="js编译执行"></a>js编译执行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><span class="line">//  V8引擎执行 JS 代码要经过以下阶段</span><br><span class="line">//  Parse 阶段：V8 引擎负责将 JS 代码转换成 AST（抽象语法树）；</span><br><span class="line">//  Ignition 阶段：解释器将 AST 转换为字节码，解析执行字节码也会为下一个阶段优化编译提供需要的信息；</span><br><span class="line">//  TurboFan 阶段：编译器利用上个阶段收集的信息，将字节码优化为可以执行的机器码；</span><br><span class="line">//  Orinoco 阶段：垃圾回收阶段，将程序中不再使用的内存空间进行回收。</span><br><span class="line"></span><br><span class="line">// 生成 AST</span><br><span class="line">// 生成 AST 分为两个阶段，一是词法分析，二是语法分析</span><br><span class="line">// 词法分析：这个阶段会将源代码拆成最小的、不可再分的词法单元，称为 token。比如这行代码 var a =1；通常会被分解成 var 、a、=、2、; 这五个词法单元。另外刚才代码中的空格在 JavaScript 中是直接忽略的。</span><br><span class="line">// 语法分析：这个过程是将词法单元转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树，这个树被称为抽象语法树。</span><br><span class="line">// 现在浏览器还不支持 ES6 语法，需要将其转换成 ES5 语法，这个过程就要借助 Babel 来实现。将 ES6 源码解析成 AST，再将 ES6 语法的抽象语法树转成 ES5 的抽象语法树，最后利用它来生成 ES5 的源代码。另外 ESlint 的原理也大致相同，检测流程也是将源码转换成抽象语法树，再利用它来检测代码规范。</span><br><span class="line"></span><br><span class="line">// 生成字节码</span><br><span class="line">// 之前的 V8 版本不会经过这个过程，最早只是通过 AST 直接转换成机器码，而后面几个版本中才对此进行了改进。如果将 AST 直接转换为机器码还是会有一些问题存在的，例如：</span><br><span class="line">// 直接转换会带来内存占用过大的问题，因为将抽象语法树全部生成了机器码，而机器码相比字节码占用的内存多了很多；</span><br><span class="line">// 某些 JavaScript 使用场景使用解释器更为合适，解析成字节码，有些代码没必要生成机器码，进而尽可能减少了占用内存过大的问题。</span><br><span class="line">// 官方在 V8 的 v5.6 版本中还是将抽象语法树转换成字节码这一过程又加上了，重新加入了字节码的处理过程。再然后，V8 重新引进了 Ignition 解释器，将抽象语法树转换成字节码后，内存占用显著下降了，同时也可以使用 JIT 编译器做进一步的优化。</span><br><span class="line">// 字节码是介于 AST 和机器码之间的一种代码，需要将其转换成机器码后才能执行，字节码可以理解为是机器码的一种抽象。Ignition 解释器除了可以快速生成没有优化的字节码外，还可以执行部分字节码。</span><br><span class="line"></span><br><span class="line">// 生成机器码</span><br><span class="line">// 在 Ignition 解释器处理完之后，如果发现一段代码被重复执行多次的情况，生成的字节码以及分析数据会传给 TurboFan 编译器，它会根据分析数据的情况生成优化好的机器码。再执行这段代码之后，只需要直接执行编译后的机器码，这样性能就会更好。</span><br><span class="line">// TurboFan 编译器，它是 JIT 优化的编译器，因为 V8 引擎是多线程的，TurboFan 的编译线程和生成字节码不会在同一个线程上，这样可以和 Ignition 解释器相互配合着使用，不受另一方的影响。</span><br><span class="line">// 由 Ignition 解释器收集的分析数据被 TurboFan 编译器使用，主要是通过一种推测优化的技术，生成已经优化的机器码来执行。</span><br><span class="line"></span><br><span class="line">// JavaScript 代码是需要在 JavaScript 引擎中运行的。我们在说到 JavaScript 运行的时候，常常会提到执行环境、词法环境、作用域、执行上下文、闭包等内容。</span><br><span class="line">// JavaScript引擎执行JavaScript代码时会进行词法分析、语法分析、语义分析等处理，最终生成抽象语法树，根据抽象语法树生成机器码</span><br><span class="line">// 在 V8 引擎中 JavaScript 代码的运行过程主要分成三个阶段：</span><br><span class="line">// 语法分析阶段：对代码进行语法分析，检查是否有语法错误</span><br><span class="line">// 编译阶段：会创建执行上下文，包括变量对象的创建、作用域链的建立、this指向的确立等。每进入一个不同的运行环境，V8引擎都会创建一个执行上下文。</span><br><span class="line">// 执行阶段：将编译阶段的执行上下文压入调用栈，代码执行结束后，将其弹出调用栈</span><br><span class="line">// 前面提到的执行环境、词法环境、作用域、执行上下文等内容都是在编译和执行阶段中产生的概念。</span><br><span class="line"></span><br><span class="line">// 执行上下文创建</span><br><span class="line">// 全局环境和函数环境的创建过程如下</span><br><span class="line">// 第一次载入JavaScript代码时会创建一个全局环境。全局环境位于最外层，直到应用程序结束后（浏览器、网页关闭等）才会被销毁。</span><br><span class="line">// 每个函数有自己的运行环境，当函数被调用时，会进入该函数的运行环境。当该环境中的代码全部执行完毕后，该环境会被销毁。不同函数运行环境不一样，同一个函数多次被调用会创建不同的函数环境。</span><br><span class="line">// 每进入一个不同的运行环境时，JavaScript 都会创建一个新的执行上下文，该过程包括：</span><br><span class="line">// 建立作用域链（Scope Chain）；</span><br><span class="line">// 创建变量对象（Variable Object，简称 VO）；</span><br><span class="line">// 确定 this 的指向。</span><br><span class="line"></span><br><span class="line">// 创建变量对象</span><br><span class="line">// 每个执行上下文都会有一个关联的变量对象，该对象上会保存这个上下文中定义的所有变量和函数。</span><br><span class="line">// 而在浏览器中，全局环境的变量对象是window对象，因此所有的全局变量和函数都是作为window对象的属性和方法创建的。相应的，在 Node 中全局环境的变量对象则是global对象。</span><br><span class="line">// 创建变量对象将会创建arguments对象（仅函数环境下），同时会检查当前上下文的函数声明和变量声明。</span><br><span class="line">// 对于变量声明：此时会给变量分配内存，并将其初始化为undefined（该过程只进行定义声明，执行阶段才执行赋值语句）。</span><br><span class="line">// 对于函数声明：此时会在内存里创建函数对象，并且直接初始化为该函数对象。</span><br><span class="line">// 变量声明和函数声明的处理过程，便是我们常说的变量提升和函数提升，其中函数声明提升会优先于变量声明提升。因为变量提升容易带来变量在预期外被覆盖掉的问题，同时还可能导致本应该被销毁的变量没有被销毁等情况。因此 ES6 中引入了let和const关键字，从而使 JavaScript 也拥有了块级作用域。</span><br><span class="line">// 在 JavaScript 中，词法环境又分为词法环境（Lexical Environment）和变量环境（Variable Environment）两种，其中：</span><br><span class="line">// 变量环境用来记录var/function等变量声明；</span><br><span class="line">// 词法环境是用来记录let/const/class等变量声明。</span><br><span class="line"></span><br><span class="line">// 建立作用域链</span><br><span class="line">// 作用域就是词法环境，而词法环境由两个成员组成。</span><br><span class="line">// 环境记录（Environment Record）：用于记录自身词法环境中的变量对象。</span><br><span class="line">// 外部词法环境引用（Outer Lexical Environment）：记录外层词法环境的引用。</span><br><span class="line">// 通过外部词法环境的引用，作用域可以层层拓展，建立起从里到外延伸的一条作用域链。当某个变量无法在自身词法环境记录中找到时，可以根据外部词法环境引用向外层进行寻找，直到最外层的词法环境中外部词法环境引用为null，这便是作用域链的变量查询。</span><br><span class="line">// 通过外部词法环境的引用，作用域可以层层拓展，建立起从里到外延伸的一条作用域链。当某个变量无法在自身词法环境记录中找到时，可以根据外部词法环境引用向外层进行寻找，直到最外层的词法环境中外部词法环境引用为null，这便是作用域链的变量查询。</span><br><span class="line"></span><br><span class="line">// function foo(a) &#123;</span><br><span class="line"></span><br><span class="line">//   var b = 2;</span><br><span class="line"></span><br><span class="line">//   function c() &#123;&#125;</span><br><span class="line"></span><br><span class="line">//   var d = function() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">// foo(1);</span><br><span class="line"></span><br><span class="line">// 在执行foo(1)时，首先进入定义期，此时：</span><br><span class="line">// 参数变量a的值为1</span><br><span class="line">// 变量b和d初始化为undefined</span><br><span class="line">// 函数c创建函数并初始化</span><br><span class="line"></span><br><span class="line">// AO = &#123;</span><br><span class="line"></span><br><span class="line">//   arguments: &#123;</span><br><span class="line"></span><br><span class="line">//     0: 1,</span><br><span class="line"></span><br><span class="line">//     length: 1</span><br><span class="line"></span><br><span class="line">//   &#125;,</span><br><span class="line"></span><br><span class="line">//   a: 1,</span><br><span class="line"></span><br><span class="line">//   b: undefined,</span><br><span class="line"></span><br><span class="line">//   c: reference to function c()&#123;&#125;,</span><br><span class="line"></span><br><span class="line">//   d: undefined</span><br><span class="line"></span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">// 进入执行期之后，会执行赋值语句进行赋值，此时变量b和d会被赋值为 2 和函数表达式：</span><br><span class="line">// AO = &#123;</span><br><span class="line"></span><br><span class="line">//    arguments: &#123;</span><br><span class="line"></span><br><span class="line">//     0: 1,</span><br><span class="line"></span><br><span class="line">//     length: 1</span><br><span class="line"></span><br><span class="line">//   &#125;,</span><br><span class="line"></span><br><span class="line">//   a: 1,</span><br><span class="line"></span><br><span class="line">//   b: 2,</span><br><span class="line"></span><br><span class="line">//   c: reference to function c()&#123;&#125;,</span><br><span class="line"></span><br><span class="line">//   d: reference to FunctionExpression &quot;d&quot;</span><br><span class="line"></span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">// 一般来说，当函数执行结束之后，执行期上下文将被销毁（作用域链和活动对象均被销毁）。但有时候我们想要保留其中一些变量对象，不想被销毁，此时就会使用到闭包。</span><br><span class="line"></span><br><span class="line">// function foo() &#123;</span><br><span class="line"></span><br><span class="line">//   var a = 1;</span><br><span class="line"></span><br><span class="line">//   function bar() &#123;</span><br><span class="line"></span><br><span class="line">//     return a;</span><br><span class="line"></span><br><span class="line">//   &#125;</span><br><span class="line"></span><br><span class="line">//   return bar;</span><br><span class="line"></span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">// var b = foo();</span><br><span class="line"></span><br><span class="line">// console.log(b()); // 1</span><br><span class="line"></span><br><span class="line">// 在这个例子中，当b()执行时，foo函数上下文包括作用域都已经被销毁了，为什么foo作用域下的a依然可以被访问到呢？</span><br><span class="line"></span><br><span class="line">// 这是因为bar函数引用了foo函数变量对象中的值，此时即使创建bar函数的foo函数执行上下文被销毁了，但它的变量对象依然会保留在 JavaScript 内存中，bar函数依然可以通过bar函数的作用域链找到它，并进行访问。这便是我们常说的闭包，即使创建它的上下文已经销毁，它仍然被保留在内存中。</span><br><span class="line"></span><br><span class="line">// 闭包使得我们可以从外部读取局部变量，在大多数项目中都会被使用到，常见的用途包括：</span><br><span class="line"></span><br><span class="line">// 用于从外部读取其他函数内部变量的函数；</span><br><span class="line">// 可以使用闭包来模拟私有方法；</span><br><span class="line">// 让这些变量的值始终保持在内存中。</span><br><span class="line"></span><br><span class="line">// 确定 this 的指向</span><br><span class="line">// 根据 JavaScript 中函数的调用方式不同，this的指向分为以下情况。</span><br><span class="line">// 在全局环境中，this指向全局对象（在浏览器中为window）</span><br><span class="line">// 在函数内部，this的值取决于函数被调用的方式</span><br><span class="line">// 函数作为对象的方法被调用，this指向调用这个方法的对象</span><br><span class="line">// 函数用作构造函数时（使用new关键字），它的this被绑定到正在构造的新对象</span><br><span class="line">// 在类的构造函数中，this是一个常规对象，类中所有非静态的方法都会被添加到this的原型中</span><br><span class="line">// 在箭头函数中，this指向它被创建时的环境</span><br><span class="line">// 使用apply、call、bind等方式调用：根据 API 不同，可切换函数执行的上下文环境，即this绑定的对象</span><br><span class="line"></span><br><span class="line">// 当一段代码被执行时，JavaScript 引擎先会对其进行编译，并创建执行上下文。</span><br><span class="line">// 当 JavaScript 执行全局代码的时候，会编译全局代码并创建全局执行上下文，而且在整个页面的生存周期内，全局执行上下文只有一份。</span><br><span class="line">// 当调用一个函数的时候，函数体内的代码会被编译，并创建函数执行上下文，一般情况下，函数执行结束之后，创建的函数执行上下文会被销毁。</span><br><span class="line">// 当使用 eval 函数的时候，eval 的代码也会被编译，并创建执行上下文。</span><br><span class="line">// 用栈就是用来管理函数调用关系的一种数据结构。</span><br><span class="line"></span><br><span class="line">// 每调用一个函数，JavaScript 引擎会为其创建执行上下文，并把该执行上下文压入调用栈，然后 JavaScript 引擎开始执行函数代码。</span><br><span class="line">// 如果在一个函数 A 中调用了另外一个函数 B，那么 JavaScript 引擎会为 B 函数创建执行上下文，并将 B 函数的执行上下文压入栈顶。</span><br><span class="line">// 当前函数执行完毕后，JavaScript 引擎会将该函数的执行上下文弹出栈。</span><br><span class="line">// 当分配的调用栈空间被占满时，会引发“堆栈溢出”问题。</span><br><span class="line"></span><br><span class="line">// function foo()&#123;</span><br><span class="line">//   var a = 1</span><br><span class="line">//   let b = 2</span><br><span class="line">//   &#123;</span><br><span class="line">//     let b = 3</span><br><span class="line">//     var c = 4</span><br><span class="line">//     let d = 5</span><br><span class="line">//     console.log(a)</span><br><span class="line">//     console.log(b)</span><br><span class="line">//   &#125;</span><br><span class="line">//   console.log(b)</span><br><span class="line">//   console.log(c)</span><br><span class="line">//   console.log(d)</span><br><span class="line">// &#125;</span><br><span class="line">// foo()</span><br><span class="line"></span><br><span class="line">// 第一步是编译并创建执行上下文</span><br><span class="line">// 函数内部通过 var 声明的变量，在编译阶段全都被存放到变量环境里面了。</span><br><span class="line">// 通过 let 声明的变量，在编译阶段会被存放到词法环境（Lexical Environment）中。</span><br><span class="line">// 在函数的作用域块内部，通过 let 声明的变量并没有被存放到词法环境中。</span><br><span class="line"></span><br><span class="line">// 第二步继续执行代码，当执行到代码块里面时，变量环境中 a 的值已经被设置成了 1，词法环境中 b 的值已经被设置成了 2</span><br><span class="line">// 当进入函数的作用域块时，作用域块中通过 let 声明的变量，会被存放在词法环境的一个单独的区域中，这个区域中的变量并不影响作用域块外面的变量，比如在作用域外面声明了变量 b，在该作用域块内部也声明了变量 b，当执行到作用域内部时，它们都是独立的存在。</span><br><span class="line">// 其实，在词法环境内部，维护了一个小型栈结构，栈底是函数最外层的变量，进入一个作用域块后，就会把该作用域块内部的变量压到栈顶；当作用域执行完成之后，该作用域的信息就会从栈顶弹出，这就是词法环境的结构。</span><br><span class="line">// 需要注意下，我这里所讲的变量是指通过 let 或者 const 声明的变量。</span><br><span class="line"></span><br><span class="line">// 再接下来，当执行到作用域块中的console.log(a)这行代码时，就需要在词法环境和变量环境中查找变量 a 的值了，</span><br><span class="line">// 具体查找方式是：沿着词法环境的栈顶向下查询，如果在词法环境中的某个块中查找到了，就直接返回给 JavaScript 引擎，</span><br><span class="line">// 如果没有查找到，那么继续在变量环境中查找。</span><br><span class="line"></span><br><span class="line">// var myObj = &#123;</span><br><span class="line">//   name : &quot;diamonds&quot;,</span><br><span class="line">//   showThis: function()&#123;</span><br><span class="line">//     console.log(this)</span><br><span class="line">//     function bar()&#123;console.log(this)&#125;</span><br><span class="line">//     bar()</span><br><span class="line">//   &#125;</span><br><span class="line">// &#125;</span><br><span class="line">// myObj.showThis()</span><br><span class="line"></span><br><span class="line">// 执行这段代码后，你会发现函数 bar 中的 this 指向的是全局 window 对象，而函数 showThis 中的 this 指向的是 myObj 对象。</span><br><span class="line"></span><br><span class="line">// var myObj = &#123;</span><br><span class="line">//   name : &quot;diamond&quot;,</span><br><span class="line">//   showThis: function()&#123;</span><br><span class="line">//     console.log(this)</span><br><span class="line">//     var bar = ()=&gt;&#123;</span><br><span class="line">//       this.name = &quot;diamonds&quot;</span><br><span class="line">//       console.log(this)</span><br><span class="line">//     &#125;</span><br><span class="line">//     bar()</span><br><span class="line">//   &#125;</span><br><span class="line">// &#125;</span><br><span class="line">// myObj.showThis()</span><br><span class="line">// console.log(myObj.name)</span><br><span class="line">// console.log(window.name)</span><br><span class="line"></span><br><span class="line">// ES6 中的箭头函数并不会创建其自身的执行上下文，所以箭头函数中的 this 取决于它的外部函数。</span><br><span class="line">// 因为箭头函数没有自己的执行上下文，所以箭头函数的 this 就是它外层函数的 this。</span><br></pre></td></tr></table></figure>
<h3 id="渲染相关"><a href="#渲染相关" class="headerlink" title="渲染相关"></a>渲染相关</h3><h4 id="DOM-树如何生成"><a href="#DOM-树如何生成" class="headerlink" title="DOM 树如何生成"></a>DOM 树如何生成</h4><ul>
<li>在渲染引擎内部，有一个叫 HTML 解析器（HTMLParser）的模块，它的职责就是负责将 HTML 字节流转换为 DOM 结构。</li>
<li>HTML 解析器并不是等整个文档加载完成之后再解析的，而是网络进程加载了多少数据，HTML 解析器便解析多少数据。</li>
<li>网络进程接收到响应头之后，会根据响应头中的 content-type 字段来判断文件的类型，比如 content-type 的值是“text/html”，那么浏览器就会判断这是一个 HTML 类型的文件，然后为该请求选择或者创建一个渲染进程。渲染进程准备好之后，网络进程和渲染进程之间会建立一个共享数据的管道，网络进程接收到数据后就往这个管道里面放，而渲染进程则从管道的另外一端不断地读取数据，并同时将读取的数据“喂”给 HTML 解析器。你可以把这个管道想象成一个“水管”，网络进程接收到的字节流像水一样倒进这个“水管”，而“水管”的另外一端是渲染进程的 HTML 解析器，它会动态接收字节流，并将其解析为 DOM。</li>
</ul>
<h4 id="JavaScript-是如何影响-DOM-生成的"><a href="#JavaScript-是如何影响-DOM-生成的" class="headerlink" title="JavaScript 是如何影响 DOM 生成的"></a>JavaScript 是如何影响 DOM 生成的</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;1&lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">    let div1 = document.getElementsByTagName(&apos;div&apos;)[0]</span><br><span class="line">    div1.innerText = &apos;time.geekbang&apos;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">    &lt;div&gt;test&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在两段 div 中间插入了一段 JavaScript 脚本，这段脚本的解析过程就有点不一样了。&lt;script&gt;标签之前，所有的解析流程还是和之前介绍的一样，但是解析到&lt;script&gt;标签时，渲染引擎判断这是一段脚本，此时 HTML 解析器就会暂停 DOM 的解析，因为接下来的 JavaScript 可能要修改当前已经生成的 DOM 结构。</span><br><span class="line"></span><br><span class="line">这时候 HTML 解析器暂停工作，JavaScript 引擎介入，并执行 script 标签中的这段脚本，因为这段 JavaScript 脚本修改了 DOM 中第一个 div 中的内容，所以执行这段脚本之后，div 节点内容已经修改为 time.geekbang 了。脚本执行完成之后，HTML 解析器恢复解析过程，继续解析后续的内容，直至生成最终的 DOM。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//foo.js</span><br><span class="line">let div1 = document.getElementsByTagName(&apos;div&apos;)[0]</span><br><span class="line">div1.innerText = &apos;time.geekbang&apos;</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;1&lt;/div&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot; src=&apos;foo.js&apos;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;div&gt;test&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">这段代码的功能还是和前面那段代码是一样的，不过这里把内嵌 JavaScript 脚本修改成了通过 JavaScript 文件加载。其整个执行流程还是一样的，执行到 JavaScript 标签时，暂停整个 DOM 的解析，执行 JavaScript 代码，不过这里执行 JavaScript 时，需要先下载这段 JavaScript 代码。</span><br><span class="line"></span><br><span class="line">这里需要重点关注下载环境，因为 JavaScript 文件的下载过程会阻塞 DOM 解析，而通常下载又是非常耗时的，会受到网络环境、JavaScript 文件大小等因素的影响。</span><br><span class="line"></span><br><span class="line">不过 Chrome 浏览器做了很多优化，其中一个主要的优化是预解析操作。当渲染引擎收到字节流之后，会开启一个预解析线程，用来分析 HTML 文件中包含的 JavaScript、CSS 等相关文件，解析到相关文件之后，预解析线程会提前下载这些文件。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">再回到 DOM 解析上，我们知道引入 JavaScript 线程会阻塞 DOM，不过也有一些相关的策略来规避，比如使用 CDN 来加速 JavaScript 文件的加载，压缩 JavaScript 文件的体积。另外，如果 JavaScript 文件中没有操作 DOM 相关代码，就可以将该 JavaScript 脚本设置为异步加载，通过 async 或 defer 来标记代码，使用方式如下所示：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script async type=&quot;text/javascript&quot; src=&apos;foo.js&apos;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script defer type=&quot;text/javascript&quot; src=&apos;foo.js&apos;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">async 和 defer 虽然都是异步的，不过还有一些差异，使用 async 标志的脚本文件一旦加载完成，会立即执行；</span><br><span class="line">而使用了 defer 标记的脚本文件，需要在 DOMContentLoaded 事件之前执行。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">现在我们知道了 JavaScript 是如何阻塞 DOM 解析的了，那接下来我们再来结合文中代码看看另外一种情况：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//theme.css</span><br><span class="line">div &#123;color:blue&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;style src=&apos;theme.css&apos;&gt;&lt;/style&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;1&lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">            let div1 = document.getElementsByTagName(&apos;div&apos;)[0]</span><br><span class="line">            div1.innerText = &apos;time.geekbang&apos; //需要DOM</span><br><span class="line">            div1.style.color = &apos;red&apos;  //需要CSSOM</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">    &lt;div&gt;test&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">该示例中，JavaScript 代码出现了 div1.style.color = ‘red&apos; 的语句，它是用来操纵 CSSOM 的，所以在执行 JavaScript 之前，需要先解析 JavaScript 语句之上所有的 CSS 样式。所以如果代码里引用了外部的 CSS 文件，那么在执行 JavaScript 之前，还需要等待外部的 CSS 文件下载完成，并解析生成 CSSOM 对象之后，才能执行 JavaScript 脚本。</span><br><span class="line"></span><br><span class="line">而 JavaScript 引擎在解析 JavaScript 之前，是不知道 JavaScript 是否操纵了 CSSOM 的，所以渲染引擎在遇到 JavaScript 脚本时，不管该脚本是否操纵了 CSSOM，都会执行 CSS 文件下载，解析操作，再执行 JavaScript 脚本。</span><br><span class="line"></span><br><span class="line">所以说 JavaScript 脚本是依赖样式表的，这又多了一个阻塞过程。JavaScript 会阻塞 DOM 生成，而样式文件又会阻塞 JavaScript 的执行。</span><br></pre></td></tr></table></figure>
<h4 id="CSS-如何影响首次加载时的白屏时间"><a href="#CSS-如何影响首次加载时的白屏时间" class="headerlink" title="CSS 如何影响首次加载时的白屏时间"></a>CSS 如何影响首次加载时的白屏时间</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//theme.css</span><br><span class="line">div&#123;</span><br><span class="line">    color : coral;</span><br><span class="line">    background-color:black</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;link href=&quot;theme.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;geekbang com&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">首先是发起主页面的请求，这个发起请求方可能是渲染进程，也有可能是浏览器进程，发起的请求被送到网络进程中去执行。</span><br><span class="line">网络进程接收到返回的 HTML 数据之后，将其发送给渲染进程，渲染进程会解析 HTML 数据并构建 DOM。</span><br><span class="line">这里你需要特别注意下，请求 HTML 数据和构建 DOM 中间有一段空闲时间，这个空闲时间有可能成为页面渲染的瓶颈。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">当渲染进程接收 HTML 文件字节流时，会先开启一个预解析线程，如果遇到 JavaScript 文件或者 CSS 文件，那么预解析线程会提前下载这些数据。对于上面的代码，预解析线程会解析出来一个外部的 theme.css 文件，并发起 theme.css 的下载。</span><br><span class="line">这里也有一个空闲时间需要你注意一下，就是在 DOM 构建结束之后、theme.css 文件还未下载完成的这段时间内，渲染流水线无事可做，因为下一步是合成布局树，而合成布局树需要 CSSOM 和 DOM，所以这里需要等待 CSS 加载结束并解析成 CSSOM</span><br></pre></td></tr></table></figure>
<h4 id="影响页面展示的因素以及优化策略"><a href="#影响页面展示的因素以及优化策略" class="headerlink" title="影响页面展示的因素以及优化策略"></a>影响页面展示的因素以及优化策略</h4><p>为什么要花这么多文字来分析渲染流水线呢？主要原因就是渲染流水线影响到了首次页面展示的速度，而首次页面展示的速度又直接影响到了用户体验<br>从发起 URL 请求开始，到首次显示页面的内容，在视觉上经历的三个阶段。<br>第一个阶段，等请求发出去之后，到提交数据阶段，这时页面展示出来的还是之前页面的内容。<br>第二个阶段，提交数据之后渲染进程会创建一个空白页面，我们通常把这段时间称为解析白屏，并等待 CSS 文件和 JavaScript 文件的加载完成，生成 CSSOM 和 DOM，然后合成布局树，最后还要经过一系列的步骤准备首次渲染。<br>第三个阶段，等首次渲染完成之后，就开始进入完整页面的生成阶段了，然后页面会一点点被绘制出来。<br>影响第一个阶段的因素主要是网络或者是服务器处理这块儿,<br>第二个阶段，这个阶段的主要问题是白屏时间，通常情况下的瓶颈主要体现在下载 CSS 文件、下载 JavaScript 文件和执行 JavaScript。所以要想缩短白屏时长，可以有以下策略：<br>通过内联 JavaScript、内联 CSS 来移除这两种类型的文件下载，这样获取到 HTML 文件之后就可以直接开始渲染流程了。<br>并不是所有的场合都适合内联，那么还可以尽量减少文件大小，比如通过 webpack 等工具移除一些不必要的注释，并压缩 JavaScript 文件。<br>还可以将一些不需要在解析 HTML 阶段使用的 JavaScript 标记上 async 或者 defer。<br>对于大的 CSS 文件，可以通过媒体查询属性，将其拆分为多个不同用途的 CSS 文件，这样只有在特定的场景下才会加载特定的 CSS 文件。</p>
<h4 id="为什么-CSS-动画比-JavaScript-高效？"><a href="#为什么-CSS-动画比-JavaScript-高效？" class="headerlink" title="为什么 CSS 动画比 JavaScript 高效？"></a>为什么 CSS 动画比 JavaScript 高效？</h4><p>大多数设备屏幕的更新频率是60 次 / 秒，这也就意味着正常情况下要实现流畅的动画效果，渲染引擎需要每秒更新 60 张图片到显卡的后缓冲区。<br>我们把渲染流水线生成的每一副图片称为一帧，把渲染流水线每秒更新了多少帧称为帧率，比如滚动过程中 1 秒更新了 60 帧，那么帧率就是 60Hz（或者 60FPS）<br>由于用户很容易观察到那些丢失的帧，如果在一次动画过程中，渲染引擎生成某些帧的时间过久，那么用户就会感受到卡顿，这会给用户造成非常不好的印象。<br>要解决卡顿问题，就要解决每帧生成时间过久的问题，为此 Chrome 对浏览器渲染方式做了大量的工作，其中最卓有成效的策略就是引入了分层和合成机制。</p>
<p>重排、重绘和合成这三种方式的渲染路径是不同的，通常渲染路径越长，生成图像花费的时间就越多。<br>比如重排，它需要重新根据 CSSOM 和 DOM 来计算布局树，这样生成一幅图片时，会让整个渲染流水线的每个阶段都执行一遍，如果布局复杂的话，就很难保证渲染的效率了。<br>而重绘因为没有了重新布局的阶段，操作效率稍微高点，但是依然需要重新计算绘制信息，并触发绘制操作之后的一系列操作。<br>相较于重排和重绘，合成操作的路径就显得非常短了，并不需要触发布局和绘制两个阶段，如果采用了 GPU，那么合成的效率会非常高。<br>所以，关于渲染引擎生成一帧图像的几种方式，按照效率我们推荐合成方式优先，若实在不能满足需求，那么就再退后一步使用重绘或者重排的方式。<br>Chrome 中的合成技术，可以用三个词来概括总结：分层、分块和合成。</p>
<p>在 Chrome 的渲染流水线中，分层体现在生成布局树之后，渲染引擎会根据布局树的特点将其转换为层树（Layer Tree），层树是渲染流水线后续流程的基础结构。<br>层树中的每个节点都对应着一个图层，下一步的绘制阶段就依赖于层树中的节点。<br>绘制阶段其实并不是真正地绘出图片，而是将绘制指令组合成一个列表，比如一个图层要设置的背景为黑色，并且还要在中间画一个圆形，那么绘制过程会生成|Paint BackGroundColor:Black | Paint Circle|这样的绘制指令列表，绘制过程就完成了。<br>有了绘制列表之后，就需要进入光栅化阶段了，光栅化就是按照绘制列表中的指令生成图片。每一个图层都对应一张图片，合成线程有了这些图片之后，会将这些图片合成为“一张”图片，并最终将生成的图片发送到后缓冲区。这就是一个大致的分层、合成流程。<br>合成操作是在合成线程上完成的，这也就意味着在执行合成操作时，是不会影响到主线程执行的。这就是为什么经常主线程卡住了，但是 CSS 动画依然能执行的原因。</p>
<p>如果说分层是从宏观上提升了渲染效率，那么分块则是从微观层面提升了渲染效率。<br>通常情况下，页面的内容都要比屏幕大得多，显示一个页面时，如果等待所有的图层都生成完毕，再进行合成的话，会产生一些不必要的开销，也会让合成图片的时间变得更久。<br>因此，合成线程会将每个图层分割为大小固定的图块，然后优先绘制靠近视口的图块，这样就可以大大加速页面的显示速度。不过有时候， 即使只绘制那些优先级最高的图块，也要耗费不少的时间，因为涉及到一个很关键的因素——纹理上传，这是因为从计算机内存上传到 GPU 内存的操作会比较慢。<br>为了解决这个问题，Chrome 又采取了一个策略：在首次合成图块的时候使用一个低分辨率的图片。比如可以是正常分辨率的一半，分辨率减少一半，纹理就减少了四分之三。在首次显示页面内容的时候，将这个低分辨率的图片显示出来，然后合成器继续绘制正常比例的网页内容，当正常比例的网页内容绘制完成后，再替换掉当前显示的低分辨率内容。这种方式尽管会让用户在开始时看到的是低分辨率的内容，但是也比用户在开始时什么都看不到要好。</p>
<h4 id="如何利用分层技术优化代码"><a href="#如何利用分层技术优化代码" class="headerlink" title="如何利用分层技术优化代码"></a>如何利用分层技术优化代码</h4><p>CSS 属性 will-change 为 web 开发者提供了一种告知浏览器该元素会有哪些变化的方法，这样浏览器可以在元素属性真正发生变化之前提前做好对应的优化准备工作。 这种优化可以将一部分复杂的计算工作提前准备好，使页面的反应更为快速灵敏。</p>
<p>所以，如果涉及到一些可以使用合成线程来处理 CSS 特效或者动画的情况，就尽量使用 will-change 来提前告诉渲染引擎，让它为该元素准备独立的层。但是凡事都有两面性，每当渲染引擎为一个元素准备一个独立层的时候，它占用的内存也会大大增加，因为从层树开始，后续每个阶段都会多一个层结构，这些都需要额外的内存，所以你需要恰当地使用 will-change。</p>
<h4 id="如何系统地优化页面？"><a href="#如何系统地优化页面？" class="headerlink" title="如何系统地优化页面？"></a>如何系统地优化页面？</h4><p>图片、音频、视频等文件就不会阻塞页面的首次渲染；而 JavaScript、首次请求的 HTML 资源文件、CSS 文件是会阻塞首次渲染的，因为在构建 DOM 的过程中需要 HTML 和 JavaScript 文件，在构造渲染树的过程中需要用到 CSS 文件。<br>我们把这些能阻塞网页首次渲染的资源称为关键资源。基于关键资源，我们可以继续细化出来三个影响页面首次渲染的核心因素。<br>第一个是关键资源个数。关键资源个数越多，首次页面的加载时间就会越长。比如上图中的关键资源个数就是 3 个，1 个 HTML 文件、1 个 JavaScript 和 1 个 CSS 文件。<br>第二个是关键资源大小。通常情况下，所有关键资源的内容越小，其整个资源的下载时间也就越短，那么阻塞渲染的时间也就越短。上图中关键资源的大小分别是 6KB、8KB 和 9KB，那么整个关键资源大小就是 23KB。<br>第三个是请求关键资源需要多少个 RTT（Round Trip Time）。那什么是 RTT 呢？<br>当使用 TCP 协议传输一个文件时，比如这个文件大小是 0.1M，由于 TCP 的特性，这个数据并不是一次传输到服务端的，而是需要拆分成一个个数据包来回多次进行传输的。<br>RTT 就是这里的往返时延。它是网络中一个重要的性能指标，表示从发送端发送数据开始，到发送端收到来自接收端的确认，总共经历的时延。<br>通常 1 个 HTTP 的数据包在 14KB 左右，所以 1 个 0.1M 的页面就需要拆分成 8 个包来传输了，也就是说需要 8 个 RTT。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">首先是请求 HTML 资源，大小是 6KB，小于 14KB，所以 1 个 RTT 就可以解决了。</span><br><span class="line">至于 JavaScript 和 CSS 文件，这里需要注意一点，由于渲染引擎有一个预解析的线程，在接收到 HTML 数据之后，预解析线程会快速扫描 HTML 数据中的关键资源，一旦扫描到了，会立马发起请求，你可以认为 JavaScript 和 CSS 是同时发起请求的，所以它们的请求是重叠的，那么计算它们的 RTT 时，只需要计算体积最大的那个数据就可以了。这里最大的是 CSS 文件（9KB），所以我们就按照 9KB 来计算，同样由于 9KB 小于 14KB，所以 JavaScript 和 CSS 资源也就可以算成 1 个 RTT。也就是说，关键资源请求共花费了 2 个 RTT。</span><br></pre></td></tr></table></figure>
<p>如果在计算样式阶段发现有布局信息的修改，那么就会触发重排操作，然后触发后续渲染流水线的一系列操作，这个代价是非常大的。<br>同样如果在计算样式阶段没有发现有布局信息的修改，只是修改了颜色一类的信息，那么就不会涉及到布局相关的调整，所以可以跳过布局阶段，直接进入绘制阶段，这个过程叫重绘。不过重绘阶段的代价也是不小的。<br>还有另外一种情况，通过 CSS 实现一些变形、渐变、动画等特效，这是由 CSS 触发的，并且是在合成线程上执行的，这个过程称为合成。因为它不会触发重排或者重绘，而且合成操作本身的速度就非常快，所以执行合成是效率最高的方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;mian_div&quot;&gt;</span><br><span class="line">        &lt;li id=&quot;time_li&quot;&gt;time&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;geekbang&lt;/li&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;p id=&quot;demo&quot;&gt;强制布局demo&lt;/p&gt;</span><br><span class="line">    &lt;button onclick=&quot;foo()&quot;&gt;添加新元素&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        function foo() &#123;</span><br><span class="line">            let main_div = document.getElementById(&quot;mian_div&quot;)</span><br><span class="line">            let new_node = document.createElement(&quot;li&quot;)</span><br><span class="line">            let textnode = document.createTextNode(&quot;time.geekbang&quot;)</span><br><span class="line">            new_node.appendChild(textnode);</span><br><span class="line">            document.getElementById(&quot;mian_div&quot;).appendChild(new_node);</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">执行 JavaScript 添加元素是在一个任务中执行的，重新计算样式布局是在另外一个任务中执行，这就是正常情况下的布局操作。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">    let main_div = document.getElementById(&quot;mian_div&quot;)</span><br><span class="line">    let new_node = document.createElement(&quot;li&quot;)</span><br><span class="line">    let textnode = document.createTextNode(&quot;time.geekbang&quot;)</span><br><span class="line">    new_node.appendChild(textnode);</span><br><span class="line">    document.getElementById(&quot;mian_div&quot;).appendChild(new_node);</span><br><span class="line">    //由于要获取到offsetHeight，</span><br><span class="line">    //但是此时的offsetHeight还是老的数据，</span><br><span class="line">    //所以需要立即执行布局操作</span><br><span class="line">    console.log(main_div.offsetHeight)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">将新的元素添加到 DOM 之后，我们又调用了main_div.offsetHeight来获取新 main_div 的高度信息。</span><br><span class="line">如果要获取到 main_div 的高度，就需要重新布局，所以这里在获取到 main_div 的高度之前，JavaScript 还需要强制让渲染引擎默认执行一次布局操作。</span><br><span class="line">我们把这个操作称为强制同步布局。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">    let time_li = document.getElementById(&quot;time_li&quot;)</span><br><span class="line">    for (let i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">        let main_div = document.getElementById(&quot;mian_div&quot;)</span><br><span class="line">        let new_node = document.createElement(&quot;li&quot;)</span><br><span class="line">        let textnode = document.createTextNode(&quot;time.geekbang&quot;)</span><br><span class="line">        new_node.appendChild(textnode);</span><br><span class="line">        new_node.offsetHeight = time_li.offsetHeight;</span><br><span class="line">        document.getElementById(&quot;mian_div&quot;).appendChild(new_node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在 foo 函数内部重复执行计算样式和布局，这会大大影响当前函数的执行效率。这种情况的避免方式和强制同步布局一样，都是尽量不要在修改 DOM 结构时再去查询一些相关值。</span><br></pre></td></tr></table></figure>
<h3 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h3><p>强制缓存优先于协商缓存进行，若强制缓存(Expires 和 Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified/If-Modified-Since 和 Etag/If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回 200，重新返回资源和缓存标识，再存入浏览器缓存中；生效则返回 304，继续使用缓存。<br>当你点”刷新”按钮的时候，协商缓存<br>Ctrl+F5 的”强制刷新”又是什么样的呢？请求头里面没有 if-modified-since/if-none-match 字段</p>
<h4 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h4><ul>
<li><p>不会向服务器发送请求，直接从缓存中读取资源，在 chrome 控制台的 network 选项中可以看到该请求返回200 的状态码，并且 size 显示 from disk cache 或 from memory cache。强缓存判断是否缓存的依据来自于是否超出某个时间或者某个时间段，而不关心服务器端文件是否已经更新，这可能会导致加载文件不是服务器端最新的内容</p>
</li>
<li><p>Expires：response header 里的过期时间，浏览器再次加载资源时，如果在这个过期时间内，则命中强缓存。它的值为一个绝对时间的 GMT 格式的时间字符串， 比如 <code>Expires:Thu,21 Jan 2018 23:39:02 GMT</code></p>
</li>
<li><p>max-age：当 Cache-Control:max-age=300 时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5 分钟内再次加载资源，就会命中强缓存。</p>
</li>
<li><p>no-cache：客户端缓存内容，是否使用缓存则需要经过协商缓存来验证决定。用 Etag 或者 Last-Modified 字段来控制缓存。</p>
</li>
<li>no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存</li>
</ul>
<h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><ul>
<li><p>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：协商缓存生效，返回304 和 Not Modified 协商缓存失效，返回200 和请求结果</p>
</li>
<li><p>Last-Modified 和 If-Modified-Since 浏览器在第一次访问资源时，服务器返回资源的同时，在 response header 中添加 Last-Modified 的 header，值是这个资源在服务器上的最后修改时间，浏览器接收后缓存文件和 header；</p>
</li>
<li>ETag 和 If-None-Match Etag 是上一次加载资源时，服务器返回的 response header，是对该资源的一种唯一标识，只要资源有变化，Etag 就会重新生成。</li>
<li>首先在精确度上，Etag 要优于 Last-Modified。Last-Modified 的时间单位是秒，如果某个文件在 1 秒内改变了多次，那么他们的 Last-Modified 其实并没有体现出来修改，但是 Etag 每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的 Last-Modified 也有可能不一致。<br>第二在性能上，Etag 要逊于 Last-Modified，毕竟 Last-Modified 只需要记录时间，而 Etag 需要服务器通过算法来计算出一个 hash 值。<br>第三在优先级上，服务器校验优先考虑 Etag  </li>
</ul>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">基础类型存储在栈内存，被引用或拷贝时，会创建一个完全相等的变量；</span><br><span class="line">Undefined Null String Number Boolean Symbol BigInt</span><br><span class="line"></span><br><span class="line">引用类型存储在堆内存，存储的是地址，多个引用指向同一个地址，这里会涉及一个“共享”的概念。</span><br><span class="line">Object</span><br><span class="line">Array Date RegExp Function Math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let a = &#123;</span><br><span class="line">  name: &quot;Julia&quot;,</span><br><span class="line"></span><br><span class="line">  age: 20,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function change(o) &#123;</span><br><span class="line">  o.age = 24;</span><br><span class="line">  //关键   变量o改变内存指向 跟a已经没有关系</span><br><span class="line">  o = &#123;</span><br><span class="line">    name: &quot;Kath&quot;,</span><br><span class="line">    age: 30,</span><br><span class="line">  &#125;;</span><br><span class="line">  return o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let b = change(a);</span><br><span class="line"></span><br><span class="line">console.log(b.age); // 第一个console   30</span><br><span class="line"></span><br><span class="line">console.log(a.age); // 第二个console   24</span><br></pre></td></tr></table></figure>
<h4 id="数据类型检测"><a href="#数据类型检测" class="headerlink" title="数据类型检测"></a>数据类型检测</h4><h5 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">typeof 1 // &apos;number&apos;</span><br><span class="line"></span><br><span class="line">typeof &apos;1&apos; // &apos;string&apos;</span><br><span class="line"></span><br><span class="line">typeof undefined // &apos;undefined&apos;</span><br><span class="line"></span><br><span class="line">typeof true // &apos;boolean&apos;</span><br><span class="line"></span><br><span class="line">typeof Symbol() // &apos;symbol&apos;</span><br><span class="line"></span><br><span class="line">typeof null // &apos;object&apos;       !!!!!!!!!!!!!!!!</span><br><span class="line"></span><br><span class="line">typeof [] // &apos;object&apos;</span><br><span class="line"></span><br><span class="line">typeof &#123;&#125; // &apos;object&apos;</span><br><span class="line"></span><br><span class="line">typeof console // &apos;object&apos;</span><br><span class="line"></span><br><span class="line">typeof console.log // &apos;function&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">虽然 typeof null 会输出 object，但这只是 JS 存在的一个悠久 Bug，不代表 null 就是引用数据类型，并且 null 本身也不是对象。因此，null 在 typeof 之后返回的是有问题的结果，不能作为判断 null 的方法。如果你需要在 if 语句中判断是否为 null，直接通过 ‘===null’来判断就好。</span><br><span class="line"></span><br><span class="line">引用数据类型 Object，用 typeof 来判断的话，除了 function 会判断为 OK 以外，其余都是 ‘object’，是无法判断出来的。</span><br></pre></td></tr></table></figure>
<h5 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">let Car = function() &#123;&#125;</span><br><span class="line"></span><br><span class="line">let benz = new Car()</span><br><span class="line"></span><br><span class="line">benz instanceof Car // true</span><br><span class="line"></span><br><span class="line">let car = new String(&apos;Mercedes Benz&apos;)</span><br><span class="line"></span><br><span class="line">car instanceof String // true</span><br><span class="line"></span><br><span class="line">let str = &apos;Covid-19&apos;</span><br><span class="line"></span><br><span class="line">str instanceof String // false</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------------------------------</span><br><span class="line"></span><br><span class="line">function myInstanceof(left, right) &#123;</span><br><span class="line"></span><br><span class="line">  // 这里先用typeof来判断基础数据类型，如果是，直接返回false</span><br><span class="line"></span><br><span class="line">  if(typeof left !== &apos;object&apos; || left === null) return false;</span><br><span class="line"></span><br><span class="line">  // getPrototypeOf是Object对象自带的API，能够拿到参数的原型对象</span><br><span class="line"></span><br><span class="line">  let proto = Object.getPrototypeOf(left);</span><br><span class="line"></span><br><span class="line">  while(true) &#123;                  //循环往下寻找，直到找到相同的原型对象</span><br><span class="line"></span><br><span class="line">    if(proto === null) return false;</span><br><span class="line"></span><br><span class="line">    if(proto === right.prototype) return true;//找到相同原型对象，返回true</span><br><span class="line"></span><br><span class="line">    proto = Object.getPrototypeof(proto);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 验证一下自己实现的myInstanceof是否OK</span><br><span class="line"></span><br><span class="line">console.log(myInstanceof(new Number(123), Number));    // true</span><br><span class="line"></span><br><span class="line">console.log(myInstanceof(123, Number));                // false</span><br><span class="line"></span><br><span class="line">instanceof 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型；</span><br><span class="line">而 typeof 也存在弊端，它虽然可以判断基础数据类型（null 除外），但是引用数据类型中，除了 function 类型以外，其他的也无法判断。</span><br></pre></td></tr></table></figure>
<h5 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString"></a>Object.prototype.toString</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString(&#123;&#125;)       // &quot;[object Object]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(&#123;&#125;)  // 同上结果，加上call也ok</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(1)    // &quot;[object Number]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(&apos;1&apos;)  // &quot;[object String]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(true)  // &quot;[object Boolean]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(function()&#123;&#125;)  // &quot;[object Function]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(null)   //&quot;[object Null]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(undefined) //&quot;[object Undefined]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(/123/g)    //&quot;[object RegExp]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(new Date()) //&quot;[object Date]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call([])       //&quot;[object Array]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(document)  //&quot;[object HTMLDocument]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(window)   //&quot;[object Window]&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function getType(obj)&#123;</span><br><span class="line">  let type  = typeof obj;</span><br><span class="line">  if (type !== &quot;object&quot;) &#123;    // 先进行typeof判断，如果是基础数据类型，直接返回</span><br><span class="line">    return type;</span><br><span class="line">  &#125;</span><br><span class="line">  // 对于typeof返回结果是object的，再进行如下的判断，正则返回结果</span><br><span class="line">  return Object.prototype.toString.call(obj).replace(/^\[object (\S+)\]$/, &apos;$1&apos;);  // 注意正则中间有个空格</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">强制类型转换 Number()、parseInt()、parseFloat()、toString()、String()、Boolean()</span><br><span class="line"></span><br><span class="line">Number() 方法的强制转换规则</span><br><span class="line">如果是布尔值，true 和 false 分别被转换为 1 和 0；</span><br><span class="line">如果是数字，返回自身；</span><br><span class="line">如果是 null，返回 0；</span><br><span class="line">如果是 undefined，返回 NaN；</span><br><span class="line">如果是字符串，遵循以下规则：如果字符串中只包含数字（或者是 0X / 0x 开头的十六进制数字字符串，允许包含正负号），则将其转换为十进制；如果字符串中包含有效的浮点格式，将其转换为浮点数值；如果是空字符串，将其转换为 0；如果不是以上格式的字符串，均返回 NaN；</span><br><span class="line">如果是 Symbol，抛出错误；</span><br><span class="line">如果是对象，并且部署了 [Symbol.toPrimitive] ，那么调用此方法，否则调用对象的 valueOf() 方法，然后依据前面的规则转换返回的值；如果转换的结果是 NaN ，则调用对象的 toString() 方法，再次依照前面的顺序转换返回对应的值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Number(true);        // 1</span><br><span class="line"></span><br><span class="line">Number(false);       // 0</span><br><span class="line"></span><br><span class="line">Number(&apos;0111&apos;);      //111</span><br><span class="line"></span><br><span class="line">Number(null);        //0</span><br><span class="line"></span><br><span class="line">Number(&apos;&apos;);          //0</span><br><span class="line"></span><br><span class="line">Number(&apos;1a&apos;);        //NaN</span><br><span class="line"></span><br><span class="line">Number(-0X11);       //-17</span><br><span class="line"></span><br><span class="line">Number(&apos;0X11&apos;)       //17</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Boolean() 方法的强制转换规则</span><br><span class="line">除了 undefined、 null、 false、 &apos;&apos;、 0（包括 +0，-0）、 NaN 转换出来是 false，其他都是 true。</span><br><span class="line"></span><br><span class="line">Boolean(0)          //false</span><br><span class="line"></span><br><span class="line">Boolean(null)       //false</span><br><span class="line"></span><br><span class="line">Boolean(undefined)  //false</span><br><span class="line"></span><br><span class="line">Boolean(NaN)        //false</span><br><span class="line"></span><br><span class="line">Boolean(1)          //true</span><br><span class="line"></span><br><span class="line">Boolean(13)         //true</span><br><span class="line"></span><br><span class="line">Boolean(&apos;12&apos;)       //true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------------------------------------------------</span><br><span class="line"></span><br><span class="line">&quot;==&quot; 的隐式类型转换规则</span><br><span class="line">如果类型相同，无须进行类型转换；</span><br><span class="line">如果其中一个操作值是 null 或者 undefined，那么另一个操作符必须为 null 或者 undefined，才会返回 true，否则都返回 false；</span><br><span class="line">如果其中一个是 Symbol 类型，那么返回 false；</span><br><span class="line">两个操作值如果为 string 和 number 类型，那么就会将字符串转换为 number；</span><br><span class="line">如果一个操作值是 boolean，那么转换成 number；</span><br><span class="line">如果一个操作值为 object 且另一方为 string、number 或者 symbol，就会把 object 转为原始类型再进行判断（调用 object 的 valueOf/toString 方法进行转换）。</span><br><span class="line"></span><br><span class="line">null == undefined       // true  规则2</span><br><span class="line"></span><br><span class="line">null == 0               // false 规则2</span><br><span class="line"></span><br><span class="line">&apos;&apos; == null              // false 规则2</span><br><span class="line"></span><br><span class="line">&apos;&apos; == 0                 // true  规则4 字符串转隐式转换成Number之后再对比</span><br><span class="line"></span><br><span class="line">&apos;123&apos; == 123            // true  规则4 字符串转隐式转换成Number之后再对比</span><br><span class="line"></span><br><span class="line">0 == false              // true  规则5 布尔型隐式转换成Number之后再对比</span><br><span class="line"></span><br><span class="line">1 == true               // true  规则5 布尔型隐式转换成Number之后再对比</span><br><span class="line"></span><br><span class="line">var a = &#123;</span><br><span class="line"></span><br><span class="line">  value: 0,</span><br><span class="line"></span><br><span class="line">  valueOf: function() &#123;</span><br><span class="line"></span><br><span class="line">    this.value++;</span><br><span class="line"></span><br><span class="line">    return this.value;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 注意这里a又可以等于1、2、3</span><br><span class="line"></span><br><span class="line">console.log(a == 1 &amp;&amp; a == 2 &amp;&amp; a ==3);  //true f规则 Object隐式转换</span><br><span class="line"></span><br><span class="line">// 注：但是执行过3遍之后，再重新执行a==3或之前的数字就是false，因为value已经加上去了，这里需要注意一下</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------------------------------------</span><br><span class="line"></span><br><span class="line">&apos;+’ 的隐式类型转换规则</span><br><span class="line">如果其中有一个是字符串，另外一个是 undefined、null 或布尔型，则调用 toString() 方法进行字符串拼接；如果是纯对象、数组、正则等，则默认调用对象的转换方法会存在优先级，然后再进行拼接。</span><br><span class="line">如果其中有一个是数字，另外一个是 undefined、null、布尔型或数字，则会将其转换成数字进行加法运算，对象的情况还是参考上一条规则。</span><br><span class="line">如果其中一个是字符串、一个是数字，则按照字符串规则进行拼接</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-------------------------------------------------------</span><br><span class="line">Object 的转换规则</span><br><span class="line">如果部署了 Symbol.toPrimitive 方法，优先调用再返回；</span><br><span class="line">调用 valueOf()，如果转换为基础类型，则返回；</span><br><span class="line">调用 toString()，如果转换为基础类型，则返回；</span><br><span class="line">如果都没有返回基础类型，会报错。</span><br></pre></td></tr></table></figure>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><h4 id="http-proxy-middleware"><a href="#http-proxy-middleware" class="headerlink" title="http-proxy-middleware"></a>http-proxy-middleware</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// javascript</span><br><span class="line"></span><br><span class="line">const express = require(&apos;express&apos;);</span><br><span class="line">const &#123; createProxyMiddleware &#125; = require(&apos;http-proxy-middleware&apos;);</span><br><span class="line"></span><br><span class="line">const app = express();</span><br><span class="line"></span><br><span class="line">app.use(&apos;/api&apos;, createProxyMiddleware(&#123; target: &apos;http://www.example.org&apos;, changeOrigin: true &#125;));</span><br><span class="line">app.listen(3000);</span><br><span class="line"></span><br><span class="line">// http://localhost:3000/api/foo/bar -&gt; http://www.example.org/api/foo/bar</span><br></pre></td></tr></table></figure>
<ul>
<li>箭头函数有几个使用注意点。<br>（1）箭头函数没有自己的 this 对象。对于普通函数来说，内部的 this 指向函数运行时所在的对象，但是这一点对箭头函数不立。它没有自己的 this 对象，内部的 this 就是定义时上层作用域中的 this。也就是说，箭头函数内部的 this 指向是固定的，相比之下，普通函数的 this 指向是可变的。<br>（2）不可以当作构造函数，也就是说，不可以对箭头函数使用 new 命令，否则会抛出一个错误。<br>（3）不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。<br>（4）不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。</li>
<li>AMD 是”Asynchronous Module Definition”的缩写，意思就是”异步模块定义”。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。require.js 实现了 AMD 规范。浏览器端的模块，不能采用”同步加载”（synchronous），只能采用”异步加载”（asynchronous）。这就是 AMD 规范诞生的背景。<br>CommonJS node.js 的模块系统，就是参照 CommonJS 规范实现的。在 CommonJS 中，有一个全局性方法 require()，用于加载模块。<br>RequireJS 的做法是并行加载所有依赖的模块, 并完成解析后, 再开始执行其他代码。<br>而 SeaJS 一样是并行加载所有依赖的模块, 但不会立即执行模块, 等到真正需要(require)的时候才开始解析。</li>
<li>WebP 新一代图片格式，有损压缩，压缩体积小，在压缩方面比当前 JPEG 格式更优越。谷歌表示，webp 这种格式的主要优势在于高效率。他们发现，“在质量相同的情况下，WebP 格式图像的体积要比 JPEG 格式图像小 40%。美中不足的是，WebP 格式图像的编码时间“比 JPEG 格式图像长8 倍”。<br>png 是一种采用无损压缩算法的位图格式，其设计目的是试图替代 GIF 和 TIFF 文件格式，压缩比高，生成文件体积小。<br>JPEG 有损压缩</li>
<li>设置元素浮动后，该元素的 display 值为 block(window.getComputedStyle(‘对应 dom 元素’))</li>
<li>块格式化上下文(<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context</a>)<br>块格式化上下文（Block Formatting Context，BFC） 是 Web 页面的可视 CSS 渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。<br>块格式化上下文对浮动定位（参见 float）与清除浮动（参见 clear）都很重要。浮动定位和清除浮动时只会应用于同一个 BFC 内的元素。浮动不会影响其它 BFC 中元素的布局，而清除浮动只能清除同一 BFC 中在它前面的元素的浮动。外边距折叠（Margin collapsing）也只会发生在属于同一 BFC 的块级元素之间。<br>下列方式会创建块格式化上下文：<br>根元素（<code>&lt;html&gt;</code>）<br>浮动元素（元素的 float 不是 none）<br>绝对定位元素（元素的 position 为 absolute 或 fixed）<br>行内块元素（元素的 display 为 inline-block）<br>表格单元格（元素的 display 为 table-cell，HTML 表格单元格默认为该值）<br>表格标题（元素的 display 为 table-caption，HTML 表格标题默认为该值）<br>匿名表格单元格元素（元素的 display 为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是 HTML table、row、tbody、thead、tfoot 的默认属性）或 inline-table）<br>overflow 计算值(Computed)不为 visible 的块元素<br>display 值为 flow-root 的元素<br>contain 值为 layout、content 或 paint 的元素<br>弹性元素（display 为 flex 或 inline-flex 元素的直接子元素）<br>网格元素（display 为 grid 或 inline-grid 元素的直接子元素）<br>多列容器（元素的 column-count 或 column-width (en-US) 不为 auto，包括 column-count 为 1）</li>
<li>清除浮动</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.clear:after</span><br><span class="line">&#123;</span><br><span class="line">    content:&apos;&apos;;</span><br><span class="line">    display:table;</span><br><span class="line">    clear:both;</span><br><span class="line">&#125;</span><br><span class="line">.clear</span><br><span class="line">&#123;</span><br><span class="line">    *zoom:1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Cache Manifest</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line"># 2012-02-21 v1.0.0</span><br><span class="line">/theme.css</span><br><span class="line">/logo.gif</span><br><span class="line">/main.js</span><br><span class="line"></span><br><span class="line">NETWORK:</span><br><span class="line">login.php</span><br><span class="line"></span><br><span class="line">FALLBACK:</span><br><span class="line">/html/ /offline.html</span><br></pre></td></tr></table></figure>
<ul>
<li>web worker 是运行在后台的 JavaScript，不会影响页面的性能。<br>当在 HTML 页面中执行脚本时，页面的状态是不可响应的，直到脚本已完成。<br>web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;计数： &lt;output id=&quot;result&quot;&gt;&lt;/output&gt;&lt;/p&gt;</span><br><span class="line">&lt;button onclick=&quot;startWorker()&quot;&gt;开始工作&lt;/button&gt;</span><br><span class="line">&lt;button onclick=&quot;stopWorker()&quot;&gt;停止工作&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; Internet Explorer 9 及更早 IE 版本浏览器不支持 Web Workers.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">var w;</span><br><span class="line"></span><br><span class="line">function startWorker() &#123;</span><br><span class="line">    if(typeof(Worker) !== &quot;undefined&quot;) &#123;</span><br><span class="line">        if(typeof(w) == &quot;undefined&quot;) &#123;</span><br><span class="line">            w = new Worker(&quot;demo_workers.js&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        w.onmessage = function(event) &#123;</span><br><span class="line">            document.getElementById(&quot;result&quot;).innerHTML = event.data;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        document.getElementById(&quot;result&quot;).innerHTML = &quot;抱歉，你的浏览器不支持 Web Workers...&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function stopWorker()</span><br><span class="line">&#123;</span><br><span class="line">    w.terminate();</span><br><span class="line">    w = undefined;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">demo_workers.js</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var i=0;</span><br><span class="line"></span><br><span class="line">function timedCount()</span><br><span class="line">&#123;</span><br><span class="line">    i=i+1;</span><br><span class="line">    postMessage(i);</span><br><span class="line">    setTimeout(&quot;timedCount()&quot;,500);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timedCount();</span><br></pre></td></tr></table></figure>
<ul>
<li>Web App Manifest Web 应用程序清单在一个 JSON 文本文件中提供有关应用程序的信息（如名称，作者，图标和描述）。manifest 的目的是将 Web 应用程序安装到设备的主屏幕，为用户提供更快的访问和更丰富的体验。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;manifest&quot; href=&quot;/manifest.json&quot;&gt;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;HackerWeb&quot;,</span><br><span class="line">  &quot;short_name&quot;: &quot;HackerWeb&quot;,</span><br><span class="line">  &quot;start_url&quot;: &quot;.&quot;,</span><br><span class="line">  &quot;display&quot;: &quot;standalone&quot;,</span><br><span class="line">  &quot;background_color&quot;: &quot;#fff&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;A simply readable Hacker News app.&quot;,</span><br><span class="line">  &quot;icons&quot;: [&#123;</span><br><span class="line">    &quot;src&quot;: &quot;images/touch/homescreen48.png&quot;,</span><br><span class="line">    &quot;sizes&quot;: &quot;48x48&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;image/png&quot;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    &quot;src&quot;: &quot;images/touch/homescreen72.png&quot;,</span><br><span class="line">    &quot;sizes&quot;: &quot;72x72&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;image/png&quot;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    &quot;src&quot;: &quot;images/touch/homescreen96.png&quot;,</span><br><span class="line">    &quot;sizes&quot;: &quot;96x96&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;image/png&quot;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    &quot;src&quot;: &quot;images/touch/homescreen144.png&quot;,</span><br><span class="line">    &quot;sizes&quot;: &quot;144x144&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;image/png&quot;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    &quot;src&quot;: &quot;images/touch/homescreen168.png&quot;,</span><br><span class="line">    &quot;sizes&quot;: &quot;168x168&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;image/png&quot;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    &quot;src&quot;: &quot;images/touch/homescreen192.png&quot;,</span><br><span class="line">    &quot;sizes&quot;: &quot;192x192&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;image/png&quot;</span><br><span class="line">  &#125;],</span><br><span class="line">  &quot;related_applications&quot;: [&#123;</span><br><span class="line">    &quot;platform&quot;: &quot;web&quot;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    &quot;platform&quot;: &quot;play&quot;,</span><br><span class="line">    &quot;url&quot;: &quot;https://play.google.com/store/apps/details?id=cheeaun.hackerweb&quot;</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>offsetWidth :内容宽度+padding+border<br>offsetHeight :内容高度+padding+border<br>clientWidth :内容宽度+padding<br>clientHeight :内容高度度+padding<br>scrollWidth,<br>scrollHeight :能够滚动的内容高度+padding <code>1340=44*30（滚动内容高度）+20（padding-top）</code><br>offsetTop : 距离具有定位属性的父盒子的距离,父盒子没有定位属性则一直向上找直到 body(不带 border 值)<br>offsetLeft<br>clientTop:border-top 的值<br>clientLeft:border-left<br>scrollTop:滚动条滚动距离(需要 onscroll 事件监听)<br>scrollLeft</p>
</li>
<li><p><code>[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;].map(parseInt) [ 1, NaN, NaN ]</code></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">parseInt(string, radix);</span><br><span class="line"></span><br><span class="line">string</span><br><span class="line">要被解析的值。如果参数不是一个字符串，则将其转换为字符串(使用  ToString 抽象操作)。字符串开头的空白符将会被忽略。</span><br><span class="line">radix 可选</span><br><span class="line">从 2 到 36，表示字符串的基数。例如指定 16 表示被解析值是十六进制数。请注意，10不是默认值！</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如果 radix 是 undefined、0或未指定的，JavaScript会假定以下情况：</span><br><span class="line">如果输入的 string以 &quot;0x&quot;或 &quot;0x&quot;（一个0，后面是小写或大写的X）开头，那么radix被假定为16，字符串的其余部分被当做十六进制数去解析。</span><br><span class="line">如果输入的 string以 &quot;0&quot;（0）开头， radix被假定为8（八进制）或10（十进制）。具体选择哪一个radix取决于实现。ECMAScript 5 澄清了应该使用 10 (十进制)，但不是所有的浏览器都支持。因此，在使用 parseInt 时，一定要指定一个 radix。</span><br><span class="line">如果输入的 string 以任何其他值开头， radix 是 10 (十进制)。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">当radix 小于 2 或大于 36 ，或第一个非空格字符不能转换为数字，parseInt会返回 NaN。</span><br><span class="line"></span><br><span class="line">parseInt(&apos;123&apos;, 5) // 将&apos;123&apos;看作5进制数，返回十进制数38 =&gt; 1*5^2 + 2*5^1 + 3*5^0 = 38</span><br><span class="line"></span><br><span class="line">以下例子均返回 NaN:</span><br><span class="line">parseInt(&quot;Hello&quot;, 8); // 根本就不是数值</span><br><span class="line">parseInt(&quot;546&quot;, 2);   // 除了“0、1”外，其它数字都不是有效二进制数字</span><br></pre></td></tr></table></figure>
<ul>
<li>use strict</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function f()&#123;</span><br><span class="line">    return !this;</span><br><span class="line">&#125;</span><br><span class="line">// 返回false，因为&quot;this&quot;指向全局对象，&quot;!this&quot;就是false</span><br><span class="line"></span><br><span class="line">function f()&#123;</span><br><span class="line">    &quot;use strict&quot;;</span><br><span class="line">    return !this;</span><br><span class="line">&#125;</span><br><span class="line">// 返回true，因为严格模式下，this的值为undefined，所以&quot;!this&quot;为true。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;use strict&quot;;</span><br><span class="line">x = &#123;p1:10, p2:20&#125;;      // 报错 (x 未定义)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;use strict&quot;;</span><br><span class="line">x = 3.14;                // 报错 (x 未定义)</span><br></pre></td></tr></table></figure>
<ul>
<li>Properties attributes</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Properties&#123;</span><br><span class="line">  标签上面的属性</span><br><span class="line">  attributes:&#123;</span><br><span class="line">   id</span><br><span class="line">   class</span><br><span class="line">  &#125;,</span><br><span class="line">  id</span><br><span class="line">  className</span><br><span class="line">  innerHTML</span><br><span class="line">  onclick</span><br><span class="line">  scrollTop</span><br><span class="line">  replaceChild</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>options 请求方法要求服务器列出可对资源实行的操作方法（Access-Control-Allow-Methods: GET），在响应头的 Allow 字段里返回。它的功能很有限，用处也不大，有的服务器（例如 Nginx）干脆就没有实现对它的支持。</li>
<li><p>HEAD：获取资源的元信息；</p>
</li>
<li><p>JavaScript 类型化数组</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">JavaScript类型化数组是一种类似数组的对象，并提供了一种用于访问原始二进制数据的机制。 正如你可能已经知道，Array 存储的对象能动态增多和减少，并且可以存储任何JavaScript值。JavaScript引擎会做一些内部优化，以便对数组的操作可以很快。然而，随着Web应用程序变得越来越强大，尤其一些新增加的功能例如：音频视频编辑，访问WebSockets的原始数据等，很明显有些时候如果使用JavaScript代码可以快速方便地通过类型化数组来操作原始的二进制数据将会非常有帮助。</span><br><span class="line"></span><br><span class="line">但是，不要把类型化数组与正常数组混淆，因为在类型数组上调用  Array.isArray()  会返回false。此外，并不是所有可用于正常数组的方法都能被类型化数组所支持（如 push 和 pop）。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">为了达到最大的灵活性和效率，JavaScript 类型数组（Typed Arrays）将实现拆分为缓冲和视图两部分。一个缓冲（由 ArrayBuffer 对象实现）描述的是一个数据块。缓冲没有格式可言，并且不提供机制访问其内容。为了访问在缓冲对象中包含的内存，你需要使用视图。视图提供了上下文 — 即数据类型、起始偏移量和元素数 — 将数据转换为实际有类型的数组。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var buffer = new ArrayBuffer(16);</span><br><span class="line">var int32View = new Int32Array(buffer);</span><br><span class="line">for (var i = 0; i &lt; int32View.length; i++) &#123;</span><br><span class="line">  int32View[i] = i * 2;</span><br><span class="line">&#125;</span><br><span class="line">该代码会将数组以0, 2, 4和6填充 （一共4个4字节元素，所以总长度为16字节）。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var int16View = new Int16Array(buffer);</span><br><span class="line"></span><br><span class="line">for (var i = 0; i &lt; int16View.length; i++) &#123;</span><br><span class="line">  console.log(&quot;Entry &quot; + i + &quot;: &quot; + int16View[i]);</span><br><span class="line">&#125;</span><br><span class="line">这里我们创建了一个2字节整数视图，该视图共享上文的4字节整数视图的缓冲，然后以2字节整数打印出缓冲里的数据，这次我们会得到0, 0, 2, 0, 4, 0, 6, 0这样的输出。</span><br></pre></td></tr></table></figure>
<ul>
<li>设计模式<ul>
<li>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。</li>
<li>观察者模式。当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知依赖它的对象。观察者模式属于行为型模式。</li>
</ul>
</li>
<li>window.onpopstate<br>注意：调用 history.pushState()或者 history.replaceState()不会触发 popstate 事件. popstate 事件只会在浏览器某些行为下触发, 比如点击后退、前进按钮(或者在 JavaScript 中调用 history.back()、history.forward()、history.go()方法)，此外，a 标签的锚点也会触发该事件.</li>
<li>Object.getOwnPropertyDescriptor() 方法返回指定对象上一个自有属性对应的属性描述符。（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）<br>一个属性描述符是一个记录，由下面属性当中的某些组成的：<br>value<br>该属性的值(仅针对数据属性描述符有效)<br>writable<br>当且仅当属性的值可以被改变时为 true。(仅针对数据属性描述有效)<br>get<br>获取该属性的访问器函数（getter）。如果没有访问器，该值为 undefined。(仅针对包含访问器或设置器的属性描述有效)<br>set<br>获取该属性的设置器函数（setter）。如果没有设置器，该值为 undefined。(仅针对包含访问器或设置器的属性描述有效)<br>configurable<br>当且仅当指定对象的属性描述可以被改变或者属性可被删除时，为 true。<br>enumerable<br>当且仅当指定对象的属性可以被枚举出时，为 true</li>
</ul>
<h3 id="typescript"><a href="#typescript" class="headerlink" title="typescript"></a>typescript</h3><ul>
<li>readonly vs const<br>最简单判断该用 readonly 还是 const 的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 const，若做为属性则使用 readonly。</li>
<li><p>对象展开还有其它一些意想不到的限制。 首先，它仅包含对象自身的可枚举属性。 大体上是说当你展开一个对象实例时，你会丢失其方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class C &#123;</span><br><span class="line">  p = 12;</span><br><span class="line">  m() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let c = new C();</span><br><span class="line">let clone = &#123; ...c &#125;;</span><br><span class="line">clone.p; // ok</span><br><span class="line">clone.m(); // error!</span><br></pre></td></tr></table></figure>
</li>
<li><p>联合类型（Union Types）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface Bird &#123;</span><br><span class="line">  fly();</span><br><span class="line">  layEggs();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">interface Fish &#123;</span><br><span class="line">  swim();</span><br><span class="line">  ayEggs();</span><br><span class="line">&#125;</span><br><span class="line">function getSmallPet(): Fish | Bird &#123;</span><br><span class="line">// ...</span><br><span class="line">&#125;</span><br><span class="line">let pet = getSmallPet();</span><br><span class="line">pet.layEggs(); // okay</span><br><span class="line">pet.swim(); // errors</span><br></pre></td></tr></table></figure>
</li>
<li><p>类型断言有两种形式。 其一是“尖括号”语法。另一个为 as 语法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let someValue: any = &quot;this is a string&quot;;</span><br><span class="line"></span><br><span class="line">let strLength: number = (&lt;string&gt;someValue).length;</span><br><span class="line"></span><br><span class="line">let someValue: any = &quot;this is a string&quot;;</span><br><span class="line"></span><br><span class="line">let strLength: number = (someValue as string).length;</span><br></pre></td></tr></table></figure>
</li>
<li><p>数组<br>有两种方式可以定义数组。 第一种，可以在元素类型后面接上 <code>[]</code>，表示由此类型元素组成的一个数组。第二种方式是使用数组泛型，<code>Array&lt;元素类型&gt;</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let list: number[] = [1, 2, 3];</span><br><span class="line">let list: Array&lt;number&gt; = [1, 2, 3];</span><br></pre></td></tr></table></figure>
</li>
<li><p>元组 Tuple<br>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string 和 number 类型的元组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Declare a tuple type</span><br><span class="line">let x: [string, number];</span><br><span class="line">// Initialize it</span><br><span class="line">x = [&apos;hello&apos;, 10]; // OK</span><br><span class="line">// Initialize it incorrectly</span><br><span class="line">x = [10, &apos;hello&apos;]; // Error</span><br></pre></td></tr></table></figure>
</li>
<li><p>接口 vs. 类型别名</p>
<ul>
<li>接口创建了一个新的名字，可以在其它任何地方使用。 类型别名并不创建新名字—比如，错误信息就不会使用别名。 在下面的示例代码里，在编译器中将鼠标悬停在 interfaced 上，显示它返回的是 Interface，但悬停在 aliased 上时，显示的却是对象字面量类型。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type Alias = &#123; num: number &#125;</span><br><span class="line">interface Interface &#123;</span><br><span class="line">    num: number;</span><br><span class="line">&#125;</span><br><span class="line">declare function aliased(arg: Alias): Alias;</span><br><span class="line">declare function interfaced(arg: Interface): Interface;</span><br></pre></td></tr></table></figure>
<ul>
<li>另一个重要区别是类型别名不能被 extends 和 implements（自己也不能 extends 和 implements 其它类型）。</li>
<li>如果你无法通过接口来描述一个类型并且需要使用联合类型或元组类型，这时通常会使用类型别名。</li>
</ul>
</li>
<li><p>类型别名</p>
<ul>
<li>类型别名有时和接口很像，但是可以作用于原始值，联合类型，元组以及其它任何你需要手写的类型。</li>
<li>起别名不会新建一个类型 - 它创建了一个新名字来引用那个类型。 给原始类型起别名通常没什么用，尽管可以做为文档的一种形式使用。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type Name = string;</span><br><span class="line">type NameResolver = () =&gt; string;</span><br><span class="line">type NameOrResolver = Name | NameResolver;</span><br><span class="line">function getName(n: NameOrResolver): Name &#123;</span><br><span class="line">    if (typeof n === &apos;string&apos;) &#123;</span><br><span class="line">        return n;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        return n();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>与交叉类型一起使用，我们可以创建出一些十分稀奇古怪的类型。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type LinkedList&lt;T&gt; = T &amp; &#123; next: LinkedList&lt;T&gt; &#125;;</span><br><span class="line"></span><br><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var people: LinkedList&lt;Person&gt;;</span><br><span class="line">var s = people.name;</span><br><span class="line">var s = people.next.name;</span><br><span class="line">var s = people.next.next.name;</span><br><span class="line">var s = people.next.next.next.name;</span><br></pre></td></tr></table></figure>
<ul>
<li>类型别名不能出现在声明右侧的任何地方。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type Yikes = Array&lt;Yikes&gt;; // error</span><br></pre></td></tr></table></figure>
<ul>
<li>同接口一样，类型别名也可以是泛型 - 我们可以添加类型参数并且在别名声明的右侧传入<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type Container&lt;T&gt; = &#123; value: T &#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>keyof 索引类型查询操作符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line">let personProps: keyof Person; // &apos;name&apos; | &apos;age&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>模块解析<br>共有两种可用的模块解析策略：Node 和 Classic。 你可以使用 –moduleResolution 标记来指定使用哪种模块解析策略。若未指定，那么在使用了 <code>--module AMD | System | ES2015</code>时的默认值为 Classic，其它情况时则为 Node。</p>
<pre><code>- Classic
  - 这种策略在以前是 TypeScript 默认的解析策略。 现在，它存在的理由主要是为了向后兼容。
    相对导入的模块是相对于导入它的文件进行解析的。 因此 `/root/src/folder/A.ts` 文件里的 `import { b } from &quot;./moduleB&quot;`会使用下面的查找流程：
    `/root/src/folder/moduleB.ts`
    `/root/src/folder/moduleB.d.ts`
  - 对于非相对模块的导入，编译器则会从包含导入文件的目录开始依次向上级目录遍历，尝试定位匹配的声明文件。
    有一个对 moduleB 的非相对导入 `import { b } from &quot;moduleB&quot;`，它是在`/root/src/folder/A.ts` 文件里，会以如下的方式来定位&quot;moduleB&quot;：
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/root/src/folder/moduleB.ts</span><br><span class="line">         /root/src/folder/moduleB.d.ts</span><br><span class="line">         /root/src/moduleB.ts</span><br><span class="line">         /root/src/moduleB.d.ts</span><br><span class="line">         /root/moduleB.ts</span><br><span class="line">         /root/moduleB.d.ts</span><br><span class="line">         /moduleB.ts</span><br><span class="line">         /moduleB.d.ts</span><br></pre></td></tr></table></figure>

- Node

  - Node.js 如何解析模块

    - 相对路径很简单。 例如，假设有一个文件路径为 `/root/src/moduleA.js`，包含了一个导入 `var x = require(&quot;./moduleB&quot;);` Node.js 以下面的顺序解析这个导入：
      检查`/root/src/moduleB.js` 文件是否存在。
      检查`/root/src/moduleB` 目录是否包含一个 package.json 文件，且 package.json 文件指定了一个&quot;main&quot;模块。 在我们的例子里，如果 Node.js 发现文件 `/root/src/moduleB/package.json` 包含了`{ &quot;main&quot;: &quot;lib/mainModule.js&quot; }`，那么 Node.js 会引用`/root/src/moduleB/lib/mainModule.js`。
      检查`/root/src/moduleB `目录是否包含一个 index.js 文件。 这个文件会被隐式地当作那个文件夹下的&quot;main&quot;模块。
    - 但是，非相对模块名的解析是个完全不同的过程。 Node 会在一个特殊的文件夹 node_modules 里查找你的模块。 node_modules 可能与当前文件在同一级目录下，或者在上层目录里。 Node 会向上级目录遍历，查找每个 node_modules 直到它找到要加载的模块。
      假设`/root/src/moduleA.js` 里使用的是非相对路径导入` var x = require(&quot;moduleB&quot;);`。 Node 则会以下面的顺序去解析 moduleB，直到有一个匹配上。
      `/root/src/node_modules/moduleB.js`
      `/root/src/node_modules/moduleB/package.json` (如果指定了&quot;main&quot;属性)
      `/root/src/node_modules/moduleB/index.js`

      `/root/node_modules/moduleB.js`
      `/root/node_modules/moduleB/package.json` (如果指定了&quot;main&quot;属性)
      `/root/node_modules/moduleB/index.js`

      `/node_modules/moduleB.js`
      `/node_modules/moduleB/package.json` (如果指定了&quot;main&quot;属性)
      `/node_modules/moduleB/index.js`

  - TypeScript 如何解析模块
    - 有一个导入语句 `import { b } from &quot;./moduleB&quot;`在`/root/src/moduleA.ts` 里，会以下面的流程来定位`&quot;./moduleB&quot;`：
      /root/src/moduleB.ts
      /root/src/moduleB.tsx
      /root/src/moduleB.d.ts
      /root/src/moduleB/package.json (如果指定了&quot;types&quot;属性)
      /root/src/moduleB/index.ts
      /root/src/moduleB/index.tsx
      /root/src/moduleB/index.d.ts
    - 非相对的导入会遵循 Node.js 的解析逻辑，首先查找文件，然后是合适的文件夹。 因此 /root/src/moduleA.ts 文件里的 `import { b } from &quot;moduleB&quot;`会以下面的查找顺序解析：
      /root/src/node_modules/moduleB.ts
      /root/src/node_modules/moduleB.tsx
      /root/src/node_modules/moduleB.d.ts
      /root/src/node_modules/moduleB/package.json (如果指定了&quot;types&quot;属性)
      /root/src/node_modules/moduleB/index.ts
      /root/src/node_modules/moduleB/index.tsx
      /root/src/node_modules/moduleB/index.d.ts

      /root/node_modules/moduleB.ts
      /root/node_modules/moduleB.tsx
      /root/node_modules/moduleB.d.ts
      /root/node_modules/moduleB/package.json (如果指定了&quot;types&quot;属性)
      /root/node_modules/moduleB/index.ts
      /root/node_modules/moduleB/index.tsx
      /root/node_modules/moduleB/index.d.ts

      /node_modules/moduleB.ts
      /node_modules/moduleB.tsx
      /node_modules/moduleB.d.ts
      /node_modules/moduleB/package.json (如果指定了&quot;types&quot;属性)
      /node_modules/moduleB/index.ts
      /node_modules/moduleB/index.tsx
      /node_modules/moduleB/index.d.ts
</code></pre></li>
<li><p>declare</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">jQuery(&apos;#foo&apos;);</span><br><span class="line"></span><br><span class="line">// index.ts(1,1): error TS2304: Cannot find name &apos;jQuery&apos;.</span><br><span class="line"></span><br><span class="line">declare var jQuery: (selector: string) =&gt; any;</span><br><span class="line"></span><br><span class="line">jQuery(&apos;#foo&apos;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Thunk-函数的含义和用法"><a href="#Thunk-函数的含义和用法" class="headerlink" title="Thunk 函数的含义和用法"></a>Thunk 函数的含义和用法</h3><p><strong><a href="https://www.ruanyifeng.com/blog/2015/05/thunk.html" target="_blank" rel="noopener">https://www.ruanyifeng.com/blog/2015/05/thunk.html</a></strong></p>
<p>在 JavaScript 语言中，Thunk 函数替换的不是表达式，而是多参数函数，将其替换成单参数的版本，且只接受回调函数作为参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 正常版本的readFile（多参数版本）</span><br><span class="line">fs.readFile(fileName, callback);</span><br><span class="line"></span><br><span class="line">// Thunk版本的readFile（单参数版本）</span><br><span class="line">var readFileThunk = Thunk(fileName);</span><br><span class="line">readFileThunk(callback);</span><br><span class="line"></span><br><span class="line">var Thunk = function (fileName)&#123;</span><br><span class="line">  return function (callback)&#123;</span><br><span class="line">    return fs.readFile(fileName, callback); </span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var thunkify = require(&apos;thunkify&apos;);</span><br><span class="line">var fs = require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">var read = thunkify(fs.readFile);</span><br><span class="line">read(&apos;package.json&apos;)(function(err, str)&#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="Thunk-函数的自动流程管理"><a href="#Thunk-函数的自动流程管理" class="headerlink" title="Thunk 函数的自动流程管理"></a>Thunk 函数的自动流程管理</h4><p>Thunk 函数真正的威力，在于可以自动执行 Generator 函数。下面就是一个基于 Thunk 函数的 Generator 执行器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function run(fn) &#123;</span><br><span class="line">  var gen = fn();</span><br><span class="line"></span><br><span class="line">  function next(err, data) &#123;</span><br><span class="line">    var result = gen.next(data);</span><br><span class="line">    if (result.done) return;</span><br><span class="line">    result.value(next);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(gen);</span><br></pre></td></tr></table></figure>
<p>上面代码的 run 函数，就是一个 Generator 函数的自动执行器。内部的 next 函数就是 Thunk 的回调函数。 next 函数先将指针移到 Generator 函数的下一步（gen.next 方法），然后判断 Generator 函数是否结束（result.done 属性），如果没结束，就将 next 函数再传入 Thunk 函数（result.value 属性），否则就直接退出。</p>
<h3 id="co-函数库的含义和用法"><a href="#co-函数库的含义和用法" class="headerlink" title="co 函数库的含义和用法"></a>co 函数库的含义和用法</h3><p>比如，有一个 Generator 函数，用于依次读取两个文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var gen = function* ()&#123;</span><br><span class="line">  var f1 = yield readFile(&apos;/etc/fstab&apos;);</span><br><span class="line">  var f2 = yield readFile(&apos;/etc/shells&apos;);</span><br><span class="line">  console.log(f1.toString());</span><br><span class="line">  console.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>co 函数库可以让你不用编写 Generator 函数的执行器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var co = require(&apos;co&apos;);</span><br><span class="line">co(gen);</span><br></pre></td></tr></table></figure>
<p>上面代码中，Generator 函数只要传入 co 函数，就会自动执行。</p>
<p>co 函数返回一个 Promise 对象，因此可以用 then 方法添加回调函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">co(gen).then(function ()&#123;</span><br><span class="line">  console.log(&apos;Generator 函数执行完成&apos;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>上面代码中，等到 Generator 函数执行结束，就会输出一行提示。</p>
<h3 id="async-函数的含义和用法"><a href="#async-函数的含义和用法" class="headerlink" title="async 函数的含义和用法"></a>async 函数的含义和用法</h3><p>async 函数对 Generator 函数的改进，体现在以下三点。</p>
<ul>
<li>内置执行器。 Generator 函数的执行必须靠执行器，所以才有了 co 函数库，而 async 函数自带执行器。也就是说，async 函数的执行，与普通函数一模一样，只要一行。</li>
<li>更好的语义。 async 和 await，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。</li>
<li>更广的适用性。 co 函数库约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以跟 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。</li>
</ul>
<h2 id="前端安全"><a href="#前端安全" class="headerlink" title="前端安全"></a>前端安全</h2><p>XSS 全称是 Cross Site Scripting，为了与“CSS”区分开来，故简称 XSS，翻译过来就是“跨站脚本”。<br>针对 XSS 攻击，主要有三种防范策略，第一种是通过服务器对输入的内容进行过滤或者转码，第二种是充分利用好 CSP，第三种是使用 HttpOnly 来保护重要的 Cookie 信息。<br>当然除了以上策略之外，我们还可以通过添加验证码防止脚本冒充用户提交危险操作。而对于一些不受信任的输入，还可以限制其输入长度，这样可以增大 XSS 攻击的难度。</p>
<p>CSRF 英文全称是 Cross-site request forgery，所以又称为“跨站请求伪造”<br>和 XSS 不同的是，CSRF 攻击不需要将恶意代码注入用户的页面，仅仅是利用服务器的漏洞和用户的登录状态来实施攻击。<br>要让服务器避免遭受到 CSRF 攻击，通常有以下几种途径。<br>充分利用好 Cookie 的 SameSite 属性<br>验证请求的来源站点<br>CSRF Token</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">在 HTTP 响应头中，通过 set-cookie 字段设置 Cookie 时，可以带上 SameSite 选项，如下：</span><br><span class="line">set-cookie: 1P_JAR=2019-10-20-06; expires=Tue, 19-Nov-2019 06:36:21 GMT; path=/; domain=.google.com; SameSite=none</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SameSite 选项通常有 Strict、Lax 和 None 三个值。</span><br><span class="line">1. Strict 最为严格。如果 SameSite 的值是 Strict，那么浏览器会完全禁止第三方 Cookie。</span><br><span class="line">简言之，如果你从a页面中访问 b的资源，而 b 的某些 Cookie 设置了 SameSite = Strict 的话，</span><br><span class="line">那么这些 Cookie 是不会被发送到 b 的服务器上的。</span><br><span class="line">只有你从 b的站点去请求 b的资源时，才会带上这些 Cookie。</span><br><span class="line">2.Lax 相对宽松一点。在跨站点的情况下，从第三方站点的链接打开和从第三方站点提交 Get 方式的表单这两种方式都会携带 Cookie。</span><br><span class="line">但如果在第三方站点中使用 Post 方法，或者通过 img、iframe 等标签加载的 URL，这些场景都不会携带 Cookie。</span><br><span class="line">3.而如果使用 None 的话，在任何情况下都会发送 Cookie 数据。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">大致分为两步：</span><br><span class="line">第一步，在浏览器向服务器发起请求时，服务器生成一个 CSRF Token。</span><br><span class="line">CSRF Token 其实就是服务器生成的字符串，然后将该字符串植入到返回的页面中。你可以参考下面示例代码：</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form action=&quot;https://diamonds.org/sendcoin&quot; method=&quot;POST&quot;&gt;</span><br><span class="line">      &lt;input type=&quot;hidden&quot; name=&quot;csrf-token&quot; value=&quot;nc98P987bcpncYhoadjoiydc9ajDlcn&quot;&gt;</span><br><span class="line">      &lt;input type=&quot;text&quot; name=&quot;user&quot;&gt;</span><br><span class="line">      &lt;input type=&quot;text&quot; name=&quot;number&quot;&gt;</span><br><span class="line">      &lt;input type=&quot;submit&quot;&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第二步，在浏览器端如果要发起转账的请求，那么需要带上页面中的 CSRF Token，然后服务器会验证该 Token 是否合法。</span><br><span class="line">如果是从第三方站点发出的请求，那么将无法获取到 CSRF Token 的值，所以即使发出了请求，服务器也会因为 CSRF Token 不正确而拒绝请求。</span><br></pre></td></tr></table></figure>
<p>现代浏览器采用了多进程架构，将渲染进程和浏览器主进程做了分离，浏览器被划分为浏览器内核和渲染内核两个核心模块，其中浏览器内核是由网络进程、浏览器主进程和 GPU 进程组成的，渲染内核就是渲染进程。<br>浏览器中的安全沙箱是利用操作系统提供的安全技术，让渲染进程在执行过程中无法访问或者修改操作系统中的数据，在渲染进程需要访问系统资源的时候，需要通过浏览器内核来实现，然后将访问的结果通过 IPC 转发给渲染进程。</p>
<h2 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h2><h3 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line">(function (modules) &#123;&#125;)(&#123;</span><br><span class="line">  &quot;&quot;: function (module,exports) &#123;&#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//--------------------------------------------</span><br><span class="line">// ES Modules</span><br><span class="line">// 1.自动采用严格模式（use strict）</span><br><span class="line">// 2.每个ESM模块都是单独的私有作用域</span><br><span class="line">// 3.ESM模块通过CORS（跨域资源共享）去请求外部js模块</span><br><span class="line">// 4.ESM的script标签会延迟脚本的执行</span><br><span class="line">//--------------------------------------------</span><br><span class="line">// url-loader  小文件使用Data URLs,减少请求次数 一个用于webpack的加载器，它将文件转换为base64 uri。</span><br><span class="line">// file-loader 大文件单独提取存放，提高加载速度  文件加载器将文件上的import/require()解析为一个url，并将文件发送到输出目录中。</span><br><span class="line"></span><br><span class="line">// css-loader 将css代码转换成js模块</span><br><span class="line">// style-loader 将css代码通过style标签插入html当中</span><br><span class="line"></span><br><span class="line">//html-loader 默认情况下，每个本地的 &lt;img src=&quot;image.png&quot;&gt; 都需要通过 require （require(&apos;./image.png&apos;)）来进行加载。你可能需要在配置中为图片指定 loader（推荐 file-loader 或 url-loader ） 你可以通过查询参数 attrs，来指定哪个标签属性组合(tag-attribute combination)应该被此 loader 处理。传递数组或以空格分隔的 &lt;tag&gt;:&lt;attribute&gt; 组合的列表。（默认值：attrs=img:src）</span><br><span class="line"></span><br><span class="line">// &#123;</span><br><span class="line">//   module: &#123;</span><br><span class="line">//     rules: [</span><br><span class="line">//       &#123; test: /\.jpg$/, use: [ &quot;file-loader&quot; ] &#125;,</span><br><span class="line">//       &#123; test: /\.png$/, use: [ &quot;url-loader?mimetype=image/png&quot; ] &#125;</span><br><span class="line">//     ]</span><br><span class="line">//   &#125;,</span><br><span class="line">//   output: &#123;</span><br><span class="line">//     publicPath: &quot;http://cdn.example.com/[hash]/&quot;</span><br><span class="line">//   &#125;</span><br><span class="line">// &#125;</span><br><span class="line">// &lt;!-- file.html --&gt;</span><br><span class="line">// &lt;img src=&quot;image.png&quot; data-src=&quot;image2x.png&quot; &gt;</span><br><span class="line">// require(&quot;html-loader!./file.html&quot;);</span><br><span class="line"></span><br><span class="line">// // =&gt; &apos;&lt;img src=&quot;http://cdn.example.com/49eba9f/a992ca.png&quot;</span><br><span class="line">// //         data-src=&quot;image2x.png&quot;&gt;&apos;</span><br><span class="line">// require(&quot;html-loader?attrs=img:data-src!./file.html&quot;);</span><br><span class="line"></span><br><span class="line">// // =&gt; &apos;&lt;img src=&quot;image.png&quot; data-src=&quot;data:image/png;base64,...&quot; &gt;&apos;</span><br><span class="line">// require(&quot;html-loader?attrs=img:src img:data-src!./file.html&quot;);</span><br><span class="line">// require(&quot;html-loader?attrs[]=img:src&amp;attrs[]=img:data-src!./file.html&quot;);</span><br><span class="line"></span><br><span class="line">// // =&gt; &apos;&lt;img  src=&quot;http://cdn.example.com/49eba9f/a992ca.png&quot;</span><br><span class="line">// //           data-src=&quot;data:image/png;base64,...&quot; &gt;&apos;</span><br><span class="line">// require(&quot;html-loader?-attrs!./file.html&quot;);</span><br><span class="line"></span><br><span class="line">// // =&gt; &apos;&lt;img  src=&quot;image.jpg&quot;  data-src=&quot;image2x.png&quot; &gt;&apos;</span><br><span class="line"></span><br><span class="line">//通过运行 webpack --optimize-minimize 来最小化</span><br><span class="line">//或者</span><br><span class="line">// module: &#123;</span><br><span class="line">//   rules: [&#123;</span><br><span class="line">//     test: /\.html$/,</span><br><span class="line">//     use: [ &#123;</span><br><span class="line">//       loader: &apos;html-loader&apos;,</span><br><span class="line">//       options: &#123;</span><br><span class="line">//         minimize: true</span><br><span class="line">//       &#125;</span><br><span class="line">//     &#125;],</span><br><span class="line">//   &#125;]</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">//extract-loader 提取HTML和CSS</span><br><span class="line">// 一个很常见的场景，将 HTML 导出到 .html 文件中，直接访问它们，而不是使用 javascript 注入。这可以通过3个 loader 的组合来实现：file-loader extract-loader html-loader</span><br><span class="line">// html-loader 将解析 URL，并请求图片和你所期望的一切资源。extract-loader 会将 javascript 解析为合适的 html 文件，确保引用的图片指向正确的路径，file-loader 将结果写入 .html 文件。示例：</span><br><span class="line">// &#123;</span><br><span class="line">//   test: /\.html$/,</span><br><span class="line">//   use: [&apos;file-loader?name=[name].[ext]&apos;, &apos;extract-loader&apos;, &apos;html-loader&apos;],</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">// mini-css-extract-plugin</span><br><span class="line">//（css文件超过150kb时可以考虑单独提取） 样式会单独存放在文件当中，不再需要style标签引入（style-loader）,通过link标签方式注入样式文件</span><br><span class="line">// module:&#123;</span><br><span class="line">//   rules:[</span><br><span class="line">//   &#123;</span><br><span class="line">//   test:/\.css$/,</span><br><span class="line">//   use:[</span><br><span class="line">//   MiniCssExtractPlugin.loader,  //通过link标签引入样式文件</span><br><span class="line">//   &apos;css-loader&apos;</span><br><span class="line">//   ]</span><br><span class="line">//   &#125;</span><br><span class="line">// ]</span><br><span class="line">// &#125;</span><br><span class="line">//--------------------------------------------</span><br><span class="line">//loader</span><br><span class="line">// 专注实现资源模块加载，实现项目打包</span><br><span class="line">// 加载过程类似于管道，可以依次使用多个loader，最终结果必须是js代码。</span><br><span class="line">// module:&#123;</span><br><span class="line">//   rules:[</span><br><span class="line">//      &#123;</span><br><span class="line">//      test:/.md$/,</span><br><span class="line">//      use:&apos;./markdown-loader&apos;  //可以是模块路径或模块名称</span><br><span class="line">//      &#125;</span><br><span class="line">//   ]</span><br><span class="line">//   &#125;</span><br><span class="line"></span><br><span class="line">//   //自定义loader  处理md文件</span><br><span class="line">//   const marked=reuqire(&apos;marked&apos;)</span><br><span class="line">//   module.exports=source=&gt;&#123;</span><br><span class="line">//    const html = marked(source)</span><br><span class="line">//    return  `export default $&#123;JSON.stringify(html)&#125;`   //最终输出结果必须是js代码 。   可以返回html，交给html-loader继续处理</span><br><span class="line">//   &#125;</span><br><span class="line"></span><br><span class="line">// 编译转换类：将资源模块转换为js代码。 //css-loader:将css代码转换成js模块</span><br><span class="line">// 文件操作类：将资源模块拷贝到输出目录，向外导出文件的访问路径 //file-loader</span><br><span class="line">// 代码检查类：对资源模块进行校验 //eslint-loader</span><br><span class="line"></span><br><span class="line">//----------------------------------------</span><br><span class="line">//plugin</span><br><span class="line">// 增强webpack自动化能力，实现大多前端工程化 //清除dist目录插件、拷贝不需要参与打包的静态资源文件到输出目录、压缩输出代码等</span><br><span class="line">// 拥有更宽的能力范围，通过钩子机制实现</span><br><span class="line">// 必须是一个函数或者包含apply方法的对象,通过在生命周期的钩子中挂载函数实现扩展</span><br><span class="line">//插件能够 钩入(hook) 到在每个编译(compilation)中触发的所有关键事件。在编译的每一步，插件都具备完全访问 compiler 对象的能力，如果情况合适，还可以访问当前 compilation 对象。</span><br><span class="line"></span><br><span class="line">//自定义插件</span><br><span class="line">// class MyPlugin&#123;</span><br><span class="line"></span><br><span class="line">//   //webpack启动时自动调用</span><br><span class="line">//   apply(compiler)&#123;</span><br><span class="line">//    compiler.hooks.emit.tap(&apos;MyPlugin&apos;,compilation=&gt;&#123;</span><br><span class="line">//      //compilation  //打包上下文</span><br><span class="line">//    //compilation.assets   //打包的资源文件 (对象)</span><br><span class="line">//    //compilation.assets[&apos;文件名&apos;].source()  //资源文件内容</span><br><span class="line"></span><br><span class="line">//    compilation.assets[&apos;文件名&apos;]=&#123;</span><br><span class="line">//     source:()=&gt; 返回更改的文件内容，</span><br><span class="line">//     size:()=&gt;返回文件的大小</span><br><span class="line">//    &#125;</span><br><span class="line">//    &#125;)</span><br><span class="line"></span><br><span class="line">//   &#125;</span><br><span class="line">//  &#125;</span><br><span class="line">// const &#123;CleanWebpackPlugin&#125;  from &apos;clean-webpack-plugin&apos; //自动清除输出目录</span><br><span class="line">// const HtmlWebpackPlugin  from &apos;html-webpack-plugin&apos; //自动生成html</span><br><span class="line">// const CopyWebpackPlugin  from &apos;copy-webpack-plugin&apos; //拷贝不需要打包静态资源到输出目录</span><br><span class="line">// optimize-css-assets-webpack-plugin  //压缩css文件</span><br><span class="line">// optimization:&#123;</span><br><span class="line">//   //webpack默认压缩js代码</span><br><span class="line">//   //production模式自动开启</span><br><span class="line">//   //自动压缩插件</span><br><span class="line">//   minimizer:[</span><br><span class="line">//     new OptimizeCssAssetsWebpackPlugin()</span><br><span class="line">//     new TerserWebpackPlugin()   //压缩js代码</span><br><span class="line">//    ]</span><br><span class="line">//  &#125;</span><br><span class="line">//--------------------------------------</span><br><span class="line">// mode</span><br><span class="line">// production //优化打包结果 代码压缩等</span><br><span class="line">// development //优化打包速度，增加辅助函数便于调试</span><br><span class="line">// none //不做处理</span><br><span class="line">//--------------------------------------</span><br><span class="line">//–-watch 监听文件改变 自动编译</span><br><span class="line">//--------------------------------------</span><br><span class="line">//实现浏览器自动刷新</span><br><span class="line">//browser-sync 文件目录  --files  &apos;**/*&apos; //启动并监听文件改变</span><br><span class="line">//---------------------------------------------</span><br><span class="line">//webpack-dev-server //集成自动编译、自动刷新功能</span><br><span class="line"></span><br><span class="line">//------------------------------------------</span><br><span class="line">//devtool</span><br><span class="line">// source-map</span><br><span class="line">// eval //通过sourceURL描述对应模块文件的资源路径 不生成对应的sourceMap,只能定位到错误出现的具体文件 构建速度快</span><br><span class="line">// cheap-eveal-source-map 阉割版 生成的sourceMap只能定位到错误具体行，没有列的信息</span><br><span class="line">// cheap-module-eveal-source-map 解析出来的源代码没有经过对应的loader加工，与手写时候的代码一样 一般开发环境使用多</span><br><span class="line">// inline-source-map 通过DataURL方式将sourceMap嵌入到代码当中，eval-source-map也是</span><br><span class="line">// hidden-source-map 代码当中没有通过注释方式引入sourceMap</span><br><span class="line">// nosources-source-map 能看到错误出现行列信息，但看不到源代码 生产环境不会暴露源代码</span><br><span class="line">// none 推荐生产环境使用</span><br><span class="line">//---------------------------------------------------</span><br><span class="line">//HMR 热更新</span><br><span class="line">// 应用运行过程中实时替换某个模块，应用运行状态不受影响</span><br><span class="line">// 不刷新页面情况下，及时更新模块</span><br><span class="line">// 提高开发效率</span><br><span class="line">// 集成在webpack-dev-server 中</span><br><span class="line">// 使用方式：webpack-dev-server --hot</span><br><span class="line">//或</span><br><span class="line">// style-loader自动处理样式文件的热更新  js模块热更新需要手动处理</span><br><span class="line">// const webpack=require(&apos;webpack&apos;)</span><br><span class="line">// devServer:&#123;</span><br><span class="line">//   hot:true  //热替换失败，自动刷新浏览器      hotOnly取消浏览器自动刷新</span><br><span class="line">// &#125;,</span><br><span class="line">// plugins:[</span><br><span class="line">//   //module.hot</span><br><span class="line">//   new webpack.HotModuleReplacementPlugin()</span><br><span class="line">// ]</span><br><span class="line">//------------------------------------------------------</span><br><span class="line">// webpack --env production //生产模式打包</span><br><span class="line">// webpack --config webpack.prod.js</span><br><span class="line">// const merge=require(&apos;webpack-merge&apos;)//合并webpack配置文件</span><br><span class="line">//-------------------------------------------------------</span><br><span class="line">//tree-shaking (基于ES Modules)</span><br><span class="line">// 移除未引用代码</span><br><span class="line">// 生产模式下自动开启</span><br><span class="line">// 由Webpack打包的代码必须使用ESM</span><br><span class="line">//-----------------------------------------------------------</span><br><span class="line">//optimization</span><br><span class="line">//优化选项</span><br><span class="line">// optimization:&#123;</span><br><span class="line">//   usedExports:true,   //只导出外部使用过的成员</span><br><span class="line">//   minimize:true, //代码压缩</span><br><span class="line">//   concatenateModules:true,  // `ScopeHoisting`作用域提升）   尽可能将所有模块合并在一起，提高运行效率，减少代码体积</span><br><span class="line">//   sideEffects:true  //production模式下会自动开启  为tree-shaking提供更大的压缩空间   （使用前应确保代码真的没有副作用。 副作用：模块执行时除了导出成员外所做的其它的事情	）          //   webpack会先检查当前项目的package.json当中是否有sideEffects字段 ,  sideEffects:false表示没有副作用，也可是数组 sideEffects:[&apos;*.css&apos;]  表示有副作用的模块</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure>
<h2 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h2><h3 id="vue初始化"><a href="#vue初始化" class="headerlink" title="vue初始化"></a>vue初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Vue.prototype.$mount</span><br><span class="line"> * 对vue组件进行挂载，基于render函数，没有render函数时，会获取template，将template解析生成render函数</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * mountComponent</span><br><span class="line"> * 挂载vue组件，在运行时版本、开发环境下如果没有render函数有template，vue会输出警告（运行时版本没有模板编译）</span><br><span class="line"> * 该方法会先触发beforeMount生命周期钩子函数</span><br><span class="line"> * new Watcher(),实例化一个渲染Watcher，传入一个updateComponent方法（该方法会调用_render方法（_render方法会调用render方法生成虚拟Dom）,通过_update方法将虚拟Dom转换成真实Dom）</span><br><span class="line"> * 接着触发mounted生命周期钩子</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * vue初始化过程</span><br><span class="line"> * 声明Vue构造函数，定义状态相关的属性和方法（$date/$props/$set/$delete/$watch）,定义事件有关的方法（$on/$emit/$off/$once），生命周期有关的方法(_update/$forceUpdate/$destroy),渲染有关的方法（$nextTick/_render）</span><br><span class="line"> * initGlobalAPI()初始化一些全局属性和方法（Vue.set/Vue.delete/Vue.nextTick/Vue.observable/Vue.options/Vue.use/Vue.mixin/Vue.extend/Vue.directive/Vue.component/Vue.filter）</span><br><span class="line"> * new Vue()时会调用_init()方法，对vue实例初始化</span><br><span class="line"> * initLifecycle() 初始化生命周期相关变量（$children/$parent/$root/$refs）/initEvents()/initRender()</span><br><span class="line"> * 接着触发beforeCreate生命周期钩子函数</span><br><span class="line"> * initInjections()在data/props之前处理injections/initState()(_props/methods/_data/computed/watch)/initProvide()在data/props之前处理provide</span><br><span class="line"> * 接着会触发created生命周期钩子函数</span><br><span class="line"> * 最后挂载并渲染页面</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<h3 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * vue响应式原理</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> * -----------</span><br><span class="line"> * vue2</span><br><span class="line"> * -----------</span><br><span class="line"> * Observer</span><br><span class="line"> * new Observer(value)，对data方法返回的对象进行响应式处理</span><br><span class="line"> * Observer类通过value记录被观察的对象，通过dep记录被观察对象的依赖</span><br><span class="line"> * value是数组时：</span><br><span class="line"> *  observeArray (items: Array&lt;any&gt;) &#123;</span><br><span class="line"> *   for (let i = 0, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line"> *    observe(items[i])</span><br><span class="line"> *   &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> * value是对象时：</span><br><span class="line"> * walk (obj: Object) &#123;</span><br><span class="line"> *    const keys = Object.keys(obj)</span><br><span class="line"> *    for (let i = 0; i &lt; keys.length; i++) &#123;</span><br><span class="line"> *      defineReactive(obj, keys[i])</span><br><span class="line"> *    &#125;</span><br><span class="line"> *  &#125;</span><br><span class="line"> *</span><br><span class="line"> * ----------</span><br><span class="line"> *</span><br><span class="line"> * defineReactive</span><br><span class="line"> * function defineReactive ( obj: Object,key: string,val: any,customSetter?: ?Function,shallow?: boolean //浅   false时为深度监听)&#123;</span><br><span class="line"> *  //收集依赖 watcher</span><br><span class="line"> *  const dep = new Dep()</span><br><span class="line"> *  let childOb = !shallow &amp;&amp; observe(val)</span><br><span class="line"> *  Object.defineProperty(obj, key, &#123;</span><br><span class="line"> *  get()&#123;&#125;,</span><br><span class="line"> *  set()&#123;&#125;</span><br><span class="line"> * &#125;)</span><br><span class="line"> * &#125;</span><br><span class="line"> * defineReactive通过shallow记录是否深度监听 false时为深度监听</span><br><span class="line"> * 通过Object.defineProperty()进行响应式处理</span><br><span class="line"> * 通过get()&#123;&#125;进行依赖收集</span><br><span class="line"> * get: function reactiveGetter () &#123;</span><br><span class="line"> * 	 //用户传入getter时先调用</span><br><span class="line"> *      const value = getter ? getter.call(obj) : val</span><br><span class="line"> * 	  //如果存在依赖对象watcher，则收集依赖</span><br><span class="line"> *       if (Dep.target) &#123;</span><br><span class="line"> * 	    //收集依赖</span><br><span class="line"> *         dep.depend()</span><br><span class="line"> *         if (childOb) &#123;</span><br><span class="line"> * 		  //子对象收集依赖</span><br><span class="line"> *           childOb.dep.depend()</span><br><span class="line"> * 		  //数组</span><br><span class="line"> *           if (Array.isArray(value)) &#123;</span><br><span class="line"> *             dependArray(value)</span><br><span class="line"> *           &#125;</span><br><span class="line"> *         &#125;</span><br><span class="line"> *      &#125;</span><br><span class="line"> *       return value</span><br><span class="line"> *  &#125;,</span><br><span class="line"> * set: function reactiveSetter (newVal) &#123;</span><br><span class="line"> *      const value = getter ? getter.call(obj) : val</span><br><span class="line"> *</span><br><span class="line"> * 	    //新值旧值相等</span><br><span class="line"> *      //  eslint-disable no-self-compare      NaN</span><br><span class="line"> *      if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line"> *        return</span><br><span class="line"> *      &#125;</span><br><span class="line"> *      // #7981: for accessor properties without setter</span><br><span class="line"> *      if (getter &amp;&amp; !setter) return</span><br><span class="line"> * 	    //存在setter时进行调用</span><br><span class="line"> *      if (setter) &#123;</span><br><span class="line"> *        setter.call(obj, newVal)</span><br><span class="line"> *      &#125; else &#123;</span><br><span class="line"> *        val = newVal</span><br><span class="line"> *      &#125;</span><br><span class="line"> *     childOb = !shallow &amp;&amp; observe(newVal)</span><br><span class="line"> *     dep.notify()</span><br><span class="line"> *  &#125;</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> * 数组处理</span><br><span class="line"> * const arrayProto = Array.prototype</span><br><span class="line"> * export const arrayMethods = Object.create(arrayProto)</span><br><span class="line"> * const methodsToPatch = [&apos;push&apos;,&apos;pop&apos;,&apos;shift&apos;,&apos;unshift&apos;,&apos;splice&apos;,&apos;sort&apos;,&apos;reverse&apos;]</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> * methodsToPatch.forEach(function (method) &#123;</span><br><span class="line"> *  // cache original method</span><br><span class="line"> *  const original = arrayProto[method]</span><br><span class="line"> *  def(arrayMethods, method, function mutator (...args) &#123;</span><br><span class="line"> *</span><br><span class="line"> *    //调用原型上的方法</span><br><span class="line"> *    const result = original.apply(this, args)</span><br><span class="line"> *    const ob = this.__ob__</span><br><span class="line"> *    let inserted</span><br><span class="line"> *    switch (method) &#123;</span><br><span class="line"> *      case &apos;push&apos;:</span><br><span class="line"> *      case &apos;unshift&apos;:</span><br><span class="line"> *        inserted = args</span><br><span class="line"> *        break</span><br><span class="line"> *      case &apos;splice&apos;:</span><br><span class="line"> *        inserted = args.slice(2)</span><br><span class="line"> *        break</span><br><span class="line"> *    &#125;</span><br><span class="line"> *</span><br><span class="line"> * 	//对新增的元素进行响应式处理</span><br><span class="line"> *     if (inserted) ob.observeArray(inserted)</span><br><span class="line"> *     // notify change</span><br><span class="line"> *</span><br><span class="line"> * 	//通知依赖更新视图</span><br><span class="line"> *     ob.dep.notify()</span><br><span class="line"> *     return result</span><br><span class="line"> *   &#125;)</span><br><span class="line"> *  &#125;)</span><br><span class="line"> * observeArray (items: Array&lt;any&gt;) &#123;</span><br><span class="line"> *    for (let i = 0, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line"> *      observe(items[i])</span><br><span class="line"> *    &#125;</span><br><span class="line"> *  &#125;</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> * -------------</span><br><span class="line"> * Dep</span><br><span class="line"> * class Dep&#123;</span><br><span class="line"> *  static target: ?Watcher;</span><br><span class="line"> *  id: number;</span><br><span class="line"> *  subs: Array&lt;Watcher&gt;;</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> *  addSub (sub: Watcher) &#123;</span><br><span class="line"> *    this.subs.push(sub)</span><br><span class="line"> *  &#125;</span><br><span class="line"> *  depend () &#123;</span><br><span class="line"> *    if (Dep.target) &#123;</span><br><span class="line"> *      Dep.target.addDep(this)</span><br><span class="line"> *    &#125;</span><br><span class="line"> *  &#125;</span><br><span class="line"> *  notify () &#123;</span><br><span class="line"> *    // stabilize the subscriber list first</span><br><span class="line"> *    const subs = this.subs.slice()</span><br><span class="line"> *   if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; !config.async) &#123;</span><br><span class="line"> *      // subs aren&apos;t sorted in scheduler if not running async</span><br><span class="line"> *      // we need to sort them now to make sure they fire in correct</span><br><span class="line"> *      // order</span><br><span class="line"> *      subs.sort((a, b) =&gt; a.id - b.id)</span><br><span class="line"> *    &#125;</span><br><span class="line"> *    for (let i = 0, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line"> *      subs[i].update()</span><br><span class="line"> *    &#125;</span><br><span class="line"> *  &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> * //Dep.target用来存放目前正在使用的watcher 全局唯一，并且一次也只能有一个watcher被使用</span><br><span class="line"> * // The current target watcher being evaluated.</span><br><span class="line"> * // This is globally unique because only one watcher</span><br><span class="line"> * // can be evaluated at a time.</span><br><span class="line"> * Dep.target = null</span><br><span class="line"> *</span><br><span class="line"> * --------------</span><br><span class="line"> * Watcher</span><br><span class="line"> * Watcher分为用户watcher/computed watcher/渲染watcher</span><br><span class="line"> * 渲染watcher:每个组件对应一个mountComponent方法，每个mountComponent对应一个Watcher对象</span><br><span class="line"> * 用户watcher/computed watcher在initState时进行初始化</span><br><span class="line"> * new Watcher时会调用Watcher的get方法，Watcher的get方法会调用Dep的pushTarget方法，Dep的pushTarget方法会设置全局Watcher给Dep.target</span><br><span class="line"> * 数据更新时调用Dep的notify方法，遍历Dep的subs，调用每个watcher的update方法，computed watcher和用户watcher调用watcher的run方法，渲染watcher调用queueWatcher方法将watcher加入队列，在queueWatcher方法中调用flushSchedulerQueue方法，在flushSchedulerQueue方法中对watcher按照id从小到大排序，接着遍历watcher，调用run方法</span><br><span class="line"> * watcher的run方法调用watcher的get方法，watcher的get方法会调用watcher的getter方法，渲染watcher的getter方法存储的是updateComponent方法,updateComponent方法调用_update()更新视图。</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> * -------------</span><br><span class="line"> * 响应式总结</span><br><span class="line"> * 在_init方法中调用initState方法，在initState方法中调用initData方法，在initData方法中调用observe(value)方法</span><br><span class="line"> * observe(value)方法会判断value是否是对象，如果是对象会接着判断是否有ob属性，有则直接返回，没有则直接创建Observe对象，返回Observe对象。</span><br><span class="line"> * Observe构造函数中会给value添加一个不可枚举ob字段，记录当前的observe对象。接着对数组、对象做响应式处理，当数据发生改变时，会找到对应的Observe对象，在Observe对象中调用dep的notify方法，通知watcher更新视图。</span><br><span class="line"> * 数组的响应式处理会对push/pop/shift/unshift/sort/reverse/splice方法进行处理，接着对数组的成员进行响应式处理。</span><br><span class="line"> * 对象的响应式处理则直接调用walk方法，遍历对象的每个属性，调用defineReactive方法</span><br><span class="line"> * defineReactive方法会为每个属性创建Dep对象收集依赖，如果属性是对象，则调用observe方法进行响应式处理。在getter中为属性收集依赖，属性的值为对象时，也会为属性的值收集依赖。在setter中，调用dep的notify方法发送通知，如果新值是对象时，调用observe进行响应式处理。</span><br><span class="line"> * 在watcher对象的get方法中调用pushTarget方法记录Dep.target属性，在访问data中成员时，出触发defineReactive的getter收集依赖，吧属性对应的watcher添加到dep的subs数组中，如果属性值也是对象，也会为属性值收集依赖。</span><br><span class="line"> * 渲染watcher，当数据发生改变时会调用dep的notify方法，通知watcher调用update方法，update方法中会调用queueWatcher方法,queueWatcher方法会判断watcher是否被处，没有被处理的话会被添加到queue队列中，并调用flushSchedulerQueue方法，flushSchedulerQueue方法中会触发beforeUpdate钩子函数/调用watcher的run方法（run()=&gt;get()=&gt;getter()=&gt;updateComponent()）/清空上一次依赖/触发activated钩子函数/触发updated钩子函数。</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> * ----------</span><br><span class="line"> * vue3</span><br><span class="line"> * ----------</span><br><span class="line"> * 通过proxy对象实现属性监听，初始化时不需要遍历所有属性</span><br><span class="line"> * 多层属性嵌套，在访问属性的过程中处理下一级属性</span><br><span class="line"> * 默认监听动态添加的属性</span><br><span class="line"> * 默认监听属性的删除操作</span><br><span class="line"> * 默认监听数组索引和length属性</span><br><span class="line"> * 可以作为单独模块使用</span><br><span class="line"> *</span><br><span class="line"> * ------------</span><br><span class="line"> * reactive</span><br><span class="line"> *</span><br><span class="line"> * const isObject =val=&gt;val!==null&amp;&amp;typeof val === &apos;object&apos;</span><br><span class="line"> * const convert=target=&gt;isObject(target)?reactive(target):target</span><br><span class="line"> * const hasOwnProperty=Object.prototype.hasOwnProperty</span><br><span class="line"> * const hasOwn=(target,key)=&gt; hasOwnProperty.call(target,key)</span><br><span class="line"> *</span><br><span class="line"> * function reactive(target)&#123;</span><br><span class="line"> *  if(!isObject(target)) return target</span><br><span class="line"> *</span><br><span class="line"> *  const handler=&#123;</span><br><span class="line"> *   get(target,key,receiver)&#123;</span><br><span class="line"> *     //收集依赖</span><br><span class="line"> *     track(target,key)</span><br><span class="line"> *     const result=Reflect.get(target,key,receiver)</span><br><span class="line"> *     return convert(result)</span><br><span class="line"> *   &#125;,</span><br><span class="line"> *   set(target,key,value,receiver)&#123;</span><br><span class="line"> *    const oldValue=Reflect.get(target,key,receiver)</span><br><span class="line"> *    let result=true</span><br><span class="line"> *    if(oldValue!==value)&#123;</span><br><span class="line"> *      result=Reflect.set(target,key,value,receiver)</span><br><span class="line"> *      //触发更新</span><br><span class="line"> *      trigger(target,key)</span><br><span class="line"> *    &#125;</span><br><span class="line"> *     return result</span><br><span class="line"> *   &#125;,</span><br><span class="line"> *   deleteProperty(target,key)&#123;</span><br><span class="line"> *    const hasKey=hasOwn(target,key)</span><br><span class="line"> *    const result=Reflect.deleteProperty(target,key)</span><br><span class="line"> *    if(hasKey&amp;&amp;result)&#123;</span><br><span class="line"> *      //触发更新</span><br><span class="line"> *      trigger(target,key)</span><br><span class="line"> *    &#125;</span><br><span class="line"> *    return result</span><br><span class="line"> *   &#125;</span><br><span class="line"> *</span><br><span class="line"> *   &#125;</span><br><span class="line"> *</span><br><span class="line"> * &#125;</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> * -----------------</span><br><span class="line"> * ref</span><br><span class="line"> * function ref(raw)&#123;</span><br><span class="line"> * //如果raw是ref创建的对象则直接返回</span><br><span class="line"> * if(isObject(raw)&amp;&amp;raw.__v_isRef) return</span><br><span class="line"> * //如果raw是对象则通过reactive处理</span><br><span class="line"> * let value=convert(raw)</span><br><span class="line"> * const r=&#123;</span><br><span class="line"> *   __v_isRef:true,</span><br><span class="line"> *   get value()&#123;</span><br><span class="line"> *     track(r,&apos;value)</span><br><span class="line"> *     return value</span><br><span class="line"> *  &#125;,</span><br><span class="line"> *   set value(newValue)&#123;</span><br><span class="line"> *    if(newValue!==value)&#123;</span><br><span class="line"> *     raw=newValue</span><br><span class="line"> *     value=convert(raw)</span><br><span class="line"> *     trigger(r,&apos;value&apos;)</span><br><span class="line"> *    &#125;</span><br><span class="line"> *  &#125;</span><br><span class="line"> *</span><br><span class="line"> * &#125;</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> *  return r</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> * &#125;</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> * -----------------</span><br><span class="line"> * toRefs</span><br><span class="line"> * function toRefs(proxy)&#123;</span><br><span class="line"> *   const ret=proxy instanceof Array?new Array(proxy.length):&#123;&#125;</span><br><span class="line"> *   for(const key in proxy)&#123;</span><br><span class="line"> *     ret[key]=toProxyRef(proxy,key)</span><br><span class="line"> *   &#125;</span><br><span class="line"> *   return ret</span><br><span class="line"> * &#125;</span><br><span class="line"> *</span><br><span class="line"> * function toProxyRef(proxy,key)&#123;</span><br><span class="line"> *  const r=&#123;</span><br><span class="line"> *     __v_isRef:true,</span><br><span class="line"> *     get value()&#123;</span><br><span class="line"> *      return proxy[key]</span><br><span class="line"> *     &#125;</span><br><span class="line"> *     set value(newvalue)&#123;</span><br><span class="line"> *      proxy[key]=newValue</span><br><span class="line"> *     &#125;</span><br><span class="line"> *</span><br><span class="line"> *  &#125;</span><br><span class="line"> *  return r</span><br><span class="line"> * &#125;</span><br><span class="line"> *</span><br><span class="line"> * ------------</span><br><span class="line"> * computed</span><br><span class="line"> * function computed(getter)&#123;</span><br><span class="line"> *   const result=ref()</span><br><span class="line"> *   effect(()=&gt;&#123;result.value=getter()&#125;)</span><br><span class="line"> *   return result</span><br><span class="line"> * &#125;</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> * -------------</span><br><span class="line"> * 收集依赖</span><br><span class="line"> * targetMap newWeakMap() key:目标对象 value:depsMap</span><br><span class="line"> * depsMap new Map() key:目标对象的属性名称 value:dep</span><br><span class="line"> * dep new Set()  value:effect函数</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> * --------------</span><br><span class="line"> * effect/track</span><br><span class="line"> * let activeEffect=null</span><br><span class="line"> * function effect(callback)&#123;</span><br><span class="line"> *   activeEffect=callback</span><br><span class="line"> *   callback()</span><br><span class="line"> *   activeEffect-null</span><br><span class="line"> * &#125;</span><br><span class="line"> * let targetMap=new WeakMap()</span><br><span class="line"> * function track(target,key)&#123;</span><br><span class="line"> *  if(!activeEffect) return</span><br><span class="line"> *  //目标对象字典</span><br><span class="line"> *  let depsMap=targetMap.get(target)</span><br><span class="line"> *  if(!depsMap)&#123;</span><br><span class="line"> *    targetMap.set(target,(depsMap=new Map()))</span><br><span class="line"> *  &#125;</span><br><span class="line"> *  let dep=depsMap.get(key)</span><br><span class="line"> *  if(!dep)&#123;</span><br><span class="line"> *    depsMap.set(key,(dep=new Set()))</span><br><span class="line"> *  &#125;</span><br><span class="line"> *  dep.add(activeEffect)</span><br><span class="line"> *</span><br><span class="line"> * &#125;</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> * -------------</span><br><span class="line"> * trigger</span><br><span class="line"> * function trigger(target,key)&#123;</span><br><span class="line"> *  const depsMap=targetMap.get(target)</span><br><span class="line"> *  if(!depsMap) return</span><br><span class="line"> *  const dep=depsMap.get(key)</span><br><span class="line"> *  //触发effect的函数</span><br><span class="line"> *  if(dep)&#123;</span><br><span class="line"> *    dep.forEach(effect=&gt; effect())</span><br><span class="line"> *  &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> *</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<h3 id="虚拟Dom"><a href="#虚拟Dom" class="headerlink" title="虚拟Dom"></a>虚拟Dom</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * patch</span><br><span class="line"> */</span><br><span class="line">//相同节点判断</span><br><span class="line">// function sameVnode (a, b) &#123;</span><br><span class="line">//   return (</span><br><span class="line">//     a.key === b.key &amp;&amp;</span><br><span class="line">//     a.asyncFactory === b.asyncFactory &amp;&amp; (</span><br><span class="line">//       (</span><br><span class="line">//         a.tag === b.tag &amp;&amp;</span><br><span class="line">//         a.isComment === b.isComment &amp;&amp;</span><br><span class="line">//         isDef(a.data) === isDef(b.data) &amp;&amp;</span><br><span class="line">//         sameInputType(a, b)</span><br><span class="line">//       ) || (</span><br><span class="line">//         isTrue(a.isAsyncPlaceholder) &amp;&amp;</span><br><span class="line">//         isUndef(b.asyncFactory.error)</span><br><span class="line">//       )</span><br><span class="line">//     )</span><br><span class="line">//   )</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">//节点比对</span><br><span class="line">// function patchVnode(</span><br><span class="line">//   oldVnode,</span><br><span class="line">//   vnode,</span><br><span class="line">//   insertedVnodeQueue,</span><br><span class="line">//   ownerArray,</span><br><span class="line">//   index,</span><br><span class="line">//   removeOnly</span><br><span class="line">// ) &#123;</span><br><span class="line">//   if (oldVnode === vnode) &#123;</span><br><span class="line">//     return;</span><br><span class="line">//   &#125;</span><br><span class="line">//   //获取子节点</span><br><span class="line">//   const oldCh = oldVnode.children;</span><br><span class="line">//   const ch = vnode.children;</span><br><span class="line">//   //新节点没有文本</span><br><span class="line">//   if (isUndef(vnode.text)) &#123;</span><br><span class="line">//     //新旧节点都有子节点时</span><br><span class="line">//     if (isDef(oldCh) &amp;&amp; isDef(ch)) &#123;</span><br><span class="line">//       if (oldCh !== ch)</span><br><span class="line">//         updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);</span><br><span class="line">//     &#125;</span><br><span class="line">//     //新节点有子节点，老节点没有子节点</span><br><span class="line">//     else if (isDef(ch)) &#123;</span><br><span class="line">//       if (process.env.NODE_ENV !== &quot;production&quot;) &#123;</span><br><span class="line">//         //检查是否有重复key</span><br><span class="line">//         checkDuplicateKeys(ch);</span><br><span class="line">//       &#125;</span><br><span class="line">//       //清空老节点文本内容</span><br><span class="line">//       if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, &quot;&quot;);</span><br><span class="line">//       //将新节点的子节点转换成dom元素并添加到dom树</span><br><span class="line">//       addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);</span><br><span class="line">//     &#125;</span><br><span class="line">//     //老节点有子节点，新点没子节点</span><br><span class="line">//     else if (isDef(oldCh)) &#123;</span><br><span class="line">//       //删除老节点中的子节点</span><br><span class="line">//       removeVnodes(oldCh, 0, oldCh.length - 1);</span><br><span class="line">//     &#125;</span><br><span class="line">//     //老节点有文本，新节点没有文本</span><br><span class="line">//     else if (isDef(oldVnode.text)) &#123;</span><br><span class="line">//       //清空老节点文本内容</span><br><span class="line">//       nodeOps.setTextContent(elm, &quot;&quot;);</span><br><span class="line">//     &#125;</span><br><span class="line">//   &#125;</span><br><span class="line">//   //新老节点都有文本节点</span><br><span class="line">//   else if (oldVnode.text !== vnode.text) &#123;</span><br><span class="line">//     //修改文本</span><br><span class="line">//     nodeOps.setTextContent(elm, vnode.text);</span><br><span class="line">//   &#125;</span><br><span class="line">// &#125;</span><br><span class="line">//更新子节点</span><br><span class="line">// function updateChildren(</span><br><span class="line">//   parentElm,</span><br><span class="line">//   oldCh,</span><br><span class="line">//   newCh,</span><br><span class="line">//   insertedVnodeQueue,</span><br><span class="line">//   removeOnly</span><br><span class="line">// ) &#123;</span><br><span class="line">//   //新老节点子节点开始节点索引</span><br><span class="line">//   let oldStartIdx = 0;</span><br><span class="line">//   let newStartIdx = 0;</span><br><span class="line">//   //老节点子节点结束节点索引</span><br><span class="line">//   let oldEndIdx = oldCh.length - 1;</span><br><span class="line">//   //老节点开始子节点</span><br><span class="line">//   let oldStartVnode = oldCh[0];</span><br><span class="line">//   let oldEndVnode = oldCh[oldEndIdx];</span><br><span class="line">//   let newEndIdx = newCh.length - 1;</span><br><span class="line">//   let newStartVnode = newCh[0];</span><br><span class="line">//   let newEndVnode = newCh[newEndIdx];</span><br><span class="line">//   let oldKeyToIdx, idxInOld, vnodeToMove, refElm;</span><br><span class="line"></span><br><span class="line">//   // removeOnly is a special flag used only by &lt;transition-group&gt;</span><br><span class="line">//   // to ensure removed elements stay in correct relative positions</span><br><span class="line">//   // during leaving transitions</span><br><span class="line">//   const canMove = !removeOnly;</span><br><span class="line"></span><br><span class="line">//   if (process.env.NODE_ENV !== &quot;production&quot;) &#123;</span><br><span class="line">//     checkDuplicateKeys(newCh);</span><br><span class="line"></span><br><span class="line">//     //当新节点和老节点都没有遍历完成时</span><br><span class="line">//     while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">//       if (isUndef(oldStartVnode)) &#123;</span><br><span class="line">//         oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left</span><br><span class="line">//       &#125; else if (isUndef(oldEndVnode)) &#123;</span><br><span class="line">//         oldEndVnode = oldCh[--oldEndIdx];</span><br><span class="line">//       &#125;</span><br><span class="line"></span><br><span class="line">//       //老节点子节点的开始节点和新节点子节点的开始节点是相同节点时</span><br><span class="line">//       else if (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">//         patchVnode(</span><br><span class="line">//           oldStartVnode,</span><br><span class="line">//           newStartVnode,</span><br><span class="line">//           insertedVnodeQueue,</span><br><span class="line">//           newCh,</span><br><span class="line">//           newStartIdx</span><br><span class="line">//         );</span><br><span class="line">//         oldStartVnode = oldCh[++oldStartIdx];</span><br><span class="line">//         newStartVnode = newCh[++newStartIdx];</span><br><span class="line">//       &#125;</span><br><span class="line">//       //老节点子节点的结束节点和新节点子节点的结束节点是相同节点时</span><br><span class="line">//       else if (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">//         patchVnode(</span><br><span class="line">//           oldEndVnode,</span><br><span class="line">//           newEndVnode,</span><br><span class="line">//           insertedVnodeQueue,</span><br><span class="line">//           newCh,</span><br><span class="line">//           newEndIdx</span><br><span class="line">//         );</span><br><span class="line">//         oldEndVnode = oldCh[--oldEndIdx];</span><br><span class="line">//         newEndVnode = newCh[--newEndIdx];</span><br><span class="line">//       &#125;</span><br><span class="line">//       //老节点子节点的开始节点和新节点子节点的结束节点是相同节点时</span><br><span class="line">//       else if (sameVnode(oldStartVnode, newEndVnode)) &#123;</span><br><span class="line">//         // Vnode moved right</span><br><span class="line"></span><br><span class="line">//         //进行patchVnode，并将oldStartVnode移动到最后</span><br><span class="line">//         patchVnode(</span><br><span class="line">//           oldStartVnode,</span><br><span class="line">//           newEndVnode,</span><br><span class="line">//           insertedVnodeQueue,</span><br><span class="line">//           newCh,</span><br><span class="line">//           newEndIdx</span><br><span class="line">//         );</span><br><span class="line">//         canMove &amp;&amp;</span><br><span class="line">//           nodeOps.insertBefore(</span><br><span class="line">//             parentElm,</span><br><span class="line">//             oldStartVnode.elm,</span><br><span class="line">//             nodeOps.nextSibling(oldEndVnode.elm)</span><br><span class="line">//           );</span><br><span class="line">//         oldStartVnode = oldCh[++oldStartIdx];</span><br><span class="line">//         newEndVnode = newCh[--newEndIdx];</span><br><span class="line">//       &#125;</span><br><span class="line">//       //老节点子节点的结束节点和新节点子节点的开始节点是相同节点时</span><br><span class="line">//       else if (sameVnode(oldEndVnode, newStartVnode)) &#123;</span><br><span class="line">//         // Vnode moved left</span><br><span class="line"></span><br><span class="line">//         //进行patchVnode，并将oldEndVnode移动到最前</span><br><span class="line">//         patchVnode(</span><br><span class="line">//           oldEndVnode,</span><br><span class="line">//           newStartVnode,</span><br><span class="line">//           insertedVnodeQueue,</span><br><span class="line">//           newCh,</span><br><span class="line">//           newStartIdx</span><br><span class="line">//         );</span><br><span class="line">//         canMove &amp;&amp;</span><br><span class="line">//           nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);</span><br><span class="line">//         oldEndVnode = oldCh[--oldEndIdx];</span><br><span class="line">//         newStartVnode = newCh[++newStartIdx];</span><br><span class="line">//       &#125;</span><br><span class="line"></span><br><span class="line">//       //以上情况都不满足时，依次对比新老节点</span><br><span class="line">//       else &#123;</span><br><span class="line">//         //从新节点子节点的开始节点开始，在老节点子节点中找相同节点</span><br><span class="line">//         //先通过key查找，如果没有找到，再通过sameVnode查找</span><br><span class="line">//         if (isUndef(oldKeyToIdx))</span><br><span class="line">//           oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);</span><br><span class="line">//         idxInOld = isDef(newStartVnode.key)</span><br><span class="line">//           ? oldKeyToIdx[newStartVnode.key]</span><br><span class="line">//           : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);</span><br><span class="line"></span><br><span class="line">//         //如果没有找到</span><br><span class="line">//         if (isUndef(idxInOld)) &#123;</span><br><span class="line">//           // New element</span><br><span class="line">//           //创建节点插入到最前面</span><br><span class="line">//           createElm(</span><br><span class="line">//             newStartVnode,</span><br><span class="line">//             insertedVnodeQueue,</span><br><span class="line">//             parentElm,</span><br><span class="line">//             oldStartVnode.elm,</span><br><span class="line">//             false,</span><br><span class="line">//             newCh,</span><br><span class="line">//             newStartIdx</span><br><span class="line">//           );</span><br><span class="line">//         &#125; else &#123;</span><br><span class="line">//           vnodeToMove = oldCh[idxInOld];</span><br><span class="line"></span><br><span class="line">//           //如果两个节点是相同节点</span><br><span class="line">//           if (sameVnode(vnodeToMove, newStartVnode)) &#123;</span><br><span class="line">//             //执行patchVnode，并将查找到的老节点移动到最前面</span><br><span class="line">//             patchVnode(</span><br><span class="line">//               vnodeToMove,</span><br><span class="line">//               newStartVnode,</span><br><span class="line">//               insertedVnodeQueue,</span><br><span class="line">//               newCh,</span><br><span class="line">//               newStartIdx</span><br><span class="line">//             );</span><br><span class="line">//             oldCh[idxInOld] = undefined;</span><br><span class="line">//             canMove &amp;&amp;</span><br><span class="line">//               nodeOps.insertBefore(</span><br><span class="line">//                 parentElm,</span><br><span class="line">//                 vnodeToMove.elm,</span><br><span class="line">//                 oldStartVnode.elm</span><br><span class="line">//               );</span><br><span class="line">//           &#125; else &#123;</span><br><span class="line">//             // same key but different element. treat as new element</span><br><span class="line">//             createElm(</span><br><span class="line">//               newStartVnode,</span><br><span class="line">//               insertedVnodeQueue,</span><br><span class="line">//               parentElm,</span><br><span class="line">//               oldStartVnode.elm,</span><br><span class="line">//               false,</span><br><span class="line">//               newCh,</span><br><span class="line">//               newStartIdx</span><br><span class="line">//             );</span><br><span class="line">//           &#125;</span><br><span class="line">//         &#125;</span><br><span class="line">//         newStartVnode = newCh[++newStartIdx];</span><br><span class="line">//       &#125;</span><br><span class="line">//     &#125;</span><br><span class="line"></span><br><span class="line">//     //老节点子节点遍历完，新节点子节点未遍历完</span><br><span class="line">//     if (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">//       //说明新节点子节点比老节点子节点多，把新节点剩余的子节点插入到老节点子节点后面</span><br><span class="line">//       refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;</span><br><span class="line">//       addVnodes(</span><br><span class="line">//         parentElm,</span><br><span class="line">//         refElm,</span><br><span class="line">//         newCh,</span><br><span class="line">//         newStartIdx,</span><br><span class="line">//         newEndIdx,</span><br><span class="line">//         insertedVnodeQueue</span><br><span class="line">//       );</span><br><span class="line">//     &#125;</span><br><span class="line">//     //新节点子节点遍历完，老节点子节点未遍历完</span><br><span class="line">//     else if (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">//       //删除老节点剩余子节点</span><br><span class="line">//       removeVnodes(oldCh, oldStartIdx, oldEndIdx);</span><br><span class="line">//     &#125;</span><br><span class="line">//   &#125;</span><br><span class="line">// &#125;</span><br><span class="line">// arr:[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;]</span><br><span class="line"></span><br><span class="line">// arr.splice(1,0,&apos;x&apos;)</span><br><span class="line"></span><br><span class="line">// arr：[&apos;a&apos;,&apos;x&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;]</span><br><span class="line"></span><br><span class="line">//没有设置key tag相同时也会被判断为相同节点</span><br><span class="line">// 没有设置key时，更新了三次dom，插入了一次dom</span><br><span class="line">// 设置key时，插入了一次dom   （key的设置决定了相同节点的判断）</span><br></pre></td></tr></table></figure>
<h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><ul>
<li>v-memo 记住一个模板的子树。元素和组件上都可以使用。该指令接收一个固定长度的数组作为依赖值进行记忆比对。如果数组中的每个值都和上次渲染的时候相同，则整个该子树的更新会被跳过。</li>
<li><p>v-cloak 这个指令保持在元素上直到关联组件实例结束编译。和 CSS 规则如 <code>[v-cloak] { display: none }</code>一起用时，这个指令可以隐藏未编译的 Mustache 标签直到组件实例准备完毕。</p>
</li>
<li><p>2.x 版本中在一个元素上同时使用 v-if 和 v-for 时，v-for 会优先作用。3.x 版本中 v-if 总是优先于 v-for 生效。</p>
</li>
</ul>
<h4 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const app = Vue.createApp(&#123;&#125;)</span><br><span class="line">// 注册一个全局自定义指令 `v-focus`</span><br><span class="line">app.directive(&apos;focus&apos;, &#123;</span><br><span class="line">  // 当被绑定的元素挂载到 DOM 中时……</span><br><span class="line">  mounted(el) &#123;</span><br><span class="line">    // 聚焦元素</span><br><span class="line">    el.focus()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">一个指令定义对象可以提供如下几个钩子函数 (均为可选)：钩子函数的参数 (即 el、binding、vnode 和 prevVnode)</span><br><span class="line">created：在绑定元素的 attribute 或事件监听器被应用之前调用。在指令需要附加须要在普通的 v-on 事件监听器前调用的事件监听器时，这很有用。</span><br><span class="line">beforeMount：当指令第一次绑定到元素并且在挂载父组件之前调用。</span><br><span class="line">mounted：在绑定元素的父组件被挂载后调用。</span><br><span class="line">beforeUpdate：在更新包含组件的 VNode 之前调用。</span><br><span class="line">updated：在包含组件的 VNode 及其子组件的 VNode 更新后调用。</span><br><span class="line">beforeUnmount：在卸载绑定元素的父组件之前调用</span><br><span class="line">unmounted：当指令与元素解除绑定且父组件已卸载时，只调用一次。</span><br></pre></td></tr></table></figure>
<h3 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h3><p>新的 setup 选项在组件创建之前执行，一旦 props 被解析，就将作为组合式 API 的入口。<br>在 setup 中你应该避免使用 this，因为它不会找到组件实例。setup 的调用发生在 data property、computed property 或 methods 被解析之前，所以它们无法在 setup 中被获取。<br>setup 函数中的第一个参数是 props。正如在一个标准组件中所期望的那样，setup 函数中的 props 是响应式的，当传入新的 prop 时，它将被更新。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// MyBook.vue</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    title: String</span><br><span class="line">  &#125;,</span><br><span class="line">  setup(props) &#123;</span><br><span class="line">    console.log(props.title)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 props 是响应式的，你不能使用 ES6 解构，它会消除 prop 的响应性。<br>如果需要解构 prop，可以在 setup 函数中使用 toRefs 函数来完成此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// MyBook.vue</span><br><span class="line"></span><br><span class="line">import &#123; toRefs &#125; from &apos;vue&apos;</span><br><span class="line"></span><br><span class="line">setup(props) &#123;</span><br><span class="line">  const &#123; title &#125; = toRefs(props)</span><br><span class="line"></span><br><span class="line">  console.log(title.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>传递给 setup 函数的第二个参数是 context。context 是一个普通 JavaScript 对象，暴露了其它可能在 setup 中有用的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// MyBook.vue</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  setup(props, context) &#123;</span><br><span class="line">    // Attribute (非响应式对象，等同于 $attrs)</span><br><span class="line">    console.log(context.attrs)</span><br><span class="line"></span><br><span class="line">    // 插槽 (非响应式对象，等同于 $slots)</span><br><span class="line">    console.log(context.slots)</span><br><span class="line"></span><br><span class="line">    // 触发事件 (方法，等同于 $emit)</span><br><span class="line">    console.log(context.emit)</span><br><span class="line"></span><br><span class="line">    // 暴露公共 property (函数)</span><br><span class="line">    console.log(context.expose)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 setup 返回一个对象，那么该对象的 property 以及传递给 setup 的 props 参数中的 property 就都可以在模板中访问到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- MyBook.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;&#123;&#123; collectionName &#125;&#125;: &#123;&#123; readersNumber &#125;&#125; &#123;&#123; book.title &#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import &#123; ref, reactive &#125; from &apos;vue&apos;</span><br><span class="line"></span><br><span class="line">  export default &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">      collectionName: String</span><br><span class="line">    &#125;,</span><br><span class="line">    setup(props) &#123;</span><br><span class="line">      const readersNumber = ref(0)</span><br><span class="line">      const book = reactive(&#123; title: &apos;Vue 3 Guide&apos; &#125;)</span><br><span class="line"></span><br><span class="line">      // 暴露给 template</span><br><span class="line">      return &#123;</span><br><span class="line">        readersNumber,</span><br><span class="line">        book</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>setup 还可以返回一个渲染函数，该函数可以直接使用在同一作用域中声明的响应式状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// MyBook.vue</span><br><span class="line"></span><br><span class="line">import &#123; h, ref, reactive &#125; from &apos;vue&apos;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const readersNumber = ref(0)</span><br><span class="line">    const book = reactive(&#123; title: &apos;Vue 3 Guide&apos; &#125;)</span><br><span class="line">    // 请注意这里我们需要显式使用 ref 的 value</span><br><span class="line">    return () =&gt; h(&apos;div&apos;, [readersNumber.value, book.title])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回一个渲染函数将阻止我们返回任何其它的东西。从内部来说这不应该成为一个问题，但当我们想要将这个组件的方法通过模板 ref 暴露给父组件时就不一样了。</p>
<p>我们可以通过调用 expose 来解决这个问题，给它传递一个对象，其中定义的 property 将可以被外部组件实例访问：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import &#123; h, ref &#125; from &apos;vue&apos;</span><br><span class="line">export default &#123;</span><br><span class="line">  setup(props, &#123; expose &#125;) &#123;</span><br><span class="line">    const count = ref(0)</span><br><span class="line">    const increment = () =&gt; ++count.value</span><br><span class="line"></span><br><span class="line">    expose(&#123;</span><br><span class="line">      increment</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    return () =&gt; h(&apos;div&apos;, count.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>keep-alive</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  name: &apos;keep-alive&apos;,</span><br><span class="line">  abstract: true,</span><br><span class="line">  props: &#123;</span><br><span class="line">    include: patternTypes,</span><br><span class="line">    exclude: patternTypes,</span><br><span class="line">    max: [String, Number]</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;&#125;,</span><br><span class="line">  created()&#123;&#125;,</span><br><span class="line">  destroyed()&#123;&#125;,</span><br><span class="line">  mounted()&#123;&#125;,</span><br><span class="line">  updated()&#123;&#125;,</span><br><span class="line">  render()&#123;</span><br><span class="line">     const slot = this.$slots.default</span><br><span class="line">     const vnode: VNode = getFirstComponentChild(slot)</span><br><span class="line">     return vnode || (slot &amp;&amp; slot[0])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="vue3"><a href="#vue3" class="headerlink" title="vue3"></a>vue3</h3><ul>
<li><p>Teleport<br> 在同一目标上使用多个 teleport。一个常见的用例场景是一个可重用的 <code>&lt;Modal&gt;</code>组件，它可能同时有多个实例处于活动状态。对于这种情况，多个 <code>&lt;teleport&gt;</code> 组件可以将其内容挂载到同一个目标元素。顺序将是一个简单的追加——稍后挂载将位于目标元素中较早的挂载之后。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;teleport to=&quot;#modals&quot;&gt;</span><br><span class="line">  &lt;div&gt;A&lt;/div&gt;</span><br><span class="line">&lt;/teleport&gt;</span><br><span class="line">&lt;teleport to=&quot;#modals&quot;&gt;</span><br><span class="line">  &lt;div&gt;B&lt;/div&gt;</span><br><span class="line">&lt;/teleport&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- result--&gt;</span><br><span class="line">&lt;div id=&quot;modals&quot;&gt;</span><br><span class="line">  &lt;div&gt;A&lt;/div&gt;</span><br><span class="line">  &lt;div&gt;B&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>在 3.x 中，组件可以包含多个根节点！但是，这要求开发者显式定义 attribute 应该分布在哪里。</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Layout.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;header&gt;...&lt;/header&gt;</span><br><span class="line">  &lt;main v-bind=&quot;$attrs&quot;&gt;...&lt;/main&gt;</span><br><span class="line">  &lt;footer&gt;...&lt;/footer&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>v-model 参数<br>默认情况下，组件上的 v-model 使用 modelValue 作为 prop 和 update:modelValue 作为事件。我们可以通过向 v-model 传递参数来修改这些名称：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component v-model:title=&quot;bookTitle&quot;&gt;&lt;/my-component&gt;</span><br></pre></td></tr></table></figure>
<p>在本例中，子组件将需要一个 title prop 并发出 update:title 事件来进行同步：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">app.component(&apos;my-component&apos;, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    title: String</span><br><span class="line">  &#125;,</span><br><span class="line">  emits: [&apos;update:title&apos;],</span><br><span class="line">  template: `</span><br><span class="line">    &lt;input</span><br><span class="line">      type=&quot;text&quot;</span><br><span class="line">      :value=&quot;title&quot;</span><br><span class="line">      @input=&quot;$emit(&apos;update:title&apos;, $event.target.value)&quot;&gt;</span><br><span class="line">  `</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>正如我们之前在 v-model 参数中所学的那样，通过利用以特定 prop 和事件为目标的能力，我们现在可以在单个组件实例上创建多个 v-model 绑定。<br>每个 v-model 将同步到不同的 prop，而不需要在组件中添加额外的选项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;user-name v-model:first-name=&quot;firstName&quot; v-model:last-name=&quot;lastName&quot;&gt;&lt;/user-name&gt;</span><br><span class="line">app.component(&apos;user-name&apos;, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    firstName: String,</span><br><span class="line">    lastName: String</span><br><span class="line">  &#125;,</span><br><span class="line">  emits: [&apos;update:firstName&apos;, &apos;update:lastName&apos;],</span><br><span class="line">  template: `</span><br><span class="line">    &lt;input</span><br><span class="line">      type=&quot;text&quot;</span><br><span class="line">      :value=&quot;firstName&quot;</span><br><span class="line">      @input=&quot;$emit(&apos;update:firstName&apos;, $event.target.value)&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;input</span><br><span class="line">      type=&quot;text&quot;</span><br><span class="line">      :value=&quot;lastName&quot;</span><br><span class="line">      @input=&quot;$emit(&apos;update:lastName&apos;, $event.target.value)&quot;&gt;</span><br><span class="line">  `</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>处理 v-model 修饰符<br>添加到组件 v-model 的修饰符将通过 modelModifiers prop 提供给组件。在下面的示例中，我们创建了一个组件，其中包含默认为空对象的 modelModifiers prop。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component v-model.capitalize=&quot;myText&quot;&gt;&lt;/my-component&gt;</span><br><span class="line">app.component(&apos;my-component&apos;, &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">      modelValue: String,</span><br><span class="line">      modelModifiers: &#123;</span><br><span class="line">        default: () =&gt; (&#123;&#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    emits: [&apos;update:modelValue&apos;],</span><br><span class="line">    template: `</span><br><span class="line">      &lt;input type=&quot;text&quot;</span><br><span class="line">        :value=&quot;modelValue&quot;</span><br><span class="line">        @input=&quot;$emit(&apos;update:modelValue&apos;, $event.target.value)&quot;&gt;</span><br><span class="line">    `,</span><br><span class="line">    created() &#123;</span><br><span class="line">      console.log(this.modelModifiers) // &#123; capitalize: true &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>对于带参数的 v-model 绑定，生成的 prop 名称将为 arg + “Modifiers”：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component v-model:description.capitalize=&quot;myText&quot;&gt;&lt;/my-component&gt;</span><br><span class="line">app.component(&apos;my-component&apos;, &#123;</span><br><span class="line">  props: [&apos;description&apos;, &apos;descriptionModifiers&apos;],</span><br><span class="line">  emits: [&apos;update:description&apos;],</span><br><span class="line">  template: `</span><br><span class="line">    &lt;input type=&quot;text&quot;</span><br><span class="line">      :value=&quot;description&quot;</span><br><span class="line">      @input=&quot;$emit(&apos;update:description&apos;, $event.target.value)&quot;&gt;</span><br><span class="line">  `,</span><br><span class="line">  created() &#123;</span><br><span class="line">    console.log(this.descriptionModifiers) // &#123; capitalize: true &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在 2.x 中，在组件上使用 v-model 相当于绑定 value prop 并触发 input 事件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;ChildComponent v-model=&quot;pageTitle&quot; /&gt;</span><br><span class="line">&lt;!-- 是以下的简写: --&gt;</span><br><span class="line">&lt;ChildComponent :value=&quot;pageTitle&quot; @input=&quot;pageTitle = $event&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- ParentComponent.vue --&gt;</span><br><span class="line"></span><br><span class="line">&lt;ChildComponent v-model=&quot;pageTitle&quot; /&gt;</span><br><span class="line"></span><br><span class="line">// ChildComponent.vue</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  model: &#123;</span><br><span class="line">    prop: &apos;title&apos;,</span><br><span class="line">    event: &apos;change&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    // 这将允许 `value` 属性用于其他用途</span><br><span class="line">    value: String,</span><br><span class="line">    // 使用 `title` 代替 `value` 作为 model 的 prop</span><br><span class="line">    title: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      default: &apos;Default title&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;ChildComponent :title=&quot;pageTitle&quot; @change=&quot;pageTitle = $event&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>在某些情况下，我们可能需要对某一个 prop 进行“双向绑定”(除了前面用 v-model 绑定 prop 的情况)。为此，我们建议使用 update:myPropName 抛出事件。例如，对于在上一个示例中带有 title prop 的 ChildComponent，我们可以通过下面的方式将分配新 value 的意图传达给父级：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.$emit(&apos;update:title&apos;, newValue)</span><br><span class="line">&lt;ChildComponent :title=&quot;pageTitle&quot; @update:title=&quot;pageTitle = $event&quot; /&gt;</span><br><span class="line">&lt;ChildComponent :title.sync=&quot;pageTitle&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>在 3.x 中，自定义组件上的 v-model 相当于传递了 modelValue prop 并接收抛出的 update:modelValue 事件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;ChildComponent v-model=&quot;pageTitle&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 是以下的简写: --&gt;</span><br><span class="line"></span><br><span class="line">&lt;ChildComponent</span><br><span class="line">  :modelValue=&quot;pageTitle&quot;</span><br><span class="line">  @update:modelValue=&quot;pageTitle = $event&quot;</span><br><span class="line">/&gt;</span><br><span class="line">&lt;ChildComponent v-model:title=&quot;pageTitle&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 是以下的简写: --&gt;</span><br><span class="line"></span><br><span class="line">&lt;ChildComponent :title=&quot;pageTitle&quot; @update:title=&quot;pageTitle = $event&quot; /&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>状态驱动的动态 CSS</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">   &lt;div class=&quot;text&quot;&gt;hello&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"> &lt;script&gt;</span><br><span class="line">   export default &#123;</span><br><span class="line">     data() &#123;</span><br><span class="line">       return &#123;</span><br><span class="line">         color: &apos;red&apos;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &lt;/script&gt;</span><br><span class="line"></span><br><span class="line"> &lt;style&gt;</span><br><span class="line"> .text &#123;</span><br><span class="line">   color: v-bind(color);</span><br><span class="line"> &#125;</span><br><span class="line"> &lt;/style&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>全局 API<br>Vue 2.x 有许多全局 API 和配置，它们可以全局改变 Vue 的行为。从技术上讲，Vue 2 没有“app”的概念，我们定义的应用只是通过 new Vue() 创建的根 Vue 实例。从同一个 Vue 构造函数创建的每个根实例共享相同的全局配置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;button-counter&apos;, &#123;</span><br><span class="line">   data: () =&gt; (&#123;</span><br><span class="line">     count: 0</span><br><span class="line">   &#125;),</span><br><span class="line">   template: &apos;&lt;button @click=&quot;count++&quot;&gt;Clicked &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&apos;</span><br><span class="line"> &#125;)</span><br><span class="line">Vue.directive(&apos;focus&apos;, &#123;</span><br><span class="line">    inserted: el =&gt; el.focus()</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>
<p>全局配置使得在同一页面上的多个“应用”在全局配置不同时共享同一个 Vue 副本非常困难。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 这会影响到所有根实例</span><br><span class="line">Vue.mixin(&#123;</span><br><span class="line">  /* ... */</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const app1 = new Vue(&#123; el: &apos;#app-1&apos; &#125;)</span><br><span class="line">const app2 = new Vue(&#123; el: &apos;#app-2&apos; &#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>一个新的全局 API：createApp。应用实例暴露了 Vue 2 全局 API 的一个子集，经验法则是，任何全局改变 Vue 行为的 API 现在都会移动到应用实例上。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createApp &#125; from &apos;vue&apos;</span><br><span class="line">const app = createApp(&#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>Vue.prototype 替换为 config.globalProperties</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> // 之前 - Vue 2</span><br><span class="line">Vue.prototype.$http = () =&gt; &#123;&#125;</span><br><span class="line">// 之后 - Vue 3</span><br><span class="line">const app = createApp(&#123;&#125;)</span><br><span class="line">app.config.globalProperties.$http = () =&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>与在 2.x 根实例中使用 provide 选项类似，Vue 3 应用实例也提供了可被应用内任意组件注入的依赖项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 在入口中</span><br><span class="line">app.provide(&apos;guide&apos;, &apos;Vue 3 Guide&apos;)</span><br><span class="line"></span><br><span class="line">// 在子组件中</span><br><span class="line">export default &#123;</span><br><span class="line">  inject: &#123;</span><br><span class="line">    book: &#123;</span><br><span class="line">      from: &apos;guide&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: `&lt;div&gt;&#123;&#123; book &#125;&#125;&lt;/div&gt;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在应用之间共享配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createApp &#125; from &apos;vue&apos;</span><br><span class="line">import Foo from &apos;./Foo.vue&apos;</span><br><span class="line">import Bar from &apos;./Bar.vue&apos;</span><br><span class="line"></span><br><span class="line">const createMyApp = options =&gt; &#123;</span><br><span class="line">  const app = createApp(options)</span><br><span class="line">  app.directive(&apos;focus&apos; /* ... */)</span><br><span class="line"></span><br><span class="line">  return app</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createMyApp(Foo).mount(&apos;#foo&apos;)</span><br><span class="line">createMyApp(Bar).mount(&apos;#bar&apos;)</span><br></pre></td></tr></table></figure>
<p>Vue.extend 移除<br>在 Vue 2.x 中，Vue.extend 曾经被用于创建一个基于 Vue 构造函数的“子类”，其参数应为一个包含组件选项的对象。在 Vue 3.x 中，我们已经没有组件构造器的概念了。应该始终使用 createApp 这个全局 API 来挂载组件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 之前 - Vue 2</span><br><span class="line"></span><br><span class="line">// 创建构造器</span><br><span class="line">const Profile = Vue.extend(&#123;</span><br><span class="line">  template: &apos;&lt;p&gt;&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125; aka &#123;&#123;alias&#125;&#125;&lt;/p&gt;&apos;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      firstName: &apos;Walter&apos;,</span><br><span class="line">      lastName: &apos;White&apos;,</span><br><span class="line">      alias: &apos;Heisenberg&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">// 创建一个 Profile 的实例，并将它挂载到一个元素上</span><br><span class="line">new Profile().$mount(&apos;#mount-point&apos;)</span><br><span class="line"></span><br><span class="line">// 之后 - Vue 3</span><br><span class="line">const Profile = &#123;</span><br><span class="line">  template: &apos;&lt;p&gt;&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125; aka &#123;&#123;alias&#125;&#125;&lt;/p&gt;&apos;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      firstName: &apos;Walter&apos;,</span><br><span class="line">      lastName: &apos;White&apos;,</span><br><span class="line">      alias: &apos;Heisenberg&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Vue.createApp(Profile).mount(&apos;#mount-point&apos;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>全局 API Treeshaking<br>在 Vue 3 中，全局和内部 API 都经过了重构，并考虑到了 tree-shaking 的支持。因此，对于 ES 模块构建版本来说，全局 API 现在通过具名导出进行访问。例如，我们之前的代码片段现在应该如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &#123; nextTick &#125; from &apos;vue&apos;</span><br><span class="line"></span><br><span class="line">nextTick(() =&gt; &#123;</span><br><span class="line">  // 一些和 DOM 有关的东西</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 Vue 2.x 中，<code>&lt;template&gt;</code> 标签不能拥有 key。不过，你可以为其每个子节点分别设置 key。在 Vue 3.x 中，key 则应该被设置在 <code>&lt;template&gt;</code> 标签上。</p>
</li>
<li>2.x 版本中在一个元素上同时使用 v-if 和 v-for 时，v-for 会优先作用。3.x 版本中 v-if 总是优先于 v-for 生效。</li>
<li>2.x 默认情况下，传递给带有 v-on 的组件的事件监听器只能通过 this.$emit 触发。要将原生 DOM 监听器添加到子组件的根元素中，可以使用 .native 修饰符。3.x v-on 的 .native 修饰符已被移除。同时，新增的 emits 选项允许子组件定义真正会被触发的事件。因此，对于子组件中未被定义为组件触发的所有事件监听器，Vue 现在将把它们作为原生事件监听器添加到子组件的根元素中 (除非在子组件的选项中设置了 inheritAttrs: false)。</li>
<li><p>v-for 中的 Ref 数组<br>在 Vue 2 中，在 v-for 中使用的 ref attribute 会用 ref 数组填充相应的 $refs property。当存在嵌套的 v-for 时，这种行为会变得不明确且效率低下。<br>在 Vue 3 中，此类用法将不再自动创建 $ref 数组。要从单个绑定获取多个 ref，请将 ref 绑定到一个更灵活的函数上 (这是一个新特性)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-for=&quot;item in list&quot; :ref=&quot;setItemRef&quot;&gt;&lt;/div&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">   data() &#123;</span><br><span class="line">     return &#123;</span><br><span class="line">       itemRefs: []</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   methods: &#123;</span><br><span class="line">     setItemRef(el) &#123;</span><br><span class="line">       if (el) &#123;</span><br><span class="line">         this.itemRefs.push(el)</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   beforeUpdate() &#123;</span><br><span class="line">     this.itemRefs = []</span><br><span class="line">   &#125;,</span><br><span class="line">   updated() &#123;</span><br><span class="line">     console.log(this.itemRefs)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>emits 选项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;button v-on:click=&quot;$emit(&apos;click&apos;, $event)&quot;&gt;OK&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">   export default &#123;</span><br><span class="line">     emits: [] // 不声明事件</span><br><span class="line">   &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;my-button v-on:click=&quot;handleClick&quot;&gt;&lt;/my-button&gt;</span><br><span class="line">该事件现在会被触发两次:一次来自 $emit() 另一次来自应用在根元素上的原生事件监听器</span><br></pre></td></tr></table></figure>
</li>
<li><p>$listeners 对象在 Vue 3 中已被移除。事件监听器现在是 $attrs 的一部分</p>
</li>
<li>在 2.x 中，开发者可以通过 object 或者是 function 定义 data 选项。 在 3.x 中，data 选项已标准化为只接受返回 object 的 function。</li>
<li>3.x 当使用 watch 选项侦听数组时，只有在数组被替换时才会触发回调。换句话说，在数组被改变时侦听回调将不再被触发。要想在数组被改变时触发侦听回调，必须指定 deep 选项。</li>
<li>在 Vue 2.x 中，当挂载一个具有 template 的应用时，被渲染的内容会替换我们要挂载的目标元素。在 Vue 3.x 中，被渲染的应用会作为子元素插入，从而替换目标元素的 innerHTML。</li>
<li>在 Vue 2 中，我们可以通过事件来监听组件生命周期中的关键阶段。这些事件名都是以 hook: 前缀开头，并跟随相应的生命周期钩子的名字。<br>在 Vue 3 中，这个前缀已被更改为 vnode-。额外地，这些事件现在也可用于 HTML 元素，和在组件上的用法一样。</li>
<li>在 2.x 中，开发者可以使用 this.$children 访问当前实例的直接子组件 在 3.x 中，$children property 已被移除，且不再支持。如果你需要访问子组件实例，我们建议使用 $refs。</li>
<li>$on，$off 和 $once 实例方法已被移除，组件实例不再实现事件触发接口。</li>
<li>在 3.x 中，过滤器已移除，且不再支持。取而代之的是，我们建议用方法调用或计算属性来替换它们。</li>
</ul>
</li>
</ul>
<h3 id="其它-1"><a href="#其它-1" class="headerlink" title="其它"></a>其它</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * $set/set</span><br><span class="line"> */</span><br><span class="line">//  export function set (target: Array&lt;any&gt; | Object, key: any, val: any): any &#123;</span><br><span class="line">//   if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp;</span><br><span class="line">//     (isUndef(target) || isPrimitive(target))</span><br><span class="line">//   ) &#123;</span><br><span class="line">//     warn(`Cannot set reactive property on undefined, null, or primitive value: $&#123;(target: any)&#125;`)</span><br><span class="line">//   &#125;</span><br><span class="line"></span><br><span class="line">//   //数组时 调用splice方法</span><br><span class="line">//   if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123;</span><br><span class="line">//     target.length = Math.max(target.length, key)</span><br><span class="line">//     target.splice(key, 1, val)</span><br><span class="line">//     return val</span><br><span class="line">//   &#125;</span><br><span class="line"></span><br><span class="line">//   if (key in target &amp;&amp; !(key in Object.prototype)) &#123;</span><br><span class="line">//     target[key] = val</span><br><span class="line">//     return val</span><br><span class="line">//   &#125;</span><br><span class="line">//   const ob = (target: any).__ob__</span><br><span class="line">//   if (target._isVue || (ob &amp;&amp; ob.vmCount)) &#123;</span><br><span class="line">//     process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; warn(</span><br><span class="line">//       &apos;Avoid adding reactive properties to a Vue instance or its root $data &apos; +</span><br><span class="line">//       &apos;at runtime - declare it upfront in the data option.&apos;</span><br><span class="line">//     )</span><br><span class="line">//     return val</span><br><span class="line">//   &#125;</span><br><span class="line">//   if (!ob) &#123;</span><br><span class="line">//     target[key] = val</span><br><span class="line">//     return val</span><br><span class="line">//   &#125;</span><br><span class="line">//   //把key设为响应式属性</span><br><span class="line">//   defineReactive(ob.value, key, val)</span><br><span class="line">//   //发送通知</span><br><span class="line">//   ob.dep.notify()</span><br><span class="line">//   return val</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * $delete/delete</span><br><span class="line"> */</span><br><span class="line">//  export function del (target: Array&lt;any&gt; | Object, key: any) &#123;</span><br><span class="line">//   if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp;</span><br><span class="line">//     (isUndef(target) || isPrimitive(target))</span><br><span class="line">//   ) &#123;</span><br><span class="line">//     warn(`Cannot delete reactive property on undefined, null, or primitive value: $&#123;(target: any)&#125;`)</span><br><span class="line">//   &#125;</span><br><span class="line"></span><br><span class="line">//   //数组处理</span><br><span class="line">//   if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123;</span><br><span class="line">//     target.splice(key, 1)</span><br><span class="line">//     return</span><br><span class="line">//   &#125;</span><br><span class="line">//   const ob = (target: any).__ob__</span><br><span class="line">//   if (target._isVue || (ob &amp;&amp; ob.vmCount)) &#123;</span><br><span class="line">//     process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; warn(</span><br><span class="line">//       &apos;Avoid deleting properties on a Vue instance or its root $data &apos; +</span><br><span class="line">//       &apos;- just set it to null.&apos;</span><br><span class="line">//     )</span><br><span class="line">//     return</span><br><span class="line">//   &#125;</span><br><span class="line">//   if (!hasOwn(target, key)) &#123;</span><br><span class="line">//     return</span><br><span class="line">//   &#125;</span><br><span class="line"></span><br><span class="line">//   //delete 操作符</span><br><span class="line">//   delete target[key]</span><br><span class="line">//   if (!ob) &#123;</span><br><span class="line">//     return</span><br><span class="line">//   &#125;</span><br><span class="line">//   ob.dep.notify()</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * $nextTick/nextTick</span><br><span class="line"> * nextTick的目的就是产生一个回调函数加入task或者microtask中，当前栈执行完以后（可能中间还有别的排在前面的函数）调用该回调函数，起到了异步触发（即下一个tick时触发）的目的。</span><br><span class="line"> * 优先使用Promise，在Promise不存在的情况下使用MutationObserver，这两个方法的回调函数都会在microtask中执行，它们会比setTimeout更早执行，所以优先使用。 如果上述两种方法都不支持的环境则会使用setTimeout，在task尾部推入这个函数，等待调用执行。</span><br><span class="line"> * JS 的 event loop 执行时会区分 task 和 microtask，引擎在每个 task 执行完毕，从队列中取下一个 task 来执行之前，会先执行完所有 microtask 队列中的 microtask。</span><br><span class="line"> * setTimeout 回调会被分配到一个新的 task 中执行，而 Promise 的 resolver、MutationObserver 的回调都会被安排到一个新的 microtask 中执行，会比 setTimeout 产生的 task 先执行。</span><br><span class="line"> * 要创建一个新的 microtask，优先使用 Promise，如果浏览器不支持，再尝试 MutationObserver。</span><br><span class="line"> * 实在不行，只能用 setTimeout 创建 task 了。</span><br><span class="line"> * 为啥要用 microtask？</span><br><span class="line"> * 根据 HTML Standard，在每个 task 运行完以后，UI 都会重渲染，那么在 microtask 中就完成数据更新，当前 task 结束就可以得到最新的 UI 了。</span><br><span class="line"> * 反之如果新建一个 task 来做数据更新，那么渲染就会进行两次。</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> * 为什么要异步更新视图?</span><br><span class="line"> * 现在有这样的一种情况，mounted的时候test的值会被++循环执行1000次。 每次++时，都会根据响应式触发setter-&gt;Dep-&gt;Watcher-&gt;update-&gt;patch。 如果这时候没有异步更新视图，那么每次++都会直接操作DOM更新视图，这是非常消耗性能的。 所以Vue.js实现了一个queue队列，在下一个tick的时候会统一执行queue中Watcher的run。同时，拥有相同id的Watcher不会被重复加入到该queue中去，所以不会执行1000次Watcher的run。最终更新视图只会直接将test对应的DOM的0变成1000。 保证更新视图操作DOM的动作是在当前栈执行完以后下一个tick的时候调用，大大优化了性能。</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Vue.use() </span><br><span class="line"> * 插件是function时直接调用,插件有install字段且install是function时调用install</span><br><span class="line"> * export function initUse (Vue: GlobalAPI) &#123;</span><br><span class="line">   //参数为函数或对象</span><br><span class="line">  Vue.use = function (plugin: Function | Object) &#123;</span><br><span class="line">   //已经安装的插件</span><br><span class="line">    const installedPlugins = (this._installedPlugins || (this._installedPlugins = []))</span><br><span class="line">	//已经安装过的插件不会再次安装</span><br><span class="line">    if (installedPlugins.indexOf(plugin) &gt; -1) &#123;</span><br><span class="line">      return this</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // additional parameters   把参数的第一个元素去除，第一个元素是插件</span><br><span class="line">    const args = toArray(arguments, 1)</span><br><span class="line">    args.unshift(this)   //args数组第一项插入this(Vue)</span><br><span class="line">	//参数为对象时，有一个install方法，调用install方法</span><br><span class="line">    if (typeof plugin.install === &apos;function&apos;) &#123;</span><br><span class="line">      plugin.install.apply(plugin, args)</span><br><span class="line">    &#125; </span><br><span class="line">	//参数为函数时,直接调用</span><br><span class="line">	else if (typeof plugin === &apos;function&apos;) &#123;</span><br><span class="line">      plugin.apply(null, args)</span><br><span class="line">    &#125;</span><br><span class="line">    installedPlugins.push(plugin)</span><br><span class="line">    return this</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<h2 id="react"><a href="#react" class="headerlink" title="react"></a>react</h2><h3 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line">function render()&#123;</span><br><span class="line"> diff()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export default function diff(virtualDOM, container, oldDOM) &#123;</span><br><span class="line">  const oldVirtualDOM = oldDOM &amp;&amp; oldDOM._virtualDOM</span><br><span class="line">  const oldComponent = oldVirtualDOM &amp;&amp; oldVirtualDOM.component</span><br><span class="line">  // 判断 oldDOM 是否存在</span><br><span class="line">  if (!oldDOM) &#123;</span><br><span class="line">    mountElement(virtualDOM, container)</span><br><span class="line">  &#125; else if (</span><br><span class="line">    // 如果要比对的两个节点类型不相同</span><br><span class="line">    virtualDOM.type !== oldVirtualDOM.type &amp;&amp;</span><br><span class="line">    // 并且节点的类型不是组件 因为组件要单独处理</span><br><span class="line">    typeof virtualDOM.type !== &quot;function&quot;</span><br><span class="line">  ) &#123;</span><br><span class="line">    // 不需要对比</span><br><span class="line">    // 使用新的 virtualDOM 对象生成真实 DOM 对象</span><br><span class="line">    const newElement = createDOMElement(virtualDOM)</span><br><span class="line">    // 使用新的 DOM 对象替换旧的 DOM 对象</span><br><span class="line">    oldDOM.parentNode.replaceChild(newElement, oldDOM)</span><br><span class="line">  &#125; else if (typeof virtualDOM.type === &quot;function&quot;) &#123;</span><br><span class="line">    // 组件</span><br><span class="line">    diffComponent(virtualDOM, oldComponent, oldDOM, container)</span><br><span class="line">  &#125; else if (oldVirtualDOM &amp;&amp; virtualDOM.type === oldVirtualDOM.type) &#123;</span><br><span class="line">    if (virtualDOM.type === &quot;text&quot;) &#123;</span><br><span class="line">      // 更新内容</span><br><span class="line">      updateTextNode(virtualDOM, oldVirtualDOM, oldDOM)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // 更新元素节点属性</span><br><span class="line">      updateNodeElement(oldDOM, virtualDOM, oldVirtualDOM)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 1. 将拥有key属性的子元素放置在一个单独的对象中</span><br><span class="line">    let keyedElements = &#123;&#125;</span><br><span class="line">    for (let i = 0, len = oldDOM.childNodes.length; i &lt; len; i++) &#123;</span><br><span class="line">      let domElement = oldDOM.childNodes[i]</span><br><span class="line">      if (domElement.nodeType === 1) &#123;</span><br><span class="line">        let key = domElement.getAttribute(&quot;key&quot;)</span><br><span class="line">        if (key) &#123;</span><br><span class="line">          keyedElements[key] = domElement</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let hasNoKey = Object.keys(keyedElements).length === 0</span><br><span class="line"></span><br><span class="line">    if (hasNoKey) &#123;</span><br><span class="line">      // 对比子节点</span><br><span class="line">      virtualDOM.children.forEach((child, i) =&gt; &#123;</span><br><span class="line">        diff(child, oldDOM, oldDOM.childNodes[i])</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // 2. 循环 virtualDOM 的子元素 获取子元素的 key 属性</span><br><span class="line">      virtualDOM.children.forEach((child, i) =&gt; &#123;</span><br><span class="line">        let key = child.props.key</span><br><span class="line">        if (key) &#123;</span><br><span class="line">          let domElement = keyedElements[key]</span><br><span class="line">          if (domElement) &#123;</span><br><span class="line">            // 3. 看看当前位置的元素是不是我们期望的元素</span><br><span class="line">            if (oldDOM.childNodes[i] &amp;&amp; oldDOM.childNodes[i] !== domElement) &#123;</span><br><span class="line">              oldDOM.insertBefore(domElement, oldDOM.childNodes[i])</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            // 新增元素</span><br><span class="line">            mountElement(child, oldDOM, oldDOM.childNodes[i])</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 删除节点</span><br><span class="line">    // 获取旧节点</span><br><span class="line">    let oldChildNodes = oldDOM.childNodes</span><br><span class="line">    // 判断旧节点的数量</span><br><span class="line">    if (oldChildNodes.length &gt; virtualDOM.children.length) &#123;</span><br><span class="line">      if (hasNoKey) &#123;</span><br><span class="line">        // 有节点需要被删除</span><br><span class="line">        for (</span><br><span class="line">          let i = oldChildNodes.length - 1;</span><br><span class="line">          i &gt; virtualDOM.children.length - 1;</span><br><span class="line">          i--</span><br><span class="line">        ) &#123;</span><br><span class="line">          unmountNode(oldChildNodes[i])</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        // 通过key属性删除节点</span><br><span class="line">        for (let i = 0; i &lt; oldChildNodes.length; i++) &#123;</span><br><span class="line">          let oldChild = oldChildNodes[i]</span><br><span class="line">          let oldChildKey = oldChild._virtualDOM.props.key</span><br><span class="line">          let found = false</span><br><span class="line">          for (let n = 0; n &lt; virtualDOM.children.length; n++) &#123;</span><br><span class="line">            if (oldChildKey === virtualDOM.children[n].props.key) &#123;</span><br><span class="line">              found = true</span><br><span class="line">              break</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          if (!found) &#123;</span><br><span class="line">            unmountNode(oldChild)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export default function mountComponent(virtualDOM, container, oldDOM) &#123;</span><br><span class="line">  let nextVirtualDOM = null</span><br><span class="line">  let component = null</span><br><span class="line">  // 判断组件是类组件还是函数组件</span><br><span class="line">  if (isFunctionComponent(virtualDOM)) &#123;</span><br><span class="line">    // 函数组件</span><br><span class="line">    nextVirtualDOM = buildFunctionComponent(virtualDOM)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // 类组件</span><br><span class="line">    nextVirtualDOM = buildClassComponent(virtualDOM)</span><br><span class="line">    component = nextVirtualDOM.component</span><br><span class="line">  &#125;</span><br><span class="line">  if (isFunction(nextVirtualDOM)) &#123;</span><br><span class="line">    mountComponent(nextVirtualDOM, container, oldDOM)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    mountNativeElement(nextVirtualDOM, container, oldDOM)</span><br><span class="line">  &#125;</span><br><span class="line">  if (component) &#123;</span><br><span class="line">    component.componentDidMount()</span><br><span class="line">    if (component.props &amp;&amp; component.props.ref) &#123;</span><br><span class="line">      component.props.ref(component)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function buildFunctionComponent(virtualDOM) &#123;</span><br><span class="line">  return virtualDOM.type(virtualDOM.props || &#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function buildClassComponent(virtualDOM) &#123;</span><br><span class="line">  const component = new virtualDOM.type(virtualDOM.props || &#123;&#125;)</span><br><span class="line">  const nextVirtualDOM = component.render()</span><br><span class="line">  nextVirtualDOM.component = component</span><br><span class="line">  return nextVirtualDOM</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">关键：insertBefore 可以使用 insertBefore 方法插入/移动已有元素。</span><br></pre></td></tr></table></figure>
<h3 id="fiber"><a href="#fiber" class="headerlink" title="fiber"></a>fiber</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//https://mp.weixin.qq.com/s/zjhCIUtJrSmw2icy2zkKFg</span><br><span class="line">// 完整的一帧中，具体做了哪些事情：</span><br><span class="line">// 1.首先需要处理输入事件，能够让用户得到最早的反馈</span><br><span class="line"></span><br><span class="line">// 2.接下来是处理定时器，需要检查定时器是否到时间，并执行对应的回调</span><br><span class="line"></span><br><span class="line">// 3.接下来处理 Begin Frame（开始帧），即每一帧的事件，包括 window.resize、scroll、media query change 等</span><br><span class="line"></span><br><span class="line">// 4.接下来执行请求动画帧 requestAnimationFrame（rAF），即在每次绘制之前，会执行 rAF 回调</span><br><span class="line"></span><br><span class="line">// 5.紧接着进行 Layout 操作，包括计算布局和更新布局，即这个元素的样式是怎样的，它应该在页面如何展示</span><br><span class="line"></span><br><span class="line">// 6.接着进行 Paint 操作，得到树中每个节点的尺寸与位置等信息，浏览器针对每个元素进行内容填充</span><br><span class="line"></span><br><span class="line">// 7.到这时以上的六个阶段都已经完成了，接下来处于空闲阶段（Idle Peroid），可以在这时执行 requestIdleCallback 里注册的任务（后面会详细讲到这个 requestIdleCallback ，它是 React Fiber 实现的基础）</span><br><span class="line"></span><br><span class="line">// js引擎和页面渲染引擎是在同一个渲染线程之内，两者是互斥关系。如果在某个阶段执行任务特别长，例如在定时器阶段或Begin Frame阶段执行时间非常长，时间已经明显超过了16ms，那么就会阻塞页面的渲染，从而出现卡顿现象。</span><br><span class="line">// 在 react16 引入 Fiber 架构之前，react 会采用递归对比虚拟DOM树，找出需要变动的节点，然后同步更新它们，这个过程 react 称为reconcilation（协调）。在reconcilation期间，react 会一直占用浏览器资源，会导致用户触发的事件得不到响应。</span><br><span class="line">// 这种遍历是递归调用，执行栈会越来越深，而且不能中断，中断后就不能恢复了。递归如果非常深，就会十分卡顿。如果递归花了100ms，则这100ms浏览器是无法响应的，代码执行时间越长卡顿越明显。传统的方法存在不能中断和执行栈太深的问题。</span><br><span class="line"></span><br><span class="line">// 因此，为了解决以上的痛点问题，React希望能够彻底解决主线程长时间占用问题，于是引入了 Fiber 来改变这种不可控的现状，把渲染/更新过程拆分为一个个小块的任务，通过合理的调度机制来调控时间，指定任务执行的时机，从而降低页面卡顿的概率，提升页面交互体验。通过Fiber架构，让reconcilation过程变得可被中断。适时地让出CPU执行权，可以让浏览器及时地响应用户的交互。</span><br><span class="line">//React16中使用了 Fiber，但是 Vue 是没有 Fiber 的，为什么呢？原因是二者的优化思路不一样：</span><br><span class="line">//Vue 是基于 template 和 watcher 的组件级更新，把每个更新任务分割得足够小，不需要使用到 Fiber 架构，将任务进行更细粒度的拆分</span><br><span class="line">//React 是不管在哪里调用 setState，都是从根节点开始更新的，更新任务还是很大，需要使用到 Fiber 将大任务分割为多个小任务，可以中断和恢复，不阻塞主进程执行高优先级的任务</span><br><span class="line"></span><br><span class="line">// Fiber 执行原理</span><br><span class="line">// 从根节点开始渲染和调度的过程可以分为两个阶段：render 阶段、commit 阶段。</span><br><span class="line">// render 阶段：这个阶段是可中断的，会找出所有节点的变更</span><br><span class="line">// commit 阶段：这个阶段是不可中断的，会执行所有的变更</span><br></pre></td></tr></table></figure>
<h3 id="其它-2"><a href="#其它-2" class="headerlink" title="其它"></a>其它</h3><ul>
<li>受控组件 非受控组件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">受控组件</span><br><span class="line">class NameForm extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;value: &apos;&apos;&#125;;</span><br><span class="line"></span><br><span class="line">    this.handleChange = this.handleChange.bind(this);</span><br><span class="line">    this.handleSubmit = this.handleSubmit.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(event) &#123;</span><br><span class="line">    this.setState(&#123;value: event.target.value&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSubmit(event) &#123;</span><br><span class="line">    alert(&apos;提交的名字: &apos; + this.state.value);</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          名字:</span><br><span class="line">          &lt;input type=&quot;text&quot; value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt;</span><br><span class="line">        &lt;/label&gt;</span><br><span class="line">        &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;</span><br><span class="line">      &lt;/form&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">非受控组件</span><br><span class="line">class NameForm extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.handleSubmit = this.handleSubmit.bind(this);</span><br><span class="line">    this.input = React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSubmit(event) &#123;</span><br><span class="line">    alert(&apos;A name was submitted: &apos; + this.input.current.value);</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          Name:</span><br><span class="line">          &lt;input type=&quot;text&quot; ref=&#123;this.input&#125; /&gt;</span><br><span class="line">        &lt;/label&gt;</span><br><span class="line">        &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;</span><br><span class="line">      &lt;/form&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>高阶组件 高阶组件是参数为组件，返回值为新组件的函数。</li>
<li>React.Children 提供了用于处理 this.props.children 不透明数据结构的实用方法。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">React.Children.map</span><br><span class="line">在 children 里的每个直接子节点上调用一个函数，并将 this 设置为 thisArg。如果 children 是一个数组，它将被遍历并为数组中的每个子节点调用该函数。如果子节点为 null 或是 undefined，则此方法将返回 null 或是 undefined，而不会返回数组。</span><br></pre></td></tr></table></figure>
<h2 id="node"><a href="#node" class="headerlink" title="node"></a>node</h2><h2 id="各种手写"><a href="#各种手写" class="headerlink" title="各种手写"></a>各种手写</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br></pre></td><td class="code"><pre><span class="line">1.call/apply/bind</span><br><span class="line"></span><br><span class="line">Function.prototype.call = function (context, ...args) &#123;</span><br><span class="line">  var context = context || window;</span><br><span class="line"></span><br><span class="line">  //当前this指向Function.prototype上面的方法</span><br><span class="line">  context.fn = this;</span><br><span class="line">  var result = eval(&quot;context.fn(...args)&quot;);</span><br><span class="line"></span><br><span class="line">  delete context.fn;</span><br><span class="line"></span><br><span class="line">  return result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Function.prototype.apply = function (context, args) &#123;</span><br><span class="line"></span><br><span class="line">  let context = context || window;</span><br><span class="line"></span><br><span class="line">  context.fn = this;</span><br><span class="line"></span><br><span class="line">  let result = eval(&apos;context.fn(...args)&apos;);</span><br><span class="line"></span><br><span class="line">  delete context.fn</span><br><span class="line"></span><br><span class="line">  return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Function.prototype.bind = function (context, ...args) &#123;</span><br><span class="line">  if (typeof this !== &quot;function&quot;) &#123;</span><br><span class="line">    throw new Error(&quot;this must be a function&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  var self = this;</span><br><span class="line">  var fbound = function () &#123;  </span><br><span class="line">    self.apply(</span><br><span class="line">      this instanceof fbound ? this : context,</span><br><span class="line">      args.concat(Array.prototype.slice.call(arguments))</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  if (this.prototype) &#123;</span><br><span class="line">    fbound.prototype = Object.create(this.prototype);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return fbound;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">2.promise</span><br><span class="line"></span><br><span class="line">class APromise &#123;</span><br><span class="line">  //容器状态</span><br><span class="line">  status = &quot;pending&quot;;</span><br><span class="line">  //处理成功时的容器值</span><br><span class="line">  value = &quot;&quot;;</span><br><span class="line">  //处理失败时的原因</span><br><span class="line">  reason = &quot;&quot;;</span><br><span class="line">  //处理成功回调函数     then方法被多次调用时，采用数组进行存储回调函数</span><br><span class="line">  fullFilledCallbacks = [];</span><br><span class="line">  //处理失败回调函数</span><br><span class="line">  rejectedCallBacks = [];</span><br><span class="line">  //处理成功</span><br><span class="line">  resolve = (value) =&gt; &#123;</span><br><span class="line">    if (this.status === &quot;pending&quot;) &#123;</span><br><span class="line">      this.status = &quot;fullFilled&quot;;</span><br><span class="line">      this.value = value;</span><br><span class="line"></span><br><span class="line">      //处理成功回调</span><br><span class="line">      while (this.fullFilledCallbacks.length) &#123;</span><br><span class="line">        this.fullFilledCallbacks.shift()(value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  //处理成败</span><br><span class="line">  reject = (reason) =&gt; &#123;</span><br><span class="line">    if (this.status === &quot;pending&quot;) &#123;</span><br><span class="line">      this.status = &quot;rejected&quot;;</span><br><span class="line">      this.reason = reason;</span><br><span class="line"></span><br><span class="line">      //处理失败回调</span><br><span class="line">      while (this.rejectedCallBacks.length) &#123;</span><br><span class="line">        this.rejectedCallBacks.shift()(reason);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  //处理then方法回调函数返回值</span><br><span class="line">  resolvePromise = (promise, res, resolve, reject) =&gt; &#123;</span><br><span class="line">    //then方法成功回调返回值和then方法返回值一样时</span><br><span class="line">    if (promise === res) &#123;</span><br><span class="line">      //避免循环引用</span><br><span class="line">      reject(new TypeError(&quot;Chaining cycle detected for promise #&lt;Promise&gt;&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //返回值为promise（这里的promise指then方法成功回调时返回的promise）时</span><br><span class="line">    if (res instanceof APromise) &#123;</span><br><span class="line">      //对返回的promise（这里的promise指then方法成功回调时返回的promise）的处理结果进行处理</span><br><span class="line">      //通过resolve/reject对返回的promise（这里的promise指调用then方法时返回的promise）状态进行处理</span><br><span class="line">      res.then(resolve, reject);</span><br><span class="line">    &#125;</span><br><span class="line">    //普通值</span><br><span class="line">    else &#123;</span><br><span class="line">      resolve(res);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  //处理完成   (rejected/pending逻辑参考fullFilled状态)</span><br><span class="line">  then = (onFullFilled, onRejected) =&gt; &#123;</span><br><span class="line">    // 如果不传，就使用默认函数</span><br><span class="line">    onFullFilled =</span><br><span class="line">      typeof onFullFilled === &quot;function&quot; ? onFullFilled : (value) =&gt; value;</span><br><span class="line">    // 如果不传，就使用默认函数</span><br><span class="line">    onRejected =</span><br><span class="line">      typeof onRejected === &quot;function&quot;</span><br><span class="line">        ? onRejected</span><br><span class="line">        : (reason) =&gt; &#123;</span><br><span class="line">            throw reason;</span><br><span class="line">          &#125;;</span><br><span class="line"></span><br><span class="line">    //返回promise用于链式调用</span><br><span class="line">    const promise = new APromise((resolve, reject) =&gt; &#123;</span><br><span class="line">      //成功回调</span><br><span class="line">      if (this.status === &quot;fullFilled&quot;) &#123;</span><br><span class="line">        // 为了拿到上面返回的promise实例对象，需要创建一个微任务等待promise初始化</span><br><span class="line">        //否则，会报ReferenceError: Cannot access &apos;promise&apos; before initialization</span><br><span class="line">        queueMicrotask(() =&gt; &#123;</span><br><span class="line">          //异常捕获</span><br><span class="line">          try &#123;</span><br><span class="line">            const res = onFullFilled(this.value);</span><br><span class="line">            this.resolvePromise(promise, res, resolve, reject);</span><br><span class="line">          &#125; catch (error) &#123;</span><br><span class="line">            reject(error);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      //失败回调</span><br><span class="line">      if (this.status === &quot;rejected&quot;) &#123;</span><br><span class="line">        queueMicrotask(() =&gt; &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">            const res = onRejected(this.reason);</span><br><span class="line">            this.resolvePromise(promise, res, resolve, reject);</span><br><span class="line">          &#125; catch (error) &#123;</span><br><span class="line">            reject(error);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      //处理异步任务</span><br><span class="line">      if (this.status === &quot;pending&quot;) &#123;</span><br><span class="line">        //对成功、失败回调进行存储。异步任务执行成功后再进行处理</span><br><span class="line">        //对成功处理函数存储</span><br><span class="line">        this.fullFilledCallbacks.push(() =&gt; &#123;</span><br><span class="line">          //异常捕获</span><br><span class="line">          try &#123;</span><br><span class="line">            const res = onFullFilled(this.value);</span><br><span class="line">            this.resolvePromise(promise, res, resolve, reject);</span><br><span class="line">          &#125; catch (error) &#123;</span><br><span class="line">            reject(error);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        //对失败处理函数进行存储</span><br><span class="line">        this.rejectedCallBacks.push(() =&gt; &#123;</span><br><span class="line">          queueMicrotask(() =&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">              const res = onRejected(this.reason);</span><br><span class="line">              this.resolvePromise(promise, res, resolve, reject);</span><br><span class="line">            &#125; catch (error) &#123;</span><br><span class="line">              reject(error);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return promise;</span><br><span class="line">  &#125;;</span><br><span class="line">  constructor(executor) &#123;</span><br><span class="line">    //异常捕获</span><br><span class="line">    try &#123;</span><br><span class="line">      //执行器</span><br><span class="line">      executor(this.resolve, this.reject);</span><br><span class="line">    &#125; catch (error) &#123;</span><br><span class="line">      console.log(error);</span><br><span class="line">      this.reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default APromise;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------------</span><br><span class="line">/**</span><br><span class="line"> * Promise.all Promise.race Promise.allSettled Promise.any</span><br><span class="line"> *</span><br><span class="line"> * Promise.all()方法只适合所有异步操作都成功的情况，如果有一个操作失败，就无法满足要求。</span><br><span class="line"> * ES2020 引入了Promise.allSettled()方法，用来确定一组异步操作是否都结束了（不管成功或失败）。</span><br><span class="line"> * Promise.any()跟Promise.race()方法很像，只有一点不同，就是Promise.any()不会因为某个 Promise 变成rejected状态而结束，必须等到所有参数 Promise 变成rejected状态才会结束。</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">Promise.all = function (promiseArr) &#123;</span><br><span class="line">  let index = 0,</span><br><span class="line">    result = [];</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    promiseArr.forEach((p, i) =&gt; &#123;</span><br><span class="line">      Promise.resolve(p).then(</span><br><span class="line">        (val) =&gt; &#123;</span><br><span class="line">          index++;</span><br><span class="line">          result[i] = val;</span><br><span class="line">          if (index === promiseArr.length) &#123;</span><br><span class="line">            resolve(result);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        (err) =&gt; &#123;</span><br><span class="line">          reject(err);</span><br><span class="line">        &#125;</span><br><span class="line">      );</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Promise.race = function (promiseArr) &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    promiseArr.forEach((p) =&gt; &#123;</span><br><span class="line">      Promise.resolve(p).then(</span><br><span class="line">        (val) =&gt; &#123;</span><br><span class="line">          resolve(val);</span><br><span class="line">        &#125;,</span><br><span class="line">        (err) =&gt; &#123;</span><br><span class="line">          reject(err);</span><br><span class="line">        &#125;</span><br><span class="line">      );</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Promise.allSettled = function(promiseArr) &#123;</span><br><span class="line">  let result = []</span><br><span class="line"></span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      promiseArr.forEach((p, i) =&gt; &#123;</span><br><span class="line">          Promise.resolve(p).then(val =&gt; &#123;</span><br><span class="line">              result.push(&#123;</span><br><span class="line">                  status: &apos;fulfilled&apos;,</span><br><span class="line">                  value: val</span><br><span class="line">              &#125;)</span><br><span class="line">              if (result.length === promiseArr.length) &#123;</span><br><span class="line">                  resolve(result)</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;, err =&gt; &#123;</span><br><span class="line">              result.push(&#123;</span><br><span class="line">                  status: &apos;rejected&apos;,</span><br><span class="line">                  reason: err</span><br><span class="line">              &#125;)</span><br><span class="line">              if (result.length === promiseArr.length) &#123;</span><br><span class="line">                  resolve(result)</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise.any = function(promiseArr) &#123;</span><br><span class="line">  let index = 0</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      if (promiseArr.length === 0) return</span><br><span class="line">      promiseArr.forEach((p, i) =&gt; &#123;</span><br><span class="line">          Promise.resolve(p).then(val =&gt; &#123;</span><br><span class="line">              resolve(val)</span><br><span class="line"></span><br><span class="line">          &#125;, err =&gt; &#123;</span><br><span class="line">              index++</span><br><span class="line">              if (index === promiseArr.length) &#123;</span><br><span class="line">                reject(new AggregateError(&apos;All promises were rejected&apos;))</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3.JSON.stringify/JSON.parse</span><br><span class="line"></span><br><span class="line">function jsonStringify(data) &#123;</span><br><span class="line">  let type = typeof data;</span><br><span class="line"></span><br><span class="line">  if (type !== &quot;object&quot;) &#123;</span><br><span class="line">    let result = data;</span><br><span class="line"></span><br><span class="line">    //data 可能是基础数据类型的情况在这里处理</span><br><span class="line"></span><br><span class="line">    if (Number.isNaN(data) || data === Infinity) &#123;</span><br><span class="line">      //NaN 和 Infinity 序列化返回 &quot;null&quot;</span><br><span class="line"></span><br><span class="line">      result = &quot;null&quot;;</span><br><span class="line">    &#125; else if (</span><br><span class="line">      type === &quot;function&quot; ||</span><br><span class="line">      type === &quot;undefined&quot; ||</span><br><span class="line">      type === &quot;symbol&quot;</span><br><span class="line">    ) &#123;</span><br><span class="line">      // 由于 function 序列化返回 undefined，因此和 undefined、symbol 一起处理</span><br><span class="line"></span><br><span class="line">      return undefined;</span><br><span class="line">    &#125; else if (type === &quot;string&quot;) &#123;</span><br><span class="line">      result = &apos;&quot;&apos; + data + &apos;&quot;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return String(result);</span><br><span class="line">  &#125; else if (type === &quot;object&quot;) &#123;</span><br><span class="line">    //null</span><br><span class="line">    if (data === null) &#123;</span><br><span class="line">      return &quot;null&quot;; // 第01讲有讲过 typeof null 为&apos;object&apos;的特殊情况</span><br><span class="line">    &#125;</span><br><span class="line">    //date类型</span><br><span class="line">    else if (data.toJSON &amp;&amp; typeof data.toJSON === &quot;function&quot;) &#123;</span><br><span class="line">      return jsonStringify(data.toJSON());</span><br><span class="line">    &#125;</span><br><span class="line">    //数组</span><br><span class="line">    else if (data instanceof Array) &#123;</span><br><span class="line">      let result = [];</span><br><span class="line"></span><br><span class="line">      //如果是数组，那么数组里面的每一项类型又有可能是多样的</span><br><span class="line"></span><br><span class="line">      data.forEach((item, index) =&gt; &#123;</span><br><span class="line">        if (</span><br><span class="line">          typeof item === &quot;undefined&quot; ||</span><br><span class="line">          typeof item === &quot;function&quot; ||</span><br><span class="line">          typeof item === &quot;symbol&quot;</span><br><span class="line">        ) &#123;</span><br><span class="line">          result[index] = &quot;null&quot;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          result[index] = jsonStringify(item);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      result = &quot;[&quot; + result + &quot;]&quot;;</span><br><span class="line"></span><br><span class="line">      return result.replace(/&apos;/g, &apos;&quot;&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    //普通对象</span><br><span class="line">    else &#123;</span><br><span class="line">      // 处理普通对象</span><br><span class="line"></span><br><span class="line">      let result = [];</span><br><span class="line"></span><br><span class="line">      Object.keys(data).forEach((item, index) =&gt; &#123;</span><br><span class="line">        if (typeof item !== &quot;symbol&quot;) &#123;</span><br><span class="line">          //key 如果是 symbol 对象，忽略</span><br><span class="line"></span><br><span class="line">          if (</span><br><span class="line">            data[item] !== undefined &amp;&amp;</span><br><span class="line">            typeof data[item] !== &quot;function&quot; &amp;&amp;</span><br><span class="line">            typeof data[item] !== &quot;symbol&quot;</span><br><span class="line">          ) &#123;</span><br><span class="line">            //键值如果是 undefined、function、symbol 为属性值，忽略</span><br><span class="line"></span><br><span class="line">            result.push(&apos;&quot;&apos; + item + &apos;&quot;&apos; + &quot;:&quot; + jsonStringify(data[item]));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      return (&quot;&#123;&quot; + result + &quot;&#125;&quot;).replace(/&apos;/g, &apos;&quot;&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------------------------------</span><br><span class="line">eval(`($&#123;&apos;&#123;&quot;p&quot;: 5,&quot;p2&quot;: 52&#125;&apos;&#125;)`)</span><br><span class="line">new Function(`return ($&#123;&apos;&#123;&quot;p&quot;: 5,&quot;p2&quot;: 52&#125;&apos;&#125;)`)()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4.EventEmitter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function EventEmitter() &#123;</span><br><span class="line">  this.__events = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventEmitter.VERSION = &quot;1.0.0&quot;;</span><br><span class="line"></span><br><span class="line">//绑定事件</span><br><span class="line">EventEmitter.prototype.on = function (eventName, event) &#123;</span><br><span class="line">  let events = (this.__events[eventName] = this.__events[eventName] || []);</span><br><span class="line">  //是否存在该事件</span><br><span class="line">  let isExist = events.find((ev) =&gt; ev.listener === (event.listener || event));</span><br><span class="line">  if (!isExist) &#123;</span><br><span class="line">    events.push(</span><br><span class="line">      //对象或函数</span><br><span class="line">      event.listener</span><br><span class="line">        ? event</span><br><span class="line">        : &#123;</span><br><span class="line">            once: false,</span><br><span class="line">            listener: event,</span><br><span class="line">          &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return this;</span><br><span class="line">&#125;;</span><br><span class="line">//触发事件</span><br><span class="line">EventEmitter.prototype.emit = function (eventName, args) &#123;</span><br><span class="line">  let events = this.__events[eventName] || [];</span><br><span class="line"></span><br><span class="line">  //多个事件</span><br><span class="line">  for (let event of events) &#123;</span><br><span class="line">    event.listener.apply(this, args || []);</span><br><span class="line">    if (event.once) &#123;</span><br><span class="line">      this.off(eventName, event);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//执行一次</span><br><span class="line">EventEmitter.prototype.once = function (eventName, event) &#123;</span><br><span class="line">  return this.on(eventName, &#123;</span><br><span class="line">    once: true,</span><br><span class="line">    listener: event.listener || event,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">//移除事件</span><br><span class="line">EventEmitter.prototype.off = function (eventName, event) &#123;</span><br><span class="line">  let events = this.__events[eventName] || [];</span><br><span class="line">  //事件下标</span><br><span class="line">  let eventIndex = events.findIndex(</span><br><span class="line">    (ev) =&gt; ev.listener === (event.listener || event)</span><br><span class="line">  );</span><br><span class="line">  //存在该事件时</span><br><span class="line">  if (eventIndex !== -1) events.splice(eventIndex, 1);</span><br><span class="line">&#125;;</span><br><span class="line">//移除所有事件</span><br><span class="line">EventEmitter.prototype.allOff = function (eventName) &#123;</span><br><span class="line">  if (this.__events[eventName]) this.__events[eventName] = [];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5.继承</span><br><span class="line"></span><br><span class="line">//原型链继承</span><br><span class="line">function Parent1() &#123;</span><br><span class="line">  this.name = &quot;parent1&quot;;</span><br><span class="line"></span><br><span class="line">  this.play = [1, 2, 3];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child1() &#123;</span><br><span class="line">  this.type = &quot;child2&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child1.prototype = new Parent1();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//构造函数继承</span><br><span class="line">function Parent1() &#123;</span><br><span class="line">  this.name = &quot;parent1&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent1.prototype.getName = function () &#123;</span><br><span class="line">  return this.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Child1() &#123;</span><br><span class="line">  Parent1.call(this);</span><br><span class="line"></span><br><span class="line">  this.type = &quot;child1&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//组合继承</span><br><span class="line"></span><br><span class="line">function Parent3() &#123;</span><br><span class="line">  this.name = &quot;parent3&quot;;</span><br><span class="line"></span><br><span class="line">  this.play = [1, 2, 3];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent3.prototype.getName = function () &#123;</span><br><span class="line">  return this.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Child3() &#123;</span><br><span class="line"></span><br><span class="line">  Parent3.call(this);</span><br><span class="line"></span><br><span class="line">  this.type = &quot;child3&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Child3.prototype = new Parent3();</span><br><span class="line"></span><br><span class="line">// 手动挂上构造器，指向自己的构造函数</span><br><span class="line">Child3.prototype.constructor = Child3;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">6.new</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//new 关键字会进行如下的操作：</span><br><span class="line"></span><br><span class="line">//创建一个空的简单JavaScript对象（即&#123;&#125;）；</span><br><span class="line">//为步骤1新创建的对象添加属性__proto__，将该属性链接至构造函数的原型对象 ；</span><br><span class="line">//将步骤1新创建的对象作为this的上下文 ；</span><br><span class="line">//如果该函数没有返回对象，则返回this。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function _new(ctor, ...args) &#123;</span><br><span class="line">  if (typeof ctor !== &quot;function&quot;) &#123;</span><br><span class="line">    throw &quot;ctor must be a function&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let obj = new Object();</span><br><span class="line"></span><br><span class="line">  obj.__proto__ = Object.create(ctor.prototype);</span><br><span class="line"></span><br><span class="line">  //关键  this指向</span><br><span class="line">  let res = ctor.apply(obj, [...args]);</span><br><span class="line"></span><br><span class="line">  let isObject = typeof res === &quot;object&quot; &amp;&amp; res !== null;</span><br><span class="line"></span><br><span class="line">  let isFunction = typeof res === &quot;function&quot;;</span><br><span class="line"></span><br><span class="line">  return isObject || isFunction ? res : obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">7.对象拷贝</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const isComplexDataType = (obj) =&gt;</span><br><span class="line">  (typeof obj === &quot;object&quot; || typeof obj === &quot;function&quot;) &amp;&amp; obj !== null;</span><br><span class="line"></span><br><span class="line">const deepClone = function (obj, hash = new WeakMap()) &#123;</span><br><span class="line">  if (obj.constructor === Date) return new Date(obj); // 日期对象直接返回一个新的日期对象</span><br><span class="line"></span><br><span class="line">  if (obj.constructor === RegExp) return new RegExp(obj); //正则对象直接返回一个新的正则对象</span><br><span class="line"></span><br><span class="line">  //如果循环引用了就用 weakMap 来解决</span><br><span class="line"></span><br><span class="line">  if (hash.has(obj)) return hash.get(obj);</span><br><span class="line"></span><br><span class="line">  let allDesc = Object.getOwnPropertyDescriptors(obj);</span><br><span class="line"></span><br><span class="line">  //遍历传入参数所有键的特性</span><br><span class="line"></span><br><span class="line">  let cloneObj = Object.create(Object.getPrototypeOf(obj), allDesc);</span><br><span class="line"></span><br><span class="line">  //继承原型链</span><br><span class="line"></span><br><span class="line">  hash.set(obj, cloneObj);</span><br><span class="line"></span><br><span class="line">  for (let key of Reflect.ownKeys(obj)) &#123;</span><br><span class="line">    cloneObj[key] =</span><br><span class="line">      isComplexDataType(obj[key]) &amp;&amp; typeof obj[key] !== &quot;function&quot;</span><br><span class="line">        ? deepClone(obj[key], hash)</span><br><span class="line">        : obj[key];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return cloneObj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">8.字符串模板</span><br><span class="line"></span><br><span class="line">function render(template, data) &#123;</span><br><span class="line">  const reg = /\&#123;\&#123;(\w+)\&#125;\&#125;/; // 模板字符串正则</span><br><span class="line">  if (reg.test(template)) &#123; // 判断模板里是否有模板字符串</span><br><span class="line">      const name = reg.exec(template)[1]; // 查找当前模板里第一个模板字符串的字段</span><br><span class="line">      template = template.replace(reg, data[name]); // 将第一个模板字符串渲染</span><br><span class="line">      return render(template, data); // 递归的渲染并返回渲染后的结构</span><br><span class="line">  &#125;</span><br><span class="line">  return template; // 如果模板没有模板字符串直接返回</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">9.防抖/节流</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//节流</span><br><span class="line">//leading 是否第一次执行</span><br><span class="line">//trailing 是否最后一次执行</span><br><span class="line">function throttle(fn, wait, options) &#123;</span><br><span class="line">  var timeout, result;</span><br><span class="line">  var previous = 0;</span><br><span class="line">  if (!options) options = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  var later = function () &#123;</span><br><span class="line">    previous = options.leading === false ? 0 : Date.now();</span><br><span class="line">    timeout = null;</span><br><span class="line">    result = fn.apply(null);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  var throttled = function () &#123;</span><br><span class="line">    var now = Date.now();</span><br><span class="line"></span><br><span class="line">    if (!previous &amp;&amp; options.leading === false) previous = now;</span><br><span class="line"></span><br><span class="line">    //计算剩余时间</span><br><span class="line">    var remaining = wait - (now - previous);</span><br><span class="line">    //立即执行</span><br><span class="line">    if (remaining &lt;= 0 || remaining &gt; wait) &#123;</span><br><span class="line">      //设置options中leading为false时 remaining=wait  不执行函数</span><br><span class="line">      if (timeout) &#123;</span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        timeout = null;</span><br><span class="line">      &#125;</span><br><span class="line">      previous = now;</span><br><span class="line">      result = fn.apply(null);</span><br><span class="line">    &#125;</span><br><span class="line">    //延迟执行</span><br><span class="line">    else if (!timeout &amp;&amp; options.trailing !== false) &#123;</span><br><span class="line">      timeout = setTimeout(later, remaining);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;;</span><br><span class="line">  return throttled;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//防抖</span><br><span class="line"></span><br><span class="line">function debounce(func, wait, immediate) &#123;</span><br><span class="line">  var timeout, result;</span><br><span class="line"></span><br><span class="line">  var later = function () &#123;</span><br><span class="line">    timeout = null;</span><br><span class="line">    result = func.apply(null);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  var debounced = function () &#123;</span><br><span class="line">    if (timeout) clearTimeout(timeout);</span><br><span class="line">    //立即执行</span><br><span class="line">    if (immediate) &#123;</span><br><span class="line">      //存在定时器时无法立即执行（通俗讲就是wait秒内该事件又触发了，需要再等wait秒才能触发）</span><br><span class="line">      var callNow = !timeout;</span><br><span class="line">      timeout = setTimeout(later, wait);</span><br><span class="line">      //不存在定时器，立即执行该事件</span><br><span class="line">      if (callNow) result = func.apply(null);</span><br><span class="line">    &#125;</span><br><span class="line">    //指定时间后执行</span><br><span class="line">    else &#123;</span><br><span class="line">      timeout = setTimeout(later, wait);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return debounced;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">10.柯里化</span><br><span class="line">//什么叫函数柯里化？其实就是将使用多个参数的函数转换成一系列使用一个参数的函数的技术。</span><br><span class="line">function curry(fn) &#123;</span><br><span class="line">  let func;</span><br><span class="line"></span><br><span class="line">  func = (...args) =&gt; &#123;</span><br><span class="line">    if (args.length === fn.length) return fn(...args);</span><br><span class="line">    else return (...arg) =&gt; func(...arg, ...args);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return func;</span><br><span class="line">&#125;</span><br><span class="line">11.偏函数</span><br><span class="line">//什么是偏函数？偏函数就是将一个 n 参的函数转换成固定 x 参的函数，剩余参数（n - x）将在下次调用全部传入。</span><br><span class="line"> function partial(fn, ...args) &#123;</span><br><span class="line">  return (...arg) =&gt; &#123;</span><br><span class="line">      return fn(...args, ...arg)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">12.instance</span><br><span class="line"></span><br><span class="line">function instanceOf(left, right) &#123;</span><br><span class="line">  let proto = left.__proto__;</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    if (proto === null) return false;</span><br><span class="line">    if (proto === right.prototype) &#123;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">    proto = proto.__proto__;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">13.sleep</span><br><span class="line">function sleep(time) &#123;</span><br><span class="line">  return new Promise((resolve) =&gt; setTimeout(resolve, time));</span><br><span class="line">&#125;</span><br><span class="line">async function testSleep() &#123;</span><br><span class="line">  console.log(1);</span><br><span class="line">  await sleep(2000);</span><br><span class="line">  console.log(2);</span><br><span class="line">&#125;</span><br><span class="line">testSleep();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">14.Object.create</span><br><span class="line">Object.create2 = function (proto, propertyObject = undefined) &#123;</span><br><span class="line">  if (typeof proto !== &quot;object&quot; &amp;&amp; typeof proto !== &quot;function&quot;) &#123;</span><br><span class="line">    throw new TypeError(&quot;Object prototype may only be an Object or null.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  if (propertyObject == null) &#123;</span><br><span class="line">    new TypeError(&quot;Cannot convert undefined or null to object&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  function F() &#123;&#125;</span><br><span class="line">  F.prototype = proto;</span><br><span class="line">  const obj = new F();</span><br><span class="line">  if (propertyObject != undefined) &#123;</span><br><span class="line">    Object.defineProperties(obj, propertyObject);</span><br><span class="line">  &#125;</span><br><span class="line">  if (proto === null) &#123;</span><br><span class="line">    // 创建一个没有原型对象的对象，Object.create(null)</span><br><span class="line">    obj.__proto__ = null;</span><br><span class="line">  &#125;</span><br><span class="line">  return obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/学习/">学习</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/学习/">学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网站/">网站</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/资源/">资源</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-optimize" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2021/08/01/optimize/" class="article-date">
      <time datetime="2021-07-31T16:00:00.000Z" itemprop="datePublished">2021-08-01</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/08/01/optimize/">前端性能优化</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="首屏"><a href="#首屏" class="headerlink" title="首屏"></a>首屏</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">懒加载</span><br><span class="line">以百度图片列表页为例，可视区域范围内的图片先请求加载，一般会根据不同手机机型估算一个最大数据，比如 ihone12 Pro 屏幕比较大， 4 行 8 条数据，我们就先请求 8 条数据，用来在可视区域展示，其他位置采用占位符填充，在滑动到目标区域位置后，才使用真实的图片填充。</span><br><span class="line">这样，通过使用懒加载，可以最大限度降低了数据接口传输阶段的时间。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">接口缓存</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">静态资源缓存</span><br><span class="line">资源长期不变的话，比如 1 年都不怎么变化，我们可以使用强缓存，如 Cache-Control 来实现。</span><br><span class="line">具体来说可以通过设置 Cache-Control:max-age=31536000，来让浏览器在一年内直接使用本地缓存文件，而不是向服务端发出请求。</span><br><span class="line">**如果资源本身随时会发生改动的，可以通过设置 Etag 实现协商缓存。</span><br><span class="line">**具体来说，在初次请求资源时，设置 Etag（比如使用资源的 md5 作为 Etag），并且返回 200 的状态码，之后请求时带上 If-none-match 字段，来询问服务器当前版本是否可用。</span><br><span class="line">如果服务端数据没有变化，会返回一个 304 的状态码给客户端，告诉客户端不需要请求数据，直接使用之前缓存的数据即可。</span><br><span class="line"></span><br><span class="line">离线化</span><br><span class="line">可以通过 Webpack 的 prerender-spa-plugin 来实现预渲染，进而实现离线化。</span><br><span class="line">// webpack.conf.js</span><br><span class="line"></span><br><span class="line">var path = require(&apos;path&apos;)</span><br><span class="line"></span><br><span class="line">var PrerenderSpaPlugin = require(&apos;prerender-spa-plugin&apos;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line"></span><br><span class="line">  // ...</span><br><span class="line"></span><br><span class="line">  plugins: [</span><br><span class="line"></span><br><span class="line">    new PrerenderSpaPlugin(</span><br><span class="line"></span><br><span class="line">      // 编译后的html需要存放的路径</span><br><span class="line"></span><br><span class="line">      path.join(__dirname, &apos;../dist&apos;),</span><br><span class="line"></span><br><span class="line">      // 列出哪些路由需要预渲染</span><br><span class="line"></span><br><span class="line">      [ &apos;/&apos;, &apos;/about&apos;, &apos;/contact&apos; ]</span><br><span class="line"></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">并行化</span><br><span class="line">并行化则是在请求通道上功夫，解决请求阻塞问题，进而减少首屏时间。借助于HTTP 2.0 的多路复用方案来解决。</span><br></pre></td></tr></table></figure>
<h2 id="白屏"><a href="#白屏" class="headerlink" title="白屏"></a>白屏</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">基于影响白屏时间长短的两个主要因素来解决——DNS 查询和首字符展示。</span><br><span class="line"></span><br><span class="line">DNS 查询优化</span><br><span class="line">前端侧，可以通过在页面中加入 dns-prefetch，在静态资源请求之前对域名进行解析，从而减少用户进入页面的等待时间。如下所示：</span><br><span class="line">&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot; /&gt;</span><br><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;https://s.google.com/&quot; &gt;</span><br><span class="line">其中第一行中的 x-dns-prefetch-control 表示开启 DNS 预解析功能，第二行 dns-prefetch 表示强制对 s.google.com 的域名做预解析。这样在 s.google.com 的资源请求开始前，DNS 解析完成，后续请求就不需要重复做解析了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">客户端侧呢？可以在启动 App 时，同步创建一个肉眼不可见的 WebView（例如 1*1 像素的 webview），将常用的静态资源路径写入这个 WebView 中，然后对它做域名解析并放入缓存中。</span><br><span class="line">这样后面需要使用 WebView 打开真正所需的页面时，由于已经做过域名解析了，客户端直接从缓存中获取即可。</span><br><span class="line"></span><br><span class="line">如果是端外页面，因为没在 App 里面，就没法使用 1*1 WebView 的策略了，我们可以使用 iframe ，也能达到类似效果。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">首字符展示优化</span><br><span class="line">使用骨架屏。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">卡顿治理</span><br><span class="line">如果问题出在前端，一般和以下两种情形有关：浏览器的主线程与合成线程调度不合理，以及计算耗时操作。</span><br><span class="line">一般来说，主线程主要负责运行 JavaScript，计算 CSS 样式，元素布局，然后交给合成线程，合成线程主要负责绘制。</span><br><span class="line">比如红包元素从 margin-left:-10px 渲染到 margin-left:0，主线程需要计算样式 margin-left:-9px，margin-left:-8px，一直到 margin-left:0，每一次主线程计算样式后，合成线程都需要绘制到 GPU 再渲染到屏幕上，来来回回需要进行 10 次主线程渲染，10 次合成线程渲染，这给浏览器造成很大压力，从而出现卡顿。</span><br><span class="line">如何解决呢？我们可以利用 transform 来做，比如 tranform:translate(-10px,0) 到 transform:translate(0,0)，主线程只需要进行一次tranform:translate(-10px,0) 到 transform:translate(0,0)，然后合成线程去一次将 -10px 转换到 0px。这样的话，总计 11 次计算，可以减少 9 步操作，假设一次 10ms，将减少 90ms。</span><br><span class="line">计算耗时操作</span><br><span class="line">空间换时间方面，比如你需要频繁增加删除很多 DOM 元素，这时候一定会很卡，在对 DOM 元素增删的过程中最好先在 DocumentFragment （DOM文档碎片）上操作，而不是直接在 DOM上操作。只在最后一步操作完成后，将所有 DocumentFragment 的变动更新到 DOM上，从而解决频繁更新 DOM 带来的卡顿问题。</span><br></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/学习/">学习</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/学习/">学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网站/">网站</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/资源/">资源</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-test" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2021/08/01/test/" class="article-date">
      <time datetime="2021-07-31T16:00:00.000Z" itemprop="datePublished">2021-08-01</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/08/01/test/">前端测试</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/学习/">学习</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/学习/">学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网站/">网站</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/资源/">资源</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-node" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2021/07/18/node/" class="article-date">
      <time datetime="2021-07-17T16:00:00.000Z" itemprop="datePublished">2021-07-18</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/07/18/node/">node学习</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="process"><a href="#process" class="headerlink" title="process"></a>process</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">process.argv  //运行参数</span><br><span class="line">process.uptime() 脚本运行时间</span><br><span class="line">process.memoryUsage //内存</span><br><span class="line">process.cpuUsage  //cpu</span><br></pre></td></tr></table></figure>
<h2 id="命令行配置"><a href="#命令行配置" class="headerlink" title="命令行配置"></a>命令行配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#! /usr/bin/env node</span><br></pre></td></tr></table></figure>
<h2 id="fs"><a href="#fs" class="headerlink" title="fs"></a>fs</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">fs.writeFile(&apos;data.txt&apos;,&apos;123&apos;,&#123;</span><br><span class="line">    mode:438,//可读可写不可执行</span><br><span class="line">    flag:&apos;r+&apos;,  //  r+:不会清除原文件内容   w+:会先清除原文件内容再写入</span><br><span class="line">    encoding:&apos;utf-8&apos;</span><br><span class="line">&#125;,(err)=&gt;&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">fs.appendFile 追加文件</span><br><span class="line"></span><br><span class="line">fs.copyFile 拷贝文件</span><br><span class="line"></span><br><span class="line">fs.watchFile 监听文件修改</span><br><span class="line"></span><br><span class="line">fs.watchFile(&apos;data.txt&apos;,&#123;</span><br><span class="line">interval:20 //每20ms监听一次</span><br><span class="line">&#125;,(curr,prev)=&gt;&#123;</span><br><span class="line">//curr.mtime 当前文件修改时间</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fs.unwatchFile 取消文件修改监听</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">大文件读写</span><br><span class="line"></span><br><span class="line">//read:将数据从磁盘文件写入到buffer中</span><br><span class="line">let buf=Buffer.alloc(10)</span><br><span class="line"></span><br><span class="line">fs.open(&apos;data.txt&apos;,&apos;r&apos;,(err,rfd)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">//rfd:文件标识</span><br><span class="line">//buf 当前缓冲区</span><br><span class="line">//offset 从buf的哪个位置开始执行写入</span><br><span class="line">//length 写入长度</span><br><span class="line">//position 从文件哪个位置开始读取</span><br><span class="line">fs.read(rfd,buf,1,4,0,(err,readBytes)=&gt;&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//write:将缓冲区内容写入到磁盘中</span><br><span class="line"> buf=Buffer.from(&apos;aaaaaaaddfgdsg&apos;)</span><br><span class="line"></span><br><span class="line">fs.open(&apos;b.txt&apos;,&apos;w&apos;,(err,wfd)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">fs.write(wfd,buf,1,4,0,(err,written,buffer)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">//written 写入字节数</span><br><span class="line">//buffer：数据源 buf=Buffer.from(&apos;aaaaaaaddfgdsg&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  fs.close(wrd)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------------------------------------------</span><br><span class="line"></span><br><span class="line">文件拷贝</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let buf=Buffer.alloc(10)</span><br><span class="line">const BUFFER_SIZE=buf.length</span><br><span class="line">let readOffset=0</span><br><span class="line"></span><br><span class="line">fs.open(&apos;a.txt&apos;,&apos;r&apos;,(err,rfd)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">fs.open(&apos;b.txt&apos;,&apos;w&apos;,(err,wfd)=&gt;&#123;</span><br><span class="line"> function next()&#123;</span><br><span class="line"> </span><br><span class="line"> fs.read(rfd,buf,0,BUFFER_SIZE,readOffset,(err,readBytes)=&gt;&#123;</span><br><span class="line">     if(!readBytes)&#123;</span><br><span class="line">	 </span><br><span class="line">	   fs.close(rfd,()=&gt;&#123;&#125;)</span><br><span class="line">	   fs.close(wfd,()=&gt;&#123;&#125;)</span><br><span class="line">	   </span><br><span class="line">	   return</span><br><span class="line">	 &#125;</span><br><span class="line">	 readOffset+= readBytes</span><br><span class="line">	 fs.write(wfd,buf,0,readBytes,(err,written)=&gt;&#123;</span><br><span class="line">	 </span><br><span class="line">	   next()</span><br><span class="line">	 &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  next()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">目录操作</span><br><span class="line"></span><br><span class="line">access:判断文件或目录是否具有操作权限</span><br><span class="line">stat:获取目录及文件信息</span><br><span class="line">mkdir:创建目录   &#123;recursive:true //递归创建&#125;</span><br><span class="line">rmdir:删除目录   &#123;recursive:true //递归删除&#125;</span><br><span class="line">readdir:读取目录内容</span><br><span class="line">unlink:删除指定文件</span><br></pre></td></tr></table></figure>
<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">CommonJS</span><br><span class="line">语言层面的规范，主要用于Node.js</span><br><span class="line">规定模块化分为引入、定义、标识符三部分</span><br><span class="line">Module在任意模块中可直接使用包含模块信息</span><br><span class="line">Require接受标识符，加载目标模块</span><br><span class="line">Exports与module.exports都能导出模块数据</span><br><span class="line">CommonJS定义模块加载时同步的，不适用于浏览器</span><br><span class="line"></span><br><span class="line">--------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">module属性</span><br><span class="line">任意js文件就是一个模块，可以直接使用module属性</span><br><span class="line">id:返回模块标识符，一般是一个绝对路径</span><br><span class="line">filename:返回文件模块的绝对路径</span><br><span class="line">loaded:返回布尔值，标识模块是否完成加载</span><br><span class="line">parent:返回对象存放调用当前模块的模块</span><br><span class="line">children:返回数组，存放当前模块调用的其他模块</span><br><span class="line">exports:返回当前模块需要暴露的内容</span><br><span class="line">paths:返回数组，存放不同目录下的node_modules位置(路径查找策略,逐层向上查找)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">模块加载流程</span><br><span class="line">路径分析：依据标识符确定模块位置(核心模块根据package.json文件查找入口)</span><br><span class="line">文件定位：确定目标模块中具体的文件及文件类型</span><br><span class="line">编译执行：采用对应的方式完成文件的编译执行</span><br><span class="line"></span><br><span class="line">js文件的编译执行</span><br><span class="line">使用fs模块同步读入目标文件内容</span><br><span class="line">对内容进行语法包装，生成可执行js函数</span><br><span class="line">调用函数时传入exports/module/require等属性值</span><br><span class="line"></span><br><span class="line">json文件编译执行</span><br><span class="line">将读取到的内容通过JSON.parse()进行解析</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">缓存优先原则</span><br><span class="line">使用路径作为索引进行模块缓存</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vm模块</span><br><span class="line"></span><br><span class="line">const fs=require(&apos;fs&apos;)</span><br><span class="line">const vm=require(&apos;vm&apos;)</span><br><span class="line">let content=fs.readFileSync(&apos;test.txt&apos;,&apos;utf-8&apos;)</span><br><span class="line"></span><br><span class="line">eval(content) //处于同一上下文,不是独立作用域</span><br><span class="line">new Function() //操作麻烦</span><br><span class="line"></span><br><span class="line">vm.runInThisContext(content)</span><br></pre></td></tr></table></figure>
<h2 id="事件环"><a href="#事件环" class="headerlink" title="事件环"></a>事件环</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">常见宏任务：setTimeout()/setInterval()/setImmediate()/点击和键盘事件/...</span><br><span class="line">常见微任务：promise.then()/promise.catch()/new MutationObserver()/process.nextTick()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------------</span><br><span class="line">node环境</span><br><span class="line">timers:执行setTimeout与setInterval回调</span><br><span class="line">pending callbacks:执行系统操作的回调，例如tcp、udp</span><br><span class="line">idle,prepare:只在系统内部调用</span><br><span class="line">poll:执行与I/O相关的回调,轮询等待新的链接和请求等事件。V8 引擎将 JS 代码解析并传入 Libuv 引擎后首先进入此阶段。如果此阶段任务队列已经执行完了，则进入 check 阶段执行 setImmediate 回调（如果有 setImmediate），或等待新的任务进来（如果没有 setImmediate）。在等待新的任务时，如果有 timers 计时到期，则会直接进入 timers 阶段。此阶段可能会阻塞等待。</span><br><span class="line">check:执行setImmediate中的回调</span><br><span class="line">close callbacks:执行close事件的回调</span><br><span class="line">----------------------------------</span><br><span class="line"></span><br><span class="line">Nodejs完整事件环</span><br><span class="line">执行同步代码，将不同任务添加至相应的队列</span><br><span class="line">所有同步代码执行完成后会去执行满足条件的微任务</span><br><span class="line">所有微任务代码执行完会执行timer队列中满足得宏任务</span><br><span class="line">timers中所有宏任务执行完成后就会依次切换队列（在完成队列切换之前会先清空微任务代码）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------------------------------------</span><br><span class="line"></span><br><span class="line">浏览器、node环境</span><br><span class="line">任务队列数不同</span><br><span class="line">微任务执行时机不同：二者都会在同步代码执行完毕后执行微任务、浏览器平台下每当一个宏任务执行完毕后就会清空微任务、node环境下在事件队列切换时会去清空微任务队列(新版node（NodeJS 11 ）与浏览器保持一致)</span><br><span class="line">微任务优先级：浏览器环境微任务存放于事件队列，先进先出、node环境中process.nextTick先于promise.then执行</span><br><span class="line"></span><br><span class="line">-------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">setTimeout(()=&gt;&#123;&#125;,0)  不稳定，会产生延时     // timers</span><br><span class="line">setImmediate(()=&gt;&#123;&#125;)                         // check</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fs.readFile(&apos;./test.js&apos;,()=&gt;&#123;     // poll</span><br><span class="line">setTimeout(()=&gt;&#123;&#125;,0)  </span><br><span class="line">setImmediate(()=&gt;&#123;&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">-------------------------------</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    console.log(&apos;timeout&apos;);</span><br><span class="line"></span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">Promise.resolve().then(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    console.error(&apos;promise&apos;)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">process.nextTick(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    console.error(&apos;nextTick&apos;)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 输出：nextTick、promise、timeout</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------------------</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  console.log(&apos;timeout&apos;);</span><br><span class="line"></span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">setImmediate(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  console.log(&apos;setImmediate&apos;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 输出：timeout、 setImmediate</span><br><span class="line"></span><br><span class="line">分析上面代码，第一轮循环后，分别将 setTimeout  和 setImmediate 加入了各自阶段的任务队列。</span><br><span class="line">第二轮循环首先进入timers 阶段，执行定时器队列回调，然后 pending callbacks和poll 阶段没有任务，</span><br><span class="line">因此进入check 阶段执行 setImmediate 回调。所以最后输出为“timeout”、“setImmediate”。</span><br><span class="line">当然这里还有种理论上的极端情况，就是第一轮循环结束后耗时很短，导致 setTimeout 的计时还没结束，此时第二轮循环则会先执行 setImmediate 回调。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------------------------------</span><br><span class="line">const fs = require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">fs.readFile(__filename, (data) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    console.log(&apos;readFile&apos;);</span><br><span class="line"></span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">        console.log(&apos;timeout&apos;);</span><br><span class="line"></span><br><span class="line">    &#125;, 0);</span><br><span class="line"></span><br><span class="line">    setImmediate(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">        console.log(&apos;setImmediate&apos;);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 输出：readFile、setImmediate、timeout</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如上面代码所示：</span><br><span class="line"></span><br><span class="line">第一轮循环没有需要执行的异步任务队列；</span><br><span class="line"></span><br><span class="line">第二轮循环 timers 等阶段都没有任务，只有 poll 阶段有 I/O 回调任务，即输出“readFile”；</span><br><span class="line"></span><br><span class="line">参考前面事件阶段的说明，接下来，poll 阶段会检测如果有 setImmediate 的任务队列则进入 check 阶段，否则再进行判断，如果有定时器任务回调，则回到 timers 阶段，所以应该进入 check 阶段执行 setImmediate，输出“setImmediate”；</span><br><span class="line"></span><br><span class="line">然后进入最后的 close callbacks 阶段，本次循环结束；</span><br><span class="line"></span><br><span class="line">最后进行第三轮循环，进入 timers 阶段，输出“timeout”。</span><br><span class="line"></span><br><span class="line">所以最终输出“setImmediate”在“timeout”之前。可见这两者的执行顺序与当前执行的阶段有关系。</span><br></pre></td></tr></table></figure>
<h2 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line">readable  可读流</span><br><span class="line">writeable 可写流</span><br><span class="line">duplex 双工流，可读可写</span><br><span class="line">transform 转换流，可读可写可转换</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------------------------------</span><br><span class="line"></span><br><span class="line">readable事件：当流中存在可读取数据时触发</span><br><span class="line">data事件：当流中数据传给消费者后触发</span><br><span class="line"></span><br><span class="line">const &#123;Readable&#125; = require(&apos;stream&apos;)</span><br><span class="line"></span><br><span class="line">// 模拟底层数据</span><br><span class="line">let source = [&apos;aa&apos;, &apos;bbb&apos;, &apos;ccc&apos;]</span><br><span class="line"></span><br><span class="line">// 自定义类继承 Readable</span><br><span class="line">class MyReadable extends Readable&#123;</span><br><span class="line">  constructor(source) &#123;</span><br><span class="line">    super()</span><br><span class="line">    this.source = source</span><br><span class="line">  &#125;</span><br><span class="line">  _read() &#123;</span><br><span class="line">    let data = this.source.shift() || null </span><br><span class="line">    this.push(data)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实例化</span><br><span class="line">let myReadable = new MyReadable(source)</span><br><span class="line"></span><br><span class="line">/* myReadable.on(&apos;readable&apos;, () =&gt; &#123;</span><br><span class="line">  let data = null </span><br><span class="line">  while((data = myReadable.read(2)) != null) &#123;</span><br><span class="line">    console.log(data.toString())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;) */</span><br><span class="line"></span><br><span class="line">myReadable.on(&apos;data&apos;, (chunk) =&gt; &#123;</span><br><span class="line">  console.log(chunk.toString())</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----------------------------------------------------</span><br><span class="line"></span><br><span class="line">const &#123;Writable&#125; = require(&apos;stream&apos;)</span><br><span class="line"></span><br><span class="line">class MyWriteable extends Writable&#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super()</span><br><span class="line">  &#125;</span><br><span class="line">  _write(chunk, en, done) &#123;</span><br><span class="line">    process.stdout.write(chunk.toString() + &apos;&lt;----&apos;)</span><br><span class="line">    process.nextTick(done)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myWriteable = new MyWriteable()</span><br><span class="line"></span><br><span class="line">myWriteable.write(&apos;aaa&apos;, &apos;utf-8&apos;, () =&gt; &#123;</span><br><span class="line">  console.log(&apos;end&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--------------------------------------------</span><br><span class="line"></span><br><span class="line">const fs = require(&apos;fs&apos;)</span><br><span class="line"></span><br><span class="line">let ws = fs.createWriteStream(&apos;test.txt&apos;, &#123;</span><br><span class="line">  highWaterMark: 3</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">let flag = ws.write(&apos;1&apos;)</span><br><span class="line">console.log(flag)</span><br><span class="line"></span><br><span class="line">flag = ws.write(&apos;2&apos;)</span><br><span class="line">console.log(flag)</span><br><span class="line"></span><br><span class="line">// 如果 flag 为 false 并不是说明当前数据不能被执行写入</span><br><span class="line">// </span><br><span class="line"></span><br><span class="line">ws.on(&apos;drain&apos;, () =&gt; &#123;</span><br><span class="line">  console.log(&apos;11&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第一次调用write方法时是将数据直接写入文件中</span><br><span class="line">第二次开始write方法将数据写入缓存当中</span><br><span class="line">生产速度和消费速度是不一样的，一般情况下生产速度要比消费速度快很多</span><br><span class="line">当flag为false之后并不意味着当前的数据不能被写入，我们应该告知生产者当前数据消费速度已经跟不上生产速度了，这个时候，一般我们会将可读流修改为暂停模式</span><br><span class="line">当数据生产者暂停之后，消费者会慢慢消化缓存中的数据直到可以再次被执行写入操作</span><br><span class="line">当缓冲区可以继续写入数据时，通过drain事件让生产者知道</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 需求：“呜呜呜呜” 写入指定的文件</span><br><span class="line"> * 01 一次性写入</span><br><span class="line"> * 02 分批写入</span><br><span class="line"> * 对比：</span><br><span class="line"> */</span><br><span class="line">let fs = require(&apos;fs&apos;)</span><br><span class="line"></span><br><span class="line">let ws = fs.createWriteStream(&apos;test.txt&apos;, &#123;</span><br><span class="line">  highWaterMark: 3</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// ws.write(&apos;呜呜呜呜&apos;)</span><br><span class="line">let source = &quot;呜呜呜呜&quot;.split(&apos;&apos;)</span><br><span class="line">let num = 0</span><br><span class="line">let flag = true</span><br><span class="line"></span><br><span class="line">function executeWrite () &#123;</span><br><span class="line">  flag = true</span><br><span class="line">  while(num !== 4 &amp;&amp; flag) &#123;</span><br><span class="line">    flag = ws.write(source[num])</span><br><span class="line">    num++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">executeWrite()</span><br><span class="line"></span><br><span class="line">ws.on(&apos;drain&apos;, () =&gt; &#123;</span><br><span class="line">  console.log(&apos;drain 执行了&apos;)</span><br><span class="line">  executeWrite()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------------------------------------------------------</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/学习/">学习</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/学习/">学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网站/">网站</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/资源/">资源</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-performance" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2021/05/01/performance/" class="article-date">
      <time datetime="2021-04-30T16:00:00.000Z" itemprop="datePublished">2021-05-01</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/05/01/performance/">performance</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="window-performance"><a href="#window-performance" class="headerlink" title="window.performance"></a>window.performance</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line">connectEnd	HTTP（TCP） 返回浏览器与服务器之间的连接建立时的时间戳。如果建立的是持久连接，则返回值等同于fetchStart属性的值。连接建立指的是所有握手和认证过程全部结束。</span><br><span class="line">connectStart	HTTP（TCP） 域名查询结束的时间戳。如果使用了持续连接(persistent connection)，或者这个信息存储到了缓存或者本地资源上，这个值将和 fetchStart一致。</span><br><span class="line">domComplete	当前文档解析完成，即Document.readyState 变为 &apos;complete&apos;且相对应的readystatechange 被触发时的时间戳</span><br><span class="line">domContentLoadedEventEnd	当所有需要立即执行的脚本已经被执行（不论执行顺序）时的时间戳。</span><br><span class="line">domContentLoadedEventStart	当解析器发送DOMContentLoaded 事件，即所有需要被执行的脚本已经被解析时的时间戳。</span><br><span class="line">domInteractive	当前网页DOM结构结束解析、开始加载内嵌资源时（即Document.readyState属性变为“interactive”、相应的readystatechange事件触发时）的时间戳。</span><br><span class="line">domLoading	当前网页DOM结构开始解析时（即Document.readyState属性变为“loading”、相应的 readystatechange事件触发时）的时间戳。</span><br><span class="line">domainLookupEnd	DNS 域名查询完成的时间。如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等</span><br><span class="line">domainLookupStart	DNS 域名查询开始的UNIX时间戳。如果使用了持续连接(persistent connection)，或者这个信息存储到了缓存或者本地资源上，这个值将和fetchStart一致。</span><br><span class="line">fetchStart	浏览器准备好使用HTTP请求来获取(fetch)文档的时间戳。这个时间点会在检查任何应用缓存之前。</span><br><span class="line">loadEventEnd	当load事件结束，即加载事件完成时的时间戳。如果这个事件还未被发送，或者尚未完成，它的值将会是0.</span><br><span class="line">loadEventStart	load事件被发送时的时间戳。如果这个事件还未被发送，它的值将会是0。</span><br><span class="line">navigationStart	同一个浏览器上一个页面卸载(unload)结束时的时间戳。如果没有上一个页面，这个值会和fetchStart相同。</span><br><span class="line">redirectEnd	最后一个HTTP重定向完成时（也就是说是HTTP响应的最后一个比特直接被收到的时间）的时间戳。如果没有重定向，或者重定向中的一个不同源，这个值会返回0.</span><br><span class="line">redirectStart	第一个HTTP重定向开始时的时间戳。如果没有重定向，或者重定向中的一个不同源，这个值会返回0。</span><br><span class="line">requestStart	返回浏览器向服务器发出HTTP请求时（或开始读取本地缓存时）的时间戳。</span><br><span class="line">responseEnd	返回浏览器从服务器收到（或从本地缓存读取，或从本地资源读取）最后一个字节时（如果在此之前HTTP连接已经关闭，则返回关闭时）的时间戳。</span><br><span class="line">responseStart	返回浏览器从服务器收到（或从本地缓存读取）第一个字节时的时间戳。如果传输层在开始请求之后失败并且连接被重开，该属性将会被数制成新的请求的相对应的发起时间</span><br><span class="line">secureConnectionStart	HTTPS 返回浏览器与服务器开始安全链接的握手时的时间戳。如果当前网页不要求安全连接，则返回0。</span><br><span class="line">unloadEventEnd	和 unloadEventStart 相对应，unload事件处理完成时的时间戳。如果没有上一个页面,这个值会返回0。</span><br><span class="line">unloadEventStart	上一个页面unload事件抛出时的时间戳。如果没有上一个页面，这个值会返回0。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 获取 performance 数据</span><br><span class="line">var performance = &#123;  </span><br><span class="line">    // memory 是非标准属性，只在 Chrome 有</span><br><span class="line">    //内存</span><br><span class="line">    memory: &#123;</span><br><span class="line">        usedJSHeapSize:  16100000, // JS 对象（包括V8引擎内部对象）占用的内存，一定小于 totalJSHeapSize</span><br><span class="line">        totalJSHeapSize: 35100000, // 可使用的内存</span><br><span class="line">        jsHeapSizeLimit: 793000000 // 内存大小限制</span><br><span class="line">    &#125;,</span><br><span class="line"> </span><br><span class="line">    navigation: &#123;</span><br><span class="line">        redirectCount: 0, // 如果有重定向的话，页面通过几次重定向跳转而来</span><br><span class="line">        type: 0           // 0   即 TYPE_NAVIGATENEXT 正常进入的页面（非刷新、非重定向等）</span><br><span class="line">                          // 1   即 TYPE_RELOAD       通过 window.location.reload() 刷新的页面</span><br><span class="line">                          // 2   即 TYPE_BACK_FORWARD 通过浏览器的前进后退按钮进入的页面（历史记录）</span><br><span class="line">                          // 255 即 TYPE_UNDEFINED    非以上方式进入的页面</span><br><span class="line">    &#125;,</span><br><span class="line"> </span><br><span class="line">    timing: &#123;</span><br><span class="line">        // 在同一个浏览器上下文中，前一个网页（与当前页面不一定同域）unload 的时间戳，如果无前一个网页 unload ，则与 fetchStart 值相等</span><br><span class="line">        navigationStart: 1441112691935,</span><br><span class="line"> </span><br><span class="line">        // 前一个网页（与当前页面同域）unload 的时间戳，如果无前一个网页 unload 或者前一个网页与当前页面不同域，则值为 0</span><br><span class="line">        unloadEventStart: 0,</span><br><span class="line"> </span><br><span class="line">        // 和 unloadEventStart 相对应，返回前一个网页 unload 事件绑定的回调函数执行完毕的时间戳</span><br><span class="line">        unloadEventEnd: 0,</span><br><span class="line"> </span><br><span class="line">        // 第一个 HTTP 重定向发生时的时间。有跳转且是同域名内的重定向才算，否则值为 0 </span><br><span class="line">        redirectStart: 0,</span><br><span class="line"> </span><br><span class="line">        // 最后一个 HTTP 重定向完成时的时间。有跳转且是同域名内部的重定向才算，否则值为 0 </span><br><span class="line">        redirectEnd: 0,</span><br><span class="line"> </span><br><span class="line">        // 浏览器准备好使用 HTTP 请求抓取文档的时间，这发生在检查本地缓存之前</span><br><span class="line">        fetchStart: 1441112692155,</span><br><span class="line"> </span><br><span class="line">        // DNS 域名查询开始的时间，如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等</span><br><span class="line">        domainLookupStart: 1441112692155,</span><br><span class="line"> </span><br><span class="line">        // DNS 域名查询完成的时间，如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等</span><br><span class="line">        domainLookupEnd: 1441112692155,</span><br><span class="line"> </span><br><span class="line">        // HTTP（TCP） 开始建立连接的时间，如果是持久连接，则与 fetchStart 值相等</span><br><span class="line">        // 注意如果在传输层发生了错误且重新建立连接，则这里显示的是新建立的连接开始的时间</span><br><span class="line">        connectStart: 1441112692155,</span><br><span class="line"> </span><br><span class="line">        // HTTP（TCP） 完成建立连接的时间（完成握手），如果是持久连接，则与 fetchStart 值相等</span><br><span class="line">        // 注意如果在传输层发生了错误且重新建立连接，则这里显示的是新建立的连接完成的时间</span><br><span class="line">        // 注意这里握手结束，包括安全连接建立完成、SOCKS 授权通过</span><br><span class="line">        connectEnd: 1441112692155,</span><br><span class="line"> </span><br><span class="line">        // HTTPS 连接开始的时间，如果不是安全连接，则值为 0</span><br><span class="line">        secureConnectionStart: 0,</span><br><span class="line"> </span><br><span class="line">        // HTTP 请求读取真实文档开始的时间（完成建立连接），包括从本地读取缓存</span><br><span class="line">        // 连接错误重连时，这里显示的也是新建立连接的时间</span><br><span class="line">        requestStart: 1441112692158,</span><br><span class="line"> </span><br><span class="line">        // HTTP 开始接收响应的时间（获取到第一个字节），包括从本地读取缓存</span><br><span class="line">        responseStart: 1441112692686,</span><br><span class="line"> </span><br><span class="line">        // HTTP 响应全部接收完成的时间（获取到最后一个字节），包括从本地读取缓存</span><br><span class="line">        responseEnd: 1441112692687,</span><br><span class="line"> </span><br><span class="line">        // 开始解析渲染 DOM 树的时间，此时 Document.readyState 变为 loading，并将抛出 readystatechange 相关事件</span><br><span class="line">        domLoading: 1441112692690,</span><br><span class="line"> </span><br><span class="line">        // 完成解析 DOM 树的时间，Document.readyState 变为 interactive，并将抛出 readystatechange 相关事件</span><br><span class="line">        // 注意只是 DOM 树解析完成，这时候并没有开始加载网页内的资源</span><br><span class="line">        domInteractive: 1441112693093,</span><br><span class="line"> </span><br><span class="line">        // DOM 解析完成后，网页内资源加载开始的时间</span><br><span class="line">        // 在 DOMContentLoaded 事件抛出前发生</span><br><span class="line">        domContentLoadedEventStart: 1441112693093,</span><br><span class="line"> </span><br><span class="line">        // DOM 解析完成后，网页内资源加载完成的时间（如 JS 脚本加载执行完毕）</span><br><span class="line">        domContentLoadedEventEnd: 1441112693101,</span><br><span class="line"> </span><br><span class="line">        // DOM 树解析完成，且资源也准备就绪的时间，Document.readyState 变为 complete，并将抛出 readystatechange 相关事件</span><br><span class="line">        domComplete: 1441112693214,</span><br><span class="line"> </span><br><span class="line">        // load 事件发送给文档，也即 load 回调函数开始执行的时间</span><br><span class="line">        // 注意如果没有绑定 load 事件，值为 0</span><br><span class="line">        loadEventStart: 1441112693214,</span><br><span class="line"> </span><br><span class="line">        // load 事件的回调函数执行完毕的时间</span><br><span class="line">        loadEventEnd: 1441112693215</span><br><span class="line"> </span><br><span class="line">        // 字母顺序</span><br><span class="line">        // connectEnd: 1441112692155,</span><br><span class="line">        // connectStart: 1441112692155,</span><br><span class="line">        // domComplete: 1441112693214,</span><br><span class="line">        // domContentLoadedEventEnd: 1441112693101,</span><br><span class="line">        // domContentLoadedEventStart: 1441112693093,</span><br><span class="line">        // domInteractive: 1441112693093,</span><br><span class="line">        // domLoading: 1441112692690,</span><br><span class="line">        // domainLookupEnd: 1441112692155,</span><br><span class="line">        // domainLookupStart: 1441112692155,</span><br><span class="line">        // fetchStart: 1441112692155,</span><br><span class="line">        // loadEventEnd: 1441112693215,</span><br><span class="line">        // loadEventStart: 1441112693214,</span><br><span class="line">        // navigationStart: 1441112691935,</span><br><span class="line">        // redirectEnd: 0,</span><br><span class="line">        // redirectStart: 0,</span><br><span class="line">        // requestStart: 1441112692158,</span><br><span class="line">        // responseEnd: 1441112692687,</span><br><span class="line">        // responseStart: 1441112692686,</span><br><span class="line">        // secureConnectionStart: 0,</span><br><span class="line">        // unloadEventEnd: 0,</span><br><span class="line">        // unloadEventStart: 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 计算加载时间</span><br><span class="line">function getPerformanceTiming() &#123;</span><br><span class="line">    var performance = window.performance;</span><br><span class="line">    if (!performance) &#123;</span><br><span class="line">        // 当前浏览器不支持</span><br><span class="line">        console.log(&apos;你的浏览器不支持 performance 接口&apos;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    var t = performance.timing;</span><br><span class="line">    var times = &#123;&#125;;</span><br><span class="line">    //【重要】页面加载完成的时间</span><br><span class="line">    //【原因】这几乎代表了用户等待页面可用的时间</span><br><span class="line">    times.loadPage = t.loadEventEnd - t.navigationStart;</span><br><span class="line">    //【重要】解析 DOM 树结构的时间</span><br><span class="line">    //【原因】反省下你的 DOM 树嵌套是不是太多了！</span><br><span class="line">    times.domReady = t.domComplete - t.responseEnd;</span><br><span class="line">    //【重要】重定向的时间</span><br><span class="line">    //【原因】拒绝重定向！比如，http://example.com/ 就不该写成 http://example.com</span><br><span class="line">    times.redirect = t.redirectEnd - t.redirectStart;</span><br><span class="line">    //【重要】DNS 查询时间</span><br><span class="line">    //【原因】DNS 预加载做了么？页面内是不是使用了太多不同的域名导致域名查询的时间太长？</span><br><span class="line">    // 可使用 HTML5 Prefetch 预查询 DNS ，见：[HTML5 prefetch](http://segmentfault.com/a/1190000000633364)            </span><br><span class="line">    times.lookupDomain = t.domainLookupEnd - t.domainLookupStart;</span><br><span class="line">    //【重要】读取页面第一个字节的时间</span><br><span class="line">    //【原因】这可以理解为用户拿到你的资源占用的时间，加异地机房了么，加CDN 处理了么？加带宽了么？加 CPU 运算速度了么？</span><br><span class="line">    // TTFB 即 Time To First Byte 的意思</span><br><span class="line">    // 维基百科：https://en.wikipedia.org/wiki/Time_To_First_Byte</span><br><span class="line">    times.ttfb = t.responseStart - t.navigationStart;</span><br><span class="line">    //【重要】内容加载完成的时间</span><br><span class="line">    //【原因】页面内容经过 gzip 压缩了么，静态资源 css/js 等压缩了么？</span><br><span class="line">    times.request = t.responseEnd - t.requestStart;</span><br><span class="line">    //【重要】执行 onload 回调函数的时间</span><br><span class="line">    //【原因】是否太多不必要的操作都放到 onload 回调函数里执行了，考虑过延迟加载、按需加载的策略么？</span><br><span class="line">    times.loadEvent = t.loadEventEnd - t.loadEventStart;</span><br><span class="line">    // DNS 缓存时间</span><br><span class="line">    times.appcache = t.domainLookupStart - t.fetchStart;</span><br><span class="line">    // 卸载页面的时间</span><br><span class="line">    times.unloadEvent = t.unloadEventEnd - t.unloadEventStart;</span><br><span class="line">    // TCP 建立连接完成握手的时间</span><br><span class="line">    times.connect = t.connectEnd - t.connectStart;</span><br><span class="line">    return times;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常见性能指标"><a href="#常见性能指标" class="headerlink" title="常见性能指标"></a>常见性能指标</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FP	页面首次绘制时间</span><br><span class="line">FCP	页面首次有内容绘制的时间</span><br><span class="line">FMP	页面首次有效绘制时间，FMP &gt;= FCP</span><br><span class="line">TTI	页面完全可交互时间</span><br><span class="line">FID	页面加载阶段，用户首次交互操作的延时时间</span><br><span class="line">MPFID	页面加载阶段，用户交互操作可能遇到的最大延时时间</span><br><span class="line">LOAD	页面完全加载的时间（load 事件发生的时间）</span><br></pre></td></tr></table></figure>
<h3 id="FP"><a href="#FP" class="headerlink" title="FP"></a>FP</h3><p>FP (First Paint)指标通常会反映页面的白屏时间，而白屏时间会反映当前 Web 页面的网络加载性能情况，当加载性能非常良好的情况下，白屏的时间就会越短，用户等待内容的时间就会越短，流失的概率就会降低。<br>该指标可以通过 performance.getEntriesByType(‘paint’) 方法获取 PerformancePaintTiming API 提供的打点信息，找到 name 为 first-paint 的对象，描述的即为 FP 的指标数据</p>
<h3 id="FCP"><a href="#FCP" class="headerlink" title="FCP"></a>FCP</h3><p>FCP (First Contentful Paint) 为首次有内容渲染的时间点，在性能统计指标中，从用户开始访问 Web 页面的时间点到 FCP 的时间点这段时间可以被视为无内容时间，一般 FCP &gt;= FP。<br>该指标可以通过 performance.getEntriesByType(‘paint’) 方法获取 PerformancePaintTiming API 提供的打点信息，找到 name 为 first-contentful-paint 的对象，描述的即为 FCP 的指标数据</p>
<h3 id="TTI"><a href="#TTI" class="headerlink" title="TTI"></a>TTI</h3><p>TTI（Time To Interactive），即从页面加载开始到页面处于完全可交互状态所花费的时间。页面处于完全可交互状态时，满足以下 3 个条件：</p>
<ol>
<li>页面已经显示有用内容。</li>
<li>页面上的可见元素关联的事件响应函数已经完成注册。</li>
<li>事件响应函数可以在事件发生后的 50ms 内开始执行。<br>window.performance.getEntriesByType(‘resource’)会返回当前页面加载的所有资源（js、css、img…）的各类性能指标，可用于静态资源性能数据采集。<br>主要类型有：script、link、img、css、xmlhttprequest、beacon、fetch、other。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">connectEnd	一个 DOMHighResTimeStamp，表示浏览器完成建立与服务器的连接以检索资源之后的时间。</span><br><span class="line">connectStart	一个 DOMHighResTimeStamp，表示浏览器开始建立与服务器的连接以检索资源之前的时间。</span><br><span class="line">decodedBodySize	一个 number，表示在删除任何应用的内容编码之后，从消息主体的请求（HTTP 或缓存）中接收到的大小（以八位字节为单位）。</span><br><span class="line">domainLookupEnd	一个 DOMHighResTimeStamp，表示浏览器完成资源的域名查找之后的时间。</span><br><span class="line">domainLookupStart	一个 DOMHighResTimeStamp，表示在浏览器立即开始资源的域名查找之前的时间</span><br><span class="line">duration	返回一个 timestamp，即 responseEnd 和 startTime 属性的差值。</span><br><span class="line">encodedBodySize	一个 number，表示在删除任何应用的内容编码之前，从有效内容主体的请求（HTTP 或缓存）中接收到的大小（以八位字节为单位）。</span><br><span class="line">entryType	返回 &quot;resource&quot;。</span><br><span class="line">fetchStart	一个 DOMHighResTimeStamp，表示浏览器即将开始获取资源之前的时间。</span><br><span class="line">initiatorType	一个 string，代表启动性能条目的资源的类型</span><br><span class="line">name	返回资源 URL。</span><br><span class="line">nextHopProtocol	一个 string，代表用于获取资源的网络协议，由 ALPN 协议 ID（RFC7301） 定义。</span><br><span class="line">redirectEnd	一个 DOMHighResTimeStamp，表示收到上一次重定向响应的发送最后一个字节时的时间。</span><br><span class="line">redirectStart	一个 DOMHighResTimeStamp 代表启动重定向的请求开始之前的时间。</span><br><span class="line">requestStart	一个 DOMHighResTimeStamp，表示浏览器开始向服务器请求资源之前的时间。</span><br><span class="line">responseEnd	一个 DOMHighResTimeStamp，表示在浏览器接收到资源的最后一个字节之后或在传输连接关闭之前（以先到者为准）的时间。</span><br><span class="line">responseStart	一个 DOMHighResTimeStamp，表示浏览器从服务器接收到响应的第一个字节后的时间。</span><br><span class="line">secureConnectionStart	一个 DOMHighResTimeStamp，表示浏览器即将开始握手过程以保护当前连接之前的时间。</span><br><span class="line">serverTiming	一个 PerformanceServerTiming 数组，包含服务器计时指标的 PerformanceServerTiming 条目。</span><br><span class="line">startTime	返回一个 timestamp，表示资源获取开始的时间。该值等效于 fetchStart。</span><br><span class="line">transferSize	一个 number 代表所获取资源的大小（以八位字节为单位）。该大小包括响应标头字段以及响应有效内容主体。</span><br><span class="line">workerStart	一个 DOMHighResTimeStamp， 如果服务 Worker 线程已经在运行，则返回在分派 FetchEvent 之前的时间戳，如果尚未运行，则返回在启动 Service Worker 线程之前的时间戳。如果服务 Worker 未拦截该资源，则该属性将始终返回 0。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="其他指标计算方式"><a href="#其他指标计算方式" class="headerlink" title="其他指标计算方式"></a>其他指标计算方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DNS查询	DNS 阶段耗时	domainLookupEnd - domainLookupStart</span><br><span class="line">TCP连接	TCP 阶段耗时	connectEnd - connectStart</span><br><span class="line">SSL建连	SSL 连接时间	connectEnd - secureConnectionStart</span><br><span class="line">首字节网络请求	首字节响应时间（ttfb）	responseStart - requestStart</span><br><span class="line">内容传输	内容传输，Response阶段耗时	responseEnd - responseStart</span><br><span class="line">DOM解析	Dom解析时间	domInteractive - responseEnd</span><br><span class="line">资源加载	资源加载	loadEventStart - domContentLoadedEventEnd</span><br><span class="line">首字节	首字节	responseStart - fetchStart</span><br><span class="line">DOM Ready	dom ready	domContentLoadedEventEnd - fetchStart</span><br><span class="line">redirect时间	重定向时间	redirectEnd - redirectStart</span><br><span class="line">DOM render	dom渲染耗时	domComplete - domLoading</span><br><span class="line">load	页面加载耗时	loadEventEnd - navigationStart</span><br><span class="line">unload	页面卸载耗时	unloadEventEnd - unloadEventStart</span><br><span class="line">请求耗时	请求耗时	responseEnd - requestStart</span><br><span class="line">白屏时间	白屏时间	domLoading - navigationStart</span><br></pre></td></tr></table></figure>
<h2 id="错误数据采集方案"><a href="#错误数据采集方案" class="headerlink" title="错误数据采集方案"></a>错误数据采集方案</h2><p>目前所能捕捉的错误有三种:</p>
<ol>
<li>资源加载错误，通过 addEventListener(‘error’, callback, true)在捕获阶段捕捉资源加载失败错误。</li>
<li>js 执行错误，通过 window.onerror捕捉 js 错误。<br>跨域的脚本会给出 “Script Error.” 提示，拿不到具体的错误信息和堆栈信息。此时需要在script标签增加crossorigin=”anonymous”属性，同时资源服务器需要增加CORS相关配置，比如Access-Control-Allow-Origin: *</li>
<li>promise 错误，通过 addEventListener(‘unhandledrejection’, callback)捕捉 promise 错误，但是没有发生错误的行数，列数等信息，只能手动抛出相关错误信息。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 在捕获阶段，捕获资源加载失败错误</span><br><span class="line">addEventListener(&apos;error&apos;, e =&gt; &#123;</span><br><span class="line">    const target = e.target</span><br><span class="line">    if (target != window) &#123;</span><br><span class="line">        monitor.errors.push(&#123;</span><br><span class="line">            type: target.localName,</span><br><span class="line">            url: target.src || target.href,</span><br><span class="line">            msg: (target.src || target.href) + &apos; is load error&apos;,</span><br><span class="line">            time: Date.now()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, true)</span><br><span class="line"></span><br><span class="line">// 监听 js 错误</span><br><span class="line">window.onerror = function(msg, url, row, col, error) &#123;</span><br><span class="line">    monitor.errors.push(&#123;</span><br><span class="line">        type: &apos;javascript&apos;,</span><br><span class="line">        row: row,</span><br><span class="line">        col: col,</span><br><span class="line">        msg: error &amp;&amp; error.stack? error.stack : msg,</span><br><span class="line">        url: url,</span><br><span class="line">        time: Date.now()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 监听 promise 错误 缺点是获取不到行数数据</span><br><span class="line">addEventListener(&apos;unhandledrejection&apos;, e =&gt; &#123;</span><br><span class="line">    monitor.errors.push(&#123;</span><br><span class="line">        type: &apos;promise&apos;,</span><br><span class="line">        msg: (e.reason &amp;&amp; e.reason.msg) || e.reason || &apos;&apos;,</span><br><span class="line">        time: Date.now()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="数据上报方案"><a href="#数据上报方案" class="headerlink" title="数据上报方案"></a>数据上报方案</h2><p>在这个场景中，需要考虑两个问题：</p>
<ol>
<li>如果数据上报接口与业务系统使用同一域名，浏览器对请求并发量有限制，所以存在网络资源竞争的可能性。</li>
<li>浏览器通常在页面卸载时会忽略异步ajax请求，如果需要必须进行数据请求，一般在unload或者beforeunload事件中创建同步ajax请求，以此延迟页面卸载。从用户侧角度，就是页面跳转变慢。</li>
</ol>
<ul>
<li>Beacon 接口用来调度向 Web 服务器发送的异步非阻塞请求。</li>
</ul>
<ol>
<li>Beacon 请求使用 HTTP POST方法，并且不需要有响应。</li>
<li>Beacon 请求能确保在页面触发 unload 之前完成初始化。 通俗的讲就是，Beacon可将数据异步发送至服务端，且能够保证在页面卸载完成前发送请求（解决ajax页面卸载会终止请求的问题）。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">navigator.sendBeacon(url, data);</span><br><span class="line">其中 data 参数是可选的，它的类型可以为 ArrayBufferView, Blob, DOMString 或者 FormData。如果浏览器成功地将 beacon 请求加入到待发送的队列里，这个方法将会返回 true ，否则将会返回 false</span><br><span class="line"></span><br><span class="line">使用Beacon时需要后台需要使用post方法接收参数，考虑到跨域问题，后台还需要改造接口配置CORS。同时请求头必须满足CORS-safelisted request-header，其中content-type的类型必须为application/x-www-form-urlencoded, multipart/form-data, 或者text/plain。</span><br><span class="line"></span><br><span class="line">type ContentType = &apos;application/x-www-form-urlencoded&apos; | &apos;multipart/form-data&apos; | &apos;text/plain&apos;;</span><br><span class="line"></span><br><span class="line">const serilizeParams = (params: object) =&gt; &#123;</span><br><span class="line">    return window.btoa(JSON.stringify(params))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function sendBeacon(url: string, params: object) &#123;</span><br><span class="line">  const formData = new FormData()</span><br><span class="line">  formData.append(&apos;params&apos;, serilizeParams(params))</span><br><span class="line">  navigator.sendBeacon(url, formData)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sendBeacon的兼容性问题是不可避免的，不过可以充分利用大部分浏览器会在页面卸载前完成图片的加载的特性，通过在页面添加img的方式上报数据。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function sendImage(url: string, params: object) &#123;</span><br><span class="line">  const img = new Image()</span><br><span class="line"></span><br><span class="line">  img.style.display = &apos;none&apos;</span><br><span class="line"></span><br><span class="line">  const removeImage = function() &#123;</span><br><span class="line">    img.parentNode.removeChild(img)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  img.onload = removeImage</span><br><span class="line">  img.onerror = removeImage</span><br><span class="line"></span><br><span class="line">  img.src = `$&#123;url&#125;?params=$&#123;serilizeParams(params)&#125;`</span><br><span class="line"></span><br><span class="line">  document.body.appendChild(img)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">由于img图片为get请求方式，不同服务器针对uri的长度有限制，长度超过限制时会出现HTTP 414错误，所以还要注意上报频率，减少一次性上传的属性过多。</span><br></pre></td></tr></table></figure>
</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/前端/">前端</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/">js</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-http" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2021/04/25/http/" class="article-date">
      <time datetime="2021-04-24T16:00:00.000Z" itemprop="datePublished">2021-04-25</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/04/25/http/">http协议</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="时势与英雄：HTTP的前世今生"><a href="#时势与英雄：HTTP的前世今生" class="headerlink" title="时势与英雄：HTTP的前世今生"></a>时势与英雄：HTTP的前世今生</h2><h3 id="创世纪"><a href="#创世纪" class="headerlink" title="创世纪"></a>创世纪</h3><ul>
<li>URI：即统一资源标识符，作为互联网上资源的唯一身份；</li>
<li>HTML：即超文本标记语言，描述超文本文档；</li>
<li>HTTP：即超文本传输协议，用来传输超文本。</li>
<li>这三项技术在如今的我们看来已经是稀松平常，但在当时却是了不得的大发明。基于它们，就可以把超文本系统完美地运行在互联网上，让各地的人们能够自由地共享信息，蒂姆把这个系统称为“万维网”（World Wide Web），也就是我们现在所熟知的 Web。所以在这一年，我们的英雄“HTTP”诞生了，从此开始了它伟大的征途。<h3 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP/0.9"></a>HTTP/0.9</h3></li>
<li>20 世纪 90 年代初期的互联网世界非常简陋，计算机处理能力低，存储容量小，网速很慢，还是一片“信息荒漠”。网络上绝大多数的资源都是纯文本，很多通信协议也都使用纯文本，所以 HTTP 的设计也不可避免地受到了时代的限制。</li>
<li>最初设想的系统里的文档都是只读的，所以只允许用“GET”动作从服务器上获取 HTML 文档，并且在响应请求之后立即关闭连接，功能非常有限。<h3 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP/1.0"></a>HTTP/1.0</h3></li>
<li>HTTP/1.0 版本在 1996 年正式发布。它在多方面增强了 0.9 版，形式上已经和我们现在的 HTTP 差别不大了，例如：</li>
</ul>
<ol>
<li>增加了 HEAD、POST 等新方法；</li>
<li>增加了响应状态码，标记可能的错误原因；</li>
<li>引入了协议版本号概念；</li>
<li>引入了 HTTP Header（头部）的概念，让 HTTP 处理请求和响应更加灵活；</li>
<li>传输的数据不再仅限于文本。</li>
</ol>
<ul>
<li>TTP/1.0 的发布对于当时正在蓬勃发展的互联网来说并没有太大的实际意义，各方势力仍然按照自己的意图继续在市场上奋力拼杀。<h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h3></li>
<li>1995 年，网景的 Netscape Navigator 和微软的 Internet Explorer 开始了著名的“浏览器大战”，都希望在互联网上占据主导地位。这场战争的结果你一定早就知道了，最终微软的 IE 取得了决定性的胜利，而网景则“败走麦城”（但后来却凭借 Mozilla Firefox 又扳回一局）。</li>
<li>1999 年，HTTP/1.1 发布了 RFC 文档，编号为 2616，正式确立了延续十余年的传奇。从版本号我们就可以看到，HTTP/1.1 是对 HTTP/1.0 的小幅度修正。但一个重要的区别是：它是一个“正式的标准”，而不是一份可有可无的“参考文档”。这意味着今后互联网上所有的浏览器、服务器、网关、代理等等，只要用到 HTTP 协议，就必须严格遵守这个标准，相当于是互联网世界的一个“立法”。</li>
<li>HTTP/1.1 主要的变更点有：</li>
</ul>
<ol>
<li>增加了 PUT、DELETE 等新的方法；</li>
<li>增加了缓存管理和控制；</li>
<li>明确了连接管理，允许持久连接；</li>
<li>允许响应数据分块（chunked），利于传输大文件；</li>
<li>强制要求 Host 头，让互联网主机托管成为可能。<h3 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h3></li>
</ol>
<ul>
<li>互联网标准化组织以 SPDY 为基础开始制定新版本的 HTTP 协议，最终在 2015 年发布了 HTTP/2，RFC 编号 7540。</li>
<li>HTTP/2 的制定充分考虑了现今互联网的现状：宽带、移动、不安全，在高度兼容 HTTP/1.1 的同时在性能改善方面做了很大努力，主要的特点有：</li>
</ul>
<ol>
<li>二进制协议，不再是纯文本；</li>
<li>可发起多个请求，废弃了 1.1 里的管道；</li>
<li>使用专用算法压缩头部，减少数据传输量；</li>
<li>允许服务器主动向客户端推送数据；</li>
<li>增强了安全性，“事实上”要求加密通信。<h3 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP/3"></a>HTTP/3</h3></li>
</ol>
<ul>
<li>2018 年，互联网标准化组织 IETF 提议将“HTTP over QUIC”更名为“HTTP/3”并获得批准，HTTP/3 正式进入了标准化制订阶段，也许两三年后就会正式发布，到时候我们很可能会跳过 HTTP/2 直接进入 HTTP/3。</li>
</ul>
<h2 id="HTTP是什么？HTTP又不是什么？"><a href="#HTTP是什么？HTTP又不是什么？" class="headerlink" title="HTTP是什么？HTTP又不是什么？"></a>HTTP是什么？HTTP又不是什么？</h2><ul>
<li>HTTP 是一个用在计算机世界里的协议，它确立了一种计算机之间交流通信的规范，以及相关的各种控制和错误处理方式。</li>
<li>HTTP 专门用来在两点之间传输数据，不能用于广播、寻址或路由</li>
<li>HTTP 传输的是文字、图片、音频、视频等超文本数据。</li>
<li>HTTP 是构建互联网的重要基础技术，它没有实体，依赖许多其他的技术来实现，但同时许多技术也都依赖于它。</li>
</ul>
<h2 id="HTTP世界全览（上）：与HTTP相关的各种概念"><a href="#HTTP世界全览（上）：与HTTP相关的各种概念" class="headerlink" title="HTTP世界全览（上）：与HTTP相关的各种概念"></a>HTTP世界全览（上）：与HTTP相关的各种概念</h2><h3 id="网络世界"><a href="#网络世界" class="headerlink" title="网络世界"></a>网络世界</h3><ul>
<li>互联网的正式名称是 Internet，里面存储着无穷无尽的信息资源，我们通常所说的“上网”实际上访问的只是互联网的一个子集“万维网”（World Wide Web），它基于 HTTP 协议，传输 HTML 等超文本资源，能力也就被限制在 HTTP 协议之内。</li>
<li>互联网上还有许多万维网之外的资源，例如常用的电子邮件、BT 和 Magnet 点对点下载、FTP 文件下载、SSH 安全登录、各种即时通信服务等等，它们需要用各自的专有协议来访问。</li>
<li>不过由于 HTTP 协议非常灵活、易于扩展，而且“超文本”的表述能力很强，所以很多其他原本不属于 HTTP 的资源也可以“包装”成 HTTP 来访问，这就是我们为什么能够总看到各种“网页应用”——例如“微信网页版”“邮箱网页版”——的原因。<h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3></li>
<li>常见的浏览器有 Google 的 Chrome、Mozilla 的 Firefox、Apple 的 Safari、Microsoft 的 IE 和 Edge，还有小众的 Opera 以及国内的各种“换壳”的“极速”“安全”浏览器。</li>
<li>浏览器本质上是一个 HTTP 协议中的请求方，使用 HTTP 协议获取网络上的各种资源。当然，为了让我们更好地检索查看网页，它还集成了很多额外的功能。</li>
<li>在 HTTP 协议里，浏览器的角色被称为“User Agent”即“用户代理”，意思是作为访问者的“代理”来发起 HTTP 请求。不过在不引起混淆的情况下，我们通常都简单地称之为“客户端”。<h3 id="Web-服务器"><a href="#Web-服务器" class="headerlink" title="Web 服务器"></a>Web 服务器</h3></li>
<li>比起层出不穷的各种 Web 浏览器，Web 服务器就要少很多了，一只手的手指头就可以数得过来。</li>
</ul>
<ol>
<li>Apache 是老牌的服务器，到今天已经快 25 年了，功能相当完善，相关的资料很多，学习门槛低，是许多创业者建站的入门产品。</li>
<li>Nginx 是 Web 服务器里的后起之秀，特点是高性能、高稳定，且易于扩展。自 2004 年推出后就不断蚕食 Apache 的市场份额，在高流量的网站里更是不二之选。</li>
<li>此外，还有 Windows 上的 IIS、Java 的 Jetty/Tomcat 等，因为性能不是很高，所以在互联网上应用得较少。</li>
</ol>
<ul>
<li>当我们谈到“Web 服务器”时有两个层面的含义：硬件和软件。</li>
</ul>
<ol>
<li>硬件含义就是物理形式或“云”形式的机器，在大多数情况下它可能不是一台服务器，而是利用反向代理、负载均衡等技术组成的庞大集群。但从外界看来，它仍然表现为一台机器，但这个形象是“虚拟的”。</li>
<li>软件含义的 Web 服务器可能我们更为关心，它就是提供 Web 服务的应用程序，通常会运行在硬件含义的服务器上。它利用强大的硬件能力响应海量的客户端 HTTP 请求，处理磁盘上的网页、图片等静态文件，或者把请求转发给后面的 Tomcat、Node.js 等业务应用，返回动态的信息。<h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3></li>
</ol>
<ul>
<li>浏览器通常不会直接连到服务器，中间会经过“重重关卡”，其中的一个重要角色就叫做 CDN。</li>
<li>CDN，全称是“Content Delivery Network”，翻译过来就是“内容分发网络”。它应用了 HTTP 协议里的缓存和代理技术，代替源站响应客户端的请求。</li>
<li>简单来说，它可以缓存源站的数据，让浏览器的请求不用“千里迢迢”地到达源站服务器，直接在“半路”就可以获取响应。如果 CDN 的调度算法很优秀，更可以找到离用户最近的节点，大幅度缩短响应时间。</li>
<li>CDN 也是现在互联网中的一项重要基础设施，除了基本的网络加速外，还提供负载均衡、安全防护、边缘计算、跨运营商网络等功能，能够成倍地“放大”源站服务器的服务能力，很多云服务商都把 CDN 作为产品的一部分<h3 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h3></li>
<li>HTTP 协议并没有规定用户代理后面必须是“真正的人类”，它也完全可以是“机器人”，这些“机器人”的正式名称就叫做“爬虫”（Crawler），实际上是一种可以自动访问 Web 资源的应用程序。</li>
<li>爬虫绝大多数是由各大搜索引擎“放”出来的，抓取网页存入庞大的数据库，再建立关键字索引，这样我们才能够在搜索引擎中快速地搜索到互联网角落里的页面。</li>
<li>爬虫也有不好的一面，它会过度消耗网络资源，占用服务器和带宽，影响网站对真实数据的分析，甚至导致敏感信息泄漏。所以，又出现了“反爬虫”技术，通过各种手段来限制爬虫。其中一项就是“君子协定”robots.txt，约定哪些该爬，哪些不该爬。</li>
</ul>
<h3 id="HTML-WebService-WAF"><a href="#HTML-WebService-WAF" class="headerlink" title="HTML/WebService/WAF"></a>HTML/WebService/WAF</h3><ul>
<li>HTML 是 HTTP 协议传输的主要内容之一，它描述了超文本页面，用各种“标签”定义文字、图片等资源和排版布局，最终由浏览器“渲染”出可视化页面。</li>
<li>Web  Service 是一种由 W3C 定义的应用服务开发规范，使用 client-server 主从架构，通常使用 WSDL 定义服务接口，使用 HTTP 协议传输 XML 或 SOAP 消息，也就是说，它是一个基于 Web（HTTP）的服务架构技术，既可以运行在内网，也可以在适当保护后运行在外网。因为采用了 HTTP 协议传输数据，所以在 Web  Service 架构里服务器和客户端可以采用不同的操作系统或编程语言开发。例如服务器端用 Linux+Java，客户端用 Windows+C#，具有跨平台跨语言的优点。</li>
<li>WAF 是近几年比较“火”的一个词，意思是“网络应用防火墙”。与硬件“防火墙”类似，它是应用层面的“防火墙”，专门检测 HTTP 流量，是防护 Web 应用的安全技术。WAF 通常位于 Web 服务器之前，可以阻止如 SQL 注入、跨站脚本等攻击，目前应用较多的一个开源项目是 ModSecurity，它能够完全集成进 Apache 或 Nginx。</li>
</ul>
<h2 id="HTTP世界全览（下）：与HTTP相关的各种协议"><a href="#HTTP世界全览（下）：与HTTP相关的各种协议" class="headerlink" title="HTTP世界全览（下）：与HTTP相关的各种协议"></a>HTTP世界全览（下）：与HTTP相关的各种协议</h2><h3 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h3><ul>
<li>TCP/IP 协议实际上是一系列网络通信协议的统称，其中最核心的两个协议是 TCP 和 IP，其他的还有 UDP、ICMP、ARP 等等，共同构成了一个复杂但有层次的协议栈。</li>
<li>这个协议栈有四层，最上层是“应用层”，最下层是“链接层”，TCP 和 IP 则在中间：TCP 属于“传输层”，IP 属于“网际层”。</li>
<li>IP 协议是“Internet Protocol”的缩写，主要目的是解决寻址和路由问题，以及如何在两点间传送数据包。IP 协议使用“IP 地址”的概念来定位互联网上的每一台计算机。</li>
<li>现在我们使用的 IP 协议大多数是 v4 版，地址是四个用“.”分隔的数字，例如“192.168.0.1”，总共有 2^32，大约 42 亿个可以分配的地址。看上去好像很多，但互联网的快速发展让地址的分配管理很快就“捉襟见肘”。所以，就又出现了 v6 版，使用 8 组“:”分隔的数字作为地址，容量扩大了很多，有 2^128 个，在未来的几十年里应该是足够用了。</li>
<li>TCP 协议是“Transmission Control Protocol”的缩写，意思是“传输控制协议”，它位于 IP 协议之上，基于 IP 协议提供可靠的、字节流形式的通信，是 HTTP 协议得以实现的基础。</li>
<li>“可靠”是指保证数据不丢失，“字节流”是指保证数据完整，所以在 TCP 协议的两端可以如同操作文件一样访问传输的数据，就像是读写在一个密闭的管道里“流动”的字节。</li>
<li>HTTP 是一个”传输协议”，但它不关心寻址、路由、数据完整性等传输细节，而要求这些工作都由下层来处理。因为互联网上最流行的是 TCP/IP 协议，而它刚好满足 HTTP 的要求，所以互联网上的 HTTP 协议就运行在了 TCP/IP 上，HTTP 也就可以更准确地称为“HTTP over TCP/IP”。<h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3></li>
<li>在 DNS 中，“域名”（Domain Name）又称为“主机名”（Host），为了更好地标记不同国家或组织的主机，让名字更好记，所以被设计成了一个有层次的结构。</li>
<li>域名用“.”分隔成多个单词，级别从左到右逐级升高，最右边的被称为“顶级域名”。对于顶级域名，可能你随口就能说出几个，例如表示商业公司的“com”、表示教育机构的“edu”，表示国家的“cn”“uk”等，买火车票时的域名还记得吗？是“<a href="http://www.12306.cn”。" target="_blank" rel="noopener">www.12306.cn”。</a></li>
<li>想要使用 TCP/IP 协议来通信仍然要使用 IP 地址，所以需要把域名做一个转换，“映射”到它的真实 IP，这就是所谓的“域名解析”。</li>
<li>目前全世界有 13 组根 DNS 服务器，下面再有许多的顶级 DNS、权威 DNS 和更小的本地 DNS，逐层递归地实现域名查询。<h3 id="URI-URL"><a href="#URI-URL" class="headerlink" title="URI/URL"></a>URI/URL</h3></li>
<li>URI（Uniform Resource Identifier），中文名称是 统一资源标识符，使用它就能够唯一地标记互联网上资源。</li>
<li>URI 另一个更常用的表现形式是 URL（Uniform Resource Locator）， 统一资源定位符，也就是我们俗称的“网址”，它实际上是 URI 的一个子集，不过因为这两者几乎是相同的，差异不大，所以通常不会做严格的区分。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">http://nginx.org/en/download.html</span><br><span class="line">URI 主要有三个基本的部分构成：</span><br><span class="line">1.协议名：即访问该资源应当使用的协议，在这里是“http”；</span><br><span class="line">2.主机名：即互联网上主机的标记，可以是域名或 IP 地址，在这里是“nginx.org”；</span><br><span class="line">3.路径：即资源在主机上的位置，使用“/”分隔多级目录，在这里是“/en/download.html”。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><ul>
<li>SSL/TLS，它是一个负责加密通信的安全协议，建立在 TCP/IP 之上，所以也是个可靠的传输协议，可以被用作 HTTP 的下层。</li>
<li>SSL 的全称是“Secure Socket Layer”，由网景公司发明，当发展到 3.0 时被标准化，改名为 TLS，即“Transport Layer Security”，但由于历史的原因还是有很多人称之为 SSL/TLS，或者直接简称为 SSL。</li>
<li>SSL 使用了许多密码学最先进的研究成果，综合了对称加密、非对称加密、摘要算法、数字签名、数字证书等技术，能够在不安全的环境中为通信的双方创建出一个秘密的、安全的传输通道，为 HTTP 套上一副坚固的盔甲。<h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3></li>
<li>代理（Proxy）是 HTTP 协议中请求方和应答方中间的一个环节，作为“中转站”，既可以转发客户端的请求，也可以转发服务器的应答。</li>
<li>代理有很多的种类，常见的有：</li>
</ul>
<ol>
<li>匿名代理：完全“隐匿”了被代理的机器，外界看到的只是代理服务器；</li>
<li>透明代理：顾名思义，它在传输过程中是“透明开放”的，外界既知道代理，也知道客户端；</li>
<li>正向代理：靠近客户端，代表客户端向服务器发送请求</li>
<li>反向代理：靠近服务器端，代表服务器响应客户端的请求；</li>
</ol>
<ul>
<li>CDN，实际上就是一种代理，它代替源站服务器响应客户端的请求，通常扮演着透明代理和反向代理的角色。</li>
<li>由于代理在传输过程中插入了一个“中间层”，所以可以在这个环节做很多有意思的事情，比如：</li>
</ul>
<ol>
<li>负载均衡：把访问请求均匀分散到多台机器，实现访问集群化；</li>
<li>内容缓存：暂存上下行的数据，减轻后端的压力；</li>
<li>安全防护：隐匿 IP, 使用 WAF 等工具抵御网络攻击，保护被代理的机器；</li>
<li>数据处理：提供压缩、加密等额外的功能。</li>
</ol>
<h2 id="常说的“四层”和“七层”到底是什么？“五层”“六层”哪去了？"><a href="#常说的“四层”和“七层”到底是什么？“五层”“六层”哪去了？" class="headerlink" title="常说的“四层”和“七层”到底是什么？“五层”“六层”哪去了？"></a>常说的“四层”和“七层”到底是什么？“五层”“六层”哪去了？</h2><h3 id="TCP-IP-网络分层模型"><a href="#TCP-IP-网络分层模型" class="headerlink" title="TCP/IP 网络分层模型"></a>TCP/IP 网络分层模型</h3><ul>
<li>TCP/IP 协议总共有四层：“从下往上”</li>
</ul>
<ol>
<li>第一层叫“链接层”（link layer），负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标记网络上的设备，所以有时候也叫 MAC 层。</li>
<li>第二层叫“网际层”或者“网络互连层”（internet layer），IP 协议就处在这一层。因为 IP 协议定义了“IP 地址”的概念，所以就可以在“链接层”的基础上，用 IP 地址取代 MAC 地址，把许许多多的局域网、广域网连接成一个虚拟的巨大网络，在这个网络里找设备时只要把 IP 地址再“翻译”成 MAC 地址就可以了。</li>
<li>第三层叫“传输层”（transport layer），这个层次协议的职责是保证数据在 IP 地址标记的两点之间“可靠”地传输，是 TCP 协议工作的层次，另外还有它的一个“小伙伴”UDP。<br>TCP 是一个有状态的协议，需要先与对方建立连接然后才能发送数据，而且保证数据不丢失不重复。<br>而 UDP 则比较简单，它无状态，不用事先建立连接就可以任意发送数据，但不保证数据一定会发到对方。<br>两个协议的另一个重要区别在于数据的形式。TCP 的数据是连续的“字节流”，有先后顺序，而 UDP 则是分散的小数据包，是顺序发，乱序收。</li>
<li>协议栈的第四层叫“应用层”（application layer），由于下面的三层把基础打得非常好，所以在这一层就“百花齐放”了，有各种面向具体应用的协议。例如 Telnet、SSH、FTP、SMTP 等等，当然还有我们的 HTTP。</li>
</ol>
<ul>
<li>MAC地址（英语：Media Access Control Address），直译为媒体存取控制位址，也称为局域网地址（LAN Address），MAC位址，以太网地址（Ethernet Address）或物理地址（Physical Address），它是一个用来确认网络设备位置的位址。在OSI模型中，第三层网络层负责IP地址，第二层数据链路层则负责MAC位址 。MAC地址用于在网络中唯一标示一个网卡，一台设备若有一或多个网卡，则每个网卡都需要并会有一个唯一的MAC地址 。</li>
</ul>
<h3 id="OSI-网络分层模型"><a href="#OSI-网络分层模型" class="headerlink" title="OSI 网络分层模型"></a>OSI 网络分层模型</h3><ul>
<li>OSI，全称是“开放式系统互联通信参考模型”（Open System Interconnection Reference Model）。</li>
<li>OSI 模型分成了七层，部分层次与 TCP/IP 很像，从下到上分别是：</li>
</ul>
<ol>
<li>第一层：物理层，网络的物理形式，例如电缆、光纤、网卡、集线器等等；</li>
<li>第二层：数据链路层，它基本相当于 TCP/IP 的链接层；</li>
<li>第三层：网络层，相当于 TCP/IP 里的网际层；</li>
<li>第四层：传输层，相当于 TCP/IP 里的传输层；</li>
<li>第五层：会话层，维护网络中的连接状态，即保持会话和同步；</li>
<li>第六层：表示层，把数据转换为合适、可理解的语法和语义；</li>
<li>第七层：应用层，面向具体的应用传输数据。<h3 id="两个分层模型的映射关系"><a href="#两个分层模型的映射关系" class="headerlink" title="两个分层模型的映射关系"></a>两个分层模型的映射关系</h3></li>
</ol>
<ul>
<li>OSI 在设计之初就参考了 TCP/IP 等多个协议，可以比较容易但不是很精确地实现对应关系。</li>
</ul>
<ol>
<li>第一层：物理层，TCP/IP 里无对应；</li>
<li>第二层：数据链路层，对应 TCP/IP 的链接层；</li>
<li>第三层：网络层，对应 TCP/IP 的网际层；</li>
<li>第四层：传输层，对应 TCP/IP 的传输层；</li>
<li>第五、六、七层：统一对应到 TCP/IP 的应用层。</li>
</ol>
<ul>
<li>OSI 的分层模型在四层以上分的太细，而 TCP/IP 实际应用时的会话管理、编码转换、压缩等和具体应用经常联系的很紧密，很难分开。例如，HTTP 协议就同时包含了连接管理和数据格式定义。</li>
<li>所谓的“四层负载均衡”就是指工作在传输层上，基于 TCP/IP 协议的特性，例如 IP 地址、端口号等实现对后端服务器的负载均衡。</li>
<li>所谓的“七层负载均衡”就是指工作在应用层上，看到的是 HTTP 协议，解析 HTTP 报文里的 URI、主机名、资源类型等数据，再用适当的策略转发给后端服务器。</li>
</ul>
<h3 id="TCP-IP-协议栈的工作方式"><a href="#TCP-IP-协议栈的工作方式" class="headerlink" title="TCP/IP 协议栈的工作方式"></a>TCP/IP 协议栈的工作方式</h3><ul>
<li>HTTP 协议的传输过程就是这样通过协议栈逐层向下，每一层都添加本层的专有数据，层层打包，然后通过下层发送出去。</li>
<li>接收数据则是相反的操作，从下往上穿过协议栈，逐层拆包，每层去掉本层的专有头，上层就会拿到自己的数据。</li>
<li>但下层的传输过程对于上层是完全“透明”的，上层也不需要关心下层的具体实现细节，所以就 HTTP 层次来看，它不管下层是不是 TCP/IP 协议，看到的只是一个可靠的传输链路，只要把数据加上自己的头，对方就能原样收到。</li>
</ul>
<h2 id="域名里有哪些门道？"><a href="#域名里有哪些门道？" class="headerlink" title="域名里有哪些门道？"></a>域名里有哪些门道？</h2><h3 id="域名的形式"><a href="#域名的形式" class="headerlink" title="域名的形式"></a>域名的形式</h3><ul>
<li>域名是一个有层次的结构，是一串用“.”分隔的多个单词，最右边的被称为“顶级域名”，然后是“二级域名”，层级关系向左依次降低。</li>
<li>域名不仅能够代替 IP 地址，还有许多其他的用途。在 Apache、Nginx 这样的 Web 服务器里，域名可以用来标识虚拟主机，决定由哪个虚拟主机来对外提供服务，比如在 Nginx 里就会使用“server_name”指令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;                       #监听80端口</span><br><span class="line">    server_name  time.diamonds.org;  #主机名是time.diamonds.org</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="域名的解析"><a href="#域名的解析" class="headerlink" title="域名的解析"></a>域名的解析</h3><ul>
<li>就像 IP 地址必须转换成 MAC 地址才能访问主机一样，域名也必须要转换成 IP 地址，这个过程就是“域名解析”。</li>
<li>DNS 的核心系统是一个三层的树状、分布式服务，基本对应域名的结构：</li>
</ul>
<ol>
<li>根域名服务器（Root DNS Server）：管理顶级域名服务器，返回“com”“net”“cn”等顶级域名服务器的 IP 地址；</li>
<li>顶级域名服务器（Top-level DNS Server）：管理各自域名下的权威域名服务器，比如 com 顶级域名服务器可以返回 apple.com 域名服务器的 IP 地址；</li>
<li>权威域名服务器（Authoritative DNS Server）：管理自己域名下主机的 IP 地址，比如 apple.com 权威域名服务器可以返回 <a href="http://www.apple.com" target="_blank" rel="noopener">www.apple.com</a> 的 IP 地址。</li>
</ol>
<ul>
<li>在这里根域名服务器是关键，它必须是众所周知的，否则下面的各级服务器就无从谈起了。目前全世界共有 13 组根域名服务器，又有数百台的镜像，保证一定能够被访问到。</li>
<li><p>有了这个系统以后，任何一个域名都可以在这个树形结构里从顶至下进行查询，就好像是把域名从右到左顺序走了一遍，最终就获得了域名对应的 IP 地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例如，你要访问“www.apple.com”，就要进行下面的三次查询：</span><br><span class="line">1. 访问根域名服务器，它会告诉你“com”顶级域名服务器的地址；</span><br><span class="line">2. 访问“com”顶级域名服务器，它再告诉你“apple.com”域名服务器的地址；</span><br><span class="line">3. 最后访问“apple.com”域名服务器，就得到了“www.apple.com”的地址。</span><br></pre></td></tr></table></figure>
</li>
<li><p>在核心 DNS 系统之外，还有两种手段用来减轻域名解析的压力，并且能够更快地获取结果，基本思路就是“缓存”。</p>
</li>
<li>首先，许多大公司、网络运行商都会建立自己的 DNS 服务器，作为用户 DNS 查询的代理，代替用户访问核心 DNS 系统。这些“野生”服务器被称为“非权威域名服务器”，可以缓存之前的查询结果，如果已经有了记录，就无需再向根服务器发起查询，直接返回对应的 IP 地址。</li>
<li>这些 DNS 服务器的数量要比核心系统的服务器多很多，而且大多部署在离用户很近的地方。比较知名的 DNS 有 Google 的“8.8.8.8”，Microsoft 的“4.2.2.1”，还有 CloudFlare 的“1.1.1.1”等等。</li>
<li>其次，操作系统里也会对 DNS 解析结果做缓存，如果你之前访问过“<a href="http://www.apple.com”，那么下一次在浏览器里再输入这个网址的时候就不会再跑到" target="_blank" rel="noopener">www.apple.com”，那么下一次在浏览器里再输入这个网址的时候就不会再跑到</a> DNS 那里去问了，直接在操作系统里就可以拿到 IP 地址。</li>
<li>另外，操作系统里还有一个特殊的“主机映射”文件，通常是一个可编辑的文本，在 Linux 里是“/etc/hosts”，在 Windows 里是“C:\WINDOWS\system32\drivers\etc\hosts”，如果操作系统在缓存里找不到 DNS 记录，就会找这个文件。</li>
<li>有了上面的“野生”DNS 服务器、操作系统缓存和 hosts 文件后，很多域名解析的工作就都不用“跋山涉水”了，直接在本地或本机就能解决，不仅方便了用户，也减轻了各级 DNS 服务器的压力，效率就大大提升了。</li>
</ul>
<h3 id="域名的“新玩法”"><a href="#域名的“新玩法”" class="headerlink" title="域名的“新玩法”"></a>域名的“新玩法”</h3><ul>
<li>第一种，也是最简单的，“重定向”。因为域名代替了 IP 地址，所以可以让对外服务的域名不变，而主机的 IP 地址任意变动。当主机有情况需要下线、迁移时，可以更改 DNS 记录，让域名指向其他的机器。</li>
<li>第二种，因为域名是一个名字空间，所以可以使用 bind9 等开源软件搭建一个在内部使用的 DNS，作为名字服务器。这样我们开发的各种内部服务就都用域名来标记，比如数据库服务都用域名“mysql.inner.app”，商品服务都用“goods.inner.app”，发起网络通信时也就不必再使用写死的 IP 地址了，可以直接用域名，而且这种方式也兼具了第一种“玩法”的优势。</li>
<li>第三种“玩法”包含了前两种，也就是基于域名实现的负载均衡。这种“玩法”也有两种方式，两种方式可以混用。</li>
</ul>
<ol>
<li>第一种方式，因为域名解析可以返回多个 IP 地址，所以一个域名可以对应多台主机，客户端收到多个 IP 地址后，就可以自己使用轮询算法依次向服务器发起请求，实现负载均衡。</li>
<li>第二种方式，域名解析可以配置内部的策略，返回离客户端最近的主机，或者返回当前服务质量最好的主机，这样在 DNS 端把请求分发到不同的服务器，实现负载均衡。</li>
</ol>
<ul>
<li>不怀好意的 DNS</li>
</ul>
<ol>
<li>“域名屏蔽”，对域名直接不解析，返回错误，让你无法拿到 IP 地址，也就无法访问网站；</li>
<li>“域名劫持”，也叫“域名污染”，你要访问 A 网站，但 DNS 给了你 B 网站。</li>
</ol>
<h2 id="键入网址再按下回车，后面究竟发生了什么？"><a href="#键入网址再按下回车，后面究竟发生了什么？" class="headerlink" title="键入网址再按下回车，后面究竟发生了什么？"></a>键入网址再按下回车，后面究竟发生了什么？</h2><p>###使用 IP 地址访问 Web 服务器</p>
<ul>
<li>在 Chrome 浏览器的地址栏里输入“<a href="http://127.0.0.1/”，再按下回车键" target="_blank" rel="noopener">http://127.0.0.1/”，再按下回车键</a></li>
</ul>
<ol>
<li>因为我们在地址栏里直接输入了 IP 地址“127.0.0.1”，而 Web 服务器的默认端口是 80，所以浏览器就要依照 TCP 协议的规范，使用“三次握手”建立与 Web 服务器的连接。</li>
<li>经过 SYN、SYN/ACK、ACK 的三个包之后，浏览器与服务器的 TCP 连接就建立起来了。</li>
<li>有了可靠的 TCP 连接通道后，HTTP 协议就可以开始工作了。于是，浏览器按照 HTTP 协议规定的格式，通过 TCP 发送了一个“GET / HTTP/1.1”请求报文</li>
<li>随后，Web 服务器回复了第五个包，在 TCP 协议层面确认：“刚才的报文我已经收到了”，不过这个 TCP 包 HTTP 协议是看不见的。</li>
<li>Web 服务器收到报文后在内部就要处理这个请求。同样也是依据 HTTP 协议的规定，解析报文，看看浏览器发送这个请求想要干什么。</li>
<li>它一看，原来是要求获取根目录下的默认文件，好吧，那我就从磁盘上把那个文件全读出来，再拼成符合 HTTP 格式的报文，发回去吧。</li>
<li>同样的，浏览器也要给服务器回复一个 TCP 的 ACK 确认，“你的响应报文收到了，多谢”，即第七个包。</li>
<li>这时浏览器就收到了响应数据，但里面是什么呢？所以也要解析报文。一看，服务器给我的是个 HTML 文件，好，那我就调用排版引擎、JavaScript 引擎等等处理一下，然后在浏览器窗口里展现出了欢迎页面。</li>
<li>这之后还有两个来回，共四个包，重复了相同的步骤。这是浏览器自动请求了作为网站图标的“favicon.ico”文件，与我们输入的网址无关。</li>
<li>至此，“键入网址再按下回车”的全过程就结束了。</li>
</ol>
<ul>
<li>简要叙述一下这次最简单的浏览器 HTTP 请求过程：</li>
</ul>
<ol>
<li>浏览器从地址栏的输入中获得服务器的 IP 地址和端口号；</li>
<li>浏览器用 TCP 的三次握手与服务器建立连接；</li>
<li>浏览器向服务器发送拼好的报文；</li>
<li>服务器收到报文后处理请求，同样拼好报文再发给浏览器；</li>
<li>浏览器解析报文，渲染输出页面。</li>
</ol>
<h3 id="使用域名访问-Web-服务器"><a href="#使用域名访问-Web-服务器" class="headerlink" title="使用域名访问 Web 服务器"></a>使用域名访问 Web 服务器</h3><ul>
<li>在域名解析的过程中会有多级的缓存，浏览器首先看一下自己的缓存里有没有，如果没有就向操作系统的缓存要，还没有就检查本机域名解析文件 hosts，</li>
<li>DNS 解析可能会给出 CDN 服务器的 IP 地址，这样你拿到的就会是 CDN 服务器而不是目标网站的实际地址。</li>
<li>因为 CDN 会缓存网站的大部分资源，比如图片、CSS 样式表，所以有的 HTTP 请求就不需要再发到 Apple，CDN 就可以直接响应你的请求，把数据发给你。</li>
<li>目标网站的服务器对外表现的是一个 IP 地址，但为了能够扛住高并发，在内部也是一套复杂的架构。通常在入口是负载均衡设备，例如四层的 LVS 或者七层的 Nginx，在后面是许多的服务器，构成一个更强更稳定的集群。</li>
<li>负载均衡设备会先访问系统里的缓存服务器，通常有 memory 级缓存 Redis 和 disk 级缓存 Varnish，它们的作用与 CDN 类似，不过是工作在内部网络里，把最频繁访问的数据缓存几秒钟或几分钟，减轻后端应用服务器的压力。</li>
<li>如果缓存服务器里也没有，那么负载均衡设备就要把请求转发给应用服务器了。这里就是各种开发框架大显神通的地方了，例如 Java 的 Tomcat/Netty/Jetty，Python 的 Django，还有 PHP、Node.js、Golang 等等。它们又会再访问后面的 MySQL、PostgreSQL、MongoDB 等数据库服务，实现用户登录、商品查询、购物下单、扣款支付等业务操作，然后把执行的结果返回给负载均衡设备，同时也可能给缓存服务器里也放一份。</li>
<li>应用服务器的输出到了负载均衡设备这里，请求的处理就算是完成了，就要按照原路再走回去，还是要经过许多的路由器、网关、代理。如果这个资源允许缓存，那么经过 CDN 的时候它也会做缓存，这样下次同样的请求就不会到达源站了。</li>
<li>最后网站的响应数据回到了你的设备，它可能是 HTML、JSON、图片或者其他格式的数据，需要由浏览器解析处理才能显示出来，如果数据里面还有超链接，指向别的资源，那么就又要重走一遍整个流程，直到所有的资源都下载完。</li>
</ul>
<h2 id="HTTP报文是什么样子的？"><a href="#HTTP报文是什么样子的？" class="headerlink" title="HTTP报文是什么样子的？"></a>HTTP报文是什么样子的？</h2><ul>
<li>HTTP 的工作模式是非常简单的，由于 TCP/IP 协议负责底层的具体传输工作，HTTP 协议基本上不用在这方面操心太多。单从这一点上来看，所谓的“超文本传输协议”其实并不怎么管“传输”的事情，有点“名不副实”。</li>
<li>HTTP 协议的核心部分是什么呢？答案就是它传输的报文内容。</li>
<li>HTTP 协议在规范文档里详细定义了报文的格式，规定了组成部分，解析规则，还有处理策略，所以可以在 TCP/IP 层之上实现更灵活丰富的功能，例如连接控制，缓存管理、数据编码、内容协商等等。</li>
</ul>
<h3 id="报文结构"><a href="#报文结构" class="headerlink" title="报文结构"></a>报文结构</h3><ul>
<li>拿 TCP 报文来举例，它在实际要传输的数据之前附加了一个 20 字节的头部数据，存储 TCP 协议必须的额外信息，例如发送方的端口号、接收方的端口号、包序号、标志位等等。</li>
<li>有了这个附加的 TCP 头，数据包才能够正确传输，到了目的地后把头部去掉，就可以拿到真正的数据。</li>
<li>HTTP 协议也是与 TCP/UDP 类似，同样也需要在实际传输的数据前附加一些头数据，不过与 TCP/UDP 不同的是，它是一个“纯文本”的协议，所以头数据都是 ASCII 码的文本，可以很容易地用肉眼阅读，不用借助程序解析也能够看懂。</li>
<li>HTTP 协议的请求报文和响应报文的结构基本相同，由三大部分组成：</li>
</ul>
<ol>
<li>起始行（start line）：描述请求或响应的基本信息；</li>
<li>头部字段集合（header）：使用 key-value 形式更详细地说明报文；</li>
<li>消息正文（entity）：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据。</li>
</ol>
<ul>
<li>HTTP 协议规定报文必须有 header，但可以没有 body，而且在 header 之后必须要有一个“空行”，也就是“CRLF”，十六进制的“0D0A”。</li>
<li>虽然 HTTP 协议对 header 的大小没有做限制，但各个 Web 服务器都不允许过大的请求头，因为头部太大可能会占用大量的服务器资源，影响运行效率。<h3 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h3></li>
<li>它简要地描述了客户端想要如何操作服务器端的资源。</li>
<li>请求行由三部分构成：</li>
</ul>
<ol>
<li>请求方法：是一个动词，如 GET/POST，表示对资源的操作；</li>
<li>请求目标：通常是一个 URI，标记了请求方法要操作的资源；</li>
<li>版本号：表示报文使用的 HTTP 协议版本。</li>
</ol>
<ul>
<li>这三个部分通常使用空格（space）来分隔，最后要用 CRLF 换行表示结束。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line"></span><br><span class="line">在这个请求行里，“GET”是请求方法，“/”是请求目标，“HTTP/1.1”是版本号，</span><br><span class="line">把这三部分连起来，意思就是“服务器你好，我想获取网站根目录下的默认文件，</span><br><span class="line">我用的协议版本号是 1.1，请不要用 1.0 或者 2.0 回复我。”</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h3><ul>
<li>响应报文里的起始行，在这里它不叫“响应行”，而是叫“状态行”（status line），意思是服务器响应的状态。</li>
<li>比起请求行来说，状态行要简单一些，同样也是由三部分构成：</li>
</ul>
<ol>
<li>版本号：表示报文使用的 HTTP 协议版本；</li>
<li>状态码：一个三位数，用代码的形式表示处理的结果，比如 200 是成功，500 是服务器错误；</li>
<li>原因：作为数字状态码补充，是更详细的解释文字，帮助人理解原因。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">意思就是：“浏览器你好，我已经处理完了你的请求，这个报文使用的协议版本号是 1.1，状态码是 200，一切 OK。”</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HTTP/1.1 404 Not Found</span><br><span class="line">翻译成人话就是：“抱歉啊浏览器，刚才你的请求收到了，但我没找到你要的资源，错误代码是 404，接下来的事情你就看着办吧。”</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="头部字段"><a href="#头部字段" class="headerlink" title="头部字段"></a>头部字段</h3><ul>
<li>头部字段是 key-value 的形式，key 和 value 之间用“:”分隔，最后用 CRLF 换行表示字段结束。比如在“Host: 127.0.0.1”这一行里 key 就是“Host”，value 就是“127.0.0.1”。</li>
<li>HTTP 头字段非常灵活，不仅可以使用标准里的 Host、Connection 等已有头，也可以任意添加自定义头，这就给 HTTP 协议带来了无限的扩展可能。</li>
<li>不过使用头字段需要注意下面几点：</li>
</ul>
<ol>
<li>字段名不区分大小写，例如“Host”也可以写成“host”，但首字母大写的可读性更好；</li>
<li>字段名里不允许出现空格，可以使用连字符“-”，但不能使用下划线“_”。例如，“test-name”是合法的字段名，而“test name”“test_name”是不正确的字段名；</li>
<li>字段名后面必须紧接着“:”，不能有空格，而“:”后的字段值前可以有多个空格；</li>
<li>字段的顺序是没有意义的，可以任意排列不影响语义；</li>
<li>字段原则上不能重复，除非这个字段本身的语义允许，例如 Set-Cookie。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">GET /09-1 HTTP/1.1</span><br><span class="line">Host:   www.diamonds.com</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GET /09-1 HTTP/1.1</span><br><span class="line">Host : www.diamonds.com</span><br><span class="line"></span><br><span class="line">第一个可以正确获取服务器的响应报文，而第二个得到的会是一个“400 Bad Request”，表示请求报文格式有误，服务器无法正确处理：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HTTP/1.1 400 Bad Request</span><br><span class="line">Server: openresty/1.15.8.1</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="常用头字段"><a href="#常用头字段" class="headerlink" title="常用头字段"></a>常用头字段</h3><ul>
<li>HTTP 协议规定了非常多的头部字段，实现各种各样的功能，但基本上可以分为四大类：</li>
</ul>
<ol>
<li>通用字段：在请求头和响应头里都可以出现；</li>
<li>请求字段：仅能出现在请求头里，进一步说明请求信息或者额外的附加条件；</li>
<li>响应字段：仅能出现在响应头里，补充说明响应报文的信息；</li>
<li>实体字段：它实际上属于通用字段，但专门描述 body 的额外信息。</li>
</ol>
<ul>
<li>对 HTTP 报文的解析和处理实际上主要就是对头字段的处理，理解了头字段也就理解了 HTTP 报文。</li>
<li>Host 字段，它属于请求字段，只能出现在请求头里，它同时也是唯一一个 HTTP/1.1 规范里要求必须出现的字段，也就是说，如果请求头里没有 Host，那这就是一个错误的报文。Host 字段告诉服务器这个请求应该由哪个主机来处理，当一台计算机上托管了多个虚拟主机的时候，服务器端就需要用 Host 字段来选择，有点像是一个简单的“路由重定向”。例如我们的试验环境，在 127.0.0.1 上有三个虚拟主机：“<a href="http://www.diamonds.com”“www.metroid.net”和“origin.io”。那么当使用域名的方式访问时，就必须要用" target="_blank" rel="noopener">www.diamonds.com”“www.metroid.net”和“origin.io”。那么当使用域名的方式访问时，就必须要用</a> Host 字段来区分这三个 IP 相同但域名不同的网站，否则服务器就会找不到合适的虚拟主机，无法处理。</li>
<li>User-Agent 是请求字段，只出现在请求头里。它使用一个字符串来描述发起 HTTP 请求的客户端，服务器可以依据它来返回最合适此浏览器显示的页面。但由于历史的原因，User-Agent 非常混乱，每个浏览器都自称是“Mozilla”“Chrome”“Safari”，企图使用这个字段来互相“伪装”，导致 User-Agent 变得越来越长，最终变得毫无意义。不过有的比较“诚实”的爬虫会在 User-Agent 里用“spider”标明自己是爬虫，所以可以利用这个字段实现简单的反爬虫策略。</li>
<li>Date 字段是一个通用字段，但通常出现在响应头里，表示 HTTP 报文创建的时间，客户端可以使用这个时间再搭配其他字段决定缓存策略。</li>
<li>Server 字段是响应字段，只能出现在响应头里。它告诉客户端当前正在提供 Web 服务的软件名称和版本号，例如在我们的实验环境里它就是“Server: openresty/1.15.8.1”，即使用的是 OpenResty 1.15.8.1。Server 字段也不是必须要出现的，因为这会把服务器的一部分信息暴露给外界，如果这个版本恰好存在 bug，那么黑客就有可能利用 bug 攻陷服务器。所以，有的网站响应头里要么没有这个字段，要么就给出一个完全无关的描述信息。</li>
<li>实体字段里要说的一个是 Content-Length，它表示报文里 body 的长度，也就是请求头或响应头空行后面数据的长度。服务器看到这个字段，就知道了后续有多少数据，可以直接接收。如果没有这个字段，那么 body 就是不定长的，需要使用 chunked 方式分段传输。</li>
</ul>
<h2 id="应该如何理解请求方法？"><a href="#应该如何理解请求方法？" class="headerlink" title="应该如何理解请求方法？"></a>应该如何理解请求方法？</h2><h3 id="标准请求方法"><a href="#标准请求方法" class="headerlink" title="标准请求方法"></a>标准请求方法</h3><ul>
<li>它的实际含义就是客户端发出了一个“动作指令”，要求服务器端对 URI 定位的资源执行这个动作。</li>
<li>目前 HTTP/1.1 规定了八种方法，单词都必须是大写的形式，</li>
</ul>
<ol>
<li>GET：获取资源，可以理解为读取或者下载数据；</li>
<li>HEAD：获取资源的元信息；</li>
<li>POST：向资源提交数据，相当于写入或上传数据；</li>
<li>PUT：类似 POST；</li>
<li>DELETE：删除资源；</li>
<li>CONNECT：建立特殊的连接隧道；</li>
<li>OPTIONS：列出可对资源实行的方法；</li>
<li>TRACE：追踪请求 - 响应的传输路径。</li>
</ol>
<ul>
<li>服务器掌控着所有资源，也就有绝对的决策权力。它收到 HTTP 请求报文后，看到里面的请求方法，可以执行也可以拒绝，或者改变动作的含义，毕竟 HTTP 是一个“协议”，两边都要“商量着来”。</li>
<li>比如，你发起了一个 GET 请求，想获取“/orders”这个文件，但这个文件保密级别比较高，不是谁都能看的，服务器就可以有如下的几种响应方式：</li>
</ul>
<ol>
<li>假装这个文件不存在，直接返回一个 404 Not found 报文；</li>
<li>稍微友好一点，明确告诉你有这个文件，但不允许访问，返回一个 403 Forbidden；</li>
<li>再宽松一些，返回 405 Method Not Allowed，然后用 Allow 头告诉你可以用 HEAD 方法获取文件的元信息。<h3 id="GET-HEAD"><a href="#GET-HEAD" class="headerlink" title="GET/HEAD"></a>GET/HEAD</h3></li>
</ol>
<ul>
<li>GET 方法应该是 HTTP 协议里最知名的请求方法了，它的含义是请求从服务器获取资源，这个资源既可以是静态的文本、页面、图片、视频，也可以是由 PHP、Java 动态生成的页面或者其他格式的数据。GET 方法虽然基本动作比较简单，但搭配 URI 和其他头字段就能实现对资源更精细的操作。例如，在 URI 后使用“#”，就可以在获取页面后直接定位到某个标签所在的位置；使用 If-Modified-Since 字段就变成了“有条件的请求”，仅当资源被修改时才会执行获取动作；使用 Range 字段就是“范围请求”，只获取资源的一部分数据。</li>
<li>HEAD 方法与 GET 方法类似，也是请求从服务器获取资源，服务器的处理机制也是一样的，但服务器不会返回请求的实体数据，只会传回响应头，也就是资源的“元信息”。HEAD 方法可以看做是 GET 方法的一个“简化版”或者“轻量版”。因为它的响应头与 GET 完全相同，所以可以用在很多并不真正需要资源的场合，避免传输 body 数据的浪费。比如，想要检查一个文件是否存在，只要发个 HEAD 请求就可以了，没有必要用 GET 把整个文件都取下来。再比如，要检查文件是否有最新版本，同样也应该用 HEAD，服务器会在响应头里把文件的修改时间传回来。</li>
</ul>
<h3 id="POST-PUT"><a href="#POST-PUT" class="headerlink" title="POST/PUT"></a>POST/PUT</h3><ul>
<li>POST 也是一个经常用到的请求方法，PUT 的作用与 POST 类似，也可以向服务器提交数据，但与 POST 存在微妙的不同，通常 POST 表示的是“新建”“create”的含义，而 PUT 则是“修改”“update”的含义。<h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3></li>
<li>DELETE 方法指示服务器删除资源，因为这个动作危险性太大，所以通常服务器不会执行真正的删除操作，而是对资源做一个删除标记。当然，更多的时候服务器就直接不处理 DELETE 请求。</li>
<li>CONNECT 是一个比较特殊的方法，要求服务器为客户端和另一台远程服务器建立一条特殊的连接隧道，这时 Web 服务器在中间充当了代理的角色。</li>
<li>OPTIONS 方法要求服务器列出可对资源实行的操作方法，在响应头的 Allow 字段里返回。它的功能很有限，用处也不大，有的服务器（例如 Nginx）干脆就没有实现对它的支持。</li>
<li>TRACE 方法多用于对 HTTP 链路的测试或诊断，可以显示出请求 - 响应的传输路径。它的本意是好的，但存在漏洞，会泄漏网站的信息，所以 Web 服务器通常也是禁止使用。<h3 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h3></li>
<li>虽然 HTTP/1.1 里规定了八种请求方法，但它并没有限制我们只能用这八种方法，这也体现了 HTTP 协议良好的扩展性，我们可以任意添加请求动作，只要请求方和响应方都能理解就行。</li>
<li>例如著名的愚人节玩笑 RFC2324，它定义了协议 HTCPCP，即“超文本咖啡壶控制协议”，为 HTTP 协议增加了用来煮咖啡的 BREW 方法，要求添牛奶的 WHEN 方法。</li>
<li>此外，还有一些得到了实际应用的请求方法（WebDAV），例如 MKCOL、COPY、MOVE、LOCK、UNLOCK、PATCH 等。如果有合适的场景，你也可以把它们应用到自己的系统里，比如用 LOCK 方法锁定资源暂时不允许修改，或者使用 PATCH 方法给资源打个小补丁，部分更新数据。但因为这些方法是非标准的，所以需要为客户端和服务器编写额外的代码才能添加支持。<h3 id="安全与幂等"><a href="#安全与幂等" class="headerlink" title="安全与幂等"></a>安全与幂等</h3></li>
<li>在 HTTP 协议里，所谓的“安全”是指请求方法不会“破坏”服务器上的资源，即不会对服务器上的资源造成实质的修改。</li>
<li>按照这个定义，只有 GET 和 HEAD 方法是“安全”的，因为它们是“只读”操作，只要服务器不故意曲解请求方法的处理方式，无论 GET 和 HEAD 操作多少次，服务器上的数据都是“安全的”。而 POST/PUT/DELETE 操作会修改服务器上的资源，增加或删除数据，所以是“不安全”的。</li>
<li>所谓的“幂等”实际上是一个数学用语，被借用到了 HTTP 协议里，意思是多次执行相同的操作，结果也都是相同的，即多次“幂”后结果“相等”。</li>
<li>很显然，GET 和 HEAD 既是安全的也是幂等的，DELETE 可以多次删除同一个资源，效果都是“资源不存在”，所以也是幂等的。POST 和 PUT 的幂等性质就略费解一点。</li>
<li>按照 RFC 里的语义，POST 是“新增或提交数据”，多次提交数据会创建多个资源，所以不是幂等的；而 PUT 是“替换或更新数据”，多次更新一个资源，资源还是会第一次更新的状态，所以是幂等的。可以对比一下 SQL 来加深理解：把 POST 理解成 INSERT，把 PUT 理解成 UPDATE，这样就很清楚了。多次 INSERT 会添加多条记录，而多次 UPDATE 只操作一条记录，而且效果相同。</li>
</ul>
<h2 id="你能写出正确的网址吗？"><a href="#你能写出正确的网址吗？" class="headerlink" title="你能写出正确的网址吗？"></a>你能写出正确的网址吗？</h2><ul>
<li>严格地说，URI统一资源标识符（Uniform Resource Identifier） 不完全等同于网址，它包含有 URL 和 URN 两个部分，在 HTTP 世界里用的网址实际上是 URL——统一资源定位符（Uniform Resource Locator）。但因为 URL 实在是太普及了，所以常常把这两者简单地视为相等。<h3 id="URI-的格式"><a href="#URI-的格式" class="headerlink" title="URI 的格式"></a>URI 的格式</h3></li>
<li>URI 本质上是一个字符串，这个字符串的作用是唯一地标记资源的位置或者名字。它不仅能够标记万维网的资源，也可以标记其他的，如邮件系统、本地文件系统等任意资源。而“资源”既可以是存在磁盘上的静态文本、页面数据，也可以是由 Java、PHP 提供的动态服务。<h3 id="URI-的基本组成"><a href="#URI-的基本组成" class="headerlink" title="URI 的基本组成"></a>URI 的基本组成</h3></li>
<li>URI 第一个组成部分叫 scheme，翻译成中文叫“方案名”或者“协议名”，表示资源应该使用哪种协议来访问。最常见的当然就是“http”了，表示使用 HTTP 协议。另外还有“https”，表示使用经过加密、安全的 HTTPS 协议。此外还有其他不是很常见的 scheme，例如 ftp、ldap、file、news 等。</li>
<li>在 scheme 之后，必须是三个特定的字符“://”，它把 scheme 和后面的部分分离开。URI 的创造者蒂姆·伯纳斯 - 李也曾经私下承认“://”并非必要，当初有些“过于草率”了。</li>
<li>在“://”之后，是被称为“authority”的部分，表示资源所在的主机名，通常的形式是“host:port”，即主机名加端口号。主机名可以是 IP 地址或者域名的形式，必须要有，否则浏览器就会找不到服务器。但端口号有时可以省略，浏览器等客户端会依据 scheme 使用默认的端口号，例如 HTTP 的默认端口号是 80，HTTPS 的默认端口号是 443。</li>
<li>有了协议名和主机地址、端口号，再加上后面标记资源所在位置的 path，浏览器就可以连接服务器访问资源了。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">http://nginx.org</span><br><span class="line">https://tools.ietf.org/html/rfc7230</span><br><span class="line">file:///D:/http_study/www/</span><br><span class="line"></span><br><span class="line">最后一个 URI 要注意了，它的协议名不是“http”，而是“file”，表示这是本地文件，而后面居然有三个斜杠，这是怎么回事？</span><br><span class="line">这三个斜杠里的前两个属于 URI 特殊分隔符“://”，然后后面的“/D:/http_study/www/”是路径，而中间的主机名被“省略”了。</span><br><span class="line">这实际上是 file 类型 URI 的“特例”，它允许省略主机名，默认是本机 localhost。</span><br><span class="line"></span><br><span class="line">但对于 HTTP 或 HTTPS 这样的网络通信协议，主机名是绝对不能省略的。原因之前也说了，会导致浏览器无法找到服务器。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="URI-的查询参数"><a href="#URI-的查询参数" class="headerlink" title="URI 的查询参数"></a>URI 的查询参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">http://www.diamonds.com:8080/11-1?uid=1234&amp;name=mario&amp;referer=xxx</span><br></pre></td></tr></table></figure>
<h3 id="URI-的完整格式"><a href="#URI-的完整格式" class="headerlink" title="URI 的完整格式"></a>URI 的完整格式</h3><ul>
<li>第一个多出的部分是协议名之后、主机名之前的身份信息“user:passwd@”，表示登录主机时的用户名和密码，但现在已经不推荐使用这种形式了（RFC7230），因为它把敏感信息以明文形式暴露出来，存在严重的安全隐患。</li>
<li>第二个多出的部分是查询参数后的片段标识符“#fragment”，它是 URI 所定位的资源内部的一个“锚点”或者说是“标签”，浏览器可以在获取资源后直接跳转到它指示的位置。但片段标识符仅能由浏览器这样的客户端使用，服务器是看不到的。也就是说，浏览器永远不会把带“#fragment”的 URI 发送给服务器，服务器也永远不会用这种方式去处理资源的片段。</li>
</ul>
<h3 id="URI-的编码"><a href="#URI-的编码" class="headerlink" title="URI 的编码"></a>URI 的编码</h3><ul>
<li>URI 引入了编码机制，对于 ASCII 码以外的字符集和特殊字符做一个特殊的操作，把它们转换成与 URI 语义不冲突的形式。这在 RFC 规范里称为“escape”和“unescape”，俗称“转义”。</li>
<li>URI 转义的规则有点“简单粗暴”，直接把非 ASCII 码或特殊字符转换成十六进制字节值，然后前面再加上一个“%”。例如，空格被转义成“%20”，“?”被转义成“%3F”。而中文、日文等则通常使用 UTF-8 编码后再转义，例如“银河”会被转义成“%E9%93%B6%E6%B2%B3”。</li>
<li>不过我们在浏览器的地址栏里通常是不会看到这些转义后的“乱码”的，这实际上是浏览器一种“友好”表现，隐藏了 URI 编码后的“丑陋一面”，</li>
</ul>
<h2 id="响应状态码该怎么用？"><a href="#响应状态码该怎么用？" class="headerlink" title="响应状态码该怎么用？"></a>响应状态码该怎么用？</h2><ul>
<li>RFC 标准把状态码分成了五类，用数字的第一位表示分类，而 0~99 不用，这样状态码的实际可用范围就大大缩小了，由 000~999 变成了 100~599。</li>
</ul>
<ol>
<li>1××：提示信息，表示目前是协议处理的中间状态，还需要后续的操作；</li>
<li>2××：成功，报文已经收到并被正确处理；</li>
<li>3××：重定向，资源位置发生变动，需要客户端重新发送请求；</li>
<li>4××：客户端错误，请求报文有误，服务器无法处理；</li>
<li>5××：服务器错误，服务器在处理请求时内部发生了错误。<h3 id="1××"><a href="#1××" class="headerlink" title="1××"></a>1××</h3></li>
</ol>
<ul>
<li>1××类状态码属于提示信息，是协议处理的中间状态，实际能够用到的时候很少。</li>
<li>“101 Switching Protocols”。它的意思是客户端使用 Upgrade 头字段，要求在 HTTP 协议的基础上改成其他的协议继续通信，比如 WebSocket。而如果服务器也同意变更协议，就会发送状态码 101，但这之后的数据传输就不会再使用 HTTP 了。<h3 id="2××"><a href="#2××" class="headerlink" title="2××"></a>2××</h3></li>
<li>“204 No Content”是另一个很常见的成功状态码，它的含义与“200 OK”基本相同，但响应头后没有 body 数据。所以对于 Web 服务器来说，正确地区分 200 和 204 是很必要的。</li>
<li>“206 Partial Content”是 HTTP 分块下载或断点续传的基础，在客户端发送“范围请求”、要求获取资源的部分数据时出现，它与 200 一样，也是服务器成功处理了请求，但 body 里的数据不是资源的全部，而是其中的一部分。状态码 206 通常还会伴随着头字段“Content-Range”，表示响应报文里 body 数据的具体范围，供客户端确认，例如“Content-Range: bytes 0-99/2000”，意思是此次获取的是总计 2000 个字节的前 100 个字节。<h3 id="3××"><a href="#3××" class="headerlink" title="3××"></a>3××</h3></li>
<li>“301 Moved Permanently”俗称“永久重定向”，含义是此次请求的资源已经不存在了，需要改用新的 URI 再次访问。比如，你的网站升级到了 HTTPS，原来的 HTTP 不打算用了，这就是“永久”的，所以要配置 301 跳转，把所有的 HTTP 流量都切换到 HTTPS。</li>
<li>“302 Found”，曾经的描述短语是“Moved Temporarily”，俗称“临时重定向”，意思是请求的资源还在，但需要暂时用另一个 URI 来访问。301 和 302 都会在响应头里使用字段 Location 指明后续要跳转的 URI，最终的效果很相似，浏览器都会重定向到新的 URI。两者的根本区别在于语义，一个是“永久”，一个是“临时”，所以在场景、用法上差距很大。比如，今天夜里网站后台要系统维护，服务暂时不可用，这就属于“临时”的，可以配置成 302 跳转，把流量临时切换到一个静态通知页面，浏览器看到这个 302 就知道这只是暂时的情况，不会做缓存优化，第二天还会访问原来的地址。</li>
<li>“304 Not Modified” 是一个比较有意思的状态码，它用于 If-Modified-Since 等条件请求，表示资源未修改，用于缓存控制。它不具有通常的跳转含义，但可以理解成“重定向已到缓存的文件”（即“缓存重定向”）。<h3 id="4××"><a href="#4××" class="headerlink" title="4××"></a>4××</h3></li>
<li>“400 Bad Request”是一个通用的错误码，表示请求报文有错误，但具体是数据格式错误、缺少请求头还是 URI 超长它没有明确说，只是一个笼统的错误，客户端看到 400 只会是“一头雾水”“不知所措”。所以，在开发 Web 应用时应当尽量避免给客户端返回 400，而是要用其他更有明确含义的状态码。</li>
<li>“403 Forbidden”实际上不是客户端的请求出错，而是表示服务器禁止访问资源。原因可能多种多样，例如信息敏感、法律禁止等，如果服务器友好一点，可以在 body 里详细说明拒绝请求的原因，不过现实中通常都是直接给一个“闭门羹”。</li>
<li>“404 Not Found”可能是我们最常看见也是最不愿意看到的一个状态码，它的原意是资源在本服务器上未找到，所以无法提供给客户端。但现在已经被“用滥了”，只要服务器“不高兴”就可以给出个 404，而我们也无从得知后面到底是真的未找到，还是有什么别的原因，某种程度上它比 403 还要令人讨厌。</li>
<li>405 Method Not Allowed：不允许使用某些方法操作资源，例如不允许 POST 只能 GET；</li>
<li>406 Not Acceptable：资源无法满足客户端请求的条件，例如请求中文但只有英文；</li>
<li>408 Request Timeout：请求超时，服务器等待了过长的时间；</li>
<li>409 Conflict：多个请求发生了冲突，可以理解为多线程并发时的竞态；</li>
<li>413 Request Entity Too Large：请求报文里的 body 太大；</li>
<li>414 Request-URI Too Long：请求行里的 URI 太大；</li>
<li>429 Too Many Requests：客户端发送了太多的请求，通常是由于服务器的限连策略；</li>
<li>431 Request Header Fields Too Large：请求头某个字段或总体太大；<h3 id="5××"><a href="#5××" class="headerlink" title="5××"></a>5××</h3></li>
<li>“500 Internal Server Error”与 400 类似，也是一个通用的错误码，服务器究竟发生了什么错误我们是不知道的。不过对于服务器来说这应该算是好事，通常不应该把服务器内部的详细信息，例如出错的函数调用栈告诉外界。虽然不利于调试，但能够防止黑客的窥探或者分析。</li>
<li>“501 Not Implemented”表示客户端请求的功能还不支持，这个错误码比 500 要“温和”一些，和“即将开业，敬请期待”的意思差不多，不过具体什么时候“开业”就不好说了。</li>
<li>“502 Bad Gateway”通常是服务器作为网关或者代理时返回的错误码，表示服务器自身工作正常，访问后端服务器时发生了错误，但具体的错误原因也是不知道的。<br>*　“503 Service Unavailable”表示服务器当前很忙，暂时无法响应服务，我们上网时有时候遇到的“网络服务正忙，请稍后重试”的提示信息就是状态码 503。503 是一个“临时”的状态，很可能过几秒钟后服务器就不那么忙了，可以继续提供服务，所以 503 响应报文里通常还会有一个“Retry-After”字段，指示客户端可以在多久以后再次尝试发送请求。</li>
</ul>
<h2 id="HTTP有哪些特点？"><a href="#HTTP有哪些特点？" class="headerlink" title="HTTP有哪些特点？"></a>HTTP有哪些特点？</h2><ul>
<li>灵活可扩展。HTTP 是灵活可扩展的，可以任意添加头字段实现任意功能；</li>
<li>可靠传输。这个特点显而易见，因为 HTTP 协议是基于 TCP/IP 的，而 TCP 本身是一个“可靠”的传输协议，所以 HTTP 自然也就继承了这个特性，能够在请求方和应答方之间“可靠”地传输数据。</li>
<li>应用层协议。虽然出现了许多的应用层协议，但它们都仅关注很小的应用领域，局限在很少的应用场景。例如 FTP 只能传输文件、SMTP 只能发送邮件、SSH 只能远程登录等，在通用的数据传输方面“完全不能打”。所以 HTTP 凭借着可携带任意头字段和实体数据的报文结构，以及连接控制、缓存代理等方便易用的特性，一出现就“技压群雄”，迅速成为了应用层里的“明星”协议。只要不太苛求性能，HTTP 几乎可以传递一切东西，满足各种需求，称得上是一个“万能”的协议。HTTP 完全可以用开玩笑的口吻说：“不要误会，我不是针对 FTP，我是说在座的应用层各位，都是垃圾。”</li>
<li>请求 - 应答。</li>
<li>无状态。“无状态”形象地来说就是“没有记忆能力”。比如，浏览器发了一个请求，说“我是小明，请给我 A 文件。”，服务器收到报文后就会检查一下权限，看小明确实可以访问 A 文件，于是把文件发回给浏览器。接着浏览器还想要 B 文件，但服务器不会记录刚才的请求状态，不知道第二个请求和第一个请求是同一个浏览器发来的，所以浏览器必须还得重复一次自己的身份才行：“我是刚才的小明，请再给我 B 文件。”我们可以再对比一下 UDP 协议，不过它是无连接也无状态的，顺序发包乱序收包，数据包发出去后就不管了，收到后也不会顺序整理。而 HTTP 是有连接无状态，顺序发包顺序收包，按照收发的顺序管理报文。</li>
</ul>
<h2 id="HTTP有哪些优点？又有哪些缺点？"><a href="#HTTP有哪些优点？又有哪些缺点？" class="headerlink" title="HTTP有哪些优点？又有哪些缺点？"></a>HTTP有哪些优点？又有哪些缺点？</h2><ul>
<li>HTTP 最大的优点是简单、灵活和易于扩展；</li>
<li>HTTP 拥有成熟的软硬件环境，应用的非常广泛，是互联网的基础设施；</li>
<li>HTTP 是无状态的，可以轻松实现集群化，扩展性能，但有时也需要用 Cookie 技术来实现“有状态”；</li>
<li>HTTP 是明文传输，数据完全肉眼可见，能够方便地研究分析，但也容易被窃听；</li>
<li>HTTP 是不安全的，无法验证通信双方的身份，也不能判断报文是否被窜改；</li>
<li>HTTP 的性能不算差，但不完全适应现在的互联网，还有很大的提升空间。</li>
</ul>
<h2 id="HTTP的实体数据"><a href="#HTTP的实体数据" class="headerlink" title="HTTP的实体数据"></a>HTTP的实体数据</h2><h3 id="数据类型与编码"><a href="#数据类型与编码" class="headerlink" title="数据类型与编码"></a>数据类型与编码</h3><ul>
<li>在 TCP/IP 协议栈里，传输数据基本上都是“header+body”的格式。但 TCP、UDP 因为是传输层的协议，它们不会关心 body 数据是什么，只要把数据发送到对方就算是完成了任务。</li>
<li>而 HTTP 协议则不同，它是应用层的协议，数据到达之后工作只能说是完成了一半，还必须要告诉上层应用这是什么数据才行，否则上层应用就会“不知所措”。早在 HTTP 协议诞生之前就已经有了针对这种问题的解决方案，不过它是用在电子邮件系统里的，让电子邮件可以发送 ASCII 码以外的任意数据，方案的名字叫做“多用途互联网邮件扩展”（Multipurpose Internet Mail Extensions），简称为 MIME。</li>
<li>MIME 是一个很大的标准规范，但 HTTP 只“顺手牵羊”取了其中的一部分，用来标记 body 的数据类型，这就是我们平常总能听到的“MIME type”。MIME 把数据分成了八大类，每个大类下再细分出多个子类，形式是“type/subtype”的字符串，巧得很，刚好也符合了 HTTP 明文的特点，所以能够很容易地纳入 HTTP 头字段里。</li>
</ul>
<ol>
<li>text：即文本格式的可读数据，我们最熟悉的应该就是 text/html 了，表示超文本文档，此外还有纯文本 text/plain、样式表 text/css 等。</li>
<li>image：即图像文件，有 image/gif、image/jpeg、image/png 等。</li>
<li>audio/video：音频和视频数据，例如 audio/mpeg、video/mp4 等。</li>
<li>application：数据格式不固定，可能是文本也可能是二进制，必须由上层应用程序来解释。常见的有 application/json，application/javascript、application/pdf 等，另外，如果实在是不知道数据是什么类型，像刚才说的“黑盒”，就会是 application/octet-stream，即不透明的二进制数据。</li>
</ol>
<ul>
<li>但仅有 MIME type 还不够，因为 HTTP 在传输时为了节约带宽，有时候还会压缩数据，为了不要让浏览器继续“猜”，还需要有一个“Encoding type”，告诉数据是用的什么编码格式，这样对方才能正确解压缩，还原出原始的数据。</li>
<li>比起 MIME type 来说，Encoding type 就少了很多，常用的只有下面三种：</li>
</ul>
<ol>
<li>gzip：GNU zip 压缩格式，也是互联网上最流行的压缩格式；</li>
<li>deflate：zlib（deflate）压缩格式，流行程度仅次于 gzip；</li>
<li>br：一种专门为 HTTP 优化的新压缩算法（Brotli）。<h3 id="数据类型使用的头字段"><a href="#数据类型使用的头字段" class="headerlink" title="数据类型使用的头字段"></a>数据类型使用的头字段</h3></li>
</ol>
<ul>
<li>客户端用 Accept 头告诉服务器希望接收什么样的数据，而服务器用 Content 头告诉客户端实际发送了什么样的数据。</li>
<li><p>Accept 字段标记的是客户端可理解的 MIME type，可以用“,”做分隔符列出多个类型，让服务器有更多的选择余地，例如下面的这个头：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Accept: text/html,application/xml,image/webp,image/png</span><br><span class="line">这就是告诉服务器：“我能够看懂 HTML、XML 的文本，还有 webp 和 png 的图片，请给我这四类格式的数据”。</span><br></pre></td></tr></table></figure>
</li>
<li><p>相应的，服务器会在响应报文里用头字段 Content-Type 告诉实体数据的真实类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Type: image/png</span><br></pre></td></tr></table></figure>
</li>
<li><p>Accept-Encoding 字段标记的是客户端支持的压缩格式，例如上面说的 gzip、deflate 等，同样也可以用“,”列出多个，服务器可以选择其中一种来压缩数据，实际使用的压缩格式放在响应头字段 Content-Encoding 里。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Content-Encoding: gzip</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果请求报文里没有 Accept-Encoding 字段，就表示客户端不支持压缩数据；如果响应报文里没有 Content-Encoding 字段，就表示响应数据没有被压缩。</p>
</li>
</ul>
<h3 id="语言类型与编码"><a href="#语言类型与编码" class="headerlink" title="语言类型与编码"></a>语言类型与编码</h3><ul>
<li><p>Accept-Language 字段标记了客户端可理解的自然语言，也允许用“,”做分隔符列出多个类型，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Accept-Language: zh-CN, zh, en</span><br><span class="line">这个请求头会告诉服务器：“最好给我 zh-CN 的汉语文字，如果没有就用其他的汉语方言，如果还没有就给英文”。</span><br></pre></td></tr></table></figure>
</li>
<li><p>相应的，服务器应该在响应报文里用头字段 Content-Language 告诉客户端实体数据使用的实际语言类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Content-Language: zh-CN</span><br></pre></td></tr></table></figure>
</li>
<li><p>字符集在 HTTP 里使用的请求头字段是 Accept-Charset，但响应头里却没有对应的 Content-Charset，而是在 Content-Type 字段的数据类型后面用“charset=xxx”来表示，这点需要特别注意。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Accept-Charset: gbk, utf-8</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="内容协商的质量值"><a href="#内容协商的质量值" class="headerlink" title="内容协商的质量值"></a>内容协商的质量值</h3><ul>
<li>在 HTTP 协议里用 Accept、Accept-Encoding、Accept-Language 等请求头字段进行内容协商的时候，还可以用一种特殊的“q”参数表示权重来设定优先级，这里的“q”是“quality factor”的意思。</li>
<li>权重的最大值是 1，最小值是 0.01，默认值是 1，如果值是 0 就表示拒绝。具体的形式是在数据类型或语言代码后面加一个“;”，然后是“q=value”。这里要提醒的是“;”的用法，在大多数编程语言里“;”的断句语气要强于“,”，而在 HTTP 的内容协商里却恰好反了过来，“;”的意义是小于“,”的。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Accept: text/html,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line"></span><br><span class="line">它表示浏览器最希望使用的是 HTML 文件，权重是 1，其次是 XML 文件，权重是 0.9，最后是任意数据类型，权重是 0.8。服务器收到请求头后，就会计算权重，再根据自己的实际情况优先输出 HTML 或者 XML。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="内容协商的结果"><a href="#内容协商的结果" class="headerlink" title="内容协商的结果"></a>内容协商的结果</h3><ul>
<li>内容协商的过程是不透明的，每个 Web 服务器使用的算法都不一样。但有的时候，服务器会在响应头里多加一个 Vary 字段，记录服务器在内容协商时参考的请求头字段，给出一点信息，例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Vary: Accept-Encoding,User-Agent,Accept</span><br><span class="line">这个 Vary 字段表示服务器依据了 Accept-Encoding、User-Agent 和 Accept 这三个头字段，然后决定了发回的响应报文。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="HTTP传输大文件的方法"><a href="#HTTP传输大文件的方法" class="headerlink" title="HTTP传输大文件的方法"></a>HTTP传输大文件的方法</h2><h3 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a>数据压缩</h3><ul>
<li>通常浏览器在发送请求时都会带着“Accept-Encoding”头字段，里面是浏览器支持的压缩格式列表，例如 gzip、deflate、br 等，这样服务器就可以从中选择一种压缩算法，放进“Content-Encoding”响应头里，再把原数据压缩后发给浏览器。</li>
<li>gzip 等压缩算法通常只对文本文件有较好的压缩率，而图片、音频视频等多媒体数据本身就已经是高度压缩的，再用 gzip 处理也不会变小（甚至还有可能会增大一点），所以它就失效了。</li>
<li>不过数据压缩在处理文本的时候效果还是很好的，所以各大网站的服务器都会使用这个手段作为“保底”。例如，在 Nginx 里就会使用“gzip on”指令，启用对“text/html”的压缩。<h3 id="分块传输"><a href="#分块传输" class="headerlink" title="分块传输"></a>分块传输</h3></li>
<li>压缩是把大文件整体变小，我们可以反过来思考，如果大文件整体不能变小，那就把它“拆开”，分解成多个小块，把这些小块分批发给浏览器，浏览器收到后再组装复原。</li>
<li>这种“化整为零”的思路在 HTTP 协议里就是“chunked”分块传输编码，在响应报文里用头字段“Transfer-Encoding: chunked”来表示，意思是报文里的 body 部分不是一次性发过来的，而是分成了许多的块（chunk）逐个发送。</li>
<li>分块传输也可以用于“流式数据”，例如由数据库动态生成的表单页面，这种情况下 body 数据的长度是未知的，无法在头字段“Content-Length”里给出确切的长度，所以也只能用 chunked 方式分块发送。</li>
<li>“Transfer-Encoding: chunked”和“Content-Length”这两个字段是互斥的，也就是说响应报文里这两个字段不能同时出现，一个响应报文的传输要么是长度已知，要么是长度未知（chunked），这一点你一定要记住。</li>
<li>下面我们来看一下分块传输的编码规则，其实也很简单，同样采用了明文的方式，很类似响应头。</li>
</ul>
<ol>
<li>每个分块包含两个部分，长度头和数据块；</li>
<li>长度头是以 CRLF（回车换行，即\r\n）结尾的一行明文，用 16 进制数字表示长度；</li>
<li>数据块紧跟在长度头后，最后也用 CRLF 结尾，但数据不包含 CRLF；</li>
<li>最后用一个长度为 0 的块表示结束，即“0\r\n\r\n”。<h3 id="范围请求"><a href="#范围请求" class="headerlink" title="范围请求"></a>范围请求</h3></li>
</ol>
<ul>
<li>比如，你在看当下正热播的某穿越剧，想跳过片头，直接看正片，或者有段剧情很无聊，想拖动进度条快进几分钟，这实际上是想获取一个大文件其中的片段数据，而分块传输并没有这个能力。</li>
<li>HTTP 协议为了满足这样的需求，提出了“范围请求”（range requests）的概念，允许客户端在请求头里使用专用字段来表示只获取文件的一部分，相当于是客户端的“化整为零”。</li>
<li>范围请求不是 Web 服务器必备的功能，可以实现也可以不实现，所以服务器必须在响应头里使用字段“Accept-Ranges: bytes”明确告知客户端：“我是支持范围请求的”。</li>
<li>请求头 Range 是 HTTP 范围请求的专用字段，格式是“bytes=x-y”，其中的 x 和 y 是以字节为单位的数据范围。要注意 x、y 表示的是“偏移量”，范围必须从 0 计数，例如前 10 个字节表示为“0-9”，第二个 10 字节表示为“10-19”，而“0-10”实际上是前 11 个字节。</li>
<li>服务器收到 Range 字段后，需要做四件事。</li>
</ul>
<ol>
<li>第一，它必须检查范围是否合法，比如文件只有 100 个字节，但请求“200-300”，这就是范围越界了。服务器就会返回状态码 416，意思是“你的范围请求有误，我无法处理，请再检查一下”。</li>
<li>第二，如果范围正确，服务器就可以根据 Range 头计算偏移量，读取文件的片段了，返回状态码“206 Partial Content”，和 200 的意思差不多，但表示 body 只是原数据的一部分。</li>
<li>第三，服务器要添加一个响应头字段 Content-Range，告诉片段的实际偏移量和资源的总大小，格式是“bytes x-y/length”，与 Range 头区别在没有“=”，范围后多了总长度。例如，对于“0-10”的范围请求，值就是“bytes 0-10/100”。</li>
<li>最后剩下的就是发送数据了，直接把片段用 TCP 发给客户端，一个范围请求就算是处理完了。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">GET /16-2 HTTP/1.1</span><br><span class="line">Host: www.diamonds.com</span><br><span class="line">Range: bytes=0-31</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HTTP/1.1 206 Partial Content</span><br><span class="line">Content-Length: 32</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Content-Range: bytes 0-31/96</span><br><span class="line"></span><br><span class="line">// this is a plain text json doc</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>有了范围请求之后，HTTP 处理大文件就更加轻松了，看视频时可以根据时间点计算出文件的 Range，不用下载整个文件，直接精确获取片段所在的数据内容。</li>
<li>不仅看视频的拖拽进度需要范围请求，常用的下载工具里的多段下载、断点续传也是基于它实现的，要点是：</li>
</ul>
<ol>
<li>先发个 HEAD，看服务器是否支持范围请求，同时获取文件的大小；</li>
<li>开 N 个线程，每个线程使用 Range 字段划分出各自负责下载的片段，发请求传输数据；</li>
<li>下载意外中断也不怕，不必重头再来一遍，只要根据上次的下载记录，用 Range 请求剩下的那一部分就可以了。</li>
</ol>
<h3 id="多段数据"><a href="#多段数据" class="headerlink" title="多段数据"></a>多段数据</h3><ul>
<li>范围请求一次只获取一个片段，其实它还支持在 Range 头里使用多个“x-y”，一次性获取多个片段数据。</li>
<li>这种情况需要使用一种特殊的 MIME 类型：“multipart/byteranges”，表示报文的 body 是由多段字节序列组成的，并且还要用一个参数“boundary=xxx”给出段之间的分隔标记。</li>
<li>每一个分段必须以“- -boundary”开始（前面加两个“-”），之后要用“Content-Type”和“Content-Range”标记这段数据的类型和所在范围，然后就像普通的响应头一样以回车换行结束，再加上分段数据，最后用一个“- -boundary- -”（前后各有两个“-”）表示所有的分段结束。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">GET /16-2 HTTP/1.1</span><br><span class="line">Host: www.diamonds.com</span><br><span class="line">Range: bytes=0-9, 20-29</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HTTP/1.1 206 Partial Content</span><br><span class="line">Content-Type: multipart/byteranges; boundary=00000000001</span><br><span class="line">Content-Length: 189</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--00000000001</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Range: bytes 0-9/96</span><br><span class="line"></span><br><span class="line">// this is</span><br><span class="line">--00000000001</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Range: bytes 20-29/96</span><br><span class="line"></span><br><span class="line">ext json d</span><br><span class="line">--00000000001--</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="HTTP的连接管理"><a href="#HTTP的连接管理" class="headerlink" title="HTTP的连接管理"></a>HTTP的连接管理</h2><h3 id="短连接"><a href="#短连接" class="headerlink" title="短连接"></a>短连接</h3><ul>
<li>短连接的缺点相当严重，因为在 TCP 协议里，建立连接和关闭连接都是非常“昂贵”的操作。TCP 建立连接要有“三次握手”，发送 3 个数据包，需要 1 个 RTT；关闭连接是“四次挥手”，4 个数据包需要 2 个 RTT。</li>
<li>而 HTTP 的一次简单“请求 - 响应”通常只需要 4 个包，如果不算服务器内部的处理时间，最多是 2 个 RTT。这么算下来，浪费的时间就是“3÷5=60%”，有三分之二的时间被浪费掉了，传输效率低得惊人。<h3 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h3></li>
<li>针对短连接暴露出的缺点，HTTP 协议就提出了“长连接”的通信方式，也叫“持久连接”（persistent connections）、“连接保活”（keep alive）、“连接复用”（connection reuse）。</li>
<li>其实解决办法也很简单，用的就是“成本均摊”的思路，既然 TCP 的连接和关闭非常耗时间，那么就把这个时间成本由原来的一个“请求 - 应答”均摊到多个“请求 - 应答”上</li>
<li>这样虽然不能改善 TCP 的连接效率，但基于“分母效应”，每个“请求 - 应答”的无效时间就会降低不少，整体传输效率也就提高了。</li>
<li>在短连接里发送了三次 HTTP“请求 - 应答”，每次都会浪费 60% 的 RTT 时间。而在长连接的情况下，同样发送三次请求，因为只在第一次时建立连接，在最后一次时关闭连接，所以浪费率就是“3÷9≈33%”，降低了差不多一半的时间损耗。显然，如果在这个长连接上发送的请求越多，分母就越大，利用率也就越高。<h3 id="连接相关的头字段"><a href="#连接相关的头字段" class="headerlink" title="连接相关的头字段"></a>连接相关的头字段</h3></li>
<li>由于长连接对性能的改善效果非常显著，所以在 HTTP/1.1 中的连接都会默认启用长连接。不需要用什么特殊的头字段指定，只要向服务器发送了第一次请求，后续的请求都会重复利用第一次打开的 TCP 连接，也就是长连接，在这个连接上收发数据。</li>
<li>当然，我们也可以在请求头里明确地要求使用长连接机制，使用的字段是 Connection，值是“keep-alive”。</li>
<li>因为 TCP 连接长时间不关闭，服务器必须在内存里保存它的状态，这就占用了服务器的资源。如果有大量的空闲长连接只连不发，就会很快耗尽服务器的资源，导致服务器无法为真正有需要的用户提供服务。</li>
<li>在客户端，可以在请求头里加上“Connection: close”字段，告诉服务器：“这次通信后就关闭连接”。服务器看到这个字段，就知道客户端要主动关闭连接，于是在响应报文里也加上这个字段，发送之后就调用 Socket API 关闭 TCP 连接。</li>
<li>服务器端通常不会主动关闭连接，但也可以使用一些策略。拿 Nginx 来举例，它有两种方式：</li>
</ul>
<ol>
<li>使用“keepalive_timeout”指令，设置长连接的超时时间，如果在一段时间内连接上没有任何数据收发就主动断开连接，避免空闲连接占用系统资源。</li>
<li>使用“keepalive_requests”指令，设置长连接上可发送的最大请求次数。比如设置成 1000，那么当 Nginx 在这个连接上处理了 1000 个请求后，也会主动断开连接。</li>
</ol>
<ul>
<li>另外，客户端和服务器都可以在报文里附加通用头字段“Keep-Alive: timeout=value”，限定长连接的超时时间。但这个字段的约束力并不强，通信的双方可能并不会遵守，所以不太常见。<h3 id="队头阻塞"><a href="#队头阻塞" class="headerlink" title="队头阻塞"></a>队头阻塞</h3></li>
<li>因为 HTTP 规定报文必须是“一发一收”，这就形成了一个先进先出的“串行”队列。队列里的请求没有轻重缓急的优先级，只有入队的先后顺序，排在最前面的请求被最优先处理。</li>
<li>如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本。<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3></li>
<li>在 HTTP 里就是“并发连接”（concurrent connections），也就是同时对一个域名发起多个长连接，用数量来解决质量的问题。但这种方式也存在缺陷。如果每个客户端都想自己快，建立很多个连接，用户数×并发数就会是个天文数字。服务器的资源根本就扛不住，或者被服务器认为是恶意攻击，反而会造成“拒绝服务”。</li>
<li>所以，HTTP 协议建议客户端使用并发，但不能“滥用”并发。RFC2616 里明确限制每个客户端最多并发 2 个连接。不过实践证明这个数字实在是太小了，众多浏览器都“无视”标准，把这个上限提高到了 6~8。后来修订的 RFC7230 也就“顺水推舟”，取消了这个“2”的限制。</li>
<li>“域名分片”（domain sharding）技术，还是用数量来解决质量的思路。HTTP 协议和浏览器不是限制并发连接数量吗？好，那我就多开几个域名，比如 shard1.diamonds.com、shard2.diamonds.com，而这些域名都指向同一台服务器 <a href="http://www.diamonds.com，这样实际长连接的数量就又上去了，真是“美滋滋”。不过实在是有点“上有政策，下有对策”的味道。" target="_blank" rel="noopener">www.diamonds.com，这样实际长连接的数量就又上去了，真是“美滋滋”。不过实在是有点“上有政策，下有对策”的味道。</a><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3></li>
<li>早期的 HTTP 协议使用短连接，收到响应后就立即关闭连接，效率很低；</li>
<li>HTTP/1.1 默认启用长连接，在一个连接上收发多个请求响应，提高了传输效率；</li>
<li>服务器会发送“Connection: keep-alive”字段表示启用了长连接；</li>
<li>报文头里如果有“Connection: close”就意味着长连接即将关闭；</li>
<li>过多的长连接会占用服务器资源，所以服务器会用一些策略有选择地关闭长连接；</li>
<li>“队头阻塞”问题会导致性能下降，可以用“并发连接”和“域名分片”技术缓解。</li>
</ul>
<h2 id="HTTP的重定向和跳转"><a href="#HTTP的重定向和跳转" class="headerlink" title="HTTP的重定向和跳转"></a>HTTP的重定向和跳转</h2><ul>
<li>在 Nginx 的主页上点了一下“download”链接，会发生什么呢？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">http://nginx.org/en/download.html</span><br><span class="line"></span><br><span class="line">浏览器首先要解析链接文字里的 URI。</span><br><span class="line">再用这个 URI 发起一个新的 HTTP 请求，获取响应报文后就会切换显示内容，渲染出新 URI 指向的页面。</span><br><span class="line">这样的跳转动作是由浏览器的使用者主动发起的，可以称为“主动跳转”</span><br><span class="line"></span><br><span class="line">但还有一类跳转是由服务器来发起的，浏览器使用者无法控制，相对地就可以称为“被动跳转”，这在 HTTP 协议里有个专门的名词，叫做“重定向”（Redirection）。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="重定向的过程"><a href="#重定向的过程" class="headerlink" title="重定向的过程"></a>重定向的过程</h3><ul>
<li>301 是“永久重定向”，302 是“临时重定向”，浏览器收到这两个状态码就会跳转到新的 URI。</li>
<li>“Location”字段属于响应字段，必须出现在响应报文里。但只有配合 301/302 状态码才有意义，它标记了服务器要求重定向的 URI，这里就是要求浏览器跳转到“index.html”。</li>
<li>浏览器收到 301/302 报文，会检查响应头里有没有“Location”。如果有，就从字段值里提取出 URI，发出新的 HTTP 请求，相当于自动替我们点击了这个链接。</li>
<li>在“Location”里的 URI 既可以使用绝对 URI，也可以使用相对 URI。所谓“绝对 URI”，就是完整形式的 URI，包括 scheme、host:port、path 等。所谓“相对 URI”，就是省略了 scheme 和 host:port，只有 path 和 query 部分，是不完整的，但可以从请求上下文里计算得到。<h3 id="重定向状态码"><a href="#重定向状态码" class="headerlink" title="重定向状态码"></a>重定向状态码</h3></li>
<li>301 俗称“永久重定向”（Moved Permanently），意思是原 URI 已经“永久”性地不存在了，今后的所有请求都必须改用新的 URI。</li>
<li>浏览器看到 301，就知道原来的 URI“过时”了，就会做适当的优化。比如历史记录、更新书签，下次可能就会直接用新的 URI 访问，省去了再次跳转的成本。搜索引擎的爬虫看到 301，也会更新索引库，不再使用老的 URI。</li>
<li>302 俗称“临时重定向”（“Moved Temporarily”），意思是原 URI 处于“临时维护”状态，新的 URI 是起“顶包”作用的“临时工”。</li>
<li>浏览器或者爬虫看到 302，会认为原来的 URI 仍然有效，但暂时不可用，所以只会执行简单的跳转页面，不记录新的 URI，也不会有其他的多余动作，下次访问还是用原 URI。</li>
<li>303 See Other：类似 302，但要求重定向后的请求改为 GET 方法，访问一个结果页面，避免 POST/PUT 重复操作；</li>
<li>307 Temporary Redirect：类似 302，但重定向后请求里的方法和实体不允许变动，含义比 302 更明确；</li>
<li>308 Permanent Redirect：类似 307，不允许重定向后的请求变动，但它是 301“永久重定向”的含义。</li>
<li>不过这303/307/308三个状态码的接受程度较低，有的浏览器和服务器可能不支持，开发时应当慎重，测试确认浏览器的实际效果后才能使用。</li>
</ul>
<h3 id="重定向的相关问题"><a href="#重定向的相关问题" class="headerlink" title="重定向的相关问题"></a>重定向的相关问题</h3><ul>
<li>第一个问题是“性能损耗”。很明显，重定向的机制决定了一个跳转会有两次请求 - 应答，比正常的访问多了一次。虽然 301/302 报文很小，但大量的跳转对服务器的影响也是不可忽视的。站内重定向还好说，可以长连接复用，站外重定向就要开两个连接，如果网络连接质量差，那成本可就高多了，会严重影响用户的体验。</li>
<li>第二个问题是“循环跳转”。如果重定向的策略设置欠考虑，可能会出现“A=&gt;B=&gt;C=&gt;A”的无限循环，不停地在这个链路里转圈圈，后果可想而知。</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>重定向是服务器发起的跳转，要求客户端改用新的 URI 重新发送请求，通常会自动进行，用户是无感知的；</li>
<li>301/302 是最常用的重定向状态码，分别是“永久重定向”和“临时重定向”；</li>
<li>响应头字段 Location 指示了要跳转的 URI，可以用绝对或相对的形式；</li>
<li>重定向可以把一个 URI 指向另一个 URI，也可以把多个 URI 指向同一个 URI，用途很多；</li>
<li>使用重定向时需要当心性能损耗，还要避免出现循环跳转。</li>
</ul>
<h2 id="HTTP的Cookie机制"><a href="#HTTP的Cookie机制" class="headerlink" title="HTTP的Cookie机制"></a>HTTP的Cookie机制</h2><ul>
<li>HTTP 是“无状态”的，这既是优点也是缺点。优点是服务器没有状态差异，可以很容易地组成集群，而缺点就是无法支持需要记录状态的事务操作。</li>
<li>HTTP 协议是可扩展的，后来发明的 Cookie 技术，给 HTTP 增加了“记忆能力”。<h3 id="什么是-Cookie？"><a href="#什么是-Cookie？" class="headerlink" title="什么是 Cookie？"></a>什么是 Cookie？</h3></li>
<li>相当于是服务器给每个客户端都贴上一张小纸条，上面写了一些只有服务器才能理解的数据，需要的时候客户端把这些信息发给服务器，服务器看到 Cookie，就能够认出对方是谁了。<h3 id="Cookie-的工作过程"><a href="#Cookie-的工作过程" class="headerlink" title="Cookie 的工作过程"></a>Cookie 的工作过程</h3></li>
<li>这要用到两个字段：响应头字段 Set-Cookie 和请求头字段 Cookie。</li>
<li>当用户通过浏览器第一次访问服务器的时候，服务器肯定是不知道他的身份的。所以，就要创建一个独特的身份标识数据，格式是“key=value”，然后放进 Set-Cookie 字段里，随着响应报文一同发给浏览器。</li>
<li>浏览器收到响应报文，看到里面有 Set-Cookie，知道这是服务器给的身份标识，于是就保存起来，下次再请求的时候就自动把这个值放进 Cookie 字段里发给服务器。</li>
<li>服务器有时会在响应头里添加多个 Set-Cookie，存储多个“key=value”。但浏览器这边发送时不需要用多个 Cookie 字段，只要在一行里用“;”隔开就行。</li>
<li>Cookie 是由浏览器负责存储的，而不是操作系统。所以，它是“浏览器绑定”的，只能在本浏览器内生效。<h3 id="Cookie-的属性"><a href="#Cookie-的属性" class="headerlink" title="Cookie 的属性"></a>Cookie 的属性</h3></li>
<li>Cookie 就是服务器委托浏览器存储在客户端里的一些数据，而这些数据通常都会记录用户的关键识别信息。所以，就需要在“key=value”外再用一些手段来保护，防止外泄或窃取，这些手段就是 Cookie 的属性。</li>
<li>首先，我们应该设置 Cookie 的生存周期，也就是它的有效期，让它只能在一段时间内可用，就像是食品的“保鲜期”，一旦超过这个期限浏览器就认为是 Cookie 失效，在存储里删除，也不会发送给服务器。</li>
<li>Cookie 的有效期可以使用 Expires 和 Max-Age 两个属性来设置。</li>
<li>“Expires”俗称“过期时间”，用的是绝对时间点，可以理解为“截止日期”（deadline）。“Max-Age”用的是相对时间，单位是秒，浏览器用收到报文的时间点再加上 Max-Age，就可以得到失效的绝对时间。</li>
<li>Expires 和 Max-Age 可以同时出现，两者的失效时间可以一致，也可以不一致，但浏览器会优先采用 Max-Age 计算失效期。</li>
<li>设置 Cookie 的作用域，让浏览器仅发送给特定的服务器和 URI，避免被其他网站盗用。作用域的设置比较简单，“Domain”和“Path”指定了 Cookie 所属的域名和路径，浏览器在发送 Cookie 前会从 URI 中提取出 host 和 path 部分，对比 Cookie 的属性。如果不满足条件，就不会在请求头里发送 Cookie。</li>
<li>使用这两个属性可以为不同的域名和路径分别设置各自的 Cookie，比如“/19-1”用一个 Cookie，“/19-2”再用另外一个 Cookie，两者互不干扰。不过现实中为了省事，通常 Path 就用一个“/”或者直接省略，表示域名下的任意路径都允许使用 Cookie，让服务器自己去挑。<h3 id="Cookie-的安全性"><a href="#Cookie-的安全性" class="headerlink" title="Cookie 的安全性"></a>Cookie 的安全性</h3></li>
<li>属性“HttpOnly”会告诉浏览器，此 Cookie 只能通过浏览器 HTTP 协议传输，禁止其他方式访问，浏览器的 JS 引擎就会禁用 document.cookie 等一切相关的 API，脚本攻击也就无从谈起了。</li>
<li>另一个属性“SameSite”可以防范“跨站请求伪造”（XSRF）攻击，设置成“SameSite=Strict”可以严格限定 Cookie 不能随着跳转链接跨站发送，而“SameSite=Lax”则略宽松一点，允许 GET/HEAD 等安全方法，但禁止 POST 跨站发送。</li>
<li>还有一个属性叫“Secure”，表示这个 Cookie 仅能用 HTTPS 协议加密传输，明文的 HTTP 协议会禁止发送。但 Cookie 本身不是加密的，浏览器里还是以明文的形式存在。</li>
</ul>
<h2 id="HTTP的缓存控制"><a href="#HTTP的缓存控制" class="headerlink" title="HTTP的缓存控制"></a>HTTP的缓存控制</h2><ul>
<li>缓存（Cache）是计算机领域里的一个重要概念，是优化系统性能的利器。</li>
<li>由于链路漫长，网络时延不可控，浏览器使用 HTTP 获取资源的成本较高。所以，非常有必要把“来之不易”的数据缓存起来，下次再请求的时候尽可能地复用。这样，就可以避免多次请求 - 应答的通信成本，节约网络带宽，也可以加快响应速度。<h3 id="服务器的缓存控制"><a href="#服务器的缓存控制" class="headerlink" title="服务器的缓存控制"></a>服务器的缓存控制</h3></li>
<li>服务器标记资源有效期使用的头字段是“Cache-Control”，里面的值“max-age=30”就是资源的有效时间，相当于告诉浏览器，“这个页面只能缓存 30 秒，之后就算是过期，不能用。”</li>
<li>这里的 max-age 是“生存时间”（又叫“新鲜度”“缓存寿命”，类似 TTL，Time-To-Live），时间的计算起点是响应报文的创建时刻（即 Date 字段，也就是离开服务器的时刻），而不是客户端收到报文的时刻，也就是说包含了在链路传输过程中所有节点所停留的时间。比如，服务器设定“max-age=5”，但因为网络质量很糟糕，等浏览器收到响应报文已经过去了 4 秒，那么这个资源在客户端就最多能够再存 1 秒钟，之后就会失效。</li>
<li>no-store：不允许缓存，用于某些变化非常频繁的数据，例如秒杀页面；</li>
<li>no-cache：它的字面含义容易与 no-store 搞混，实际的意思并不是不允许缓存，而是可以缓存，但在使用之前必须要去服务器验证是否过期，是否有最新的版本；<h3 id="客户端的缓存控制"><a href="#客户端的缓存控制" class="headerlink" title="客户端的缓存控制"></a>客户端的缓存控制</h3></li>
<li>当你点“刷新”按钮的时候，浏览器会在请求头里加一个“Cache-Control: max-age=0”。因为 max-age 是“生存时间”，max-age=0 的意思就是“我要一个最最新鲜的西瓜”，而本地缓存里的数据至少保存了几秒钟，所以浏览器就不会使用缓存，而是向服务器发请求。服务器看到 max-age=0，也就会用一个最新生成的报文回应浏览器。</li>
<li>Ctrl+F5 的“强制刷新”又是什么样的呢？它其实是发了一个“Cache-Control: no-cache”，含义和“max-age=0”基本一样，就看后台的服务器怎么理解，通常两者的效果是相同的。</li>
</ul>
<h3 id="条件请求"><a href="#条件请求" class="headerlink" title="条件请求"></a>条件请求</h3><ul>
<li>HTTP 协议定义了一系列“If”开头的“条件请求”字段，专门用来检查验证资源是否过期，把两个请求才能完成的工作合并在一个请求里做。而且，验证的责任也交给服务器，浏览器只需“坐享其成”。</li>
<li>条件请求一共有 5 个头字段，我们最常用的是“if-Modified-Since”和“If-None-Match”这两个。需要第一次的响应报文预先提供“Last-modified”和“ETag”，然后第二次请求时就可以带上缓存里的原值，验证资源是否是最新的。</li>
<li>ETag 是“实体标签”（Entity Tag）的缩写，是资源的一个唯一标识，主要是用来解决修改时间无法准确区分文件变化的问题。比如，一个文件在一秒内修改了多次，但因为修改时间是秒级，所以这一秒内的新版本无法区分。再比如，一个文件定期更新，但有时会是同样的内容，实际上没有变化，用修改时间就会误以为发生了变化，传送给浏览器就会浪费带宽。</li>
<li>使用 ETag 就可以精确地识别资源的变动情况，让浏览器能够更有效地利用缓存。ETag 还有“强”“弱”之分。强 ETag 要求资源在字节级别必须完全相符，弱 ETag 在值前有个“W/”标记，只要求资源在语义上没有变化，但内部可能会有部分发生了改变（例如 HTML 里的标签顺序调整，或者多了几个空格）。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">还是拿生鲜速递做比喻最容易理解：</span><br><span class="line">你打电话给超市，“我这个西瓜是 3 天前买的，还有最新的吗？”。超市看了一下库存，说：“没有啊，我这里都是 3 天前的。”于是你就知道了，再让超市送货也没用，还是吃冰箱里的西瓜吧。这就是“if-Modified-Since”和“Last-modified”。</span><br><span class="line">但你还是想要最新的，就又打电话：“有不是沙瓤的西瓜吗？”，超市告诉你都是沙瓤的（Match），于是你还是只能吃冰箱里的沙瓤西瓜。这就是“If-None-Match”和“弱 ETag”。</span><br><span class="line">第三次打电话，你说“有不是 8 斤的沙瓤西瓜吗？”，这回超市给了你满意的答复：“有个 10 斤的沙瓤西瓜”。于是，你就扔掉了冰箱里的存货，让超市重新送了一个新的大西瓜。这就是“If-None-Match”和“强 ETag”。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="HTTP的代理服务"><a href="#HTTP的代理服务" class="headerlink" title="HTTP的代理服务"></a>HTTP的代理服务</h2><ul>
<li>引入 HTTP 代理后，原来简单的双方通信就变复杂了一些，加入了一个或者多个中间人，但整体上来看，还是一个有顺序关系的链条，而且链条里相邻的两个角色仍然是简单的一对一通信，不会出现越级的情况。<h3 id="代理服务"><a href="#代理服务" class="headerlink" title="代理服务"></a>代理服务</h3></li>
<li>所谓的“代理服务”就是指服务本身不生产内容，而是处于中间位置转发上下游的请求和响应，具有双重身份：面向下游的用户时，表现为服务器，代表源服务器响应客户端的请求；而面向上游的源服务器时，又表现为客户端，代表客户端发送请求。<h3 id="代理的作用"><a href="#代理的作用" class="headerlink" title="代理的作用"></a>代理的作用</h3></li>
<li>你也许听过这样一句至理名言：“计算机科学领域里的任何问题，都可以通过引入一个中间层来解决”（在这句话后面还可以再加上一句“如果一个中间层解决不了问题，那就再加一个中间层”）。TCP/IP 协议栈是这样，而代理也是这样。</li>
<li>由于代理处在 HTTP 通信过程的中间位置，相应地就对上屏蔽了真实客户端，对下屏蔽了真实服务器，简单的说就是“欺上瞒下”。在这个中间层的“小天地”里就可以做很多的事情，为 HTTP 协议增加更多的灵活性，实现客户端和服务器的“双赢”。</li>
<li>代理最基本的一个功能是负载均衡。因为在面向客户端时屏蔽了源服务器，客户端看到的只是代理服务器，源服务器究竟有多少台、是哪些 IP 地址都不知道。于是代理服务器就可以掌握请求分发的“大权”，决定由后面的哪台服务器来响应请求。</li>
<li>代理中常用的负载均衡算法你应该也有所耳闻吧，比如轮询、一致性哈希等等，这些算法的目标都是尽量把外部的流量合理地分散到多台源服务器，提高系统的整体资源利用率和性能。</li>
<li>在负载均衡的同时，代理服务还可以执行更多的功能，比如：</li>
</ul>
<ol>
<li>健康检查：使用“心跳”等机制监控后端服务器，发现有故障就及时“踢出”集群，保证服务高可用；</li>
<li>安全防护：保护被代理的后端服务器，限制 IP 地址或流量，抵御网络攻击和过载；</li>
<li>加密卸载：对外网使用 SSL/TLS 加密通信认证，而在安全的内网不加密，消除加解密成本；</li>
<li>数据过滤：拦截上下行的数据，任意指定策略修改请求或者响应；</li>
<li>内容缓存：暂存、复用服务器响应<h3 id="代理相关头字段"><a href="#代理相关头字段" class="headerlink" title="代理相关头字段"></a>代理相关头字段</h3></li>
</ol>
<ul>
<li>首先，代理服务器需要用字段“Via”标明代理的身份。</li>
<li>Via 是一个通用字段，请求头或响应头里都可以出现。每当报文经过一个代理节点，代理服务器就会把自身的信息追加到字段的末尾，就像是经手人盖了一个章。</li>
<li>如果通信链路中有很多中间代理，就会在 Via 里形成一个链表，这样就可以知道报文究竟走过了多少个环节才到达了目的地。</li>
<li>服务器的 IP 地址应该是保密的，关系到企业的内网安全，所以一般不会让客户端知道。不过反过来，通常服务器需要知道客户端的真实 IP 地址，方便做访问控制、用户画像、统计分析。</li>
<li>“X-Forwarded-For”的字面意思是“为谁而转发”，形式上和“Via”差不多，也是每经过一个代理节点就会在字段里追加一个信息。但“Via”追加的是代理主机名（或者域名），而“X-Forwarded-For”追加的是请求方的 IP 地址。所以，在字段里最左边的 IP 地址就是客户端的地址。</li>
<li>“X-Real-IP”是另一种获取客户端真实 IP 的手段，它的作用很简单，就是记录客户端 IP 地址，没有中间的代理信息，相当于是“X-Forwarded-For”的简化版。如果客户端和源服务器之间只有一个代理，那么这两个字段的值就是相同的。<h3 id="代理协议"><a href="#代理协议" class="headerlink" title="代理协议"></a>代理协议</h3></li>
<li>通过“X-Forwarded-For”操作代理信息必须要解析 HTTP 报文头，这对于代理来说成本比较高，原本只需要简单地转发消息就好，而现在却必须要费力解析数据再修改数据，会降低代理的转发性能。</li>
<li>“X-Forwarded-For”等头必须要修改原始报文，而有些情况下是不允许甚至不可能的（比如使用 HTTPS 通信被加密）。</li>
<li>所以就出现了一个专门的“代理协议”（The PROXY protocol），它由知名的代理软件 HAProxy 所定义，也是一个“事实标准”，被广泛采用（注意并不是 RFC）。</li>
<li>“代理协议”有 v1 和 v2 两个版本，v1 和 HTTP 差不多，也是明文，而 v2 是二进制格式。</li>
<li>v1版本在 HTTP 报文前增加了一行 ASCII 码文本，相当于又多了一个头。这一行文本其实非常简单，开头必须是“PROXY”五个大写字母，然后是“TCP4”或者“TCP6”，表示客户端的 IP 地址类型，再后面是请求方地址、应答方地址、请求方端口号、应答方端口号，最后用一个回车换行（\r\n）结束。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">PROXY TCP4 1.1.1.1 2.2.2.2 55555 80\r\n</span><br><span class="line">GET / HTTP/1.1\r\n</span><br><span class="line">Host: www.xxx.com\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="HTTP的缓存代理"><a href="#HTTP的缓存代理" class="headerlink" title="HTTP的缓存代理"></a>HTTP的缓存代理</h2><ul>
<li>HTTP 传输链路上，不只是客户端有缓存，服务器上的缓存也是非常有价值的，可以让请求不必走完整个后续处理流程，“就近”获得响应结果。</li>
<li>特别是对于那些“读多写少”的数据，例如突发热点新闻、爆款商品的详情页，一秒钟内可能有成千上万次的请求。即使仅仅缓存数秒钟，也能够把巨大的访问流量挡在外面，让 RPS（request per second）降低好几个数量级，减轻应用服务器的并发压力，对性能的改善是非常显著的。</li>
<li>HTTP 的服务器缓存功能主要由代理服务器来实现（即缓存代理），而源服务器系统内部虽然也经常有各种缓存（如 Memcache、Redis、Varnish 等），但与 HTTP 没有太多关系<h3 id="缓存代理服务"><a href="#缓存代理服务" class="headerlink" title="缓存代理服务"></a>缓存代理服务</h3></li>
<li>在 HTTP 的缓存体系中，缓存代理的身份十分特殊，它“既是客户端，又是服务器”，同时也“既不是客户端，又不是服务器”。</li>
<li>说它“即是客户端又是服务器”，是因为它面向源服务器时是客户端，在面向客户端时又是服务器，所以它即可以用客户端的缓存控制策略也可以用服务器端的缓存控制策略</li>
<li>但缓存代理也“即不是客户端又不是服务器”，因为它只是一个数据的“中转站”，并不是真正的数据消费者和生产者，所以还需要有一些新的“Cache-Control”属性来对它做特别的约束。<h3 id="源服务器的缓存控制"><a href="#源服务器的缓存控制" class="headerlink" title="源服务器的缓存控制"></a>源服务器的缓存控制</h3></li>
<li>4 种服务器端的“Cache-Control”属性：max-age、no-store、no-cache 和 must-revalidate,这 4 种缓存属性可以约束客户端，也可以约束代理。</li>
<li>但客户端和代理是不一样的，客户端的缓存只是用户自己使用，而代理的缓存可能会为非常多的客户端提供服务。所以，需要对它的缓存再多一些限制条件。</li>
<li><p>首先，我们要区分客户端上的缓存和代理上的缓存，可以使用两个新属性“private”和“public”。“private”表示缓存只能在客户端保存，是用户“私有”的，不能放在代理上与别人共享。而“public”的意思就是缓存完全开放，谁都可以存，谁都可以用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比如你登录论坛，返回的响应报文里用“Set-Cookie”添加了论坛 ID，这就属于私人数据，不能存在代理上。不然，别人访问代理获取了被缓存的响应就麻烦了。</span><br></pre></td></tr></table></figure>
</li>
<li><p>其次，缓存失效后的重新验证也要区分开（即使用条件请求“Last-modified”和“ETag”），“must-revalidate”是只要过期就必须回源服务器验证，而新的“proxy-revalidate”只要求代理的缓存过期后必须验证，客户端不必回源，只验证到代理这个环节就行了。</p>
</li>
<li>再次，缓存的生存时间可以使用新的“s-maxage”（s 是 share 的意思，注意 maxage 中间没有“-”），只限定在代理上能够存多久，而客户端仍然使用“max-age”</li>
<li><p>还有一个代理专用的属性“no-transform”。代理有时候会对缓存下来的数据做一些优化，比如把图片生成 png、webp 等几种格式，方便今后的请求处理，而“no-transform”就会禁止这样做，不许“偷偷摸摸搞小动作”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这些新的缓存控制属性比较复杂，还是用“便利店冷柜”来举例好理解一些。</span><br><span class="line">水果上贴着标签“private, max-age=5”。这就是说水果不能放进冷柜，必须直接给顾客，保鲜期 5 天，过期了还得去超市重新进货。</span><br><span class="line">冻鱼上贴着标签“public, max-age=5, s-maxage=10”。这个的意思就是可以在冰柜里存 10 天，但顾客那里只能存 5 天，过期了可以来便利店取，只要在 10 天之内就不必再找超市。</span><br><span class="line">排骨上贴着标签“max-age=30, proxy-revalidate, no-transform”。因为缓存默认是 public 的，那么它在便利店和顾客的冰箱里就都可以存 30 天，过期后便利店必须去超市进新货，而且不能擅自把“大排”改成“小排”。</span><br></pre></td></tr></table></figure>
</li>
<li><p>源服务器在设置完“Cache-Control”后必须要为报文加上“Last-modified”或“ETag”字段。否则，客户端和代理后面就无法使用条件请求来验证缓存是否有效，也就不会有 304 缓存重定向。</p>
</li>
</ul>
<h3 id="客户端的缓存控制-1"><a href="#客户端的缓存控制-1" class="headerlink" title="客户端的缓存控制"></a>客户端的缓存控制</h3><ul>
<li>max-age、no-store、no-cache 这三个属性它们也是同样作用于代理和源服务器。</li>
<li>关于缓存的生存时间，多了两个新属性“max-stale”和“min-fresh”。</li>
<li><p>“max-stale”的意思是如果代理上的缓存过期了也可以接受，但不能过期太多，超过 x 秒也会不要。“min-fresh”的意思是缓存必须有效，而且必须在 x 秒后依然有效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">比如，草莓上贴着标签“max-age=5”，现在已经在冰柜里存了 7 天。如果有请求“max-stale=2”，意思是过期两天也能接受，所以刚好能卖出去。</span><br><span class="line">但要是“min-fresh=1”，这是绝对不允许过期的，就不会买走。这时如果有另外一个菠萝是“max-age=10”，那么“7+1&lt;10”，在一天之后还是新鲜的，所以就能卖出去。</span><br></pre></td></tr></table></figure>
</li>
<li><p>有的时候客户端还会发出一个特别的“only-if-cached”属性，表示只接受代理缓存的数据，不接受源服务器的响应。如果代理上没有缓存或者缓存过期，就应该给客户端返回一个 504（Gateway Timeout）。</p>
</li>
</ul>
<h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><ul>
<li>第一个是“Vary”字段，它是内容协商的结果，相当于报文的一个版本标记。同一个请求，经过内容协商后可能会有不同的字符集、编码、浏览器等版本。比如，“Vary: Accept-Encoding”“Vary: User-Agent”，缓存代理必须要存储这些不同的版本。当再收到相同的请求时，代理就读取缓存里的“Vary”，对比请求头里相应的“ Accept-Encoding”“User-Agent”等字段，如果和上一个请求的完全匹配，比如都是“gzip”“Chrome”，就表示版本一致，可以返回缓存的数据。</li>
<li>另一个问题是“Purge”，也就是“缓存清理”，它对于代理也是非常重要的功能，例如：</li>
</ul>
<ol>
<li>过期的数据应该及时淘汰，避免占用空间；</li>
<li>源站的资源有更新，需要删除旧版本，主动换成最新版（即刷新）；</li>
<li>有时候会缓存了一些本不该存储的信息，例如网络谣言或者危险链接，必须尽快把它们删除。<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3></li>
</ol>
<ul>
<li>计算机领域里最常用的性能优化手段是“时空转换”，也就是“时间换空间”或者“空间换时间”，HTTP 缓存属于后者；</li>
<li>缓存代理是增加了缓存功能的代理服务，缓存源服务器的数据，分发给下游的客户端；</li>
<li>“Cache-Control”字段也可以控制缓存代理，常用的有“private”“s-maxage”“no-transform”等，同样必须配合“Last-modified”“ETag”等字段才能使用；</li>
<li>缓存代理有时候也会带来负面影响，缓存不良数据，需要及时刷新或删除。</li>
</ul>
<h2 id="HTTPS是什么？SSL-TLS又是什么？"><a href="#HTTPS是什么？SSL-TLS又是什么？" class="headerlink" title="HTTPS是什么？SSL/TLS又是什么？"></a>HTTPS是什么？SSL/TLS又是什么？</h2><ul>
<li>为什么要有 HTTPS？简单的回答是“因为 HTTP 不安全”。由于 HTTP 天生“明文”的特点，整个传输过程完全透明，任何人都能够在链路中截获、修改或者伪造请求 / 响应报文，数据不具有可信性。</li>
<li>“代理服务”。它作为 HTTP 通信的中间人，在数据上下行的时候可以添加或删除部分头字段，也可以使用黑白名单过滤 body 里的关键字，甚至直接发送虚假的请求、响应，而浏览器和源服务器都没有办法判断报文的真伪。<h3 id="什么是安全？"><a href="#什么是安全？" class="headerlink" title="什么是安全？"></a>什么是安全？</h3></li>
<li>通常认为，如果通信过程具备了四个特性，就可以认为是“安全”的，这四个特性是：机密性、完整性，身份认证和不可否认。</li>
</ul>
<ol>
<li>机密性（Secrecy/Confidentiality）是指对数据的“保密”，只能由可信的人访问，对其他人是不可见的“秘密”，简单来说就是不能让不相关的人看到不该看的东西。</li>
<li>完整性（Integrity，也叫一致性）是指数据在传输过程中没有被篡改，不多也不少，“完完整整”地保持着原状。</li>
<li>身份认证（Authentication）是指确认对方的真实身份，也就是“证明你真的是你”，保证消息只能发送给可信的人。</li>
<li>不可否认（Non-repudiation/Undeniable），也叫不可抵赖，意思是不能否认已经发生过的行为，不能“说话不算数”“耍赖皮”。<h3 id="什么是-HTTPS？"><a href="#什么是-HTTPS？" class="headerlink" title="什么是 HTTPS？"></a>什么是 HTTPS？</h3></li>
</ol>
<ul>
<li>默认端口号 443，HTTPS 与 HTTP 最大的区别，它能够鉴别危险的网站，并且尽最大可能保证你的上网安全，防御黑客对信息的窃听、篡改或者“钓鱼”、伪造。</li>
<li>它把 HTTP 下层的传输协议由 TCP/IP 换成了 SSL/TLS，由“HTTP over TCP/IP”变成了“HTTP over SSL/TLS”，让 HTTP 运行在了安全的 SSL/TLS 协议上，收发报文不再使用 Socket API，而是调用专门的安全接口。<h3 id="SSL-TLS"><a href="#SSL-TLS" class="headerlink" title="SSL/TLS"></a>SSL/TLS</h3></li>
<li>SSL 即安全套接层（Secure Sockets Layer），在 OSI 模型中处于第 5 层（会话层），由网景公司于 1994 年发明，有 v2 和 v3 两个版本，而 v1 因为有严重的缺陷从未公开过。</li>
<li>SSL 发展到 v3 时已经证明了它自身是一个非常好的安全通信协议，于是互联网工程组 IETF 在 1999 年把它改名为 TLS（传输层安全，Transport Layer Security），正式标准化，版本号从 1.0 重新算起，所以 TLS1.0 实际上就是 SSLv3.1。到今天 TLS 已经发展出了三个版本，分别是 2006 年的 1.1、2008 年的 1.2 和去年（2018）的 1.3，每个新版本都紧跟密码学的发展和互联网的现状，持续强化安全和性能，已经成为了信息安全领域中的权威标准。目前应用的最广泛的 TLS 是 1.2，而之前的协议（TLS1.1/1.0、SSLv3/v2）都已经被认为是不安全的，各大浏览器即将在 2020 年左右停止支持，所以接下来的讲解都针对的是 TLS1.2。</li>
<li>TLS 由记录协议、握手协议、警告协议、变更密码规范协议、扩展协议等几个子协议组成，综合使用了对称加密、非对称加密、身份认证等许多密码学前沿技术。</li>
<li>浏览器和服务器在使用 TLS 建立连接时需要选择一组恰当的加密算法来实现安全通信，这些算法的组合被称为“密码套件”（cipher suite，也叫加密套件）。</li>
<li>TLS 的密码套件命名非常规范，格式很固定。基本的形式是“密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法”<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">“ECDHE-RSA-AES256-GCM-SHA384”</span><br><span class="line"></span><br><span class="line">“握手时使用 ECDHE 算法进行密钥交换，用 RSA 签名和身份认证，握手后的通信使用 AES 对称算法，密钥长度 256 位，分组模式是 GCM，摘要算法 SHA384 用于消息认证和产生随机数。”</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="OpenSSL"><a href="#OpenSSL" class="headerlink" title="OpenSSL"></a>OpenSSL</h3><ul>
<li>它是一个著名的开源密码学程序库和工具包，几乎支持所有公开的加密算法和协议，已经成为了事实上的标准，许多应用软件都会使用它作为底层库来实现 TLS 功能，包括常用的 Web 服务器 Apache、Nginx 等。</li>
</ul>
<h2 id="对称加密与非对称加密"><a href="#对称加密与非对称加密" class="headerlink" title="对称加密与非对称加密"></a>对称加密与非对称加密</h2><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><ul>
<li><p>加密和解密时使用的密钥都是同一个，是“对称”的。只要保证了密钥的安全，那整个通信过程就可以说具有了机密性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">举个例子，你想要登录某网站，只要事先和它约定好使用一个对称密钥，通信过程中传输的全是用密钥加密后的密文，只有你和网站才能解密。黑客即使能够窃听，看到的也只是乱码，因为没有密钥无法解出明文，所以就实现了机密性。</span><br></pre></td></tr></table></figure>
</li>
<li><p>TLS 里有非常多的对称加密算法可供选择，比如 RC4、DES、3DES、AES、ChaCha20 等，但前三种算法都被认为是不安全的，通常都禁止使用，目前常用的只有 AES 和 ChaCha20。</p>
<h3 id="加密分组模式"><a href="#加密分组模式" class="headerlink" title="加密分组模式"></a>加密分组模式</h3></li>
<li>对称算法还有一个“分组模式”的概念，它可以让算法用固定长度的密钥加密任意长度的明文，把小秘密（即密钥）转化为大秘密（即密文）。</li>
<li>最新的分组模式被称为 AEAD（Authenticated Encryption with Associated Data），在加密的同时增加了认证的功能，常用的是 GCM、CCM 和 Poly1305。把上面这些组合起来，就可以得到 TLS 密码套件中定义的对称加密算法。<h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3></li>
<li>它有两个密钥，一个叫“公钥”（public key），一个叫“私钥”（private key）。两个密钥是不同的，“不对称”，公钥可以公开给任何人使用，而私钥必须严格保密。</li>
<li>因为在对称加密算法中只要持有密钥就可以解密。如果你和网站约定的密钥在传递途中被黑客窃取，那他就可以在之后随意解密收发的数据，通信过程也就没有机密性可言了。</li>
<li>公钥和私钥有个特别的“单向”性，虽然都可以用来加密解密，但公钥加密后只能用私钥解密，反过来，私钥加密后也只能用公钥解密。<h3 id="混合加密"><a href="#混合加密" class="headerlink" title="混合加密"></a>混合加密</h3></li>
<li>很遗憾，虽然非对称加密没有“密钥交换”的问题，但因为它们都是基于复杂的数学难题，运算速度很慢，即使是 ECC 也要比 AES 差上好几个数量级。如果仅用非对称加密，虽然保证了安全，但通信速度有如乌龟、蜗牛，实用性就变成了零。</li>
<li>在通信刚开始的时候使用非对称算法，比如 RSA、ECDHE，首先解决密钥交换的问题。</li>
<li>然后用随机数产生对称算法使用的“会话密钥”（session key），再用公钥加密。因为会话密钥很短，通常只有 16 字节或 32 字节，所以慢一点也无所谓。</li>
</ul>
<h2 id="数字签名与证书"><a href="#数字签名与证书" class="headerlink" title="数字签名与证书"></a>数字签名与证书</h2><ul>
<li>黑客虽然拿不到会话密钥，无法破解密文，但可以通过窃听收集到足够多的密文，再尝试着修改、重组后发给网站。因为没有完整性保证，服务器只能“照单全收”，然后他就可以通过服务器的响应获取进一步的线索，最终就会破解出明文。</li>
<li>黑客也可以伪造身份发布公钥。如果你拿到了假的公钥，混合加密就完全失效了。你以为自己是在和“某宝”通信，实际上网线的另一端却是黑客，银行卡号、密码等敏感信息就在“安全”的通信过程中被窃取了。</li>
<li>所以，在机密性的基础上还必须加上完整性、身份认证等特性，才能实现真正的安全。<h3 id="摘要算法"><a href="#摘要算法" class="headerlink" title="摘要算法"></a>摘要算法</h3></li>
<li>实现完整性的手段主要是摘要算法（Digest Algorithm），也就是常说的散列函数、哈希函数（Hash Function）。</li>
<li>你可以把摘要算法近似地理解成一种特殊的压缩算法，它能够把任意长度的数据“压缩”成固定长度、而且独一无二的“摘要”字符串，就好像是给这段数据生成了一个数字“指纹”。</li>
<li>换一个角度，也可以把摘要算法理解成特殊的“单向”加密算法，它只有算法，没有密钥，加密后的数据无法解密，不能从摘要逆推出原文。</li>
<li>摘要算法实际上是把数据从一个“大空间”映射到了“小空间”，所以就存在“冲突”（collision，也叫碰撞）的可能性，就如同现实中的指纹一样，可能会有两份不同的原文对应相同的摘要。好的摘要算法必须能够“抵抗冲突”，让这种可能性尽量地小。</li>
<li>你一定在日常工作中听过、或者用过 MD5（Message-Digest 5）、SHA-1（Secure Hash Algorithm 1），它们就是最常用的两个摘要算法，能够生成 16 字节和 20 字节长度的数字摘要。但这两个算法的安全强度比较低，不够安全，在 TLS 里已经被禁止使用了。<h3 id="完整性"><a href="#完整性" class="headerlink" title="完整性"></a>完整性</h3></li>
<li>摘要算法保证了“数字摘要”和原文是完全等价的。所以，我们只要在原文后附上它的摘要，就能够保证数据的完整性。</li>
<li>不过摘要算法不具有机密性，如果明文传输，那么黑客可以修改消息后把摘要也一起改了，网站还是鉴别不出完整性。</li>
<li>所以，真正的完整性必须要建立在机密性之上，在混合加密系统里用会话密钥加密消息和摘要，这样黑客无法得知明文，也就没有办法动手脚了。<h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3></li>
<li>加密算法结合摘要算法，我们的通信过程可以说是比较安全了。但这里还有漏洞，就是通信的两个端点（endpoint）。</li>
<li>就像一开始所说的，黑客可以伪装成网站来窃取信息。而反过来，他也可以伪装成你，向网站发送支付、转账等消息，网站没有办法确认你的身份，钱可能就这么被偷走了。</li>
<li>现实生活中，解决身份认证的手段是签名和印章，只要在纸上写下签名或者盖个章，就能够证明这份文件确实是由本人而不是其他人发出的。</li>
<li>使用私钥再加上摘要算法，就能够实现“数字签名”，同时实现“身份认证”和“不可否认”。<h3 id="数字证书和-CA"><a href="#数字证书和-CA" class="headerlink" title="数字证书和 CA"></a>数字证书和 CA</h3></li>
<li>CA（Certificate Authority，证书认证机构）。它就像网络世界里的公安局、教育部、公证中心，具有极高的可信度，由它来给各个公钥签名，用自身的信誉来保证公钥无法伪造，是可信的。</li>
<li>CA 对公钥的签名认证也是有格式的，不是简单地把公钥绑定在持有者身份上就完事了，还要包含序列号、用途、颁发者、有效时间等等，把这些打成一个包再签名，完整地证明公钥关联的各种信息，形成“数字证书”（Certificate）。</li>
<li>有了这个证书体系，操作系统和浏览器都内置了各大 CA 的根证书，上网的时候只要服务器发过来它的证书，就可以验证证书里的签名，顺着证书链（Certificate Chain）一层层地验证，直到找到根证书，就能够确定证书是可信的，从而里面的公钥也是可信的。</li>
</ul>
<h3 id="证书体系的弱点"><a href="#证书体系的弱点" class="headerlink" title="证书体系的弱点"></a>证书体系的弱点</h3><ul>
<li>如果 CA 失误或者被欺骗，签发了错误的证书，虽然证书是真的，可它代表的网站却是假的。</li>
<li>还有一种更危险的情况，CA 被黑客攻陷，或者 CA 有恶意，因为它（即根证书）是信任的源头，整个信任链里的所有证书也就都不可信了。</li>
<li>针对第一种，开发出了 CRL（证书吊销列表，Certificate revocation list）和 OCSP（在线证书状态协议，Online Certificate Status Protocol），及时废止有问题的证书。</li>
<li>对于第二种，因为涉及的证书太多，就只能操作系统或者浏览器从根上“下狠手”了，撤销对 CA 的信任，列入“黑名单”，这样它颁发的所有证书就都会被认为是不安全的。</li>
</ul>
<h2 id="TLS1-2连接过程解析"><a href="#TLS1-2连接过程解析" class="headerlink" title="TLS1.2连接过程解析"></a>TLS1.2连接过程解析</h2><h3 id="HTTPS-建立连接"><a href="#HTTPS-建立连接" class="headerlink" title="HTTPS 建立连接"></a>HTTPS 建立连接</h3><ul>
<li>当你在浏览器地址栏里键入“https”开头的 URI，再按下回车，会发生什么呢？</li>
</ul>
<ol>
<li>浏览器首先要从 URI 里提取出协议名和域名。因为协议名是“https”，所以浏览器就知道了端口号是默认的 443，它再用 DNS 解析域名，得到目标的 IP 地址，然后就可以使用三次握手与网站建立 TCP 连接了。</li>
<li>在 HTTP 协议里，建立连接后，浏览器会立即发送请求报文。但现在是 HTTPS 协议，它需要再用另外一个“握手”过程，在 TCP 上建立安全连接，之后才是收发 HTTP 报文。这个“握手”过程与 TCP 有些类似，是 HTTPS 和 TLS 协议里最重要、最核心的部分。<h3 id="TLS-协议的组成"><a href="#TLS-协议的组成" class="headerlink" title="TLS 协议的组成"></a>TLS 协议的组成</h3></li>
</ol>
<ul>
<li>TLS 包含几个子协议，你也可以理解为它是由几个不同职责的模块组成，比较常用的有记录协议、警报协议、握手协议、变更密码规范协议等。</li>
</ul>
<ol>
<li>记录协议（Record Protocol）规定了 TLS 收发数据的基本单位：记录（record）。它有点像是 TCP 里的 segment，所有的其他子协议都需要通过记录协议发出。但多个记录数据可以在一个 TCP 包里一次性发出，也并不需要像 TCP 那样返回 ACK。</li>
<li>警报协议（Alert Protocol）的职责是向对方发出警报信息，有点像是 HTTP 协议里的状态码。比如，protocol_version 就是不支持旧版本，bad_certificate 就是证书有问题，收到警报后另一方可以选择继续，也可以立即终止连接。</li>
<li>握手协议（Handshake Protocol）是 TLS 里最复杂的子协议，要比 TCP 的 SYN/ACK 复杂的多，浏览器和服务器会在握手过程中协商 TLS 版本号、随机数、密码套件等信息，然后交换证书和密钥参数，最终双方协商得到会话密钥，用于后续的混合加密系统。</li>
<li>变更密码规范协议（Change Cipher Spec Protocol），它非常简单，就是一个“通知”，告诉对方，后续的数据都将使用加密保护。那么反过来，在它之前，数据都是明文的。<h3 id="ECDHE-握手过程"><a href="#ECDHE-握手过程" class="headerlink" title="ECDHE 握手过程"></a>ECDHE 握手过程</h3></li>
</ol>
<ul>
<li>在 TCP 建立连接之后，浏览器会首先发一个“Client Hello”消息，也就是跟服务器“打招呼”。里面有客户端的版本号、支持的密码套件，还有一个随机数（Client Random），用于后续生成会话密钥。这个的意思就是：“我这边有这些这些信息，你看看哪些是能用的，关键的随机数可得留着。”</li>
<li>作为“礼尚往来”，服务器收到“Client Hello”后，会返回一个“Server Hello”消息。把版本号对一下，也给出一个随机数（Server Random），然后从客户端的列表里选一个作为本次通信使用的密码套件，在这里它选择了“TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384”。这个的意思就是：“版本号对上了，可以加密，你的密码套件挺多，我选一个最合适的吧，用椭圆曲线加 RSA、AES、SHA384。我也给你一个随机数，你也得留着。”</li>
<li>然后，服务器为了证明自己的身份，就把证书也发给了客户端（Server Certificate）。</li>
<li>接下来是一个关键的操作，因为服务器选择了 ECDHE 算法，所以它会在证书后发送“Server Key Exchange”消息，里面是椭圆曲线的公钥（Server Params），用来实现密钥交换算法，再加上自己的私钥签名认证。这相当于说：“刚才我选的密码套件有点复杂，所以再给你个算法的参数，和刚才的随机数一样有用，别丢了。为了防止别人冒充，我又盖了个章。”</li>
<li>之后是“Server Hello Done”消息，服务器说：“我的信息就是这些，打招呼完毕。”</li>
<li>这样第一个消息往返就结束了（两个 TCP 包），结果是客户端和服务器通过明文共享了三个信息：Client Random、Server Random 和 Server Params。</li>
<li>客户端这时也拿到了服务器的证书，那这个证书是不是真实有效的呢？开始走证书链逐级验证，确认证书的真实性，再用证书公钥验证签名，就确认了服务器的身份：“刚才跟我打招呼的不是骗子，可以接着往下走。”</li>
<li>然后，客户端按照密码套件的要求，也生成一个椭圆曲线的公钥（Client Params），用“Client Key Exchange”消息发给服务器。</li>
<li>现在客户端和服务器手里都拿到了密钥交换算法的两个参数（Client Params、Server Params），就用 ECDHE 算法一阵算，算出了一个新的东西，叫“Pre-Master”，其实也是一个随机数。</li>
<li>现在客户端和服务器手里有了三个随机数：Client Random、Server Random 和 Pre-Master。用这三个作为原始材料，就可以生成用于加密会话的主密钥，叫“Master Secret”。而黑客因为拿不到“Pre-Master”，所以也就得不到主密钥。</li>
<li>为什么非得这么麻烦，非要三个随机数呢？这就必须说 TLS 的设计者考虑得非常周到了，他们不信任客户端或服务器伪随机数的可靠性，为了保证真正的“完全随机”“不可预测”，把三个不可靠的随机数混合起来，那么“随机”的程度就非常高了，足够让黑客难以猜测。</li>
<li>主密钥有 48 字节，但它也不是最终用于通信的会话密钥，还会再用 PRF （这里的“PRF”就是伪随机数函数，它基于密码套件里的最后一个参数，比如这次的 SHA384，通过摘要算法来再一次强化“Master Secret”的随机性）扩展出更多的密钥，比如客户端发送用的会话密钥（client_write_key）、服务器发送用的会话密钥（server_write_key）等等，避免只用一个密钥带来的安全隐患。</li>
<li>有了主密钥和派生的会话密钥，握手就快结束了。客户端发一个“Change Cipher Spec”，然后再发一个“Finished”消息，把之前所有发送的数据做个摘要，再加密一下，让服务器做个验证。意思就是告诉服务器：“后面都改用对称算法加密通信了啊，用的就是打招呼时说的 AES，加密对不对还得你测一下。”</li>
<li>服务器也是同样的操作，发“Change Cipher Spec”和“Finished”消息，双方都验证加密解密 OK，握手正式结束，后面就收发被加密的 HTTP 请求和响应了。<h3 id="RSA-握手过程"><a href="#RSA-握手过程" class="headerlink" title="RSA 握手过程"></a>RSA 握手过程</h3></li>
<li>第一个，使用 ECDHE 实现密钥交换，而不是 RSA，所以会在服务器端发出“Server Key Exchange”消息。</li>
<li>第二个，因为使用了 ECDHE，客户端可以不用等到服务器发回“Finished”确认握手完毕，立即就发出 HTTP 报文，省去了一个消息往返的时间浪费。这个叫“TLS False Start”，意思就是“抢跑”，和“TCP Fast Open”有点像，都是不等连接完全建立就提前发应用数据，提高传输的效率。</li>
<li>RSA 握手过程大体的流程没有变，只是“Pre-Master”不再需要用算法生成，而是客户端直接生成随机数，然后用服务器的公钥加密，通过“Client Key Exchange”消息发给服务器。服务器再用私钥解密，这样双方也实现了共享三个随机数，就可以生成主密钥。<h3 id="双向认证"><a href="#双向认证" class="headerlink" title="双向认证"></a>双向认证</h3></li>
<li>但为了防止账号、密码被盗，有的时候（比如网上银行）还会使用 U 盾给用户颁发客户端证书，实现“双向认证”，这样会更加安全。</li>
<li>双向认证的流程也没有太多变化，只是在“Server Hello Done”之后，“Client Key Exchange”之前，客户端要发送“Client Certificate”消息，服务器收到后也把证书链走一遍，验证客户端的身份。</li>
</ul>
<h2 id="TLS1-3特性解析"><a href="#TLS1-3特性解析" class="headerlink" title="TLS1.3特性解析"></a>TLS1.3特性解析</h2><h3 id="强化安全"><a href="#强化安全" class="headerlink" title="强化安全"></a>强化安全</h3><ul>
<li>TLS1.2 在十来年的应用中获得了许多宝贵的经验，陆续发现了很多的漏洞和加密算法的弱点，所以 TLS1.3 就在协议里修补了这些不安全因素。</li>
</ul>
<ol>
<li>伪随机数函数由 PRF 升级为 HKDF（HMAC-based Extract-and-Expand Key Derivation Function）；</li>
<li>明确禁止在记录协议里使用压缩；</li>
<li>废除了 RC4、DES 对称加密算法；</li>
<li>废除了 ECB、CBC 等传统分组模式；</li>
<li>废除了 MD5、SHA1、SHA-224 摘要算法；</li>
<li>废除了 RSA、DH 密钥交换算法和许多命名曲线。</li>
</ol>
<ul>
<li>经过这一番“减肥瘦身”之后，TLS1.3 里只保留了 AES、ChaCha20 对称加密算法，分组模式只能用 AEAD 的 GCM、CCM 和 Poly1305，摘要算法只能用 SHA256、SHA384，密钥交换算法只有 ECDHE 和 DHE，椭圆曲线也被“砍”到只剩 P-256 和 x25519 等 5 种。现在的 TLS1.3 里只有 5 个套件，无论是客户端还是服务器都不会再犯“选择困难症”了。</li>
<li>浏览器默认会使用 ECDHE 而不是 RSA 做密钥交换，这是因为它不具有“前向安全”（Forward Secrecy）。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">假设有这么一个很有耐心的黑客，一直在长期收集混合加密系统收发的所有报文。</span><br><span class="line">如果加密系统使用服务器证书里的 RSA 做密钥交换，一旦私钥泄露或被破解（使用社会工程学或者巨型计算机），那么黑客就能够使用私钥解密出之前所有报文的“Pre-Master”，再算出会话密钥，破解所有密文。</span><br><span class="line">这就是所谓的“今日截获，明日破解”。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">而 ECDHE 算法在每次握手时都会生成一对临时的公钥和私钥，每次通信的密钥对都是不同的，也就是“一次一密”，即使黑客花大力气破解了这一次的会话密钥，也只是这次通信被攻击，之前的历史消息不会受到影响，仍然是安全的。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="提升性能"><a href="#提升性能" class="headerlink" title="提升性能"></a>提升性能</h3><ul>
<li>HTTPS 建立连接时除了要做 TCP 握手，还要做 TLS 握手，在 1.2 中会多花两个消息往返（2-RTT），可能导致几十毫秒甚至上百毫秒的延迟，在移动网络中延迟还会更严重</li>
<li>TLS1.3 压缩了以前的“Hello”协商过程，删除了“Key Exchange”消息，把握手时间减少到了“1-RTT”，效率提高了一倍。<h3 id="握手分析"><a href="#握手分析" class="headerlink" title="握手分析"></a>握手分析</h3></li>
<li>在 TCP 建立连接之后，浏览器首先还是发一个“Client Hello”。注意“Client Hello”里的扩展，“supported_versions”表示这是 TLS1.3，“supported_groups”是支持的曲线，“key_share”是曲线对应的参数。这就好像是说：“还是照老规矩打招呼，这边有这些这些信息。但我猜你可能会升级，所以再多给你一些东西，也许后面用的上，咱们有话尽量一口气说完。”</li>
<li>服务器收到“Client Hello”同样返回“Server Hello”消息，还是要给出一个随机数（Server Random）和选定密码套件。“supported_versions”里确认使用的是 TLS1.3，然后在“key_share”扩展带上曲线和对应的公钥参数。</li>
<li>这时只交换了两条消息，客户端和服务器就拿到了四个共享信息：Client Random 和 Server Random、Client Params 和 Server Params，两边就可以各自用 ECDHE 算出“Pre-Master”，再用 HKDF 生成主密钥“Master Secret”，效率比 TLS1.2 提高了一大截。</li>
<li>在算出主密钥后，服务器立刻发出“Change Cipher Spec”消息，比 TLS1.2 提早进入加密通信，后面的证书等就都是加密的了，减少了握手时的明文信息泄露。</li>
<li>这里 TLS1.3 还有一个安全强化措施，多了个“Certificate Verify”消息，用服务器的私钥把前面的曲线、套件、参数等握手数据加了签名，作用和“Finished”消息差不多。但由于是私钥签名，所以强化了身份认证和和防窜改。</li>
<li>这两个“Hello”消息之后，客户端验证服务器证书，再发“Finished”消息，就正式完成了握手，开始收发 HTTP 报文。</li>
</ul>
<h2 id="HTTPS的优化"><a href="#HTTPS的优化" class="headerlink" title="HTTPS的优化"></a>HTTPS的优化</h2><ul>
<li>HTTPS 连接大致上可以划分为两个部分，第一个是建立连接时的非对称加密握手，第二个是握手后的对称加密报文传输。</li>
<li>由于目前流行的 AES、ChaCha20 性能都很好，还有硬件优化，报文传输的性能损耗可以说是非常地小，小到几乎可以忽略不计了。所以，通常所说的“HTTPS 连接慢”指的就是刚开始建立连接的那段时间。</li>
<li>在 TCP 建连之后，正式数据传输之前，HTTPS 比 HTTP 增加了一个 TLS 握手的步骤，这个步骤最长可以花费两个消息往返，也就是 2-RTT。而且在握手消息的网络耗时之外，还会有其他的一些“隐形”消耗，比如：</li>
</ul>
<ol>
<li>产生用于密钥交换的临时公私钥对（ECDHE）</li>
<li>验证证书时访问 CA 获取 CRL 或者 OCSP；</li>
<li>非对称加密解密处理“Pre-Master”。</li>
</ol>
<ul>
<li>在最差的情况下，也就是不做任何的优化措施，HTTPS 建立连接可能会比 HTTP 慢上几百毫秒甚至几秒，这其中既有网络耗时，也有计算耗时，就会让人产生“打开一个 HTTPS 网站好慢啊”的感觉。不过刚才说的情况早就是“过去时”了，现在已经有了很多行之有效的 HTTPS 优化手段，运用得好可以把连接的额外耗时降低到几十毫秒甚至是“零”。<h3 id="硬件优化"><a href="#硬件优化" class="headerlink" title="硬件优化"></a>硬件优化</h3></li>
<li>HTTPS 连接是计算密集型，而不是 I/O 密集型。所以，如果你花大价钱去买网卡、带宽、SSD 存储就是“南辕北辙”了，起不到优化的效果。</li>
<li>首先，你可以选择更快的 CPU，最好还内建 AES 优化，这样即可以加速握手，也可以加速传输。</li>
<li>其次，你可以选择“SSL 加速卡”，加解密时调用它的 API，让专门的硬件来做非对称加解密，分担 CPU 的计算压力。不过“SSL 加速卡”也有一些缺点，比如升级慢、支持算法有限，不能灵活定制解决方案等。</li>
<li>所以，就出现了第三种硬件加速方式：“SSL 加速服务器”，用专门的服务器集群来彻底“卸载”TLS 握手时的加密解密计算，性能自然要比单纯的“加速卡”要强大的多。<h3 id="软件优化"><a href="#软件优化" class="headerlink" title="软件优化"></a>软件优化</h3></li>
<li>软件方面的优化还可以再分成两部分：一个是软件升级，一个是协议优化。</li>
<li>软件升级实施起来比较简单，就是把现在正在使用的软件尽量升级到最新版本，比如把 Linux 内核由 2.x 升级到 4.x，把 Nginx 由 1.6 升级到 1.16，把 OpenSSL 由 1.0.1 升级到 1.1.0/1.1.1。</li>
<li>但对于很多大中型公司来说，硬件升级或软件升级都是个棘手的问题，有成千上万台各种型号的机器遍布各个机房，逐一升级不仅需要大量人手，而且有较高的风险，可能会影响正常的线上服务。<h3 id="协议优化"><a href="#协议优化" class="headerlink" title="协议优化"></a>协议优化</h3></li>
<li>如果有可能，应当尽量采用 TLS1.3，它大幅度简化了握手的过程，完全握手只要 1-RTT，而且更加安全。</li>
<li>如果暂时不能升级到 1.3，只能用 1.2，那么握手时使用的密钥交换协议应当尽量选用椭圆曲线的 ECDHE 算法。它不仅运算速度快，安全性高，还支持“False Start”，能够把握手的消息往返由 2-RTT 减少到 1-RTT，达到与 TLS1.3 类似的效果。</li>
<li>另外，椭圆曲线也要选择高性能的曲线，最好是 x25519，次优选择是 P-256。对称加密算法方面，也可以选用“AES_128_GCM”，它能比“AES_256_GCM”略快一点点。</li>
<li>在 Nginx 里可以用“ssl_ciphers”“ssl_ecdh_curve”等指令配置服务器使用的密码套件和椭圆曲线，把优先使用的放在前面，例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ssl_ciphers   TLS13-AES-256-GCM-SHA384:TLS13-CHACHA20-POLY1305-SHA256:EECDH+CHACHA20；</span><br><span class="line">ssl_ecdh_curve              X25519:P-256;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="证书优化"><a href="#证书优化" class="headerlink" title="证书优化"></a>证书优化</h3><ul>
<li>这里就有两个优化点，一个是证书传输，一个是证书验证。</li>
<li>服务器的证书可以选择椭圆曲线（ECDSA）证书而不是 RSA 证书，因为 224 位的 ECC 相当于 2048 位的 RSA，所以椭圆曲线证书的“个头”要比 RSA 小很多，即能够节约带宽也能减少客户端的运算量，可谓“一举两得”。</li>
<li>客户端的证书验证其实是个很复杂的操作，除了要公钥解密验证多个证书签名外，因为证书还有可能会被撤销失效，客户端有时还会再去访问 CA，下载 CRL 或者 OCSP 数据，这又会产生 DNS 查询、建立连接、收发数据等一系列网络通信，增加好几个 RTT。</li>
<li>CRL（Certificate revocation list，证书吊销列表）由 CA 定期发布，里面是所有被撤销信任的证书序号，查询这个列表就可以知道证书是否有效。但 CRL 因为是“定期”发布，就有“时间窗口”的安全隐患，而且随着吊销证书的增多，列表会越来越大，一个 CRL 经常会上 MB。想象一下，每次需要预先下载几 M 的“无用数据”才能连接网站，实用性实在是太低了。</li>
<li>所以，现在 CRL 基本上不用了，取而代之的是 OCSP（在线证书状态协议，Online Certificate Status Protocol），向 CA 发送查询请求，让 CA 返回证书的有效状态。</li>
<li>但 OCSP 也要多出一次网络请求的消耗，而且还依赖于 CA 服务器，如果 CA 服务器很忙，那响应延迟也是等不起的。于是又出来了一个“补丁”，叫“OCSP Stapling”（OCSP 装订），它可以让服务器预先访问 CA 获取 OCSP 响应，然后在握手时随着证书一起发给客户端，免去了客户端连接 CA 服务器查询的时间。<h3 id="会话复用"><a href="#会话复用" class="headerlink" title="会话复用"></a>会话复用</h3></li>
<li>HTTPS 建立连接的过程：先是 TCP 三次握手，然后是 TLS 一次握手。这后一次握手的重点是算出主密钥“Master Secret”，而主密钥每次连接都要重新计算，未免有点太浪费了，如果能够把“辛辛苦苦”算出来的主密钥缓存一下“重用”，不就可以免去了握手和计算的成本了吗？这种做法就叫“会话复用”（TLS session resumption），和 HTTP Cache 一样，也是提高 HTTPS 性能的“大杀器”，被浏览器和服务器广泛应用。</li>
<li>会话复用分两种，第一种叫“Session ID”，就是客户端和服务器首次连接后各自保存一个会话的 ID 号，内存里存储主密钥和其他相关的信息。当客户端再次连接时发一个 ID 过来，服务器就在内存里找，找到就直接用主密钥恢复会话状态，跳过证书验证和密钥交换，只用一个消息往返就可以建立安全通信。<h3 id="会话票证"><a href="#会话票证" class="headerlink" title="会话票证"></a>会话票证</h3></li>
<li>“Session ID”是最早出现的会话复用技术，也是应用最广的，但它也有缺点，服务器必须保存每一个客户端的会话数据，对于拥有百万、千万级别用户的网站来说存储量就成了大问题，加重了服务器的负担。</li>
<li>于是，又出现了第二种“Session Ticket”方案。它有点类似 HTTP 的 Cookie，存储的责任由服务器转移到了客户端，服务器加密会话信息，用“New Session Ticket”消息发给客户端，让客户端保存。重连的时候，客户端使用扩展“session_ticket”发送“Ticket”而不是“Session ID”，服务器解密后验证有效期，就可以恢复会话，开始加密通信。不过“Session Ticket”方案需要使用一个固定的密钥文件（ticket_key）来加密 Ticket，为了防止密钥被破解，保证“前向安全”，密钥文件需要定期轮换，比如设置为一小时或者一天。<h3 id="预共享密钥"><a href="#预共享密钥" class="headerlink" title="预共享密钥"></a>预共享密钥</h3></li>
<li>“False Start”“Session ID”“Session Ticket”等方式只能实现 1-RTT，而 TLS1.3 更进一步实现了“0-RTT”，原理和“Session Ticket”差不多，但在发送 Ticket 的同时会带上应用数据（Early Data），免去了 1.2 里的服务器确认步骤，这种方式叫“Pre-shared Key”，简称为“PSK”。</li>
<li>但“PSK”也不是完美的，它为了追求效率而牺牲了一点安全性，容易受到“重放攻击”（Replay attack）的威胁。黑客可以截获“PSK”的数据，像复读机那样反复向服务器发送。</li>
<li>解决的办法是只允许安全的 GET/HEAD 方法，在消息里加入时间戳、“nonce”验证，或者“一次性票证”限制重放。</li>
</ul>
<h2 id="我应该迁移到HTTPS吗？"><a href="#我应该迁移到HTTPS吗？" class="headerlink" title="我应该迁移到HTTPS吗？"></a>我应该迁移到HTTPS吗？</h2><ul>
<li>从 HTTP 迁移到 HTTPS 是“大势所趋”，能做就应该尽早做；<h3 id="重定向跳转"><a href="#重定向跳转" class="headerlink" title="重定向跳转"></a>重定向跳转</h3></li>
<li><p>把不安全的 HTTP 网址用 301 或 302“重定向”到新的 HTTPS 网站，这在 Nginx 里也很容易做到，使用“return”或“rewrite”都可以。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">return 301 https://$host$request_uri;             #永久重定向</span><br><span class="line">rewrite ^  https://$host$request_uri permanent;   #永久重定向</span><br><span class="line">但这种方式有两个问题。一个是重定向增加了网络成本，多出了一次请求；</span><br><span class="line">另一个是存在安全隐患，重定向的响应可能会被“中间人”窜改，实现“会话劫持”，跳转到恶意网站</span><br></pre></td></tr></table></figure>
</li>
<li><p>不过有一种叫“HSTS”（HTTP 严格传输安全，HTTP Strict Transport Security）的技术可以消除这种安全隐患。HTTPS 服务器需要在发出的响应头里添加一个“Strict-Transport-Security”的字段，再设定一个有效期，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Strict-Transport-Security: max-age=15768000; includeSubDomains</span><br><span class="line">这相当于告诉浏览器：我这个网站必须严格使用 HTTPS 协议，在半年之内（182.5 天）都不允许用 HTTP，你以后就自己做转换吧，不要再来麻烦我了。</span><br><span class="line">有了“HSTS”的指示，以后浏览器再访问同样的域名的时候就会自动把 URI 里的“http”改成“https”，直接访问安全的 HTTPS 网站。这样“中间人”就失去了攻击的机会，而且对于客户端来说也免去了一次跳转，加快了连接速度。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="HTTP-2特性概览"><a href="#HTTP-2特性概览" class="headerlink" title="HTTP/2特性概览"></a>HTTP/2特性概览</h2><ul>
<li>HTTPS，通过引入 SSL/TLS 在安全上达到了“极致”，但在性能提升方面却是乏善可陈，只优化了握手加密的环节，对于整体的数据传输没有提出更好的改进方案，还只能依赖于“长连接”这种“落后”的技术</li>
<li>“秦失其鹿，天下共逐之”，Google 率先发明了 SPDY 协议，并应用于自家的浏览器 Chrome，打响了 HTTP 性能优化的“第一枪”。随后互联网标准化组织 IETF 以 SPDY 为基础，综合其他多方的意见，终于推出了 HTTP/1 的继任者，也就是今天的主角“HTTP/2”，在性能方面有了一个大的飞跃。</li>
</ul>
<h3 id="为什么不是-HTTP-2-0"><a href="#为什么不是-HTTP-2-0" class="headerlink" title="为什么不是 HTTP/2.0"></a>为什么不是 HTTP/2.0</h3><ul>
<li>以前的“1.0”“1.1”造成了很多的混乱和误解，让人在实际的使用中难以区分差异，所以就决定 HTTP 协议不再使用小版本号（minor version），只使用大版本号（major version），从今往后 HTTP 协议不会出现 HTTP/2.0、2.1，只会有“HTTP/2”“HTTP/3”……<h3 id="兼容-HTTP-1"><a href="#兼容-HTTP-1" class="headerlink" title="兼容 HTTP/1"></a>兼容 HTTP/1</h3></li>
<li>由于 HTTPS 已经在安全方面做的非常好了，所以 HTTP/2 的唯一目标就是改进性能。</li>
<li>但它不仅背负着众多的期待，同时还背负着 HTTP/1 庞大的历史包袱，所以协议的修改必须小心谨慎，兼容性是首要考虑的目标，否则就会破坏互联网上无数现有的资产，这方面 TLS 已经有了先例（为了兼容 TLS1.2 不得不进行“伪装”）。</li>
<li>因为必须要保持功能上的兼容，所以 HTTP/2 把 HTTP 分解成了“语义”和“语法”两个部分，“语义”层不做改动，与 HTTP/1 完全一致（即 RFC7231）。比如请求方法、URI、状态码、头字段等概念都保留不变，这样就消除了再学习的成本，基于 HTTP 的上层应用也不需要做任何修改，可以无缝转换到 HTTP/2。</li>
<li>与 HTTPS 不同，HTTP/2 没有在 URI 里引入新的协议名，仍然用“http”表示明文协议，用“https”表示加密协议。</li>
<li>在“语义”保持稳定之后，HTTP/2 在“语法”层做了“天翻地覆”的改造，完全变更了 HTTP 报文的传输格式。</li>
</ul>
<h3 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h3><ul>
<li>首先，HTTP/2 对报文的头部做了一个“大手术”。</li>
<li>HTTP/1 里可以用头字段“Content-Encoding”指定 Body 的编码方式，比如用 gzip 压缩来节约带宽，但报文的另一个组成部分——Header 却被无视了，没有针对它的优化手段。</li>
<li>由于报文 Header 一般会携带“User Agent”“Cookie”“Accept”“Server”等许多固定的头字段，多达几百字节甚至上千字节，但 Body 却经常只有几十字节（比如 GET 请求、204/301/304 响应），成了不折不扣的“大头儿子”。</li>
<li>更要命的是，成千上万的请求响应报文里有很多字段值都是重复的，非常浪费，“长尾效应”导致大量带宽消耗在了这些冗余度极高的数据上。</li>
<li>HTTP/2 并没有使用传统的压缩算法，而是开发了专门的“HPACK”算法，在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，还釆用哈夫曼编码来压缩整数和字符串，可以达到 50%~90% 的高压缩率。<h3 id="二进制格式"><a href="#二进制格式" class="headerlink" title="二进制格式"></a>二进制格式</h3></li>
<li>HTTP/2不再使用肉眼可见的 ASCII 码，而是向下层的 TCP/IP 协议“靠拢”，全面采用二进制格式。虽然对人不友好，但却大大方便了计算机的解析。原来使用纯文本的时候容易出现多义性，比如大小写、空白字符、回车换行、多字少字等等，程序在处理时必须用复杂的状态机，效率低，还麻烦。</li>
<li>二进制里只有“0”和“1”，可以严格规定字段大小、顺序、标志位等格式，“对就是对，错就是错”，解析起来没有歧义，实现简单，而且体积小、速度快，做到“内部提效”。</li>
<li>它把 TCP 协议的部分特性挪到了应用层，把原来的“Header+Body”的消息“打散”为数个小片的二进制“帧”（Frame），用“HEADERS”帧存放头数据、“DATA”帧存放实体数据。</li>
<li>这种做法有点像是“Chunked”分块编码的方式，也是“化整为零”的思路，但 HTTP/2 数据分帧后“Header+Body”的报文结构就完全消失了，协议看到的只是一个个的“碎片”。<h3 id="虚拟的“流”"><a href="#虚拟的“流”" class="headerlink" title="虚拟的“流”"></a>虚拟的“流”</h3></li>
<li>HTTP/2 为此定义了一个“流”（Stream）的概念，它是二进制帧的双向传输序列，同一个消息往返的帧会分配一个唯一的流 ID。你可以把它想象成是一个虚拟的“数据流”，在里面流动的是一串有先后顺序的数据帧，这些数据帧按照次序组装起来就是 HTTP/1 里的请求报文和响应报文。</li>
<li>因为“流”是虚拟的，实际上并不存在，所以 HTTP/2 就可以在一个 TCP 连接上用“流”同时发送多个“碎片化”的消息，这就是常说的“多路复用”（ Multiplexing）——多个往返通信都复用一个连接来处理。</li>
<li>在“流”的层面上看，消息是一些有序的“帧”序列，而在“连接”的层面上看，消息却是乱序收发的“帧”。多个请求 / 响应之间没有了顺序关系，不需要排队等待，也就不会再出现“队头阻塞”问题，降低了延迟，大幅度提高了连接的利用率。</li>
<li>为了更好地利用连接，加大吞吐量，HTTP/2 还添加了一些控制帧来管理虚拟的“流”，实现了优先级和流量控制，这些特性也和 TCP 协议非常相似。</li>
<li>HTTP/2 还在一定程度上改变了传统的“请求 - 应答”工作模式，服务器不再是完全被动地响应请求，也可以新建“流”主动向客户端发送消息。比如，在浏览器刚请求 HTML 的时候就提前把可能会用到的 JS、CSS 文件发给客户端，减少等待的延迟，这被称为“服务器推送”（Server Push，也叫 Cache Push）。</li>
</ul>
<h3 id="强化安全-1"><a href="#强化安全-1" class="headerlink" title="强化安全"></a>强化安全</h3><ul>
<li>出于兼容的考虑，HTTP/2 延续了 HTTP/1 的“明文”特点，可以像以前一样使用明文传输数据，不强制使用加密通信，不过格式还是二进制，只是不需要解密。</li>
<li>但由于 HTTPS 已经是大势所趋，而且主流的浏览器 Chrome、Firefox 等都公开宣布只支持加密的 HTTP/2，所以“事实上”的 HTTP/2 是加密的。也就是说，互联网上通常所能见到的 HTTP/2 都是使用“https”协议名，跑在 TLS 上面。</li>
<li>为了区分“加密”和“明文”这两个不同的版本，HTTP/2 协议定义了两个字符串标识符：“h2”表示加密的 HTTP/2，“h2c”表示明文的 HTTP/2，多出的那个字母“c”的意思是“clear text”。</li>
</ul>
<h3 id="协议栈"><a href="#协议栈" class="headerlink" title="协议栈"></a>协议栈</h3><ul>
<li>http/1: http/tcp/ip/mac</li>
<li>https: http/tls/tcp/ip/mac</li>
<li>http/2: http/hpack+stream/tls 1.2+/tcp/ip/mac</li>
</ul>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li>HTTP 协议取消了小版本号，所以 HTTP/2 的正式名字不是 2.0；</li>
<li>HTTP/2 在“语义”上兼容 HTTP/1，保留了请求方法、URI 等传统概念；</li>
<li>HTTP/2 使用“HPACK”算法压缩头部信息，消除冗余数据节约带宽；</li>
<li>HTTP/2 的消息不再是“Header+Body”的形式，而是分散为多个二进制“帧”；</li>
<li>HTTP/2 使用虚拟的“流”传输消息，解决了困扰多年的“队头阻塞”问题，同时实现了“多路复用”，提高连接的利用率；</li>
<li>HTTP/2 也增强了安全性，要求至少是 TLS1.2，而且禁用了很多不安全的密码套件。</li>
</ul>
<h2 id="HTTP-2内核剖析"><a href="#HTTP-2内核剖析" class="headerlink" title="HTTP/2内核剖析"></a>HTTP/2内核剖析</h2><h3 id="连接前言"><a href="#连接前言" class="headerlink" title="连接前言"></a>连接前言</h3><ul>
<li>由于 HTTP/2“事实上”是基于 TLS，所以在正式收发数据之前，会有 TCP 握手和 TLS 握手，</li>
<li>TLS 握手成功之后，客户端必须要发送一个“连接前言”（connection preface），用来确认建立 HTTP/2 连接。这个“连接前言”是标准的 HTTP/1 请求报文，使用纯文本的 ASCII 码格式，请求方法是特别注册的一个关键字“PRI”，全文只有 24 个字节：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n</span><br><span class="line">只要服务器收到这个“有魔力的字符串”，就知道客户端在 TLS 上想要的是 HTTP/2 协议，而不是其他别的协议，后面就会都使用 HTTP/2 的数据格式。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="头部压缩-1"><a href="#头部压缩-1" class="headerlink" title="头部压缩"></a>头部压缩</h3><ul>
<li>因为语义上它与 HTTP/1 兼容，所以报文还是由“Header+Body”构成的，但在请求发送前，必须要用“HPACK”算法来压缩头部数据。</li>
<li>“HPACK”算法是专门为压缩 HTTP 头部定制的算法，与 gzip、zlib 等压缩算法不同，它是一个“有状态”的算法，需要客户端和服务器各自维护一份“索引表”，也可以说是“字典”（这有点类似 brotli），压缩和解压缩就是查表和更新表的操作。</li>
<li>为了方便管理和压缩，HTTP/2 废除了原有的起始行概念，把起始行里面的请求方法、URI、状态码等统一转换成了头字段的形式，并且给这些“不是头字段的头字段”起了个特别的名字——“伪头字段”（pseudo-header fields）。而起始行里的版本号和错误原因短语因为没什么大用，顺便也给废除了。为了与“真头字段”区分开来，这些“伪头字段”会在名字前加一个“:”，比如“:authority” “:method” “:status”，分别表示的是域名、请求方法和状态码。</li>
<li><p>现在 HTTP 报文头就简单了，全都是“Key-Value”形式的字段，于是 HTTP/2 就为一些最常用的头字段定义了一个只读的“静态表”（Static Table）。动态表”（Dynamic Table）添加在静态表后面，结构相同，但会在编码解码的时候随时更新。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">比如说，第一次发送请求时的“user-agent”字段长是一百多个字节，用哈夫曼压缩编码发送之后，客户端和服务器都更新自己的动态表，添加一个新的索引号“65”。</span><br><span class="line">那么下一次发送的时候就不用再重复发那么多字节了，只要用一个字节发送编号就好。</span><br></pre></td></tr></table></figure>
</li>
<li><p>随着在 HTTP/2 连接上发送的报文越来越多，两边的“字典”也会越来越丰富，最终每次的头部字段都会变成一两个字节的代码，原来上千字节的头用几十个字节就可以表示了，压缩效果比 gzip 要好得多。</p>
<h3 id="二进制帧"><a href="#二进制帧" class="headerlink" title="二进制帧"></a>二进制帧</h3></li>
<li>头部数据压缩之后，HTTP/2 就要把报文拆成二进制的帧准备发送。</li>
<li>HTTP/2 的帧结构有点类似 TCP 的段或者 TLS 里的记录，但报头很小，只有 9 字节，非常地节省（可以对比一下 TCP 头，它最少是 20 个字节）。</li>
<li>帧开头是 3 个字节的长度（但不包括头的 9 个字节），默认上限是 2^14，最大是 2^24，也就是说 HTTP/2 的帧通常不超过 16K，最大是 16M。</li>
<li>长度后面的一个字节是帧类型，大致可以分成数据帧和控制帧两类，HEADERS 帧和 DATA 帧属于数据帧，存放的是 HTTP 报文，而 SETTINGS、PING、PRIORITY 等则是用来管理流的控制帧。</li>
<li>报文头里最后 4 个字节是流标识符，也就是帧所属的“流”，接收方使用它就可以从乱序的帧里识别出具有相同流 ID 的帧序列，按顺序组装起来就实现了虚拟的“流”。<h3 id="流与多路复用"><a href="#流与多路复用" class="headerlink" title="流与多路复用"></a>流与多路复用</h3></li>
<li>流是二进制帧的双向传输序列。要搞明白流，关键是要理解帧头里的流 ID。</li>
<li>在 HTTP/2 连接上，虽然帧是乱序收发的，但只要它们都拥有相同的流 ID，就都属于一个流，而且在这个流里帧不是无序的，而是有着严格的先后顺序。</li>
<li>HTTP/2 的流有哪些特点呢？</li>
</ul>
<ol>
<li>流是可并发的，一个 HTTP/2 连接上可以同时发出多个流传输数据，也就是并发多请求，实现“多路复用”；</li>
<li>客户端和服务器都可以创建流，双方互不干扰；</li>
<li>流是双向的，一个流里面客户端和服务器都可以发送或接收数据帧，也就是一个“请求 - 应答”来回；</li>
<li>流之间没有固定关系，彼此独立，但流内部的帧是有严格顺序的；</li>
<li>流可以设置优先级，让服务器优先处理，比如先传 HTML/CSS，后传图片，优化用户体验；</li>
<li>流 ID 不能重用，只能顺序递增，客户端发起的 ID 是奇数，服务器端发起的 ID 是偶数；</li>
<li>在流上发送“RST_STREAM”帧可以随时终止流，取消接收或发送；</li>
<li>第 0 号流比较特殊，不能关闭，也不能发送数据帧，只能发送控制帧，用于流量控制。</li>
</ol>
<ul>
<li>HTTP/2 在一个连接上使用多个流收发数据，那么它本身默认就会是长连接，所以永远不需要“Connection”头字段（keepalive 或 close）。</li>
<li>下载大文件的时候想取消接收，在 HTTP/1 里只能断开 TCP 连接重新“三次握手”，成本很高，而在 HTTP/2 里就可以简单地发送一个“RST_STREAM”中断流，而长连接会继续保持。</li>
<li>因为客户端和服务器两端都可以创建流，而流 ID 有奇数偶数和上限的区分，所以大多数的流 ID 都会是奇数，而且客户端在一个连接里最多只能发出 2^30，也就是 10 亿个请求。ID 用完了该怎么办呢？这个时候可以再发一个控制帧“GOAWAY”，真正关闭 TCP 连接。<h3 id="流状态转换"><a href="#流状态转换" class="headerlink" title="流状态转换"></a>流状态转换</h3></li>
<li>HTTP/2 借鉴了 TCP，根据帧的标志位实现流状态转换。当然，这些状态也是虚拟的，只是为了辅助理解。</li>
<li>最开始的时候流都是“空闲”（idle）状态，也就是“不存在”，可以理解成是待分配的“号段资源”。</li>
<li>当客户端发送 HEADERS 帧后，有了流 ID，流就进入了“打开”状态，两端都可以收发数据，然后客户端发送一个带“END_STREAM”标志位的帧，流就进入了“半关闭”状态。这个“半关闭”状态很重要，意味着客户端的请求数据已经发送完了，需要接受响应数据，而服务器端也知道请求数据接收完毕，之后就要内部处理，再发送响应数据。</li>
<li>响应数据发完了之后，也要带上“END_STREAM”标志位，表示数据发送完毕，这样流两端就都进入了“关闭”状态，流就结束了。</li>
<li>流 ID 不能重用，所以流的生命周期就是 HTTP/1 里的一次完整的“请求 - 应答”，流关闭就是一次通信结束。下一次再发请求就要开一个新流（而不是新连接），流 ID 不断增加，直到到达上限，发送“GOAWAY”帧开一个新的 TCP 连接，流 ID 就又可以重头计数。</li>
<li>因为流可以并发，所以 HTTP/2 就可以实现无阻塞的多路复用。</li>
</ul>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><ul>
<li>HTTP/2 必须先发送一个“连接前言”字符串，然后才能建立正式连接；</li>
<li>HTTP/2 废除了起始行，统一使用头字段，在两端维护字段“Key-Value”的索引表，使用“HPACK”算法压缩头部；</li>
<li>HTTP/2 把报文切分为多种类型的二进制帧，报头里最重要的字段是流标识符，标记帧属于哪个流；</li>
<li>流是 HTTP/2 虚拟的概念，是帧的双向传输序列，相当于 HTTP/1 里的一次“请求 - 应答”；</li>
<li>在一个 HTTP/2 连接上可以并发多个流，也就是多个“请求 - 响应”报文，这就是“多路复用”。</li>
</ul>
<h2 id="HTTP-3展望"><a href="#HTTP-3展望" class="headerlink" title="HTTP/3展望"></a>HTTP/3展望</h2><ul>
<li>HTTP/2 做出的许多努力，比如头部压缩、二进制分帧、虚拟的“流”与多路复用，性能方面比 HTTP/1 有了很大的提升，“基本上”解决了“队头阻塞”这个“老大难”问题。<h3 id="HTTP-2-的“队头阻塞”"><a href="#HTTP-2-的“队头阻塞”" class="headerlink" title="HTTP/2 的“队头阻塞”"></a>HTTP/2 的“队头阻塞”</h3></li>
<li>HTTP/2 虽然使用“帧”“流”“多路复用”，没有了“队头阻塞”，但这些手段都是在应用层里，而在下层，也就是 TCP 协议里，还是会发生“队头阻塞”。</li>
<li>在 HTTP/2 把多个“请求 - 响应”分解成流，交给 TCP 后，TCP 会再拆成更小的包依次发送（其实在 TCP 里应该叫 segment，也就是“段”）。</li>
<li><p>在网络良好的情况下，包可以很快送达目的地。但如果网络质量比较差，像手机上网的时候，就有可能会丢包。而 TCP 为了保证可靠传输，有个特别的“丢包重传”机制，丢失的包必须要等待重新传输确认，其他的包即使已经收到了，也只能放在缓冲区里，上层的应用拿不出来，只能“干着急”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">客户端用 TCP 发送了三个包，但服务器所在的操作系统只收到了后两个包，第一个包丢了。那么内核里的 TCP 协议栈就只能把已经收到的包暂存起来，“停下”等着客户端重传那个丢失的包，这样就又出现了“队头阻塞”。</span><br><span class="line">由于这种“队头阻塞”是 TCP 协议固有的，所以 HTTP/2 即使设计出再多的“花样”也无法解决。</span><br></pre></td></tr></table></figure>
</li>
<li><p>Google 在推 SPDY 的时候就已经意识到了这个问题，于是就又发明了一个新的“QUIC”协议，让 HTTP 跑在 QUIC 上而不是 TCP 上。而这个“HTTP over QUIC”就是 HTTP 协议的下一个大版本，HTTP/3。它在 HTTP/2 的基础上又实现了质的飞跃，真正“完美”地解决了“队头阻塞”问题。</p>
</li>
</ul>
<h3 id="QUIC-协议"><a href="#QUIC-协议" class="headerlink" title="QUIC 协议"></a>QUIC 协议</h3><ul>
<li>http/2:http/qpack+stream/quic+tls 1.3+/udp/ip/mac</li>
<li>HTTP/3 有一个关键的改变，那就是它把下层的 TCP“抽掉”了，换成了 UDP。因为 UDP 是无序的，包之间没有依赖关系，所以就从根本上解决了“队头阻塞”。</li>
<li>UDP 是一个简单、不可靠的传输协议，只是对 IP 协议的一层很薄的包装，和 TCP 相比，它实际应用的较少。不过正是因为它简单，不需要建连和断连，通信成本低，也就非常灵活、高效，“可塑性”很强。</li>
<li>所以，QUIC 就选定了 UDP，在它之上把 TCP 的那一套连接管理、拥塞窗口、流量控制等“搬”了过来，“去其糟粕，取其精华”，打造出了一个全新的可靠传输协议，可以认为是“新时代的 TCP”。<h3 id="QUIC-的特点"><a href="#QUIC-的特点" class="headerlink" title="QUIC 的特点"></a>QUIC 的特点</h3></li>
<li>QUIC 基于 UDP，而 UDP 是“无连接”的，根本就不需要“握手”和“挥手”，所以天生就要比 TCP 快。</li>
<li>就像 TCP 在 IP 的基础上实现了可靠传输一样，QUIC 也基于 UDP 实现了可靠传输，保证数据一定能够抵达目的地。它还引入了类似 HTTP/2 的“流”和“多路复用”，单个“流”是有序的，可能会因为丢包而阻塞，但其他“流”不会受到影响。</li>
<li>但 QUIC 并不是建立在 TLS 之上，而是内部“包含”了 TLS。它使用自己的帧“接管”了 TLS 里的“记录”，握手消息、警报消息都不使用 TLS 记录，直接封装成 QUIC 的帧发送，省掉了一次开销。<h3 id="QUIC-内部细节"><a href="#QUIC-内部细节" class="headerlink" title="QUIC 内部细节"></a>QUIC 内部细节</h3></li>
<li>QUIC 的基本数据传输单位是包（packet）和帧（frame），一个包由多个帧组成，包面向的是“连接”，帧面向的是“流”。</li>
<li><p>QUIC 使用不透明的“连接 ID”来标记通信的两个端点，客户端和服务器可以自行选择一组 ID 来标记自己，这样就解除了 TCP 里连接对“IP 地址 + 端口”（即常说的四元组）的强绑定，支持“连接迁移”（Connection Migration）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比如你下班回家，手机会自动由 4G 切换到 WiFi。这时 IP 地址会发生变化，TCP 就必须重新建立连接。而 QUIC 连接里的两端连接 ID 不会变，所以连接在“逻辑上”没有中断，它就可以在新的 IP 地址上继续使用之前的连接，消除重连的成本，实现连接的无缝迁移。</span><br></pre></td></tr></table></figure>
</li>
<li><p>HTTP/2 里的流都是双向的，而 QUIC 则分为双向流和单向流。</p>
</li>
</ul>
<h3 id="HTTP-3-协议"><a href="#HTTP-3-协议" class="headerlink" title="HTTP/3 协议"></a>HTTP/3 协议</h3><ul>
<li>因为 QUIC 本身就已经支持了加密、流和多路复用，所以 HTTP/3 的工作减轻了很多，把流控制都交给 QUIC 去做。调用的不再是 TLS 的安全接口，也不是 Socket API，而是专门的 QUIC 函数。不过这个“QUIC 函数”还没有形成标准，必须要绑定到某一个具体的实现库。</li>
<li>HTTP/3 里仍然使用流来发送“请求 - 响应”，但它自身不需要像 HTTP/2 那样再去定义流，而是直接使用 QUIC 的流，相当于做了一个“概念映射”。</li>
<li>HTTP/3 里的“双向流”可以完全对应到 HTTP/2 的流，而“单向流”在 HTTP/3 里用来实现控制和推送，近似地对应 HTTP/2 的 0 号流。</li>
<li>头部压缩算法在 HTTP/3 里升级成了“QPACK”，使用方式上也做了改变。虽然也分成静态表和动态表，但在流上发送 HEADERS 帧时不能更新字段，只能引用，索引表的更新需要在专门的单向流上发送指令来管理，解决了 HPACK 的“队头阻塞”问题。</li>
<li>另外，QPACK 的字典也做了优化，静态表由之前的 61 个增加到了 98 个，而且序号从 0 开始，也就是说“:authority”的编号是 0。</li>
</ul>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><ul>
<li>HTTP/3 基于 QUIC 协议，完全解决了“队头阻塞”问题，弱网环境下的表现会优于 HTTP/2；</li>
<li>QUIC 是一个新的传输层协议，建立在 UDP 之上，实现了可靠传输；</li>
<li>QUIC 内含了 TLS1.3，只能加密通信，支持 0-RTT 快速建连；</li>
<li>QUIC 的连接使用“不透明”的连接 ID，不绑定在“IP 地址 + 端口”上，支持“连接迁移”；</li>
<li>QUIC 的流与 HTTP/2 的流很相似，但分为双向流和单向流；</li>
<li>HTTP/3 没有指定默认端口号，需要用 HTTP/2 的扩展帧“Alt-Svc”来发现。</li>
</ul>
<h2 id="我应该迁移到HTTP-2吗？"><a href="#我应该迁移到HTTP-2吗？" class="headerlink" title="我应该迁移到HTTP/2吗？"></a>我应该迁移到HTTP/2吗？</h2><ul>
<li>HTTP/2 完全兼容 HTTP/1，是“更安全的 HTTP、更快的 HTTPS”，头部压缩、多路复用等技术可以充分利用带宽，降低延迟，从而大幅度提高上网体验；</li>
<li>TCP 协议存在“队头阻塞”，所以 HTTP/2 在弱网或者移动网络下的性能表现会不如 HTTP/1；</li>
<li>迁移到 HTTP/2 肯定会有性能提升，但高流量网站效果会更显著；</li>
<li>如果已经升级到了 HTTPS，那么再升级到 HTTP/2 会很简单；</li>
<li>TLS 协议提供“ALPN”扩展，让客户端和服务器协商使用的应用层协议，“发现”HTTP/2 服务。</li>
</ul>
<h2 id="Nginx：高性能的Web服务器"><a href="#Nginx：高性能的Web服务器" class="headerlink" title="Nginx：高性能的Web服务器"></a>Nginx：高性能的Web服务器</h2><ul>
<li>作为一个 Web 服务器，Nginx 的功能非常完善，完美支持 HTTP/1、HTTPS 和 HTTP/2，而且还在不断进步。当前的主线版本已经发展到了 1.17，正在进行 HTTP/3 的研发，或许一年之后就能在 Nginx 上跑 HTTP/3 了。<h3 id="进程池"><a href="#进程池" class="headerlink" title="进程池"></a>进程池</h3></li>
<li>Nginx 作为“轻量级”的服务器，它的 CPU、内存占用都非常少，同样的资源配置下就能够为更多的用户提供服务，其奥秘在于它独特的工作模式。</li>
<li>在 Nginx 之前，Web 服务器对每一个请求使用单独的进程或者线程处理。这就存在创建进程或线程的成本，还会有进程、线程“上下文切换”的额外开销。如果请求数量很多，CPU 就会在多个进程、线程之间切换时“疲于奔命”，平白地浪费了计算时间。</li>
<li>Nginx 则完全不同，“一反惯例”地没有使用多线程，而是使用了“进程池 + 单线程”的工作模式。</li>
<li>Nginx 在启动的时候会预先创建好固定数量的 worker 进程，在之后的运行过程中不会再 fork 出新进程，这就是进程池，而且可以自动把进程“绑定”到独立的 CPU 上，这样就完全消除了进程创建和切换的成本，能够充分利用多核 CPU 的计算能力。</li>
<li>在进程池之上，还有一个“master”进程，专门用来管理进程池。它的作用有点像是 supervisor（一个用 Python 编写的进程管理工具），用来监控进程，自动恢复发生异常的 worker，保持进程池的稳定和服务能力。<h3 id="I-O-多路复用"><a href="#I-O-多路复用" class="headerlink" title="I/O 多路复用"></a>I/O 多路复用</h3></li>
<li>使用多线程能够很容易实现并发处理,但多线程也有一些缺点，除了刚才说到的“上下文切换”成本，还有编程模型复杂、数据竞争、同步等问题，写出正确、快速的多线程程序并不是一件容易的事情。</li>
<li>所以 Nginx 就选择了单线程的方式，带来的好处就是开发简单，没有互斥锁的成本，减少系统消耗。</li>
<li>Web 服务器从根本上来说是“I/O 密集型”而不是“CPU 密集型”，处理能力的关键在于网络收发而不是 CPU 计算（这里暂时不考虑 HTTPS 的加解密），而网络 I/O 会因为各式各样的原因不得不等待，比如数据还没到达、对端没有响应、缓冲区满发不出去等等。</li>
<li>对于一般的单线程来说 CPU 就会“停下来”，造成浪费。而多线程的解决思路有点类似“并发连接”，虽然有的线程可能阻塞，但由于多个线程并行，总体上看阻塞的情况就不会太严重了。Nginx 里使用的 epoll，就好像是 HTTP/2 里的“多路复用”技术，它把多个 HTTP 请求处理打散成碎片，都“复用”到一个单线程里，不按照先来后到的顺序处理，而是只当连接上真正可读、可写的时候才处理，如果可能发生阻塞就立刻切换出去，处理其他的请求。通过这种方式，Nginx 就完全消除了 I/O 阻塞，把 CPU 利用得“满满当当”，又因为网络收发并不会消耗太多 CPU 计算能力，也不需要切换进程、线程，所以整体的 CPU 负载是相当低的。</li>
<li>epoll 还有一个特点，大量的连接管理工作都是在操作系统内核里做的，这就减轻了应用程序的负担，所以 Nginx 可以为每个连接只分配很小的内存维护状态，即使有几万、几十万的并发连接也只会消耗几百 M 内存，而其他的 Web 服务器这个时候早就“Memory not enough”了。<h3 id="多阶段处理"><a href="#多阶段处理" class="headerlink" title="多阶段处理"></a>多阶段处理</h3></li>
<li>Nginx 的 HTTP 处理有四大类模块：</li>
</ul>
<ol>
<li>handler 模块：直接处理 HTTP 请求；</li>
<li>filter 模块：不直接处理请求，而是加工过滤响应报文；</li>
<li>upstream 模块：实现反向代理功能，转发请求到其他服务器；</li>
<li>balance 模块：实现反向代理时的负载均衡算法。</li>
</ol>
<ul>
<li>charset 模块实现了字符集编码转换;chunked 模块实现了响应数据的分块传输；range 模块实现了范围请求，只返回数据的一部分；rewrite 模块实现了重定向和跳转，还可以使用内置变量自定义跳转的 URI；not_modified 模块检查头字段“if-Modified-Since”和“If-None-Match”，处理条件请求；ssl 模块实现了 SSL/TLS 协议支持，读取磁盘上的证书和私钥，实现 TLS 握手和 SNI、ALPN 等扩展功能；http_v2 模块实现了完整的 HTTP/2 协议。</li>
</ul>
<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><ul>
<li>Nginx 是一个高性能的 Web 服务器，它非常的轻量级，消耗的 CPU、内存很少；</li>
<li>Nginx 采用“master/workers”进程池架构，不使用多线程，消除了进程、线程切换的成本</li>
<li>Nginx 基于 epoll 实现了“I/O 多路复用”，不会阻塞，所以性能很高；</li>
<li>Nginx 使用了“职责链”模式，多个模块分工合作，自由组合，以流水线的方式处理 HTTP 请求。</li>
</ul>
<h2 id="OpenResty：更灵活的Web服务器"><a href="#OpenResty：更灵活的Web服务器" class="headerlink" title="OpenResty：更灵活的Web服务器"></a>OpenResty：更灵活的Web服务器</h2><ul>
<li>“一个人很难超越时代，而时代却可以轻易超越所有人”，Nginx 当初设计时针对的应用场景已经发生了变化，它的一些缺点也就暴露出来了。</li>
<li>Nginx 的服务管理思路延续了当时的流行做法，使用磁盘上的静态配置文件，所以每次修改后必须重启才能生效。这在业务频繁变动的时候是非常致命的（例如流行的微服务架构），特别是对于拥有成千上万台服务器的网站来说，仅仅增加或者删除一行配置就要分发、重启所有的机器，对运维是一个非常大的挑战，要耗费很多的时间和精力，成本很高，很不灵活，难以“随需应变”。</li>
<li>OpenResty 并不是一个全新的 Web 服务器，而是基于 Nginx，它利用了 Nginx 模块化、可扩展的特性，开发了一系列的增强模块，并把它们打包整合，形成了一个“一站式”的 Web 开发平台。</li>
<li>虽然 OpenResty 的核心是 Nginx，但它又超越了 Nginx，关键就在于其中的 ngx_lua 模块，把小巧灵活的 Lua 语言嵌入了 Nginx，可以用脚本的方式操作 Nginx 内部的进程、多路复用、阶段式处理等各种构件。<h3 id="动态的-Lua"><a href="#动态的-Lua" class="headerlink" title="动态的 Lua"></a>动态的 Lua</h3></li>
<li>OpenResty 里的一个关键模块是 ngx_lua，它为 Nginx 引入了脚本语言 Lua。</li>
<li>Lua 的设计目标是嵌入到其他应用程序里运行，为其他编程语言带来“脚本化”能力，所以它的“个头”比较小，功能集有限，不追求“大而全”，而是“小而美”，大多数时间都“隐匿”在其他应用程序的后面，是“无名英雄”。你或许玩过或者听说过《魔兽世界》《愤怒的小鸟》吧，它们就在内部嵌入了 Lua，使用 Lua 来调用底层接口，充当“胶水语言”（glue language），编写游戏逻辑脚本，提高开发效率。</li>
<li>作为脚本语言，Lua 还有一个重要的“代码热加载”特性，不需要重启进程，就能够从磁盘、Redis 或者任何其他地方加载数据，随时替换内存里的代码片段。这就带来了“动态配置”，让 OpenResty 能够永不停机，在微秒、毫秒级别实现配置和业务逻辑的实时更新，比起 Nginx 秒级的重启是一个极大的进步。<h3 id="高效率的-Lua"><a href="#高效率的-Lua" class="headerlink" title="高效率的 Lua"></a>高效率的 Lua</h3></li>
<li>OpenResty 能够高效运行的一大“秘技”是它的“同步非阻塞”编程范式，如果你要开发 OpenResty 应用就必须时刻铭记于心。“同步非阻塞”本质上还是一种“多路复用”</li>
<li>epoll 是操作系统级别的“多路复用”，运行在内核空间。而 OpenResty 的“同步非阻塞”则是基于 Lua 内建的“协程”，是应用程序级别的“多路复用”，运行在用户空间，所以它的资源消耗要更少。</li>
</ul>
<h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><ul>
<li>Nginx 依赖于磁盘上的静态配置文件，修改后必须重启才能生效，缺乏灵活性；</li>
<li>OpenResty 基于 Nginx，打包了很多有用的模块和库，是一个高性能的 Web 开发平台；</li>
<li>OpenResty 的工作语言是 Lua，它小巧灵活，执行效率高，支持“代码热加载”；</li>
<li>OpenResty 的核心编程范式是“同步非阻塞”，使用协程，不需要异步回调函数；</li>
<li>OpenResty 也使用“阶段式处理”的工作模式，但因为在阶段里执行的都是 Lua 代码，所以非常灵活，配合 Redis 等外部数据库能够实现各种动态配置。</li>
</ul>
<h2 id="WAF：保护我们的网络服务"><a href="#WAF：保护我们的网络服务" class="headerlink" title="WAF：保护我们的网络服务"></a>WAF：保护我们的网络服务</h2><h3 id="Web-服务遇到的威胁"><a href="#Web-服务遇到的威胁" class="headerlink" title="Web 服务遇到的威胁"></a>Web 服务遇到的威胁</h3><ul>
<li><p>第一种叫“DDoS”攻击（distributed denial-of-service attack），有时候也叫“洪水攻击”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">黑客会控制许多“僵尸”计算机，向目标服务器发起大量无效请求。</span><br><span class="line">因为服务器无法区分正常用户和黑客，只能“照单全收”，这样就挤占了正常用户所应有的资源。</span><br><span class="line">如果黑客的攻击强度很大，就会像“洪水”一样对网站的服务能力造成冲击，耗尽带宽、CPU 和内存，导致网站完全无法提供正常服务。</span><br></pre></td></tr></table></figure>
</li>
<li><p>“SQL 注入”（SQL injection）应该算是最著名的一种“代码注入”攻击了，它利用了服务器字符串拼接形成 SQL 语句的漏洞，构造出非正常的 SQL 语句，获取数据库内部的敏感信息。</p>
</li>
<li>另一种“HTTP 头注入”攻击的方式也是类似的原理，它在“Host”“User-Agent”“X-Forwarded-For”等字段里加入了恶意数据或代码，服务端程序如果解析不当，就会执行预设的恶意代码。</li>
<li>利用 Cookie 的攻击手段，“跨站脚本”（XSS）攻击，它属于“JS 代码注入”，利用 JavaScript 脚本获取未设防的 Cookie。</li>
</ul>
<h3 id="网络应用防火墙"><a href="#网络应用防火墙" class="headerlink" title="网络应用防火墙"></a>网络应用防火墙</h3><ul>
<li>传统“防火墙”工作在三层或者四层，隔离了外网和内网，使用预设的规则，只允许某些特定 IP 地址和端口号的数据包通过，拒绝不符合条件的数据流入或流出内网，实质上是一种网络数据过滤设备。</li>
<li>WAF 也是一种“防火墙”，但它工作在七层，看到的不仅是 IP 地址和端口号，还能看到整个 HTTP 报文，所以就能够对报文内容做更深入细致的审核，使用更复杂的条件、规则来过滤数据。说白了，WAF 就是一种“HTTP 入侵检测和防御系统”。</li>
<li>通常一款产品能够称为 WAF，要具备下面的一些功能：</li>
</ul>
<ol>
<li>IP 黑名单和白名单，拒绝黑名单上地址的访问，或者只允许白名单上的用户访问；</li>
<li>URI 黑名单和白名单，与 IP 黑白名单类似，允许或禁止对某些 URI 的访问；</li>
<li>防护 DDoS 攻击，对特定的 IP 地址限连限速；</li>
<li>过滤请求报文，防御“代码注入”攻击；</li>
<li>过滤响应报文，防御敏感信息外泄；</li>
<li>审计日志，记录所有检测到的入侵操作。</li>
</ol>
<ul>
<li>在网络安全领域必须时刻记得“木桶效应”（也叫“短板效应”）。网站的整体安全不在于你加固的最强的那个方向，而是在于你可能都没有意识到的“短板”。黑客往往会“避重就轻”，只要发现了网站的一个弱点，就可以“一点突破”，其他方面的安全措施也就都成了“无用功”。</li>
</ul>
<h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><ul>
<li>Web 服务通常都运行在公网上，容易受到“DDoS”、“代码注入”等各种黑客攻击，影响正常的服务，所以必须要采取措施加以保护；</li>
<li>WAF 是一种“HTTP 入侵检测和防御系统”，工作在七层，为 Web 服务提供全面的防护；</li>
<li>ModSecurity 是一个开源的、生产级的 WAF 产品，核心组成部分是“规则引擎”和“规则集”，两者的关系有点像杀毒引擎和病毒特征库；</li>
<li>WAF 实质上是模式匹配与数据过滤，所以会消耗 CPU，增加一些计算成本，降低服务能力，使用时需要在安全与性能之间找到一个“平衡点”。</li>
</ul>
<h2 id="CDN：加速我们的网络服务"><a href="#CDN：加速我们的网络服务" class="headerlink" title="CDN：加速我们的网络服务"></a>CDN：加速我们的网络服务</h2><h3 id="什么是-CDN？"><a href="#什么是-CDN？" class="headerlink" title="什么是 CDN？"></a>什么是 CDN？</h3><ul>
<li>CDN 有三个关键词：“内容”“分发”和“网络”。CDN 的最核心原则是“就近访问”，如果用户能够在本地几十公里的距离之内获取到数据，那么时延就基本上变成 0 了。</li>
<li>缓存代理”技术。使用“推”或者“拉”的手段，把源站的内容逐级缓存到网络的每一个节点上。</li>
<li>用户在上网的时候就不直接访问源站，而是访问离他“最近的”一个 CDN 节点，术语叫“边缘节点”（edge node），其实就是缓存了源站内容的代理服务器，这样一来就省去了“长途跋涉”的时间成本，实现了“网络加速”。</li>
<li>套用一句广告词来形容 CDN 吧，我觉得非常恰当：“我们不生产内容，我们只是内容的搬运工。”CDN，正是把“数据传输”这件看似简单的事情“做大做强”“做专做精”，就像专门的快递公司一样，在互联网世界里实现了它的价值。<h3 id="CDN-的负载均衡"><a href="#CDN-的负载均衡" class="headerlink" title="CDN 的负载均衡"></a>CDN 的负载均衡</h3></li>
<li>它有两个关键组成部分：全局负载均衡和缓存系统，对应的是 DNS和缓存代理技术。</li>
<li>全局负载均衡（Global Sever Load Balance）一般简称为 GSLB，它是 CDN 的“大脑”，主要的职责是当用户接入网络的时候在 CDN 专网中挑选出一个“最佳”节点提供服务，解决的是用户如何找到“最近的”边缘节点，对整个 CDN 网络进行“负载均衡”。GSLB 最常见的实现方式是“DNS 负载均衡”</li>
<li>CDN 的全局负载均衡系统，“智能调度”，主要的依据有这么几个：</li>
</ul>
<ol>
<li>看用户的 IP 地址，查表得知地理位置，找相对最近的边缘节点；</li>
<li>看用户所在的运营商网络，找相同网络的边缘节点；</li>
<li>检查边缘节点的负载情况，找负载较轻的节点；</li>
<li>其他，比如节点的“健康状况”、服务能力、带宽、响应时间等。</li>
</ol>
<h3 id="CDN-的缓存代理"><a href="#CDN-的缓存代理" class="headerlink" title="CDN 的缓存代理"></a>CDN 的缓存代理</h3><ul>
<li>缓存系统是 CDN 的另一个关键组成部分，相当于 CDN 的“心脏”。如果缓存系统的服务能力不够，不能很好地满足用户的需求，那 GSLB 调度算法再优秀也没有用。</li>
<li>两个 CDN 的关键概念：“命中”和“回源”。“命中”就是指用户访问的资源恰好在缓存系统里，可以直接返回给用户；“回源”则正相反，缓存里没有，必须用代理的方式回源站取。</li>
<li>相应地，也就有了两个衡量 CDN 服务质量的指标：“命中率”和“回源率”。命中率就是命中次数与所有访问次数之比，回源率是回源次数与所有访问次数之比。显然，好的 CDN 应该是命中率越高越好，回源率越低越好。现在的商业 CDN 命中率都在 90% 以上，相当于把源站的服务能力放大了 10 倍以上。</li>
</ul>
<h2 id="WebSocket：沙盒里的TCP"><a href="#WebSocket：沙盒里的TCP" class="headerlink" title="WebSocket：沙盒里的TCP"></a>WebSocket：沙盒里的TCP</h2><ul>
<li>“WebSocket”是一种基于 TCP 的轻量级网络通信协议，在地位上是与 HTTP“平级”的。</li>
</ul>
<h3 id="为什么要有-WebSocket"><a href="#为什么要有-WebSocket" class="headerlink" title="为什么要有 WebSocket"></a>为什么要有 WebSocket</h3><ul>
<li>WebSocket 与 HTTP/2 一样，都是为了解决 HTTP 某方面的缺陷而诞生的。HTTP/2 针对的是“队头阻塞”，而 WebSocket 针对的是“请求 - 应答”通信模式。</li>
<li>“请求 - 应答”是一种“半双工”的通信模式，虽然可以双向收发数据，但同一时刻只能一个方向上有动作，传输效率低。更关键的一点，它是一种“被动”通信模式，服务器只能“被动”响应客户端的请求，无法主动向客户端发送数据。</li>
<li>虽然后来的 HTTP/2、HTTP/3 新增了 Stream、Server Push 等特性，但“请求 - 应答”依然是主要的工作方式。这就导致 HTTP 难以应用在动态页面、即时消息、网络游戏等要求“实时通信”的领域。<h3 id="WebSocket-的特点"><a href="#WebSocket-的特点" class="headerlink" title="WebSocket 的特点"></a>WebSocket 的特点</h3></li>
<li>WebSocket 是一个真正“全双工”的通信协议，与 TCP 一样，客户端和服务器都可以随时向对方发送数据，而不用像 HTTP“你拍一，我拍一”那么“客套”。</li>
<li>WebSocket 采用了二进制帧结构，语法、语义与 HTTP 完全不兼容，但因为它的主要运行环境是浏览器，为了便于推广和应用，就不得不“搭便车”，在使用习惯上尽量向 HTTP 靠拢，这就是它名字里“Web”的含义。</li>
<li>服务发现方面，WebSocket 没有使用 TCP 的“IP 地址 + 端口号”，而是延用了 HTTP 的 URI 格式，但开头的协议名不是“http”，引入的是两个新的名字：“ws”和“wss”，分别表示明文和加密的 WebSocket 协议。</li>
<li>WebSocket 的默认端口也选择了 80 和 443，因为现在互联网上的防火墙屏蔽了绝大多数的端口，只对 HTTP 的 80、443 端口“放行”，所以 WebSocket 就可以“伪装”成 HTTP 协议，比较容易地“穿透”防火墙，与服务器建立连接。<h3 id="WebSocket-的帧结构"><a href="#WebSocket-的帧结构" class="headerlink" title="WebSocket 的帧结构"></a>WebSocket 的帧结构</h3></li>
<li>不过 WebSocket 和 HTTP/2 的关注点不同，WebSocket 更侧重于“实时通信”，而 HTTP/2 更侧重于提高传输效率，所以两者的帧结构也有很大的区别。</li>
<li>WebSocket 虽然有“帧”，但却没有像 HTTP/2 那样定义“流”，也就不存在“多路复用”“优先级”等复杂的特性，而它自身就是“全双工”的，也就不需要“服务器推送”。所以综合起来，WebSocket 的帧学习起来会简单一些。<h3 id="WebSocket-的握手"><a href="#WebSocket-的握手" class="headerlink" title="WebSocket 的握手"></a>WebSocket 的握手</h3></li>
<li>和 TCP、TLS 一样，WebSocket 也要有一个握手过程，然后才能正式收发数据。</li>
<li>WebSocket 的握手是一个标准的 HTTP GET 请求，但要带上两个协议升级的专用头字段：“Connection: Upgrade”，表示要求协议“升级”；“Upgrade: websocket”，表示要“升级”成 WebSocket 协议。</li>
<li>另外，为了防止普通的 HTTP 消息被“意外”识别成 WebSocket，握手消息还增加了两个额外的认证用头字段（所谓的“挑战”，Challenge）：Sec-WebSocket-Key：一个 Base64 编码的 16 字节随机数，作为简单的认证密钥；Sec-WebSocket-Version：协议的版本号，当前必须是 13。</li>
<li>服务器收到 HTTP 请求报文，看到上面的四个字段，就知道这不是一个普通的 GET 请求，而是 WebSocket 的升级请求，于是就不走普通的 HTTP 处理流程，而是构造一个特殊的“101 Switching Protocols”响应报文，通知客户端，接下来就不用 HTTP 了，全改用 WebSocket 协议通信。（有点像 TLS 的“Change Cipher Spec”）</li>
<li>WebSocket 的握手响应报文也是有特殊格式的，要用字段“Sec-WebSocket-Accept”验证客户端请求报文，同样也是为了防止误连接。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">encode_base64(</span><br><span class="line">  sha1( </span><br><span class="line">    Sec-WebSocket-Key + &apos;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&apos; ))</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h3><ul>
<li>HTTP 的“请求 - 应答”模式不适合开发“实时通信”应用，效率低，难以实现动态页面，所以出现了 WebSocket；</li>
<li>WebSocket 是一个“全双工”的通信协议，相当于对 TCP 做了一层“薄薄的包装”，让它运行在浏览器环境里；</li>
<li>WebSocket 使用兼容 HTTP 的 URI 来发现服务，但定义了新的协议名“ws”和“wss”，端口号也沿用了 80 和 443；</li>
<li>WebSocket 使用二进制帧，结构比较简单，特殊的地方是有个“掩码”操作，客户端发数据必须掩码，服务器则不用；</li>
<li>WebSocket 利用 HTTP 协议实现连接握手，发送 GET 请求要求“协议升级”，握手过程中有个非常简单的认证机制，目的是防止误连接。</li>
</ul>
<h2 id="HTTP性能优化面面观（上）"><a href="#HTTP性能优化面面观（上）" class="headerlink" title="HTTP性能优化面面观（上）"></a>HTTP性能优化面面观（上）</h2><h3 id="HTTP-服务器"><a href="#HTTP-服务器" class="headerlink" title="HTTP 服务器"></a>HTTP 服务器</h3><ul>
<li>衡量服务器性能的主要指标有三个：吞吐量（requests per second）、并发数（concurrency）和响应时间（time per request）。除了上面的三个基本性能指标，服务器还要考虑 CPU、内存、硬盘和网卡等系统资源的占用程度，利用率过高或者过低都可能有问题。</li>
</ul>
<ol>
<li>吞吐量就是我们常说的 RPS，每秒的请求次数，也有叫 TPS、QPS，它是服务器最基本的性能指标，RPS 越高就说明服务器的性能越好。</li>
<li>并发数反映的是服务器的负载能力，也就是服务器能够同时支持的客户端数量，当然也是越多越好，能够服务更多的用户。</li>
<li>响应时间反映的是服务器的处理能力，也就是快慢程度，响应时间越短，单位时间内服务器就能够给越多的用户提供服务，提高吞吐量和并发数。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">在 Linux 上，最常用的性能测试工具可能就是 ab（Apache Bench）了，比如，下面的命令指定了并发数 100，总共发送 10000 个请求：</span><br><span class="line"></span><br><span class="line">ab -c 100 -n 10000 &apos;http://www.xxx.com&apos;</span><br><span class="line"></span><br><span class="line">系统资源监控方面，Linux 自带的工具也非常多，常用的有 uptime、top、vmstat、netstat、sar 等等，可能你比我还要熟悉，我就列几个简单的例子吧：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">top             #查看CPU和内存占用情况</span><br><span class="line">vmstat  2       #每2秒检查一次系统状态</span><br><span class="line">sar -n DEV 2    #看所有网卡的流量，定时2秒检查</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="HTTP-客户端"><a href="#HTTP-客户端" class="headerlink" title="HTTP 客户端"></a>HTTP 客户端</h3><ul>
<li>客户端是信息的消费者，一切数据都要通过网络从服务器获取，所以它最基本的性能指标就是“延迟”（latency）。所谓的“延迟”其实就是“等待”，等待数据到达客户端时所花费的时间。但因为 HTTP 的传输链路很复杂，所以延迟的原因也就多种多样。</li>
</ul>
<ol>
<li>首先，我们必须谨记有一个“不可逾越”的障碍——光速，因为地理距离而导致的延迟是无法克服的，访问数千公里外的网站显然会有更大的延迟。</li>
<li>其次，第二个因素是带宽，它又包括接入互联网时的电缆、WiFi、4G 和运营商内部网络、运营商之间网络的各种带宽，每一处都有可能成为数据传输的瓶颈，降低传输速度，增加延迟。</li>
<li>第三个因素是 DNS 查询，如果域名在本地没有缓存，就必须向 DNS 系统发起查询，引发一连串的网络通信成本，而在获取 IP 地址之前客户端只能等待，无法访问网站。</li>
<li>第四个因素是 TCP 握手，你应该对它比较熟悉了吧，必须要经过 SYN、SYN/ACK、ACK 三个包之后才能建立连接，它带来的延迟由光速和带宽共同决定。</li>
<li>建立 TCP 连接之后，就是正常的数据收发了，后面还有解析 HTML、执行 JavaScript、排版渲染等等，这些也会耗费一些时间。不过它们已经不属于 HTTP 了，所以不在今天的讨论范围之内。</li>
</ol>
<ul>
<li>因为有“队头阻塞”，浏览器对每个域名最多开 6 个并发连接（HTTP/1.1），当页面里链接很多的时候就必须排队等待（Queued、Queueing）</li>
<li>浏览器要预先分配资源，调度连接</li>
<li>连接前必须要解析域名</li>
<li>与网站服务器建立连接的成本很高</li>
<li>实际发送数据非常快</li>
<li>之后就是等待服务器的响应，专有名词叫 TTFB（Time To First Byte），也就是“首字节响应时间”，里面包括了服务器的处理时间和网络传输时间</li>
<li>接收数据也是非常快的</li>
</ul>
<h3 id="HTTP-传输链路"><a href="#HTTP-传输链路" class="headerlink" title="HTTP 传输链路"></a>HTTP 传输链路</h3><ul>
<li>“第一公里”是指网站的出口，也就是服务器接入互联网的传输线路，它的带宽直接决定了网站对外的服务能力，也就是吞吐量等指标。显然，优化性能应该在这“第一公里”加大投入，尽量购买大带宽，接入更多的运营商网络。</li>
<li>“中间一公里”就是由许多小网络组成的实际的互联网，其实它远不止“一公里”，而是非常非常庞大和复杂的网络，地理距离、网络互通都严重影响了传输速度。好在这里面有一个 HTTP 的“好帮手”——CDN，它可以帮助网站跨越“千山万水”，让这段距离看起来真的就好像只有“一公里”。</li>
<li>“最后一公里”是用户访问互联网的入口，对于固网用户就是光纤、网线，对于移动用户就是 WiFi、基站。以前它是客户端性能的主要瓶颈，延迟大带宽小，但随着近几年 4G 和高速宽带的普及，“最后一公里”的情况已经好了很多，不再是制约性能的主要因素了。</li>
</ul>
<h3 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h3><ul>
<li>性能优化是一个复杂的概念，在 HTTP 里可以分解为服务器性能优化、客户端性能优化和传输链路优化；</li>
<li>服务器有三个主要的性能指标：吞吐量、并发数和响应时间，此外还需要考虑资源利用率；</li>
<li>客户端的基本性能指标是延迟，影响因素有地理距离、带宽、DNS 查询、TCP 握手等；</li>
<li>从服务器到客户端的传输链路可以分为三个部分，我们能够优化的是前两个部分，也就是“第一公里”和“中间一公里”；</li>
<li>有很多工具可以测量这些指标，服务器端有 ab、top、sar 等，客户端可以使用测试网站，浏览器的开发者工具。</li>
</ul>
<h2 id="HTTP性能优化面面观（下）"><a href="#HTTP性能优化面面观（下）" class="headerlink" title="HTTP性能优化面面观（下）"></a>HTTP性能优化面面观（下）</h2><ul>
<li>总的来说，任何计算机系统的优化都可以分成这么几类：硬件软件、内部外部、花钱不花钱。</li>
<li>投资购买现成的硬件最简单的优化方式，比如换上更强的 CPU、更快的网卡、更大的带宽、更多的服务器，效果也会“立竿见影”，直接提升网站的服务能力，也就实现了 HTTP 优化。</li>
<li>另外，花钱购买外部的软件或者服务也是一种行之有效的优化方式，最“物有所值”的应该算是 CDN 了。CDN 专注于网络内容交付，帮助网站解决“中间一公里”的问题，还有很多其他非常专业的优化功能。把网站交给 CDN 运营，就好像是“让网站坐上了喷气飞机”，能够直达用户，几乎不需要费什么力气就能够达成很好的优化效果。</li>
<li>不过这些“花钱”的手段实在是太没有“技术含量”了，属于“懒人”（无贬义）的做法。<h3 id="开源"><a href="#开源" class="headerlink" title="开源"></a>开源</h3></li>
<li>这个“开源”可不是 Open Source，而是指抓“源头”，开发网站服务器自身的潜力，在现有条件不变的情况下尽量挖掘出更多的服务能力。</li>
<li>首先，我们应该选用高性能的 Web 服务器，最佳选择当然就是 Nginx/OpenResty 了，尽量不要选择基于 Java、Python、Ruby 的其他服务器，它们用来做后面的业务逻辑服务器更好。利用 Nginx 强大的反向代理能力实现“动静分离”，动态页面交给 Tomcat、Django、Rails，图片、样式表等静态资源交给 Nginx。</li>
<li>Nginx 或者 OpenResty 自身也有很多配置参数可以用来进一步调优，举几个例子，比如说禁用负载均衡锁、增大连接池，绑定 CPU 等等，相关的资料有很多。</li>
<li>对于 HTTP 协议一定要启用长连接。TCP 和 SSL 建立新连接的成本是非常高的，有可能会占到客户端总延迟的一半以上。长连接虽然不能优化连接握手，但可以把成本“均摊”到多次请求里，这样只有第一次请求会有延迟，之后的请求就不会有连接延迟，总体的延迟也就降低了。</li>
<li>在现代操作系统上都已经支持 TCP 的新特性“TCP Fast Open”（Win10、iOS9、Linux 4.1），它的效果类似 TLS 的“False Start”，可以在初次握手的时候就传输数据，也就是 0-RTT，所以我们应该尽可能在操作系统和 Nginx 里开启这个特性，减少外网和内网里的握手延迟。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">下面给出一个简短的 Nginx 配置示例，启用了长连接等优化参数，实现了动静分离。</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen 80 deferred reuseport backlog=4096 fastopen=1024; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  keepalive_timeout  60;</span><br><span class="line">  keepalive_requests 10000;</span><br><span class="line">  </span><br><span class="line">  location ~* \.(png)$ &#123;</span><br><span class="line">    root /var/images/png/;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  location ~* \.(php)$ &#123;</span><br><span class="line">    proxy_pass http://php_back_end;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><ul>
<li>“节流”是指减少客户端和服务器之间收发的数据量，在有限的带宽里传输更多的内容。</li>
<li>“节流”最基本的做法就是使用 HTTP 协议内置的“数据压缩”编码，不仅可以选择标准的 gzip，还可以积极尝试新的压缩算法 br，它有更好的压缩效果。</li>
<li>不过在数据压缩的时候应当注意选择适当的压缩率，不要追求最高压缩比，否则会耗费服务器的计算资源，增加响应时间，降低服务能力，反而会“得不偿失”。</li>
<li>HTML/CSS/JavaScript 属于纯文本，就可以采用特殊的“压缩”，去掉源码里多余的空格、换行、注释等元素。这样“压缩”之后的文本虽然看起来很混乱，对“人类”不友好，但计算机仍然能够毫无障碍地阅读，不影响浏览器上的运行效果。</li>
<li>图片在 HTTP 传输里占有非常高的比例，虽然它本身已经被压缩过了，不能被 gzip、br 处理，但仍然有优化的空间。比如说，去除图片里的拍摄时间、地点、机型等元数据，适当降低分辨率，缩小尺寸。图片的格式也很关键，尽量选择高压缩率的格式，有损格式应该用 JPEG，无损格式应该用 Webp 格式。</li>
<li>对于小文本或者小图片，还有一种叫做“资源合并”（Concatenation）的优化方式，就是把许多小资源合并成一个大资源，用一个请求全下载到客户端，然后客户端再用 JavaScript、CSS 切分后使用，好处是节省了请求次数，但缺点是处理比较麻烦。</li>
<li>刚才说的几种数据压缩针对的都是 HTTP 报文里的 body，在 HTTP/1 里没有办法可以压缩 header，但我们也可以采取一些手段来减少 header 的大小，不必要的字段就尽量不发（例如 Server、X-Powered-By）。</li>
<li>网站经常会使用 Cookie 来记录用户的数据，浏览器访问网站时每次都会带上 Cookie，冗余度很高。所以应当少使用 Cookie，减少 Cookie 记录的数据量，总使用 domain 和 path 属性限定 Cookie 的作用域，尽可能减少 Cookie 的传输。如果客户端是现代浏览器，还可以使用 HTML5 里定义的 Web Local Storage，避免使用 Cookie。</li>
<li>DNS 解析域名会耗费不少的时间，如果网站拥有多个域名，那么域名解析获取 IP 地址就是一个不小的成本，所以应当适当“收缩”域名，限制在两三个左右，减少解析完整域名所需的时间，让客户端尽快从系统缓存里获取解析结果。</li>
<li>重定向引发的客户端延迟也很高，它不仅增加了一次请求往返，还有可能导致新域名的 DNS 解析，是 HTTP 前端性能优化的“大忌”。除非必要，应当尽量不使用重定向，或者使用 Web 服务器的“内部重定向”。<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3></li>
<li>它不仅是 HTTP，也是任何计算机系统性能优化的“法宝”，把它和上面的“开源”“节流”搭配起来应用于传输链路，就能够让 HTTP 的性能再上一个台阶。</li>
<li>利用好缓存功能的关键是理解它的工作原理，为每个资源都添加 ETag 和 Last-modified 字段，再用 Cache-Control、Expires 设置好缓存控制属性。</li>
<li>其中最基本的是 max-age 有效期，标记资源可缓存的时间。对于图片、CSS 等静态资源可以设置较长的时间，比如一天或者一个月，对于动态资源，除非是实时性非常高，也可以设置一个较短的时间，比如 1 秒或者 5 秒。</li>
<li>这样一旦资源到达客户端，就会被缓存起来，在有效期内都不会再向服务器发送请求，也就是：“没有请求的请求，才是最快的请求。”</li>
</ul>
<h3 id="HTTP-2-1"><a href="#HTTP-2-1" class="headerlink" title="HTTP/2"></a>HTTP/2</h3><ul>
<li>HTTP 性能优化还有一个选择，那就是把协议由 HTTP/1 升级到 HTTP/2。</li>
<li>你已经知道了 HTTP/2 的很多优点，它消除了应用层的队头阻塞，拥有头部压缩、二进制帧、多路复用、流量控制、服务器推送等许多新特性，大幅度提升了 HTTP 的传输效率。</li>
<li>对于 HTTP/2 来说，一个域名使用一个 TCP 连接才能够获得最佳性能，如果开多个域名，就会浪费带宽和服务器资源，也会降低 HTTP/2 的效率，所以“域名收缩”在 HTTP/2 里是必须要做的。</li>
<li>“资源合并”在 HTTP/1 里减少了多次请求的成本，但在 HTTP/2 里因为有头部压缩和多路复用，传输小文件的成本很低，所以合并就失去了意义。而且“资源合并”还有一个缺点，就是降低了缓存的可用性，只要一个小文件更新，整个缓存就完全失效，必须重新下载。</li>
<li>所以在现在的大带宽和 CDN 应用场景下，应当尽量少用资源合并（JavaScript、CSS 图片合并，数据内嵌），让资源的粒度尽可能地小，才能更好地发挥缓存的作用。</li>
</ul>
<h3 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h3><ul>
<li>花钱购买硬件、软件或者服务可以直接提升网站的服务能力，其中最有价值的是 CDN；</li>
<li>不花钱也可以优化 HTTP，三个关键词是“开源”“节流”和“缓存”；</li>
<li>后端应该选用高性能的 Web 服务器，开启长连接，提升 TCP 的传输效率；</li>
<li>前端应该启用 gzip、br 压缩，减小文本、图片的体积，尽量少传不必要的头字段；</li>
<li>缓存是无论何时都不能忘记的性能优化利器，应该总使用 Etag 或 Last-modified 字段标记资源；</li>
<li>升级到 HTTP/2 能够直接获得许多方面的性能提升，但要留意一些 HTTP/1 的“反模式”。</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/学习/">学习</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/学习/">学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网站/">网站</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/资源/">资源</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-react" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2021/03/25/react/" class="article-date">
      <time datetime="2021-03-24T16:00:00.000Z" itemprop="datePublished">2021-03-25</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/25/react/">react进阶</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="fiber"><a href="#fiber" class="headerlink" title="fiber"></a>fiber</h2><h3 id="requestIdleCallback"><a href="#requestIdleCallback" class="headerlink" title="requestIdleCallback"></a>requestIdleCallback</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">window.requestIdleCallback()方法将在浏览器的空闲时段内调用的函数排队。</span><br><span class="line">这使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，如动画和输入响应。函数一般会按先进先调用的顺序执行，</span><br><span class="line">然而，如果回调函数指定了执行超时时间timeout，则有可能为了在超时前执行函数而打乱执行顺序。</span><br><span class="line"></span><br><span class="line">返回值为一个ID，可以把它传入 Window.cancelIdleCallback() 方法来结束回调。</span><br><span class="line"></span><br><span class="line">①参数callback:一个在事件循环空闲时即将被调用的函数的引用。函数会接收到一个名为 IdleDeadline 的参数，这个参数可以获取当前空闲时间以及回调是否在超时时间前已经执行的状态。</span><br><span class="line">②参数options：可选，包括可选的配置参数。具有如下属性：timeout：如果指定了timeout并具有一个正值，并且尚未通过超时毫秒数调用回调，那么回调会在下一次空闲时期被强制执行，尽管这样很可能会对性能造成负面影响。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function calc(deadline)&#123;</span><br><span class="line">if(deadline.timeRemaining()&gt;1)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">requestIdleCallback(calc)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">btn1.onclick=()=&gt;&#123;</span><br><span class="line">requestIdleCallback(calc)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">btn2.onclick=()=&gt;&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="旧版Stack算法"><a href="#旧版Stack算法" class="headerlink" title="旧版Stack算法"></a>旧版Stack算法</h3><ul>
<li>React 16之前比对更新虚拟Dom的过程采用循环加递归实现，一旦任务开始执行就无法进行中断，如果组件数量庞大，主线程会被长期占用，直到虚拟DOM树更新完成主线程才能被释放。主线程被长期占用会导致用户交互、动画等任务无法立即执行，页面就会卡顿，影响用户体验。</li>
<li>解决方案</li>
</ul>
<ol>
<li>利用浏览器的空闲时间执行任务（requestIdleCallback）,避免主线程的长期占用</li>
<li>放弃递归，只采用循环，循环可以中断</li>
<li>任务拆分，将任务拆分成一个一个的子任务。</li>
</ol>
<h3 id="fiber-1"><a href="#fiber-1" class="headerlink" title="fiber"></a>fiber</h3><ul>
<li>分两步：1.构建Fiber（可中断）2.提交Commit（不可中断）</li>
<li>Dom初始渲染：虚拟DOM =&gt; Fiber =&gt; Fiber [] =&gt;Dom </li>
<li>Dom更新：newFiber vs oldFiber =&gt; Fiber [] =&gt; Dom</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   type   节点；类型（元素、文本、组件）</span><br><span class="line">   props  节点属性</span><br><span class="line">   stateNode 节点Dom对象 | 组件实例对象</span><br><span class="line">   tag 节点标记（hostRoot || hostComponent || classComponent || functionComponent）</span><br><span class="line">   effects 数组，存储需要更改的fiber对象</span><br><span class="line">   effectTag 当前Fiber需要被执行的操作（新增、删除、修改）</span><br><span class="line">   parent 当前Fiber的父级Fiber</span><br><span class="line">   child 当前Fiber的子级Fiber</span><br><span class="line">   sibling 当前Fiber的下一个兄弟Fiber</span><br><span class="line">   alternate Fiber备份  fiber比对时使用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">//子任务</span><br><span class="line">const subTask=null</span><br><span class="line"></span><br><span class="line">let pendingCommit=null</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const commitAllWork = fiber =&gt;&#123;</span><br><span class="line">  fiber.effects.forEach(item=&gt;&#123;</span><br><span class="line">  </span><br><span class="line">  if(item.effectTag===&apos;update&apos;)&#123;</span><br><span class="line">  </span><br><span class="line">    //更新</span><br><span class="line">	</span><br><span class="line">	if(item.typr===item.alternate.type)&#123;</span><br><span class="line">	</span><br><span class="line">	  updateNodeElement(item.stateNode,item,item.alternate)</span><br><span class="line">	</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">	   //节点类型不同</span><br><span class="line">	  item.parent.stateNode.replaceChild(item.stateNode,item.alternate.stateNode)</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">   if(item.effectTag===&apos;placement&apos;)&#123;</span><br><span class="line">   </span><br><span class="line">    let fiber=item</span><br><span class="line">	let parentFiber = item.parent</span><br><span class="line">	</span><br><span class="line">	while(parentFiber.tag===&apos;class_component&apos;||parentFiber.tag===&apos;function_component&apos;)&#123;</span><br><span class="line">	  parentFiber=parentFiber.parent</span><br><span class="line">	&#125;</span><br><span class="line">	if(fiber.tag===&apos;host_component&apos;)&#123;</span><br><span class="line">	 parentFiber.stateNode.appendChild(fiber.stateNode)</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  //备份旧fiber节点对象</span><br><span class="line">  fiber.stateNode.__rootFiberContainer=fiber</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//获取子任务</span><br><span class="line">const getFirstTask=()=&gt;&#123;</span><br><span class="line"></span><br><span class="line">//从任务队列中获取任务</span><br><span class="line">const task =   taskQueue.pop()</span><br><span class="line"></span><br><span class="line">//返回最外层节点的fiber对象</span><br><span class="line">return &#123;</span><br><span class="line">  props:task.props,</span><br><span class="line">  stateNode:task.dom,</span><br><span class="line">  tag:&apos;host_root&apos;,</span><br><span class="line">  effects:[],</span><br><span class="line">  child:null,</span><br><span class="line">  alternate:task.dom.__rootFiberContainer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const reconcileChildren=(fiber,children)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">//children可能为对象或数组</span><br><span class="line"></span><br><span class="line">const arrChildren=Array.isArray(children)?children:[children]</span><br><span class="line"></span><br><span class="line">let index=0</span><br><span class="line">let element=null</span><br><span class="line">let newFiber=null</span><br><span class="line">let prevFiber=null</span><br><span class="line"></span><br><span class="line">let alternate=null</span><br><span class="line"></span><br><span class="line">if(fiber.alternate&amp;&amp;fiber.alternate.child)&#123;</span><br><span class="line"> alternate=fiber.alternate.child</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">while(index &lt; arrChildren.length)&#123;</span><br><span class="line"> element=arrChildren[index]</span><br><span class="line"> </span><br><span class="line"> if(element&amp;&amp;alternate)&#123;</span><br><span class="line"> //更新</span><br><span class="line"> newFiber=&#123;</span><br><span class="line">  type:element.type,</span><br><span class="line">  props:element.props,</span><br><span class="line">  tag:getTag(element),</span><br><span class="line">  effects:[],</span><br><span class="line">  effectTag:&apos;update&apos;,</span><br><span class="line">  parent:fiber,</span><br><span class="line">  alternate</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">   newFiber.stateNode=createStateNode(newFiber)</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> &#125;else if(element&amp;&amp;!alternate)&#123;</span><br><span class="line"> </span><br><span class="line"> //初始渲染</span><br><span class="line"> //子级Fiber对象</span><br><span class="line"> newFiber=&#123;</span><br><span class="line">  type:element.type,</span><br><span class="line">  props:element.props,</span><br><span class="line">  tag:getTag(element),</span><br><span class="line">  effects:[],</span><br><span class="line">  effectTag:&apos;placement&apos;,</span><br><span class="line">  parent:fiber</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> if(element.type===alternate.type)&#123;</span><br><span class="line">  newFiber.stateNode=alternate.stateNode</span><br><span class="line"> &#125;else&#123;</span><br><span class="line">  //类型不同 不需要比对</span><br><span class="line">  newFiber.stateNode=createStateNode(newFiber)</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">  </span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> //为父级Fiber添加子级Fiber</span><br><span class="line"> if(index===0)&#123;</span><br><span class="line">  fiber.child=newFiber</span><br><span class="line"> </span><br><span class="line"> &#125;else&#123;</span><br><span class="line">   prevFiber.sibling=newFiber</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> if(alternate&amp;&amp;alternate.sibling)&#123;</span><br><span class="line">  alternate=alternate.sibling</span><br><span class="line"> &#125;else&#123;</span><br><span class="line">  alternate=null</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> prevFiber=newFiber</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> index++</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const executeTask= fiber =&gt;&#123;</span><br><span class="line"></span><br><span class="line">if(fiber.tag===&apos;class_component)&#123;</span><br><span class="line"></span><br><span class="line">reconcileChildren(fiber,fiber.stateNode.render())</span><br><span class="line">&#125;else if(fiber.tag===&apos;function_component)&#123;</span><br><span class="line">  reconcileChildren(fiber,fiber.stateNode())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">else&#123;</span><br><span class="line">reconcileChildren(fiber,fiber.props.children)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> //子级处理</span><br><span class="line"> if(fiber.child)&#123;</span><br><span class="line"> </span><br><span class="line">  return fiber.children</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> //同级处理</span><br><span class="line"> let currentExecuteFiber=fiber</span><br><span class="line"> </span><br><span class="line"> while(currentExecuteFiber.parent)&#123;</span><br><span class="line"> //构建effects数组</span><br><span class="line">   currentExecuteFiber.parent.effects=currentExecuteFiber.parent.effects.concat(currentExecuteFiber.effects.concat([currentExecuteFiber]))</span><br><span class="line"> </span><br><span class="line">   if(currentExecuteFiber.sibling)&#123;</span><br><span class="line">   return currentExecuteFiber.sibling</span><br><span class="line">   &#125;</span><br><span class="line">   currentExecuteFiber=currentExecuteFiber.parent</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> pendingCommit=currentExecuteFiber</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const workLoop=deadline=&gt;&#123;</span><br><span class="line"></span><br><span class="line">//子任务不存在时，先获取子任务</span><br><span class="line"> if(!subTask)&#123;</span><br><span class="line">  subTask=getFirstTask()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> //存在子任务并且浏览器有空余时间</span><br><span class="line"> </span><br><span class="line"> while(subTask&amp;&amp;dealline.timeRemaining()&gt;1)&#123;</span><br><span class="line">   subTask =   executeTask(subTask)</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> if(pendingCommit)&#123;</span><br><span class="line"> </span><br><span class="line">  commitAllWork(pendingCommit)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const performTask=deadline=&gt;&#123;</span><br><span class="line"> //执行任务</span><br><span class="line">  workLoop(deadline)</span><br><span class="line">  </span><br><span class="line">  //还有未执行的子任务或任务</span><br><span class="line">  if(subTask || !taskQueue.isEmpty())&#123;</span><br><span class="line">     requestIdleCallback(performTask)</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export const render=(element,dom)=&gt;&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//添加任务       任务：通过虚拟Dom对象构建Fiber对象</span><br><span class="line">tackQueue.push(&#123;</span><br><span class="line"> dom,</span><br><span class="line"> props:&#123;children:element&#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//任务调度</span><br><span class="line">requestIdleCallback(performTask)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const createStateNode=fiber=&gt;&#123;</span><br><span class="line"> if(fiber.tag===&apos;host_component&apos;)&#123;</span><br><span class="line">   return createDOMElement(fiber)</span><br><span class="line"> &#125;else&#123;</span><br><span class="line">   return createReactInstance(fiber)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const createReactInstance=fiber=&gt;&#123;</span><br><span class="line">   let instance=null</span><br><span class="line">   if(fiber.tag===&apos;class_component&apos;)&#123;</span><br><span class="line">     instance=new fiber.type(fiber.props)</span><br><span class="line">   &#125;else&#123;</span><br><span class="line">     instance=fiber.type</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return instance</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const getTag= vdom=&gt;&#123;</span><br><span class="line">  if(typeof vdom.type===&apos;string&apos;)&#123;</span><br><span class="line">    return &apos;host_component&apos; </span><br><span class="line">  &#125;else if(Object.getPrototypeOf(vdom.type)=== Component)&#123;</span><br><span class="line">    return &apos;class_component&apos;</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">     return &apos;function_component&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/学习/">学习</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/学习/">学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网站/">网站</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/资源/">资源</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  

</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2022 DiamondsZz
            </div>        
        </div>
    </div>
</footer>

    </div>
    
<script src="https://www.unpkg.com/jquery@3.6.0/dist/jquery.js"></script>

<script src="/js/main.js"></script>

    <script>
        $(document).ready(function() {
            var backgroundnum = 1;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>






<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" "="">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(
            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


  </div>
</body>
</html>