<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  <meta name="baidu-site-verification" content="L6Lm9d5Crl">
  
  
  
  
  <title>可视化 | DiamondsZz</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="图形基础篇浏览器中实现可视化的四种方式 传统的 HTML+CSS。这种方式通常用来呈现普通的 Web 网页。 SVG 和传统的 HTML+CSS 的绘图方式差别不大。只不过，HTML 元素在绘制矢量图形方面的能力有些不足，而 SVG 恰好弥补了这方面的缺陷。 Canvas2D。这是浏览器提供的 Canvas API 中的其中一种上下文，使用它可以非常方便地绘制出基础的几何图形。在可视化中，Canv">
<meta name="keywords" content="学习">
<meta property="og:type" content="article">
<meta property="og:title" content="可视化">
<meta property="og:url" content="https://DiamondsZz.github.io/2022/11/26/graph/index.html">
<meta property="og:site_name" content="DiamondsZz">
<meta property="og:description" content="图形基础篇浏览器中实现可视化的四种方式 传统的 HTML+CSS。这种方式通常用来呈现普通的 Web 网页。 SVG 和传统的 HTML+CSS 的绘图方式差别不大。只不过，HTML 元素在绘制矢量图形方面的能力有些不足，而 SVG 恰好弥补了这方面的缺陷。 Canvas2D。这是浏览器提供的 Canvas API 中的其中一种上下文，使用它可以非常方便地绘制出基础的几何图形。在可视化中，Canv">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2022-11-28T14:47:45.447Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="可视化">
<meta name="twitter:description" content="图形基础篇浏览器中实现可视化的四种方式 传统的 HTML+CSS。这种方式通常用来呈现普通的 Web 网页。 SVG 和传统的 HTML+CSS 的绘图方式差别不大。只不过，HTML 元素在绘制矢量图形方面的能力有些不足，而 SVG 恰好弥补了这方面的缺陷。 Canvas2D。这是浏览器提供的 Canvas API 中的其中一种上下文，使用它可以非常方便地绘制出基础的几何图形。在可视化中，Canv">
  
    <link rel="alternative" href="/atom.xml" title="DiamondsZz" type="application/atom+xml">
  
  
  
  <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet">
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: false,
          isPost: true,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        
<script src="https://www.unpkg.com/jquery@3.6.0/dist/jquery.js"></script>

        <a href="/" class="profilepic">
            
            <img lazy-src="/img/iu.jpeg" class="js-avatar">
            
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">DiamondsZz</a></h1>
        </hgroup>
        
        <p class="header-subtitle">DiamondsZz</p>
        
        
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        
        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                        </ul>
                    </nav>
                </section>
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/css/" style="font-size: 12.5px;">css</a> <a href="/tags/js/" style="font-size: 15px;">js</a> <a href="/tags/学习/" style="font-size: 20px;">学习</a> <a href="/tags/生活，心情/" style="font-size: 10px;">生活，心情</a> <a href="/tags/网站/" style="font-size: 17.5px;">网站</a> <a href="/tags/资源/" style="font-size: 17.5px;">资源</a>
                    </div>
                </section>
                
                
                
                
                <section class="switch-part switch-part3">
                
                    <div id="js-aboutme">矮穷矬!</div>
                </section>
                
            </div>
        </div>
    </header>
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">DiamondsZz</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/img/iu.jpeg" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">DiamondsZz</a></h1>
            </hgroup>
            
            <p class="header-subtitle">DiamondsZz</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                </div>
            </nav>
        </header>
    </div>
</nav>
      <div class="body-wrap"><article id="post-graph" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/11/26/graph/" class="article-date">
      <time datetime="2022-11-25T16:00:00.000Z" itemprop="datePublished">2022-11-26</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      可视化
    </h1>
  


      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/学习/">学习</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/学习/">学习</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="图形基础篇"><a href="#图形基础篇" class="headerlink" title="图形基础篇"></a>图形基础篇</h2><h3 id="浏览器中实现可视化的四种方式"><a href="#浏览器中实现可视化的四种方式" class="headerlink" title="浏览器中实现可视化的四种方式"></a>浏览器中实现可视化的四种方式</h3><ol>
<li>传统的 HTML+CSS。这种方式通常用来呈现普通的 Web 网页。</li>
<li>SVG 和传统的 HTML+CSS 的绘图方式差别不大。只不过，HTML 元素在绘制矢量图形方面的能力有些不足，而 SVG 恰好弥补了这方面的缺陷。</li>
<li>Canvas2D。这是浏览器提供的 Canvas API 中的其中一种上下文，使用它可以非常方便地绘制出基础的几何图形。在可视化中，Canvas 比较常用。</li>
<li>WebGL。这是浏览器提供的 Canvas API 中的另一种上下文，它是 OpenGL ES 规范在 Web 端的实现。我们可以通过它，用 GPU 渲染各种复杂的 2D 和 3D 图形。值得一提的是，WebGL 利用了 GPU 并行处理的特性，这让它在处理大量数据展现的时候，性能大大优于前 3 种绘图方式。因此，在可视化的应用中，一些数据量大、视觉效果要求高的特殊场景，使用 WebGL 渲染是一种比较合适的选择。</li>
</ol>
<h4 id="HTML-CSS"><a href="#HTML-CSS" class="headerlink" title="HTML+CSS"></a>HTML+CSS</h4><p>用 CSS 实现柱状图其实很简单，原理就是使用网格布局（Grid Layout）加上线性渐变（Linear-gradient）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">   dataset = &#123;</span><br><span class="line">     current: [15, 11, 17, 25, 37],</span><br><span class="line">     total: [25, 26, 40, 45, 68],</span><br><span class="line">   &#125;</span><br><span class="line"> */</span><br><span class="line">.bargraph &#123;</span><br><span class="line">  display: grid;</span><br><span class="line">  width: 150px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  padding: 10px;</span><br><span class="line">  transform: scaleY(3);</span><br><span class="line">  grid-template-columns: repeat(5, 20%);</span><br><span class="line">&#125;</span><br><span class="line">.bargraph div &#123;</span><br><span class="line">  margin: 0 2px;</span><br><span class="line">&#125;</span><br><span class="line">.bargraph div:nth-child(1) &#123;</span><br><span class="line"> background: linear-gradient(to bottom, transparent 75%, #37c 0, #37c 85%, #3c7 0);</span><br><span class="line">&#125;</span><br><span class="line">.bargraph div:nth-child(2) &#123;</span><br><span class="line"> background: linear-gradient(to bottom, transparent 74%, #37c 0, #37c 89%, #3c7 0);</span><br><span class="line">&#125;</span><br><span class="line">.bargraph div:nth-child(3) &#123;</span><br><span class="line"> background: linear-gradient(to bottom, transparent 60%, #37c 0, #37c 83%, #3c7 0);</span><br><span class="line">&#125;</span><br><span class="line">.bargraph div:nth-child(4) &#123;</span><br><span class="line"> background: linear-gradient(to bottom, transparent 55%, #37c 0, #37c 75%, #3c7 0);</span><br><span class="line">&#125;</span><br><span class="line">.bargraph div:nth-child(5) &#123;</span><br><span class="line"> background: linear-gradient(to bottom, transparent 32%, #37c 0, #37c 63%, #3c7 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而要实现饼图，我们可以使用圆锥渐变</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.piegraph &#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  width: 250px;</span><br><span class="line">  height: 250px;</span><br><span class="line">  border-radius: 50%;</span><br><span class="line">  background-image: conic-gradient(#37c 30deg, #3c7 30deg, #3c7 65deg, orange 65deg, orange 110deg, #f73 110deg, #f73 200deg, #ccc 200deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以用高度很小的 Div 元素来模拟线段，然后用 transform 改变角度和位置，这样就能拼成折线图了。 另外，如果使用 clip-path 这样的高级属性，我们还能实现更复杂的图表，比如，用不同的颜色表示两个不同折线的面积。</p>
<p>用 HTML+CSS 实现可视化的缺点:</p>
<p>首先，HTML 和 CSS 主要还是为网页布局而创造的，使用它们虽然能绘制可视化图表，但是绘制的方式并不简洁。这是因为，从 CSS 代码里，我们很难看出数据与图形的对应关系，有很多换算也需要开发人员自己来做。这样一来，一旦图表或数据发生改动，就需要我们重新计算，维护起来会很麻烦。</p>
<p>其次，HTML 和 CSS 作为浏览器渲染引擎的一部分，为了完成页面渲染的工作，除了绘制图形外，还要做很多额外的工作。比如说，浏览器的渲染引擎在工作时，要先解析 HTML、SVG、CSS，构建 DOM 树、RenderObject 树和 RenderLayer 树，然后用 HTML（或 SVG）绘图。当图形发生变化时，我们很可能要重新执行全部的工作，这样的性能开销是非常大的。</p>
<p>因此，相比于 HTML 和 CSS，Canvas2D 和 WebGL 更适合去做可视化这一领域的绘图工作。它们的绘图 API 能够直接操作绘图上下文，一般不涉及引擎的其他部分，在重绘图像时，也不会发生重新解析文档和构建结构的过程，开销要小很多。</p>
<h4 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h4><p>在介绍 Canvas2D 和 WebGL 之前，我们先来说一说 SVG。现代浏览器支持 SVG（Scalable Vector Graphics，可缩放矢量图），SVG 是一种基于 XML 语法的图像格式，可以用图片（img 元素）的 src 属性加载。而且，浏览器更强大的是，它还可以内嵌 SVG 标签，并且像操作普通的 HTML 元素一样，利用 DOM API 操作 SVG 元素。甚至，CSS 也可以作用于内嵌的 SVG 元素。</p>
<p>比如，上面的柱状图，如果用 SVG 实现的话，我们可以用如下所示的代码来实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!--</span><br><span class="line">     dataset = &#123;</span><br><span class="line">       total: [25, 26, 40, 45, 68],</span><br><span class="line">       current: [15, 11, 17, 25, 37],</span><br><span class="line">     &#125;</span><br><span class="line"> --&gt;</span><br><span class="line"> &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;120px&quot; height=&quot;240px&quot; viewBox=&quot;0 0 60 100&quot;&gt;</span><br><span class="line">   &lt;g transform=&quot;translate(0, 100) scale(1, -1)&quot;&gt;</span><br><span class="line">     &lt;g&gt;</span><br><span class="line">       &lt;rect x=&quot;1&quot; y=&quot;0&quot; width=&quot;10&quot; height=&quot;25&quot; fill=&quot;#37c&quot;/&gt;</span><br><span class="line">       &lt;rect x=&quot;13&quot; y=&quot;0&quot; width=&quot;10&quot; height=&quot;26&quot; fill=&quot;#37c&quot;/&gt;</span><br><span class="line">       &lt;rect x=&quot;25&quot; y=&quot;0&quot; width=&quot;10&quot; height=&quot;40&quot; fill=&quot;#37c&quot;/&gt;</span><br><span class="line">       &lt;rect x=&quot;37&quot; y=&quot;0&quot; width=&quot;10&quot; height=&quot;45&quot; fill=&quot;#37c&quot;/&gt;</span><br><span class="line">       &lt;rect x=&quot;49&quot; y=&quot;0&quot; width=&quot;10&quot; height=&quot;68&quot; fill=&quot;#37c&quot;/&gt;</span><br><span class="line">     &lt;/g&gt;</span><br><span class="line">     &lt;g&gt;</span><br><span class="line">       &lt;rect x=&quot;1&quot; y=&quot;0&quot; width=&quot;10&quot; height=&quot;15&quot; fill=&quot;#3c7&quot;/&gt;</span><br><span class="line">       &lt;rect x=&quot;13&quot; y=&quot;0&quot; width=&quot;10&quot; height=&quot;11&quot; fill=&quot;#3c7&quot;/&gt;</span><br><span class="line">       &lt;rect x=&quot;25&quot; y=&quot;0&quot; width=&quot;10&quot; height=&quot;17&quot; fill=&quot;#3c7&quot;/&gt;</span><br><span class="line">       &lt;rect x=&quot;37&quot; y=&quot;0&quot; width=&quot;10&quot; height=&quot;25&quot; fill=&quot;#3c7&quot;/&gt;</span><br><span class="line">       &lt;rect x=&quot;49&quot; y=&quot;0&quot; width=&quot;10&quot; height=&quot;37&quot; fill=&quot;#3c7&quot;/&gt;</span><br><span class="line">     &lt;/g&gt;</span><br><span class="line">   &lt;/g&gt;</span><br><span class="line"> &lt;/svg&gt;</span><br></pre></td></tr></table></figure>
<p>HTML 的不足之处在于 HTML 元素的形状一般是矩形，虽然用 CSS 辅助，也能够绘制出各种其它形状的图形，甚至不规则图形，但是总体而言还是非常麻烦的。而 SVG 则弥补了这方面的不足，让不规则图形的绘制变得更简单了。因此，用 SVG 绘图比用 HTML 和 CSS 要便利得多。</p>
<p>但是，SVG 图表也有缺点。在渲染引擎中，SVG 元素和 HTML 元素一样，在输出图形前都需要经过引擎的解析、布局计算和渲染树生成。而且，一个 SVG 元素只表示一种基本图形，如果展示的数据很复杂，生成图形的 SVG 元素就会很多。这样一来，大量的 SVG 元素不仅会占用很多内存空间，还会增加引擎、布局计算和渲染树生成的开销，降低性能，减慢渲染速度。这也就注定了 SVG 只适合应用于元素较少的简单可视化场景。</p>
<h4 id="Canvas2D"><a href="#Canvas2D" class="headerlink" title="Canvas2D"></a>Canvas2D</h4><p>无论是使用 HTML/CSS 还是 SVG，它们都属于声明式绘图系统，也就是我们根据数据创建各种不同的图形元素（或者 CSS 规则），然后利用浏览器渲染引擎解析它们并渲染出来。但是 Canvas2D 不同，它是浏览器提供的一种可以直接用代码在一块平面的“画布”上绘制图形的 API，使用它来绘图更像是传统的“编写代码”，简单来说就是调用绘图指令，然后引擎直接在页面上绘制图形。这是一种指令式的绘图系统。</p>
<p>那 Canvas 到底是怎么绘制可视化图表的呢？我们一起来看。</p>
<p>首先，Canvas 元素在浏览器上创造一个空白的画布，通过提供渲染上下文，赋予我们绘制内容的能力。然后，我们只需要调用渲染上下文，设置各种属性，然后调用绘图指令完成输出，就能在画布上呈现各种各样的图形了。</p>
<p>为了实现更加复杂的效果，Canvas 还提供了非常丰富的设置和绘图 API，我们可以通过操作上下文，来改变填充和描边颜色，对画布进行几何变换，调用各种绘图指令，然后将绘制的图形输出到画布上。</p>
<p>总结来说，Canvas 能够直接操作绘图上下文，不需要经过 HTML、CSS 解析、构建渲染树、布局等一系列操作。因此单纯绘图的话，Canvas 比 HTML/CSS 和 SVG 要快得多。</p>
<p>但是，因为 HTML 和 SVG 一个元素对应一个基本图形，所以我们可以很方便地操作它们，比如在柱状图的某个柱子上注册点击事件。而同样的功能在 Canvas 上就比较难实现了，因为对于 Canvas 来说，绘制整个柱状图的过程就是一系列指令的执行过程，其中并没有区分“A 柱子”、“B 柱子”，这让我们很难单独对 Canvas 绘图的局部进行控制。不过，这并不代表我们就不能控制 Canvas 的局部了。实际上，通过数学计算我们是可以通过定位的方式来获取局部图形的，在后续的课程中我们会解决这个问题。</p>
<p>这里有一点需要你注意，Canvas 和 SVG 的使用也不是非此即彼的，它们可以结合使用。因为 SVG 作为一种图形格式，也可以作为 image 元素绘制到 Canvas 中。举个例子，我们可以先使用 SVG 生成某些图形，然后用 Canvas 来渲染。这样，我们就既可以享受 SVG 的便利性，又可以享受 Canvas 的高性能了。</p>
<h4 id="WebGL"><a href="#WebGL" class="headerlink" title="WebGL"></a>WebGL</h4><p>一般情况下，Canvas2D 绘制图形的性能已经足够高了，但是在三种情况下我们有必要直接操作更强大的 GPU 来实现绘图。</p>
<p>第一种情况，如果我们要绘制的图形数量非常多，比如有多达数万个几何图形需要绘制，而且它们的位置和方向都在不停地变化，那我们即使用 Canvas2D 绘制了，性能还是会达到瓶颈。这个时候，我们就需要使用 GPU 能力，直接用 WebGL 来绘制。</p>
<p>第二种情况，如果我们要对较大图像的细节做像素处理，比如，实现物体的光影、流体效果和一些复杂的像素滤镜。由于这些效果往往要精准地改变一个图像全局或局部区域的所有像素点，要计算的像素点数量非常的多（一般是数十万甚至上百万数量级的）。这时，即使采用 Canvas2D 操作，也会达到性能瓶颈，所以我们也要用 WebGL 来绘制。</p>
<p>第三种情况是绘制 3D 物体。因为 WebGL 内置了对 3D 物体的投影、深度检测等特性，所以用它来渲染 3D 物体就不需要我们自己对坐标做底层的处理了。那在这种情况下，WebGL 无论是在使用上还是性能上都有很大优势。</p>
<h3 id="指令式绘图系统：如何用Canvas绘制层次关系图？"><a href="#指令式绘图系统：如何用Canvas绘制层次关系图？" class="headerlink" title="指令式绘图系统：如何用Canvas绘制层次关系图？"></a>指令式绘图系统：如何用Canvas绘制层次关系图？</h3><h4 id="Canvas-元素和-2D-上下文"><a href="#Canvas-元素和-2D-上下文" class="headerlink" title="Canvas 元素和 2D 上下文"></a>Canvas 元素和 2D 上下文</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;canvas width=&quot;512&quot; height=&quot;512&quot;&gt;&lt;/canvas&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<p>这里有一点需要特别注意，Canvas 元素上的 width 和 height 属性不等同于 Canvas 元素的 CSS 样式的属性。这是因为，CSS 属性中的宽高影响 Canvas 在页面上呈现的大小，而 HTML 属性中的宽高则决定了 Canvas 的坐标系。为了区分它们，我们称 Canvas 的 HTML 属性宽高为画布宽高，CSS 样式宽高为样式宽高。</p>
<p>在实际绘制的时候，如果我们不设置 Canvas 元素的样式，那么 Canvas 元素的画布宽高就会等于它的样式宽高的像素值，也就是 512px。</p>
<p>而如果这个时候，我们通过 CSS 设置其他的值指定了它的样式宽高。比如说，我们将样式宽高设置成 256px，那么它实际的画布宽高就是样式宽高的两倍了。代码和效果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">canvas &#123;</span><br><span class="line">  width: 256px;</span><br><span class="line">  height: 256px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为画布宽高决定了可视区域的坐标范围，所以 Canvas 将画布宽高和样式宽高分开的做法，能更方便地适配不同的显示设备。</p>
<p>比如，我们要在画布宽高为 <code>500*500</code>的Canvas画布上，绘制一个居中显示的<code>100*100</code> 宽高的正方形。我们只要将它的坐标设置在  x = 200, y = 200 处即可。这样，不论这个 Canvas 以多大的尺寸显示在各种设备上，我们的代码都不需要修改。否则，如果 Canvas 的坐标范围（画布宽高）跟着样式宽高变化，那么当屏幕尺寸改变的时候，我们就要重新计算需要绘制的图形的所有坐标，这对于我们来说将会是一场“灾难”。</p>
<h4 id="Canvas-的坐标系"><a href="#Canvas-的坐标系" class="headerlink" title="Canvas 的坐标系"></a>Canvas 的坐标系</h4><p>Canvas 的坐标系和浏览器窗口的坐标系类似，它们都默认左上角为坐标原点，x 轴水平向右，y 轴垂直向下。那在我们设置好的画布宽高为 512*512 的 Canvas 画布中，它的左上角坐标值为（0,0），右下角坐标值为（512,512） 。这意味着，坐标（0,0）到（512,512）之间的所有图形，都会被浏览器渲染到画布上。</p>
<p>注意，上图中这个坐标系的 y 轴向下，意味着这个坐标系和笛卡尔坐标系不同，它们的 y 轴是相反的。那在实际应用的时候，如果我们想绘制一个向右上平抛小球的动画，它的抛物线轨迹，在 Canvas 上绘制出来的方向就是向下凹的。</p>
<h4 id="利用-Canvas-绘制几何图形"><a href="#利用-Canvas-绘制几何图形" class="headerlink" title="利用 Canvas 绘制几何图形"></a>利用 Canvas 绘制几何图形</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">d3-hierarchy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const TAU = 2 * Math.PI;</span><br><span class="line"></span><br><span class="line">function draw(ctx, node, &#123;fillStyle = &apos;rgba(0, 0, 0, 0.2)&apos;, textColor = &apos;white&apos;&#125; = &#123;&#125;) &#123;</span><br><span class="line">  const children = node.children;</span><br><span class="line">  const &#123;x, y, r&#125; = node;</span><br><span class="line">  ctx.fillStyle = fillStyle;</span><br><span class="line">  ctx.beginPath();</span><br><span class="line">  ctx.arc(x, y, r, 0, TAU);</span><br><span class="line">  ctx.fill();</span><br><span class="line">  if(children) &#123;</span><br><span class="line">    for(let i = 0; i &lt; children.length; i++) &#123;</span><br><span class="line">      draw(ctx, children[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    const name = node.data.name;</span><br><span class="line">    ctx.fillStyle = textColor;</span><br><span class="line">    ctx.font = &apos;1.5rem Arial&apos;;</span><br><span class="line">    ctx.textAlign = &apos;center&apos;;</span><br><span class="line">    ctx.fillText(name, x, y);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">draw(context, root);</span><br></pre></td></tr></table></figure>
<p>因为 Canvas 在 HTML 层面上是一个独立的画布元素，所以所有的绘制内容都是在内部通过绘图指令来完成的，绘制出的图形对于浏览器来说，只是 Canvas 中的一个个像素点，我们很难直接抽取其中的图形对象进行操作。</p>
<h3 id="声明式图形系统：如何用SVG图形元素绘制可视化图表？"><a href="#声明式图形系统：如何用SVG图形元素绘制可视化图表？" class="headerlink" title="声明式图形系统：如何用SVG图形元素绘制可视化图表？"></a>声明式图形系统：如何用SVG图形元素绘制可视化图表？</h3><h4 id="利用-SVG-绘制几何图形"><a href="#利用-SVG-绘制几何图形" class="headerlink" title="利用 SVG 绘制几何图形"></a>利用 SVG 绘制几何图形</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt;</span><br><span class="line">  &lt;circle cx=&quot;100&quot; cy=&quot;50&quot; r=&quot;40&quot; stroke=&quot;black&quot;</span><br><span class="line">  stroke-width=&quot;2&quot; fill=&quot;orange&quot; /&gt;</span><br><span class="line">&lt;/svg&gt;</span><br></pre></td></tr></table></figure>
<p>svg 元素是 SVG 的根元素，属性 xmlns 是 xml 的名字空间。那第一行代码就表示，svg 元素的 xmlns 属性值是”<a href="http://www.w3.org/2000/svg&quot;，浏览器根据这个属性值就能够识别出这是一段" target="_blank" rel="noopener">http://www.w3.org/2000/svg&quot;，浏览器根据这个属性值就能够识别出这是一段</a> SVG 的内容了。</p>
<p>svg 元素下的 circle 元素表示这是一个绘制在 SVG 图像中的圆形，属性 cx 和 cy 是坐标，表示圆心的位置在图像的 x=100、y=50 处。属性 r 表示半径，r=40 表示圆的半径为 40。</p>
<h4 id="利用-SVG-绘制层次关系图"><a href="#利用-SVG-绘制层次关系图" class="headerlink" title="利用 SVG 绘制层次关系图"></a>利用 SVG 绘制层次关系图</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">const svgroot = document.querySelector(&apos;svg&apos;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function draw(parent, node, &#123;fillStyle = &apos;rgba(0, 0, 0, 0.2)&apos;, textColor = &apos;white&apos;&#125; = &#123;&#125;) &#123;</span><br><span class="line">    const &#123;x, y, r&#125; = node;</span><br><span class="line">    const circle = document.createElementNS(&apos;http://www.w3.org/2000/svg&apos;, &apos;circle&apos;);</span><br><span class="line">    circle.setAttribute(&apos;cx&apos;, x);</span><br><span class="line">    circle.setAttribute(&apos;cy&apos;, y);</span><br><span class="line">    circle.setAttribute(&apos;r&apos;, r);</span><br><span class="line">    circle.setAttribute(&apos;fill&apos;, fillStyle);</span><br><span class="line">    parent.appendChild(circle);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">draw(svgroot, root);</span><br></pre></td></tr></table></figure>
<h4 id="SVG-和-Canvas-的不同点"><a href="#SVG-和-Canvas-的不同点" class="headerlink" title="SVG 和 Canvas 的不同点"></a>SVG 和 Canvas 的不同点</h4><p>SVG 和 Canvas 在使用上的不同主要可以分为两点，分别是写法上的不同和用户交互实现上的不同。</p>
<ol>
<li><p>在绘制层次关系图的过程中，SVG 首先通过创建标签来表示图形元素，circle 表示圆，g 表示分组，text 表示文字。接着，SVG 通过元素的 setAttribute 给图形元素赋属性值，这个和操作 HTML 元素是一样的。而 Canvas 先是通过上下文执行绘图指令来绘制图形，画圆是调用 context.arc 指令，然后再调用 context.fill 绘制，画文字是调用 context.fillText 指令。另外，Canvas 还通过上下文设置状态属性，context.fillStyle 设置填充颜色，conext.font 设置元素的字体。我们设置的这些状态，在绘图指令执行时才会生效。从写法上来看，因为 SVG 的声明式类似于 HTML 书写方式，本身对前端工程师会更加友好。但是，SVG 图形需要由浏览器负责渲染和管理，将元素节点维护在 DOM 树中。这样做的缺点是，在一些动态的场景中，也就是需要频繁地增加、删除图形元素的场景中，SVG 与一般的 HTML 元素一样会带来 DOM 操作的开销，所以 SVG 的渲染性能相对比较低。</p>
</li>
<li><p>利用 SVG 的一个图形对应一个 svg 元素的机制，我们就可以像操作普通的 HTML 元素那样，给 svg 元素添加事件实现用户交互了。所以，SVG 有一个非常大的优点，那就是可以让图形的用户交互非常简单。和 SVG 相比，利用 Canvas 对图形元素进行用户交互就没有那么容易了。不过，对于圆形的层次关系图来说，在 Canvas 图形上定位鼠标处于哪个圆中并不难，我们只需要计算一下鼠标到每个圆的圆心距离，如果这个距离小于圆的半径，我们就可以确定鼠标在某个圆内部了。</p>
</li>
</ol>
<h4 id="绘制大量几何图形时-SVG-的性能问题"><a href="#绘制大量几何图形时-SVG-的性能问题" class="headerlink" title="绘制大量几何图形时 SVG 的性能问题"></a>绘制大量几何图形时 SVG 的性能问题</h4><p>在绘制如上的层次关系图时，我们只需要绘制数十个节点。但是如果是更复杂的应用，比如我们要绘制数百上千甚至上万个节点，这个时候，DOM 树渲染就会成为性能瓶颈。事实上，在一般情况下，当 SVG 节点超过一千个的时候，你就能很明显感觉到性能问题了。</p>
<p>幸运的是，对于 SVG 的性能问题，我们也是有解决方案的。比如说，我们可以使用虚拟 DOM 方案来尽可能地减少重绘，这样就可以优化 SVG 的渲染。但是这些方案只能解决一部分问题，当节点数太多时，这些方案也无能为力。这个时候，我们还是得依靠 Canvas 和 WebGL 来绘图，才能彻底解决问题。</p>
<p>那在上万个节点的可视化应用场景中，SVG 就真的一无是处了吗？当然不是。SVG 除了嵌入 HTML 文档的用法，还可以直接作为一种图像格式使用。所以，即使是在用 Canvas 和 WebGL 渲染的应用场景中，我们也依然可能会用到 SVG，将它作为一些局部的图形使用，这也会给我们的应用实现带来方便。</p>
<h3 id="GPU与渲染管线：如何用WebGL绘制最简单的几何图形？"><a href="#GPU与渲染管线：如何用WebGL绘制最简单的几何图形？" class="headerlink" title="GPU与渲染管线：如何用WebGL绘制最简单的几何图形？"></a>GPU与渲染管线：如何用WebGL绘制最简单的几何图形？</h3><h4 id="图形系统是如何绘图的？"><a href="#图形系统是如何绘图的？" class="headerlink" title="图形系统是如何绘图的？"></a>图形系统是如何绘图的？</h4><p>一个通用计算机图形系统主要包括 6 个部分，分别是输入设备、中央处理单元、图形处理单元、存储器、帧缓存和输出设备。</p>
<ol>
<li>光栅（Raster）：几乎所有的现代图形系统都是基于光栅来绘制图形的，光栅就是指构成图像的像素阵列。</li>
<li>像素（Pixel）：一个像素对应图像上的一个点，它通常保存图像上的某个具体位置的颜色等信息。</li>
<li>帧缓存（Frame Buffer）：在绘图过程中，像素信息被存放于帧缓存中，帧缓存是一块内存地址。</li>
<li>CPU（Central Processing Unit）：中央处理单元，负责逻辑计算。</li>
<li>GPU（Graphics Processing Unit）：图形处理单元，负责图形计算。</li>
</ol>
<p>来看一个典型的绘图过程，帮你来明晰一下这些概念的实际用途。</p>
<p>首先，数据经过 CPU 处理，成为具有特定结构的几何信息。然后，这些信息会被送到 GPU 中进行处理。在 GPU 中要经过两个步骤生成光栅信息。这些光栅信息会输出到帧缓存中，最后渲染到屏幕上。</p>
<p>主要做了两件事，一是对给定的数据结合绘图的场景要素（例如相机、光源、遮挡物体等等）进行计算，最终将图形变为屏幕空间的 2D 坐标。二是为屏幕空间的每个像素点进行着色，把最终完成的图形输出到显示设备上。这整个过程是一步一步进行的，前一步的输出就是后一步的输入，所以我们也把这个过程叫做渲染管线（RenderPipelines）。</p>
<h4 id="GPU-是什么？"><a href="#GPU-是什么？" class="headerlink" title="GPU 是什么？"></a>GPU 是什么？</h4><p>CPU 和 GPU 都属于处理单元，但是结构不同。形象点来说，CPU 就像个大的工业管道，等待处理的任务就像是依次通过这个管道的货物。一条 CPU 流水线串行处理这些任务的速度，取决于 CPU（管道）的处理能力。</p>
<p>实际上，一个计算机系统会有很多条 CPU 流水线，而且任何一个任务都可以随机地通过任意一个流水线，这样计算机就能够并行处理多个任务了。这样的一条流水线就是我们常说的线程（Thread）。</p>
<p>这样的结构用来处理大型任务是足够的，但是要处理图像应用就不太合适了。这是因为，处理图像应用，实际上就是在处理计算图片上的每一个像素点的颜色和其他信息。每处理一个像素点就相当于完成了一个简单的任务，而一个图片应用又是由成千上万个像素点组成的，所以，我们需要在同一时间处理成千上万个小任务。</p>
<p>要处理这么多的小任务，比起使用若干个强大的 CPU，使用更小、更多的处理单元，是一种更好的处理方式。而 GPU 就是这样的处理单元。</p>
<p>GPU 是由大量的小型处理单元构成的，它可能远远没有 CPU 那么强大，但胜在数量众多，可以保证每个单元处理一个简单的任务。即使我们要处理一张 800 * 600 大小的图片，GPU 也可以保证这 48 万个像素点分别对应一个小单元，这样我们就可以同时对每个像素点进行计算了。</p>
<h4 id="如何用-WebGL-绘制三角形？"><a href="#如何用-WebGL-绘制三角形？" class="headerlink" title="如何用 WebGL 绘制三角形？"></a>如何用 WebGL 绘制三角形？</h4><p>浏览器提供的 WebGL API 是 OpenGL ES 的 JavaScript 绑定版本，它赋予了开发者操作 GPU 的能力。这一特点也让 WebGL 的绘图方式和其他图形系统的“开箱即用”（直接调用绘图指令或者创建图形元素就可以完成绘图）的绘图方式完全不同，甚至要复杂得多。我们可以总结为以下 5 个步骤：</p>
<ol>
<li>创建 WebGL 上下文</li>
<li>创建 WebGL 程序（WebGL Program）</li>
<li>将数据存入缓冲区</li>
<li>将缓冲区数据读取到 GPU</li>
<li>GPU 执行 WebGL 程序，输出结果</li>
</ol>
<h5 id="步骤一：创建-WebGL-上下文"><a href="#步骤一：创建-WebGL-上下文" class="headerlink" title="步骤一：创建 WebGL 上下文"></a>步骤一：创建 WebGL 上下文</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const canvas = document.querySelector(&apos;canvas&apos;);</span><br><span class="line">const gl = canvas.getContext(&apos;webgl&apos;);</span><br></pre></td></tr></table></figure>
<h5 id="步骤二：创建-WebGL-程序"><a href="#步骤二：创建-WebGL-程序" class="headerlink" title="步骤二：创建 WebGL 程序"></a>步骤二：创建 WebGL 程序</h5><p>接下来，我们要创建一个 WebGL 程序。你可能会觉得奇怪，我们不是正在写一个绘制三角形的程序吗？为什么这里又要创建一个 WebGL 程序呢？实际上，这里的 WebGL 程序是一个 WebGLProgram 对象，它是给 GPU 最终运行着色器的程序，而不是我们正在写的三角形的 JavaScript 程序。好了，解决了这个疑问，我们就正式开始创建一个 WebGL 程序吧！</p>
<p>首先，要创建这个 WebGL 程序，我们需要编写两个着色器（Shader）。着色器是用 GLSL 这种编程语言编写的代码片段，这里我们先不用过多纠结于 GLSL 语言，在后续的课程中我们会详细讲解。那在这里，我们只需要理解绘制三角形的这两个着色器的作用就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">const vertex = `</span><br><span class="line">  attribute vec2 position;</span><br><span class="line"></span><br><span class="line">  void main() &#123;</span><br><span class="line">    gl_PointSize = 1.0;</span><br><span class="line">    gl_Position = vec4(position, 1.0, 1.0);</span><br><span class="line">  &#125;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const fragment = `</span><br><span class="line">  precision mediump float;</span><br><span class="line"></span><br><span class="line">  void main()</span><br><span class="line">  &#123;</span><br><span class="line">    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);</span><br><span class="line">  &#125;    </span><br><span class="line">`;</span><br></pre></td></tr></table></figure>
<p>那我们为什么要创建两个着色器呢？这就需要我们先来理解顶点和图元这两个基本概念了。在绘图的时候，WebGL 是以顶点和图元来描述图形几何信息的。顶点就是几何图形的顶点，比如，三角形有三个顶点，四边形有四个顶点。图元是 WebGL 可直接处理的图形单元，由 WebGL 的绘图模式决定，有点、线、三角形等等。</p>
<p>所以，顶点和图元是绘图过程中必不可少的。因此，WebGL 绘制一个图形的过程，一般需要用到两段着色器，一段叫顶点着色器（Vertex Shader）负责处理图形的顶点信息，另一段叫片元着色器（Fragment Shader）负责处理图形的像素信息。</p>
<p>更具体点来说，我们可以把顶点着色器理解为处理顶点的 GPU 程序代码。它可以改变顶点的信息（如顶点的坐标、法线方向、材质等等），从而改变我们绘制出来的图形的形状或者大小等等。</p>
<p>顶点处理完成之后，WebGL 就会根据顶点和绘图模式指定的图元，计算出需要着色的像素点，然后对它们执行片元着色器程序。简单来说，就是对指定图元中的像素点着色。</p>
<p>WebGL 从顶点着色器和图元提取像素点给片元着色器执行代码的过程，就是我们前面说的生成光栅信息的过程，我们也叫它光栅化过程。所以，片元着色器的作用，就是处理光栅化后的像素信息。</p>
<p>这么说可能比较抽象，我 来举个例子。我们可以将图元设为线段，那么片元着色器就会处理顶点之间的线段上的像素点信息，这样画出来的图形就是空心的。而如果我们把图元设为三角形，那么片元着色器就会处理三角形内部的所有像素点，这样画出来的图形就是实心的。</p>
<p>这里你要注意一点，因为图元是 WebGL 可以直接处理的图形单元，所以其他非图元的图形最终必须要转换为图元才可以被 WebGL 处理。举个例子，如果我们要绘制实心的四边形，我们就需要将四边形拆分成两个三角形，再交给 WebGL 分别绘制出来。</p>
<p>好了，那让我们回到片元着色器对像素点着色的过程。你还要注意，这个过程是并行的。也就是说，无论有多少个像素点，片元着色器都可以同时处理。这也是片元着色器一大特点。</p>
<p>首先，因为在 JavaScript 中，顶点着色器和片元着色器只是一段代码片段，所以我们要将它们分别创建成 shader 对象。代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const vertexShader = gl.createShader(gl.VERTEX_SHADER);</span><br><span class="line">gl.shaderSource(vertexShader, vertex);</span><br><span class="line">gl.compileShader(vertexShader);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);</span><br><span class="line">gl.shaderSource(fragmentShader, fragment);</span><br><span class="line">gl.compileShader(fragmentShader);</span><br></pre></td></tr></table></figure>
<p>接着，我们创建 WebGLProgram 对象，并将这两个 shader 关联到这个 WebGL 程序上。WebGLProgram 对象的创建过程主要是添加 vertexShader 和 fragmentShader，然后将这个 WebGLProgram 对象链接到 WebGL 上下文对象上。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const program = gl.createProgram();</span><br><span class="line">gl.attachShader(program, vertexShader);</span><br><span class="line">gl.attachShader(program, fragmentShader);</span><br><span class="line">gl.linkProgram(program);</span><br></pre></td></tr></table></figure>
<p>最后，我们要通过 useProgram 选择启用这个 WebGLProgram 对象。这样，当我们绘制图形时，GPU 就会执行我们通过 WebGLProgram 设定的 两个 shader 程序了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">gl.useProgram(program);</span><br></pre></td></tr></table></figure>
<h5 id="步骤三：将数据存入缓冲区"><a href="#步骤三：将数据存入缓冲区" class="headerlink" title="步骤三：将数据存入缓冲区"></a>步骤三：将数据存入缓冲区</h5><p>我们要知道 WebGL 的坐标系是一个三维空间坐标系，坐标原点是（0,0,0）。其中，x 轴朝右，y 轴朝上，z 轴朝外。</p>
<p>假设，我们要在这个坐标系上显示一个顶点坐标分别是（-1, -1）、（1, -1）、（0, 1）的三角形。</p>
<p>首先，我们要定义这个三角形的三个顶点。WebGL 使用的数据需要用类型数组定义，默认格式是 Float32Array。Float32Array 是 JavaScript 的一种类型化数组（TypedArray），JavaScript 通常用类型化数组来处理二进制缓冲区。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const points = new Float32Array([</span><br><span class="line">  -1, -1,</span><br><span class="line">  0, 1,</span><br><span class="line">  1, -1,</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>
<p>接着，我们要将定义好的数据写入 WebGL 的缓冲区。这个过程我们可以简单总结为三步，分别是创建一个缓存对象，将它绑定为当前操作对象，再把当前的数据写入缓存对象。这三个步骤主要是利用 createBuffer、bindBuffer、bufferData 方法来实现的，过程很简单你可以看一下我下面给出的实现代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">const bufferId = gl.createBuffer();</span><br><span class="line">gl.bindBuffer(gl.ARRAY_BUFFER, bufferId);</span><br><span class="line">gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);</span><br></pre></td></tr></table></figure>
<h5 id="步骤四：将缓冲区数据读取到-GPU"><a href="#步骤四：将缓冲区数据读取到-GPU" class="headerlink" title="步骤四：将缓冲区数据读取到 GPU"></a>步骤四：将缓冲区数据读取到 GPU</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">attribute vec2 position;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  gl_PointSize = 1.0;</span><br><span class="line">  gl_Position = vec4(position, 1.0, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 GLSL 中，attribute 表示声明变量，vec2 是变量的类型，它表示一个二维向量，position 是变量名。接下来我们将 buffer 的数据绑定给顶点着色器的 position 变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const vPosition = gl.getAttribLocation(program, &apos;position&apos;);获取顶点着色器中的position变量的地址</span><br><span class="line">gl.vertexAttribPointer(vPosition, 2, gl.FLOAT, false, 0, 0);给变量设置长度和类型</span><br><span class="line">gl.enableVertexAttribArray(vPosition);激活这个变量</span><br></pre></td></tr></table></figure>
<h5 id="步骤五：执行着色器程序完成绘制"><a href="#步骤五：执行着色器程序完成绘制" class="headerlink" title="步骤五：执行着色器程序完成绘制"></a>步骤五：执行着色器程序完成绘制</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">gl.clear(gl.COLOR_BUFFER_BIT);</span><br><span class="line">gl.drawArrays(gl.TRIANGLES, 0, points.length / 2);</span><br></pre></td></tr></table></figure>
<p>在片元着色器里，我们可以通过设置 gl_FragColor 的值来定义和改变图形的颜色。gl_FragColor 是 WebGL 片元着色器的内置变量，表示当前像素点颜色，它是一个用 RGBA 色值表示的四维向量数据。在上面的代码中，因为我们写入 vec4(1.0, 0.0, 0.0, 1.0) 对应的是红色，所以三角形是红色的。如果我们把这个值改成 vec4(0.0, 0.0, 1.0, 1.0)，那三角形就是蓝色。</p>
<p>我们要记住，不论这个三角形是大还是小，有几十个像素点还是上百万个像素点，GPU 都是同时处理每个像素点的。也就是说，图形中有多少个像素点，着色器程序在 GPU 中就会被同时执行多少次。</p>
<h4 id="顶点着色器的作用"><a href="#顶点着色器的作用" class="headerlink" title="顶点着色器的作用"></a>顶点着色器的作用</h4><p>顶点着色器大体上可以总结为两个作用：一是通过 gl_Position 设置顶点，二是通过定义 varying 变量，向片元着色器传递数据。这么说还是有点抽象，我们还是通过三角形的例子来具体理解一下。</p>
<h5 id="通过-gl-Position-设置顶点"><a href="#通过-gl-Position-设置顶点" class="headerlink" title="通过 gl_Position 设置顶点"></a>通过 gl_Position 设置顶点</h5><p>假如，我想把三角形的周长缩小为原始大小的一半，有两种处理方式法：一种是修改 points 数组的值，另一种做法是直接对顶点着色器数据进行处理。</p>
<p>我们不需要修改 points 数据，只需要在顶点着色器中，将 gl_Position = vec4(position, 1.0, 1.0); 修改为 gl_Position = vec4(position * 0.5, 1.0, 1.0);，代码如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">attribute vec2 position;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  gl_PointSize = 1.0;</span><br><span class="line">  gl_Position = vec4(position * 0.5, 1.0, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，三角形的周长就缩小为原来的一半了。在这个过程中，我们不需要遍历三角形的每一个顶点，只需要是利用 GPU 的并行特性，在顶点着色器中同时计算所有的顶点就可以了。</p>
<h5 id="向片元着色器传递数据"><a href="#向片元着色器传递数据" class="headerlink" title="向片元着色器传递数据"></a>向片元着色器传递数据</h5><p>除了计算顶点之外，顶点着色器还可以将数据通过 varying 变量传给片元着色器。然后，这些值会根据片元着色器的像素坐标与顶点像素坐标的相对位置做线性插值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">attribute vec2 position;</span><br><span class="line">varying vec3 color;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  gl_PointSize = 1.0;</span><br><span class="line">  color = vec3(0.5 + position * 0.5, 0.0);</span><br><span class="line">  gl_Position = vec4(position * 0.5, 1.0, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段代码中，我们修改了顶点着色器，定义了一个 color 变量，它是一个三维的向量。我们通过数学技巧将顶点的值映射为一个 RGB 颜色值</p>
<p>这样一来，顶点[-1,-1]被映射为[0,0,0]也就是黑色，顶点[0,1]被映射为[0.5, 1, 0]也就是浅绿色，顶点[1,-1]被映射为[1,0,0]也就是红色。这样一来，三个顶点就会有三个不同的颜色值。</p>
<p>然后我们将 color 通过 varying 变量传给片元着色器。片元着色器中的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">precision mediump float;</span><br><span class="line">varying vec3 color;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">  gl_FragColor = vec4(color, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，这个三角形是一个颜色均匀（线性）渐变的三角形，它的三个顶点的色值就是我们通过顶点着色器来设置的。而且你会发现，中间像素点的颜色是均匀过渡的。这就是因为 WebGL 在执行片元着色器程序的时候，顶点着色器传给片元着色器的变量，会根据片元着色器的像素坐标对变量进行线性插值。利用线性插值可以让像素点的颜色均匀渐变这一特点，我们就能绘制出颜色更丰富的图形了。</p>
<h2 id="数学篇"><a href="#数学篇" class="headerlink" title="数学篇"></a>数学篇</h2><p>令人头秃…</p>
<h2 id="视觉基础篇"><a href="#视觉基础篇" class="headerlink" title="视觉基础篇"></a>视觉基础篇</h2><h3 id="图形系统如何表示颜色？"><a href="#图形系统如何表示颜色？" class="headerlink" title="图形系统如何表示颜色？"></a>图形系统如何表示颜色？</h3><h4 id="RGB-和-RGBA-的颜色表示法"><a href="#RGB-和-RGBA-的颜色表示法" class="headerlink" title="RGB 和 RGBA 的颜色表示法"></a>RGB 和 RGBA 的颜色表示法</h4><p>因为 RGB(A) 颜色用两位十六进制数来表示每一个通道的色阶，所以每个通道一共有 256 阶，取值是 0 到 255。<br>因此，RGB 颜色是将人眼可见的颜色表示为红、绿、蓝三原色不同色阶的混合。</p>
<p>WebGL 的 shader 默认支持 RGBA。因为在 WebGL 的 shader 中，我们是使用一个四维向量来表示颜色的，向量的 r、g、b、a 分量分别表示红色、绿色、蓝色和 alpha 通道。不过和 CSS 的颜色表示稍有不同的是，WebGL 采用归一化的浮点数值，也就是说，WebGL 的颜色分量 r、g、b、a 的数值都是 0 到 1 之间的浮点数。</p>
<p>当要选择一组颜色给图表使用时，我们并不知道要以什么样的规则来配置颜色，才能让不同数据对应的图形之间的对比尽可能鲜明。因此，RGB 颜色对用户其实并不友好。</p>
<p>在需要动态构建视觉颜色效果的时候，我们很少直接选用 RGB 色值，而是使用其他的颜色表示形式。这其中，比较常用的就是 HSL 和 HSV 颜色表示形式。</p>
<h4 id="HSL-和-HSV-颜色"><a href="#HSL-和-HSV-颜色" class="headerlink" title="HSL 和 HSV 颜色"></a>HSL 和 HSV 颜色</h4><p>与 RGB 颜色以色阶表示颜色不同，HSL 和 HSV 用色相（Hue）、饱和度（Saturation）和亮度（Lightness）或明度（Value）来表示颜色。其中，Hue 是角度，取值范围是 0 到 360 度，饱和度和亮度 / 明度的值都是从 0 到 100%。</p>
<p>CSS 和 Canvas2D 都可以直接支持 HSL 颜色，只有 WebGL 需要做转换。</p>
<h4 id="CIE-Lab-和-CIE-Lch-颜色"><a href="#CIE-Lab-和-CIE-Lch-颜色" class="headerlink" title="CIE Lab 和 CIE Lch 颜色"></a>CIE Lab 和 CIE Lch 颜色</h4><p>CIE Lab 颜色空间简称 Lab，它其实就是一种符合人类感觉的色彩空间，它用 L 表示亮度，a 和 b 表示颜色对立度。RGB 值也可以 Lab 转换，但是转换规则比较复杂。</p>
<p>CIE Lch 和 CIE Lab 表示颜色的技术还比较新，所以目前我们也不会接触很多，但是因为它能呈现的色彩更贴近人眼的感知，所以我相信它会发展得很快。作为技术人，这些新技术，我们也要持续关注。</p>
<h4 id="Cubehelix-色盘"><a href="#Cubehelix-色盘" class="headerlink" title="Cubehelix 色盘"></a>Cubehelix 色盘</h4><p>Cubehelix 色盘（立方螺旋色盘）。简单来说，它的原理就是在 RGB 的立方中构建一段螺旋线，让色相随着亮度增加螺旋变换。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>RGB 用三原色的色阶来表示颜色，是最基础的颜色表示法，但是它对用户不够友好。而 HSL 和 HSV 是用色相、饱和度、亮度（明度）来表示颜色，对开发者比较友好，但是它的数值变换与人眼感知并不完全相符。</p>
<p>CIELab 和 CIELch 与 Cubehelix 色盘，这两种颜色表示法还比较新，在实际工作中使用得不是很多。其中，CIELab 和 CIELch 是与人眼感知相符的色彩空间表示法，已经被纳入 css-color level4 规范中。虽然还没有被浏览器支持，但是一些如 d3-color 这样的 JavaScript 库可以直接处理 Lab 颜色空间。而如果我们要呈现颜色随数据动态改变的效果，那 Cubehelix 色盘就是一种非常更合适的选择了。</p>
<h3 id="图案生成：如何生成重复图案、分形图案以及随机效果？"><a href="#图案生成：如何生成重复图案、分形图案以及随机效果？" class="headerlink" title="图案生成：如何生成重复图案、分形图案以及随机效果？"></a>图案生成：如何生成重复图案、分形图案以及随机效果？</h3><h4 id="如何绘制大批量重复图案"><a href="#如何绘制大批量重复图案" class="headerlink" title="如何绘制大批量重复图案"></a>如何绘制大批量重复图案</h4><h5 id="使用-background-image-来绘制重复图案"><a href="#使用-background-image-来绘制重复图案" class="headerlink" title="使用 background-image 来绘制重复图案"></a>使用 background-image 来绘制重复图案</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">canvas &#123;</span><br><span class="line">  background-image: linear-gradient(to right, transparent 90%, #ccc 0),</span><br><span class="line">    linear-gradient(to bottom, transparent 90%, #ccc 0);</span><br><span class="line">  background-size: 8px 8px, 8px 8px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CSS 的 linear-gradient 属性可以定义线性渐变，在这个例子里，to right 表示颜色过渡是从左到右的，其中 0% 到 90% 的区域是透明的，90% 到 100% 的区域是 #ccc 颜色。另外，在 linear-gradient 中定义颜色过渡的时候，如果后一个过渡颜色的区域值和前面相同，我们可以把它简单写为 0。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如上面的代码所示，我们一共给 background-image 设置了两个 linear-gradient，一个是横向的（to right），一个是纵向的（to bottom）。因为 css 的 background-repeat 默认值是 repeat，所以我们给背景设置一下 background-size。这样，我们利用浏览器自己的 background-repeat 机制，就可以实现我们想要的网格背景了。</span><br></pre></td></tr></table></figure>
<h5 id="使用-Shader-来绘制重复图案"><a href="#使用-Shader-来绘制重复图案" class="headerlink" title="使用 Shader 来绘制重复图案"></a>使用 Shader 来绘制重复图案</h5><p>它的优势在于，不管我们给 rows 取值多少，图案都是一次绘制出来的，并不会因为 rows 增加而消耗性能。所以，使用 Shader 绘制重复图案，不管绘制多么细腻，图案重复多少次，绘制消耗的时间几乎是常量，不会遇到性能瓶颈。</p>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2022/11/26/graph/">可视化</a></p>
        <p><span>文章作者:</span><a href="/" title="访问 DiamondsZz 的个人博客">DiamondsZz</a></p>
        <p><span>发布时间:</span>2022年11月26日</p>
        <p><span>最后更新:</span>2022年11月28日 - 22时47分</p>    
    </div>



<nav id="article-nav">
  
  
    <a href="/2022/08/28/react+/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">深入浅出react</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>


  
</article>

    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#图形基础篇"><span class="toc-number">1.</span> <span class="toc-text">图形基础篇</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#浏览器中实现可视化的四种方式"><span class="toc-number">1.1.</span> <span class="toc-text">浏览器中实现可视化的四种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTML-CSS"><span class="toc-number">1.1.1.</span> <span class="toc-text">HTML+CSS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SVG"><span class="toc-number">1.1.2.</span> <span class="toc-text">SVG</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Canvas2D"><span class="toc-number">1.1.3.</span> <span class="toc-text">Canvas2D</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WebGL"><span class="toc-number">1.1.4.</span> <span class="toc-text">WebGL</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#指令式绘图系统：如何用Canvas绘制层次关系图？"><span class="toc-number">1.2.</span> <span class="toc-text">指令式绘图系统：如何用Canvas绘制层次关系图？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Canvas-元素和-2D-上下文"><span class="toc-number">1.2.1.</span> <span class="toc-text">Canvas 元素和 2D 上下文</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Canvas-的坐标系"><span class="toc-number">1.2.2.</span> <span class="toc-text">Canvas 的坐标系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#利用-Canvas-绘制几何图形"><span class="toc-number">1.2.3.</span> <span class="toc-text">利用 Canvas 绘制几何图形</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#声明式图形系统：如何用SVG图形元素绘制可视化图表？"><span class="toc-number">1.3.</span> <span class="toc-text">声明式图形系统：如何用SVG图形元素绘制可视化图表？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#利用-SVG-绘制几何图形"><span class="toc-number">1.3.1.</span> <span class="toc-text">利用 SVG 绘制几何图形</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#利用-SVG-绘制层次关系图"><span class="toc-number">1.3.2.</span> <span class="toc-text">利用 SVG 绘制层次关系图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SVG-和-Canvas-的不同点"><span class="toc-number">1.3.3.</span> <span class="toc-text">SVG 和 Canvas 的不同点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#绘制大量几何图形时-SVG-的性能问题"><span class="toc-number">1.3.4.</span> <span class="toc-text">绘制大量几何图形时 SVG 的性能问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GPU与渲染管线：如何用WebGL绘制最简单的几何图形？"><span class="toc-number">1.4.</span> <span class="toc-text">GPU与渲染管线：如何用WebGL绘制最简单的几何图形？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#图形系统是如何绘图的？"><span class="toc-number">1.4.1.</span> <span class="toc-text">图形系统是如何绘图的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GPU-是什么？"><span class="toc-number">1.4.2.</span> <span class="toc-text">GPU 是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何用-WebGL-绘制三角形？"><span class="toc-number">1.4.3.</span> <span class="toc-text">如何用 WebGL 绘制三角形？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#步骤一：创建-WebGL-上下文"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">步骤一：创建 WebGL 上下文</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#步骤二：创建-WebGL-程序"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">步骤二：创建 WebGL 程序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#步骤三：将数据存入缓冲区"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">步骤三：将数据存入缓冲区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#步骤四：将缓冲区数据读取到-GPU"><span class="toc-number">1.4.3.4.</span> <span class="toc-text">步骤四：将缓冲区数据读取到 GPU</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#步骤五：执行着色器程序完成绘制"><span class="toc-number">1.4.3.5.</span> <span class="toc-text">步骤五：执行着色器程序完成绘制</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#顶点着色器的作用"><span class="toc-number">1.4.4.</span> <span class="toc-text">顶点着色器的作用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#通过-gl-Position-设置顶点"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">通过 gl_Position 设置顶点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#向片元着色器传递数据"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">向片元着色器传递数据</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数学篇"><span class="toc-number">2.</span> <span class="toc-text">数学篇</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#视觉基础篇"><span class="toc-number">3.</span> <span class="toc-text">视觉基础篇</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#图形系统如何表示颜色？"><span class="toc-number">3.1.</span> <span class="toc-text">图形系统如何表示颜色？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RGB-和-RGBA-的颜色表示法"><span class="toc-number">3.1.1.</span> <span class="toc-text">RGB 和 RGBA 的颜色表示法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HSL-和-HSV-颜色"><span class="toc-number">3.1.2.</span> <span class="toc-text">HSL 和 HSV 颜色</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CIE-Lab-和-CIE-Lch-颜色"><span class="toc-number">3.1.3.</span> <span class="toc-text">CIE Lab 和 CIE Lch 颜色</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Cubehelix-色盘"><span class="toc-number">3.1.4.</span> <span class="toc-text">Cubehelix 色盘</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#总结"><span class="toc-number">3.1.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#图案生成：如何生成重复图案、分形图案以及随机效果？"><span class="toc-number">3.2.</span> <span class="toc-text">图案生成：如何生成重复图案、分形图案以及随机效果？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#如何绘制大批量重复图案"><span class="toc-number">3.2.1.</span> <span class="toc-text">如何绘制大批量重复图案</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#使用-background-image-来绘制重复图案"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">使用 background-image 来绘制重复图案</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#使用-Shader-来绘制重复图案"><span class="toc-number">3.2.1.2.</span> <span class="toc-text">使用 Shader 来绘制重复图案</span></a></li></ol></li></ol></li></ol></li></ol>
</div>
<style>
    .left-col .switch-btn {
        display: none;
    }
    .left-col .switch-area {
        display: none;
    }
</style>
<input type="button" id="tocButton" value="隐藏目录" title="点击按钮隐藏或者显示文章目录">

<script src="https://www.unpkg.com/jquery@3.6.0/dist/jquery.js"></script>

<script>
    var valueHide = "隐藏目录";
    var valueShow = "显示目录";
    if ($(".left-col").is(":hidden")) {
        $("#tocButton").attr("value", valueShow);
    }
    $("#tocButton").click(function() {
        if ($("#toc").is(":hidden")) {
            $("#tocButton").attr("value", valueHide);
            $("#toc").slideDown(320);
            $(".switch-btn, .switch-area").fadeOut(300);
        }
        else {
            $("#tocButton").attr("value", valueShow);
            $("#toc").slideUp(350);
            $(".switch-btn, .switch-area").fadeIn(500);
        }
    })
    if ($(".toc").length < 1) {
        $("#toc, #tocButton").hide();
        $(".switch-btn, .switch-area").show();
    }
</script>






    



    <div class="scroll" id="post-nav-button">
        
            <a href="/" title="回到主页"><i class="fa fa-home"></i></a>
        
        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>
        
            <a href="/2022/08/28/react+/" title="下一篇: 深入浅出react">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>
    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2022/11/26/graph/">可视化</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/08/28/react+/">深入浅出react</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/01/vue3/">玩转vue3全家桶</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/09/01/interview/">起个名字真难</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/08/01/optimize/">前端性能优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/08/01/test/">前端测试</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/07/18/node/">node学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/01/performance/">performance</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/25/http/">http协议</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/25/react/">react进阶</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/25/vue/">vue进阶</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/25/core/">核心进阶</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/25/browser/">浏览器工作原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/08/module_webpack/">模块化/webpack</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/08/yeoman/">脚手架/yeoman/gulp</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/16/question/">知识点</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/02/life/">记录生活</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/03/wfe/">前端笔记（旧）</a></li></ul>
    
<script src="https://www.unpkg.com/jquery@3.6.0/dist/jquery.js"></script>

    <script>
        $(".post-list").addClass("toc-article");
        // $(".post-list-item a").attr("target","_blank");
        $("#post-nav-button > a:nth-child(2)").click(function() {
            $(".fa-bars, .fa-times").toggle();
            $(".post-list").toggle(300);
            if ($(".toc").length > 0) {
                $("#toc, #tocButton").toggle(200, function() {
                    if ($(".switch-area").is(":visible")) {
                        $("#toc, .switch-btn, .switch-area").toggle();
                        $("#tocButton").attr("value", valueHide);
                        }
                    })
            }
            else {
                $(".switch-btn, .switch-area").fadeToggle(300);
            }
        })
    </script>




    <script>
        
    </script>

</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2022 DiamondsZz
            </div>        
        </div>
    </div>
</footer>

    </div>
    
<script src="https://www.unpkg.com/jquery@3.6.0/dist/jquery.js"></script>

<script src="/js/main.js"></script>

    <script>
        $(document).ready(function() {
            var backgroundnum = 1;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>






<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" "="">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(
            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


  </div>
</body>
</html>