<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  <meta name="baidu-site-verification" content="L6Lm9d5Crl">
  
  
  
  
  <title>vue3学习 | DiamondsZz</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="宏观视角：从前端框架发展史聊聊为什么要学 Vue 3？Vue 与 React 框架的对比在 Vue 框架下，如果数据变了，那框架会主动告诉你修改了哪些数据；而 React 的数据变化后，我们只能通过新老数据的计算 Diff 来得知数据的变化。 对于 Vue 来说，它的一个核心就是“响应式”，也就是数据变化后，会主动通知我们。响应式数据新建 Watcher 监听，本身就比较损耗性能，项目大了之后每个">
<meta name="keywords" content="资源,学习,网站">
<meta property="og:type" content="article">
<meta property="og:title" content="vue3学习">
<meta property="og:url" content="https://DiamondsZz.github.io/2022/01/01/vue3/index.html">
<meta property="og:site_name" content="DiamondsZz">
<meta property="og:description" content="宏观视角：从前端框架发展史聊聊为什么要学 Vue 3？Vue 与 React 框架的对比在 Vue 框架下，如果数据变了，那框架会主动告诉你修改了哪些数据；而 React 的数据变化后，我们只能通过新老数据的计算 Diff 来得知数据的变化。 对于 Vue 来说，它的一个核心就是“响应式”，也就是数据变化后，会主动通知我们。响应式数据新建 Watcher 监听，本身就比较损耗性能，项目大了之后每个">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2022-01-09T08:29:09.768Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="vue3学习">
<meta name="twitter:description" content="宏观视角：从前端框架发展史聊聊为什么要学 Vue 3？Vue 与 React 框架的对比在 Vue 框架下，如果数据变了，那框架会主动告诉你修改了哪些数据；而 React 的数据变化后，我们只能通过新老数据的计算 Diff 来得知数据的变化。 对于 Vue 来说，它的一个核心就是“响应式”，也就是数据变化后，会主动通知我们。响应式数据新建 Watcher 监听，本身就比较损耗性能，项目大了之后每个">
  
    <link rel="alternative" href="/atom.xml" title="DiamondsZz" type="application/atom+xml">
  
  
  
  <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet">
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: false,
          isPost: true,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        
<script src="https://www.unpkg.com/jquery@3.6.0/dist/jquery.js"></script>

        <a href="/" class="profilepic">
            
            <img lazy-src="/img/iu.jpeg" class="js-avatar">
            
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">DiamondsZz</a></h1>
        </hgroup>
        
        <p class="header-subtitle">DiamondsZz</p>
        
        
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        
        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                        </ul>
                    </nav>
                </section>
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/css/" style="font-size: 13.33px;">css</a> <a href="/tags/js/" style="font-size: 16.67px;">js</a> <a href="/tags/学习/" style="font-size: 20px;">学习</a> <a href="/tags/生活，心情/" style="font-size: 10px;">生活，心情</a> <a href="/tags/网站/" style="font-size: 20px;">网站</a> <a href="/tags/资源/" style="font-size: 20px;">资源</a>
                    </div>
                </section>
                
                
                
                
                <section class="switch-part switch-part3">
                
                    <div id="js-aboutme">矮穷矬!</div>
                </section>
                
            </div>
        </div>
    </header>
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">DiamondsZz</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/img/iu.jpeg" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">DiamondsZz</a></h1>
            </hgroup>
            
            <p class="header-subtitle">DiamondsZz</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                </div>
            </nav>
        </header>
    </div>
</nav>
      <div class="body-wrap"><article id="post-vue3" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/01/01/vue3/" class="article-date">
      <time datetime="2021-12-31T16:00:00.000Z" itemprop="datePublished">2022-01-01</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      vue3学习
    </h1>
  


      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/学习/">学习</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/学习/">学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网站/">网站</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/资源/">资源</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="宏观视角：从前端框架发展史聊聊为什么要学-Vue-3？"><a href="#宏观视角：从前端框架发展史聊聊为什么要学-Vue-3？" class="headerlink" title="宏观视角：从前端框架发展史聊聊为什么要学 Vue 3？"></a>宏观视角：从前端框架发展史聊聊为什么要学 Vue 3？</h2><h3 id="Vue-与-React-框架的对比"><a href="#Vue-与-React-框架的对比" class="headerlink" title="Vue 与 React 框架的对比"></a>Vue 与 React 框架的对比</h3><p>在 Vue 框架下，如果数据变了，那框架会主动告诉你修改了哪些数据；而 React 的数据变化后，我们只能通过新老数据的计算 Diff 来得知数据的变化。</p>
<p>对于 Vue 来说，它的一个核心就是“响应式”，也就是数据变化后，会主动通知我们。响应式数据新建 Watcher 监听，本身就比较损耗性能，项目大了之后每个数据都有一个 watcher 会影响性能。对于 React 的虚拟 DOM 的 Diff 计算逻辑来说，如果虚拟 DOM 树过于庞大，使得计算时间大于 16.6ms，那么就可能会造成性能的卡顿。</p>
<p>React 为了突破性能瓶颈，借鉴了操作系统时间分片的概念，引入了 Fiber 架构。通俗来说，就是把整个虚拟 DOM 树微观化，变成链表，然后我们利用浏览器的空闲时间计算 Diff。一旦浏览器有需求，我们可以把没计算完的任务放在一旁，把主进程控制权还给浏览器，等待浏览器下次空闲。这种架构虽然没有减少运算量，但是巧妙地利用空闲实现计算，解决了卡顿的问题。高性能的动画要求是 60fps，也就是 1 秒要渲染 60 次，每一帧的时间就是 16.6 毫秒，在这 16.6 毫秒里，浏览器自己的渲染更新任务执行后，会有一部分的空闲时间，这段时间我们就用来计算 Diff。等到下一帧任务来了，我们就把控制权还给浏览器，让它继续去更新和渲染，等待空闲时间再继续计算，这样就不会导致卡顿。</p>
<p>Vue 1 的问题在于响应式数据过多，这样会带来内存占用过多的问题。所以 Vue 2 大胆引入虚拟 DOM 来解决响应式数据过多的问题。这个解决方案使用虚拟 DOM 解决了响应式数据过多的内存占用问题，又良好地规避了 React 中虚拟 DOM 的问题， 还通过虚拟 DOM 给 Vue 带来了跨端的能力。响应式数据是主动推送变化，虚拟 DOM 是被动计算数据的 Diff，一个推一个拉，它们看起来是两个方向的技术，但被 Vue 2 很好地融合在一起，采用的方式就是组件级别的划分。对于 Vue 2 来说，组件之间的变化，可以通过响应式来通知更新。组件内部的数据变化，则通过虚拟 DOM 去更新页面。这样就把响应式的监听器，控制在了组件级别，而虚拟 DOM 的量级，也控制在了组件的大小。这个方案也体现了 Vue 一直以来坚持的中庸的设计思想。</p>
<p>除了响应式和虚拟 DOM 这个维度，Vue 和 React 还有一些理念和路线的不同，在模板的书写上，也走出了 template 和 JSX 两个路线。</p>
<p>React 的世界里只有 JSX，最终 JSX 都会在 Compiler 那一层，也就是工程化那里编译成 JS 来执行，所以 React 最终拥有了全部 JS 的动态性，这也导致了 React 的 API 一直很少，只有 state、hooks、Component 几个概念，主要都是 JavaScript 本身的语法和特性。</p>
<p>而 Vue 的世界默认是 template，也就是语法是限定死的，比如 v-if 和 v-for 等语法。有了这些写法的规矩后，我们可以在上线前做很多优化。Vue 3 很优秀的一个点，就是在虚拟 DOM 的静态标记上做到了极致，让静态的部分越过虚拟 DOM 的计算，真正做到了按需更新，很好的提高了性能。</p>
<p>在模板的书写上，除了 Vue 和 React 走出的 template 和 JSX 两个路线，还出现了 Svelte 这种框架，没有虚拟 DOM 的库，直接把模板编译成原生 DOM，几乎没有 Runtime，所有的逻辑都在 Compiler 层优化，算是另外一个极致。</p>
<p>在你看来，Vue 需不需要 React 的 Fiber 呢？<br>最早 Vue3 的提案其实是包含时间切片方案的，最后废弃的主要原因，是时间切片解决的的问题，Vue3 基本碰不到：<br>Vue3 把虚拟 Dom 控制在组件级别，组件之间使用响应式，这就让 Vue3 的虚拟 Dom 不会过于庞大<br>Vue3 虚拟 Dom 的静态标记和自动缓存功能，让静态的节点和属性可以直接绕过 Diff 逻辑，也大大减少了虚拟 Dom 的 Diff 事件<br>时间切片也会带来额外的系统复杂性<br>所以引入时间切片对于 Vue3 来说投入产出比不太理想，在后来的讨论中，Vue3 的时间切片方案就被废弃了</p>
<h2 id="新特性：初探-Vue-3-新特性"><a href="#新特性：初探-Vue-3-新特性" class="headerlink" title="新特性：初探 Vue 3 新特性"></a>新特性：初探 Vue 3 新特性</h2><p>下面列举了一些 Vue 2 常见的缺陷，你可以对照你的实际开发经验，看看是否也遇到过这些问题：<br>从开发维护的角度看，Vue 2 是使用 Flow.js 来做类型校验。但现在 Flow.js 已经停止维护了，整个社区都在全面使用 TypeScript 来构建基础库，Vue 团队也不例外。<br>从社区的二次开发难度来说，Vue 2 内部运行时，是直接执行浏览器 API 的。但这样就会在 Vue 2 的跨端方案中带来问题，要么直接进入 Vue 源码中，和 Vue 一起维护，比如 Vue 2 中你就能见到 Weex 的文件夹。<br>从我们普通开发者的角度来说，Vue 2 响应式并不是真正意义上的代理，而是基于 Object.defineProperty() 实现的。<br>这个 API 并不是代理，而是对某个属性进行拦截，所以有很多缺陷，比如：删除数据就无法监听，需要 $delete 等 API 辅助才能监听到。并且，Option API 在组织代码较多组件的时候不易维护。对于 Option API 来说，所有的 methods、computed 都在一个对象里配置，这对小应用来说还好。但代码超过 300 行的时候，新增或者修改一个功能，就需要不停地在 data，methods 里跳转写代码，我称之为上下反复横跳。</p>
<h3 id="响应式系统"><a href="#响应式系统" class="headerlink" title="响应式系统"></a>响应式系统</h3><p>Vue 2 的响应式机制是基于 Object.defineProperty() 这个 API 实现的，此外，Vue 还使用了 Proxy，这两者看起来都像是对数据的读写进行拦截，但是 defineProperty 是拦截具体某个属性，Proxy 才是真正的“代理”。</p>
<h3 id="自定义渲染器"><a href="#自定义渲染器" class="headerlink" title="自定义渲染器"></a>自定义渲染器</h3><p>Vue 2 内部所有的模块都是揉在一起的，这样做会导致不好扩展的问题，刚才我也提到了这一点。Vue 3 是怎么解决这个问题的呢？那就是拆包，使用最近流行的 monorepo 管理方式，响应式、编译和运行时全部独立了。</p>
<p>在 Vue 3 的组织架构中，响应式独立了出来。而 Vue 2 的响应式只服务于 Vue，Vue 3 的响应式就和 Vue 解耦了，你甚至可以在 Node.js 和 React 中使用响应式。</p>
<p>渲染的逻辑也拆成了平台无关渲染逻辑和浏览器渲染 API 两部分 。</p>
<h3 id="全部模块使用-TypeScript-重构"><a href="#全部模块使用-TypeScript-重构" class="headerlink" title="全部模块使用 TypeScript 重构"></a>全部模块使用 TypeScript 重构</h3><p>类型系统带来了更方便的提示，并且让我们的代码能够更健壮。</p>
<p>Vue 2 那个时代基本只有两个技术选型，Facebook 家的 Flow.js 和微软家的 TypeScript。Vue 2 选 Flow.js 没问题，但是现在 Flow.js 被抛弃了。Vue 3 选择了 TypeScript，TypeScript 官方也对使用 TypeScript 开发 Vue 3 项目的团队也更加友好。</p>
<h3 id="Composition-API-组合语法"><a href="#Composition-API-组合语法" class="headerlink" title="Composition API 组合语法"></a>Composition API 组合语法</h3><p>Options API 的写法也有几个很严重的问题：<br>由于所有数据都挂载在 this 之上，因而 Options API 的写法对 TypeScript 的类型推导很不友好，并且这样也不好做 Tree-shaking 清理代码。<br>新增功能基本都得修改 data、method 等配置，并且代码上 300 行之后，会经常上下反复横跳，开发很痛苦。<br>代码不好复用，Vue 2 的组件很难抽离通用逻辑，只能使用 mixin，还会带来命名冲突的问题。</p>
<p>Composition API 后，虽然看起来烦琐了一些，但是带来了诸多好处：<br>所有 API 都是 import 引入的。用到的功能都 import 进来，对 Tree-shaking 很友好，我的例子里没用到功能，打包的时候会被清理掉 ，减小包的大小。<br>不再上下反复横跳，我们可以把一个功能模块的 methods、data 都放在一起书写，维护更轻松。<br>代码方便复用，可以把一个功能所有的 methods、data 封装在一个独立的函数里，复用代码非常容易。<br>Composition API 新增的 return 等语句，在实际项目中使用 <code>&lt;script setup&gt;</code> 特性可以清除， 我们后续项目中都会用到这样的操作。</p>
<h3 id="新的组件"><a href="#新的组件" class="headerlink" title="新的组件"></a>新的组件</h3><p>Fragment: Vue 3 组件不再要求有一个唯一的根节点，清除了很多无用的占位 div。<br>Teleport: 允许组件渲染在别的元素内，主要开发弹窗组件的时候特别有用。<br>Suspense: 异步组件，更方便开发有异步请求的组件。</p>
<h3 id="新一代工程化工具-Vite"><a href="#新一代工程化工具-Vite" class="headerlink" title="新一代工程化工具 Vite"></a>新一代工程化工具 Vite</h3><p>Vite 主要提升的是开发的体验，Webpack 等工程化工具的原理，就是根据你的 import 依赖逻辑，形成一个依赖图，然后调用对应的处理工具，把整个项目打包后，放在内存里再启动调试。</p>
<p>具体来说，在调试环境下，我们不需要全部预打包，只是把你首页依赖的文件，依次通过网络请求去获取，整个开发体验得到巨大提升，做到了复杂项目的秒级调试和热更新。</p>
<h2 id="巧妙的响应式：深入理解-Vue-3-的响应式机制"><a href="#巧妙的响应式：深入理解-Vue-3-的响应式机制" class="headerlink" title="巧妙的响应式：深入理解 Vue 3 的响应式机制"></a>巧妙的响应式：深入理解 Vue 3 的响应式机制</h2><p>Vue 中用过三种响应式解决方案，分别是 defineProperty、Proxy 和 value setter。</p>
<p>有了 Proxy 后，响应式机制就比较完备了。但是在 Vue 3 中还有另一个响应式实现的逻辑，就是利用对象的 get 和 set 函数来进行监听，这种响应式的实现方式，只能拦截某一个属性的修改，这也是 Vue 3 中 ref 这个 API 的实现。在下面的代码中，我们拦截了 count 的 value 属性，并且拦截了 set 操作，也能实现类似的功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let getDouble = n =&gt; n * 2</span><br><span class="line">let _value = 1</span><br><span class="line">double = getDouble(_value)</span><br><span class="line"></span><br><span class="line">let count = &#123;</span><br><span class="line">  get value() &#123;</span><br><span class="line">    return _value</span><br><span class="line">  &#125;,</span><br><span class="line">  set value(val) &#123;</span><br><span class="line">    _value = val</span><br><span class="line">    double = getDouble(_value)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(count.value,double)</span><br><span class="line">count.value = 2</span><br><span class="line">console.log(count.value,double)</span><br></pre></td></tr></table></figure>
<h2 id="数据流：如何使用-Vuex-设计你的数据流"><a href="#数据流：如何使用-Vuex-设计你的数据流" class="headerlink" title="数据流：如何使用 Vuex 设计你的数据流"></a>数据流：如何使用 Vuex 设计你的数据流</h2><p>对于一个数据，如果只是组件内部使用就是用 ref 管理；如果我们需要跨组件，跨页面共享的时候，我们就需要把数据从 Vue 的组件内部抽离出来，放在 Vuex 中去管理。</p>
<h3 id="手写迷你-Vuex"><a href="#手写迷你-Vuex" class="headerlink" title="手写迷你 Vuex"></a>手写迷你 Vuex</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import &#123; inject, reactive &#125; from &apos;vue&apos;</span><br><span class="line"></span><br><span class="line">const STORE_KEY = &apos;__store__&apos;</span><br><span class="line">function useStore() &#123;</span><br><span class="line">  return inject(STORE_KEY)</span><br><span class="line">&#125;</span><br><span class="line">function createStore(options) &#123;</span><br><span class="line">  return new Store(options)</span><br><span class="line">&#125;</span><br><span class="line">class Store &#123;</span><br><span class="line">  constructor(options) &#123;</span><br><span class="line">    this._state = reactive(&#123;</span><br><span class="line">      data: options.state()</span><br><span class="line">    &#125;)</span><br><span class="line">    this._mutations = options.mutations</span><br><span class="line">  &#125;</span><br><span class="line">  get state() &#123;</span><br><span class="line">       return this._state.data</span><br><span class="line">  &#125;</span><br><span class="line">  commit = (type, payload) =&gt; &#123;</span><br><span class="line">  const entry = this._mutations[type]</span><br><span class="line">  entry &amp;&amp; entry(this.state, payload)</span><br><span class="line">  &#125;</span><br><span class="line">  // main.js入口处app.use(store)的时候，会执行这个函数</span><br><span class="line">  install(app) &#123; app.provide(STORE_KEY, this) &#125;</span><br><span class="line">&#125;</span><br><span class="line">export &#123; createStore, useStore &#125;</span><br></pre></td></tr></table></figure>
<h2 id="路由：新一代-vue-router-带来什么变化"><a href="#路由：新一代-vue-router-带来什么变化" class="headerlink" title="路由：新一代 vue-router 带来什么变化"></a>路由：新一代 vue-router 带来什么变化</h2><h3 id="手写迷你-vue-router"><a href="#手写迷你-vue-router" class="headerlink" title="手写迷你 vue-router"></a>手写迷你 vue-router</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import &#123;ref,inject&#125; from &apos;vue&apos;</span><br><span class="line">import RouterLink from &apos;./RouterLink.vue&apos;</span><br><span class="line">import RouterView from &apos;./RouterView.vue&apos;</span><br><span class="line">const ROUTER_KEY = &apos;__router__&apos;</span><br><span class="line"></span><br><span class="line">function createRouter(options)&#123;</span><br><span class="line">    return new Router(options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function useRouter()&#123;</span><br><span class="line">    return inject(ROUTER_KEY)</span><br><span class="line">&#125;</span><br><span class="line">function createWebHashHistory()&#123;</span><br><span class="line">    function bindEvents(fn)&#123;</span><br><span class="line">        window.addEventListener(&apos;hashchange&apos;,fn)</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;</span><br><span class="line">        bindEvents,</span><br><span class="line">        url:window.location.hash.slice(1) || &apos;/&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Router&#123;</span><br><span class="line">    constructor(options)&#123;</span><br><span class="line">        this.history = options.history</span><br><span class="line">        this.routes = options.routes</span><br><span class="line">        this.current = ref(this.history.url)</span><br><span class="line"></span><br><span class="line">        this.history.bindEvents(()=&gt;&#123;</span><br><span class="line">            this.current.value = window.location.hash.slice(1)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    install(app)&#123;</span><br><span class="line">        app.provide(ROUTER_KEY,this)</span><br><span class="line">        app.component(&quot;router-link&quot;,RouterLink)</span><br><span class="line">        app.component(&quot;router-view&quot;,RouterView)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export &#123;createRouter,createWebHashHistory,useRouter&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;component :is=&quot;comp&quot;&gt;&lt;/component&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line"></span><br><span class="line">import &#123;computed &#125; from &apos;vue&apos;</span><br><span class="line">import &#123; useRouter &#125; from &apos;../router/index&apos;</span><br><span class="line"></span><br><span class="line">let router = useRouter()</span><br><span class="line"></span><br><span class="line">const comp = computed(()=&gt;&#123;</span><br><span class="line">    const route = router.routes.find(</span><br><span class="line">        (route) =&gt; route.path === router.current.value</span><br><span class="line">    )</span><br><span class="line">    return route?route.component : null</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="什么是好的项目？"><a href="#什么是好的项目？" class="headerlink" title="什么是好的项目？"></a>什么是好的项目？</h2><h3 id="给项目骨干开发者的优化建议"><a href="#给项目骨干开发者的优化建议" class="headerlink" title="给项目骨干开发者的优化建议"></a>给项目骨干开发者的优化建议</h3><p>首先你会发现，一旦团队项目里多个项目之间的配置或者规范不同步，那么每个项目的配置都需要手动修改，而这很浪费时间。所以，你可以发起了一个团队的脚手架项目，把项目中的代码规范、Vite 配置，log 等等都集成在脚手架内部，通过这样的方式，可以提高项目的启动效率，这算是一个亮点。</p>
<p>然后，很多时候，公司多个项目之间会有代码复用和组件复用的需求。这时，你就可以再发起一个基础组件库的项目，做出一个类似 Element3 的基础组件库，并且发布在公司的 npm 服务之上，提供给全公司前端使用。为了让大家用这个组件库的时候能放心，你可以给组件库实现完备的文档系统以及超过 90% 的单测覆盖率，这也能够作为你的亮点。</p>
<p>前端项目的上线需要和后端服务器打交道，为了提高发布和部署的效率，你可以发起了一个 CI/CD 的项目，利用 GitHub 的 action 机制，可以把整个发布过程自动化，并且还可以一键回滚。这样日常开发的需求变更是非常快的，每一个流程的自动化都能够提高团队整体的研发效率。而且这个 CI/CD 系统里还需要能够解决需求频繁变更的问题，以及版本迭代的需求，这些优化项的解决，都能够让整个项目更稳定地交付。</p>
<p>你还可以复盘你现在负责的业务类型，如果你负责营销组，那么面对繁多的营销页面时，你可以搭建一个 Low Code 系统，让运营同学和产品同学自己通过拖拽的方式配置出营销页面。在这个过程中，你需要解决搭建系统时的一系列问题，比如：如何设计物料系统、如何实现跨端搭建系统等等。</p>
<p>然后从项目运行性能和稳定性的角度来看，我们可以制定项目的性能指标，开发项目的性能监控系统，来实时监控客户端的性能，当页面有严重的性能问题或者报错的时候，能够及时通知我们。并且除了常见的性能优化策略之外，我们还可以分析用户访问日志，提前预测用户可能访问的页面，从而做路由级别的预加载等等。</p>
<p>作为项目负责人来说，你要能够在整体上推动项目向前，提高团队整体的研发效率就是你做的项目最大的亮点。</p>
<p>其实面试官问你做过什么项目，目的就是想通过你做的项目，挖掘出你的技术亮点，所以不要一句“我做过 XXX 项目”一闪而过，我们可以尝试使用 STAR 原则去描述项目。所谓 STAR 原则，即 Situation（情景）、Task（任务）、Action（行动）和 Result（结果）四个英文单词的首字母组合，也就是你在什么情景下、遇见了什么任务、做了什么动作，拿到了怎样的结果，结果中最好还能带上数字展示，这样你的项目的描述就会很饱满。</p>
<h2 id="如何打包发布你的-Vue-3-应用？"><a href="#如何打包发布你的-Vue-3-应用？" class="headerlink" title="如何打包发布你的 Vue 3 应用？"></a>如何打包发布你的 Vue 3 应用？</h2><p>首先，我们需要一台独立的机器去进行打包和构建的操作，这台机器需要独立于所有开发环境，这样做是为了保证打包环境的稳定；之后，在部署任务启动的时候，我们需要拉取远程的代码，并且切换到需要部署的分支，然后锁定 Node 版本进行依赖安装、单元测试、ESLint 等代码检查工作；最后，在这台机器上，执行经过编译产出的打包后的代码，并打包上传代码到 CDN 和静态服务器。当然了，完成这些操作之后，还要能通过脚本自动通过内部沟通软件通知团队项目构建的结果。</p>
<p>为了减少上线时，部署操作对用户造成的影响，我们需要先选择一部分用户去做灰度测试，也就是说，上线后的项目的访问权限，暂时只对这些用户开放。或者，你也可以做一些 AB 测试，比如给北京的同学推送 Vue 课，给上海的同学推荐 React 课等等。我们需要做的，就是把不同版本的代码分开打包，互不干涉。之后，我们再设计部署的机器和机房去适配不同的用户。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">name: 打包应用的actions</span><br><span class="line">on:</span><br><span class="line">  push: # 监听代码时间</span><br><span class="line">    branches:</span><br><span class="line">      - master  # master分支代码推送的时候激活当前action</span><br><span class="line">jobs:</span><br><span class="line">  build:</span><br><span class="line">    # runs-on 操作系统</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    steps:</span><br><span class="line">      - name: 迁出代码</span><br><span class="line">        uses: actions/checkout@master</span><br><span class="line">      # 安装Node</span><br><span class="line">      - name: 安装Node</span><br><span class="line">        uses: actions/setup-node@v1</span><br><span class="line">        with:</span><br><span class="line">          node-version: 14.7.6</span><br><span class="line">      # 安装依赖</span><br><span class="line">      - name: 安装依赖</span><br><span class="line">        run: npm install</span><br><span class="line">      # 打包</span><br><span class="line">      - name: 打包</span><br><span class="line">        run: npm run build</span><br></pre></td></tr></table></figure>
<p>然后，我们需要配置上线服务器和 GitHub Actions 服务器的信任关系，通过 SSH 密钥可以实现免登录直接部署。我们直接把 build 之后的代码打包压缩，通过 SSH 直接上传到服务器上，并且要进行代码文件版本的管理，就完成了代码的部署。</p>
<h2 id="如何设计你自己的通用组件库？"><a href="#如何设计你自己的通用组件库？" class="headerlink" title="如何设计你自己的通用组件库？"></a>如何设计你自己的通用组件库？</h2><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>husky 这个库可以很方便地帮助我们设置 Git 的钩子函数，可以允许我们在代码提交之前进行代码质量的监测。<br>下面的代码中，我们首先安装和初始化了 husky，然后我们使用 npx husky add 命令新增了 commit-msg 钩子，husky 会在我们执行 git commit 提交代码的时候执行 node scripts/verifyCommit 命令来校验 commit 信息格式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">npm install -D husky # 安装husky</span><br><span class="line">npx husky install    # 初始化husky</span><br><span class="line"># 新增commit msg钩子</span><br><span class="line">npx husky add .husky/commit-msg &quot;node scripts/verifyCommit.js&quot;</span><br></pre></td></tr></table></figure>
<p>然后我们来到项目目录下的 verifyCommit 文件。在下面的代码中，我们先去 .git/COMMIT_EDITMSG 文件中读取了 commit 提交的信息，然后使用了正则去校验提交信息的格式。如果 commit 的信息不符合要求，会直接报错并且终止代码的提交。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const msg = require(&apos;fs&apos;)</span><br><span class="line">  .readFileSync(&apos;.git/COMMIT_EDITMSG&apos;, &apos;utf-8&apos;)</span><br><span class="line">  .trim()</span><br><span class="line"></span><br><span class="line">const commitRE = /^(revert: )?(feat|fix|docs|dx|style|refactor|perf|test|workflow|build|ci|chore|types|wip|release)(\(.+\))?: .&#123;1,50&#125;/</span><br><span class="line">const mergeRe = /^(Merge pull request|Merge branch)/</span><br><span class="line">if (!commitRE.test(msg)) &#123;</span><br><span class="line">  if(!mergeRe.test(msg))&#123;</span><br><span class="line">    console.log(&apos;git commit信息校验不通过&apos;)</span><br><span class="line"></span><br><span class="line">    console.error(`git commit的信息格式不对, 需要使用 title(scope): desc的格式</span><br><span class="line">      比如 fix: xxbug</span><br><span class="line">      feat(test): add new</span><br><span class="line">      具体校验逻辑看 scripts/verifyCommit.js</span><br><span class="line">    `)</span><br><span class="line">    process.exit(1)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;else&#123;</span><br><span class="line">  console.log(&apos;git commit信息校验通过&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就确保在 GitHub 中的提交日志都符合 type(scope): message 的格式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">feat: 新功能</span><br><span class="line">fix: 修改 bug</span><br><span class="line">docs: 文档</span><br><span class="line">perf: 性能相关</span><br><span class="line">refactor: 代码重构（就是不影响使用，内部结构的调整）</span><br><span class="line">test: 测试用例</span><br><span class="line">style: 样式修改</span><br><span class="line">workflow: 工作流</span><br><span class="line">build: 项目打包构建相关的配置修改</span><br><span class="line">ci: 持续集成相关</span><br><span class="line">revert: 恢复上一次提交（回滚）</span><br><span class="line">wip: work in progress 工作中 还没完成</span><br><span class="line">chore: 其他修改（不在上述类型中的修改）</span><br><span class="line">release: 发版</span><br><span class="line">deps: 依赖相关的修改</span><br></pre></td></tr></table></figure>
<p>commit-msg 是代码执行提交的时候执行的，我们还可以使用代码执行之前的钩子 pre-commit 去执行 ESLint 代码格式。这样我们在执行 git commit 的同时，就会首先进行 ESLint 校验，然后执行 commit 的 log 信息格式检查，全部通过后代码才能提交至 Git，这也是现在业界通用的解决方案。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">npx husky add .husky/pre-commit &quot;npm run lint&quot;</span><br></pre></td></tr></table></figure>
<h3 id="布局组件"><a href="#布局组件" class="headerlink" title="布局组件"></a>布局组件</h3><p>我们可以参考 Element3 组件列表页面，这里的组件分成了基础组件、表单组件、数据组件、通知组件、导航组件和其他组件几个类型，这些类型基本覆盖了组件库的适用场景，项目中的业务组件也是由这些类型组件拼接而来的。</p>
<p>我们在 src/styles 下面新建 mixin.scss。在下面的代码中，我们定义了 namespace 变量为 el，使用 Mixin 注册一个可以重复使用的模块 b，可以通过传进来的 block 生成新的变量 $B，并且变量会渲染在 class 上，并且注册了 when 可以新增 class 选择器，实现多个 class 的样式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">// bem</span><br><span class="line"></span><br><span class="line">$namespace: &apos;el&apos;;</span><br><span class="line">@mixin b($block) &#123;</span><br><span class="line">  $B: $namespace + &apos;-&apos; + $block !global;</span><br><span class="line">  .#&#123;$B&#125; &#123;</span><br><span class="line">    @content;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 添加ben后缀啥的</span><br><span class="line">@mixin when($state) &#123;</span><br><span class="line">  @at-root &#123;</span><br><span class="line">    &amp;.#&#123;$state-prefix + $state&#125; &#123;</span><br><span class="line">      @content;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;style lang=&quot;scss&quot;&gt;</span><br><span class="line">@import &apos;../styles/mixin&apos;;</span><br><span class="line">@include b(container) &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  flex-direction: row;</span><br><span class="line">  flex: 1;</span><br><span class="line">  flex-basis: auto;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">  min-width: 0;</span><br><span class="line">  @include when(vertical) &#123;</span><br><span class="line">    flex-direction: column;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.el-container &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  flex-direction: row;</span><br><span class="line">  flex: 1;</span><br><span class="line">  flex-basis: auto;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">  min-width: 0;</span><br><span class="line">&#125;</span><br><span class="line">.el-container.is-vertical &#123;</span><br><span class="line">  flex-direction: column;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import &#123;App&#125; from &apos;vue&apos;</span><br><span class="line">import ElContainer from &apos;./Container.vue&apos;</span><br><span class="line">import ElHeader from &apos;./Header.vue&apos;</span><br><span class="line">import ElFooter from &apos;./Footer.vue&apos;</span><br><span class="line">import ElAside from &apos;./Aside.vue&apos;</span><br><span class="line">import ElMain from &apos;./Main.vue&apos;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  install(app:App)&#123;</span><br><span class="line">    app.component(ElContainer.name,ElContainer)</span><br><span class="line">    app.component(ElHeader.name,ElHeader)</span><br><span class="line">    app.component(ElFooter.name,ElFooter)</span><br><span class="line">    app.component(ElAside.name,ElAside)</span><br><span class="line">    app.component(ElMain.name,ElMain)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="如何使用-TDD-开发一个组件？"><a href="#如何使用-TDD-开发一个组件？" class="headerlink" title="如何使用 TDD 开发一个组件？"></a>如何使用 TDD 开发一个组件？</h2><p>我们选择 Facebook 出品的 Jest 作为我们组件库的测试代码，Jest 是现在做测试的最佳选择了，因为它内置了断言、测试覆盖率等功能。<br>通过命令行执行下面的命令，vue-jest 和 @vue/test-utils 是测试 Vue 组件必备的库，然后安装 babel 相关的库，最后安装 Jest 适配 TypeScript 的库。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">npm install -D jest@26 vue-jest@next @vue/test-utils@next</span><br><span class="line">npm install -D babel-jest@26 @babel/core @babel/preset-env</span><br><span class="line">npm install -D ts-jest@26 @babel/preset-typescript @types/jest</span><br></pre></td></tr></table></figure>
<p>安装完毕后，我们要在根目录下新建.babel.config.js。下面的配置目的是让 babel 解析到 Node 和 TypeScript 环境下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  presets: [</span><br><span class="line">    [&apos;@babel/preset-env&apos;, &#123; targets: &#123; node: &apos;current&apos; &#125; &#125;],</span><br><span class="line">    &apos;@babel/preset-typescript&apos;,</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们还需要新建 jest.config.js，用来配置 jest 的测试行为。不同格式的文件需要使用不同命令来配置，对于.vue 文件我们使用 vue-jest，对于.js 或者.jsx 结果的文件，我们就要使用 babel-jest，而对于.ts 结尾的文件我们使用 ts-jest，然后匹配文件名是 xx.spec.js。这里请注意，Jest 只会执行.spec.js 结尾的文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  transform: &#123;</span><br><span class="line">    // .vue文件用 vue-jest 处理</span><br><span class="line">    &apos;^.+\\.vue$&apos;: &apos;vue-jest&apos;,</span><br><span class="line">    // .js或者.jsx用 babel-jest处理</span><br><span class="line">    &apos;^.+\\.jsx?$&apos;: &apos;babel-jest&apos;,</span><br><span class="line">    //.ts文件用ts-jest处理</span><br><span class="line">    &apos;^.+\\.ts$&apos;: &apos;ts-jest&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  testMatch: [&apos;**/?(*.)+(spec).[jt]s?(x)&apos;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后配置 package.json，在 scrips 配置下面新增 test 命令，即可启动 Jest。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;dev&quot;: &quot;vite&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;vue-tsc --noEmit &amp;&amp; vite build&quot;,</span><br><span class="line">    &quot;serve&quot;: &quot;vite preview&quot;,</span><br><span class="line">    &quot;lint&quot;: &quot;eslint --fix --ext .js,vue src/&quot;,</span><br><span class="line">    &quot;test&quot;: &quot;jest&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="如何实现-Vue-的跨端渲染-？"><a href="#如何实现-Vue-的跨端渲染-？" class="headerlink" title="如何实现 Vue 的跨端渲染 ？"></a>如何实现 Vue 的跨端渲染 ？</h2><h3 id="什么是渲染器"><a href="#什么是渲染器" class="headerlink" title="什么是渲染器"></a>什么是渲染器</h3><p>我们都知道，Vue 内部的组件是以虚拟 dom 形式存在的。下面的代码就是一个很常见的虚拟 Dom，用对象的方式去描述一个项目。相比 dom 标签相比，这种形式可以让整个 Vue 项目脱离浏览器的限制，更方便地实现 Vuejs 的跨端。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  tag: &apos;div&apos;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    id: &apos;app&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  children: [</span><br><span class="line">    &#123;</span><br><span class="line">      tag: Container,</span><br><span class="line">      props: &#123;</span><br><span class="line">        className: &apos;el-container&apos;</span><br><span class="line">      &#125;,</span><br><span class="line">      children: [</span><br><span class="line">        &apos;哈喽小老弟!!!&apos;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>渲染器是围绕虚拟 Dom 存在的。在浏览器中，我们把虚拟 Dom 渲染成真实的 Dom 对象，Vue 源码内部把一个框架里所有和平台相关的操作，抽离成了独立的方法。所以，我们只需要实现下面这些方法，就可以实现 Vue 3 在一个平台的渲染。</p>
<p>首先用 createElement 创建标签，还有用 createText 创建文本。创建之后就需要用 insert 新增元素，通过 remove 删除元素，通过 setText 更新文本和 patchProps 修改属性。然后再实现 parentNode、nextSibling 等方法实现节点的查找关系。完成这些工作，理论上就可以在一个平台内实现一个应用了。</p>
<p>在 Vue 3 中的 runtime-core 模块，就对外暴露了这些接口，runtime-core 内部基于这些函数实现了整个 Vue 内部的所有操作，然后在 runtime-dom 中传入以上所有方法。</p>
<p>下面的代码就是 Vue 代码提供浏览器端操作的函数，这些 DOM 编程接口完成了浏览器端增加、添加和删除操作，这些 API 都是浏览器端独有的，如果一个框架强依赖于这些函数，那就只能在浏览器端运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">export const nodeOps: Omit&lt;RendererOptions&lt;Node, Element&gt;, &apos;patchProp&apos;&gt; = &#123;</span><br><span class="line">  //插入元素</span><br><span class="line">  insert: (child, parent, anchor) =&gt; &#123;</span><br><span class="line">    parent.insertBefore(child, anchor || null)</span><br><span class="line">  &#125;,</span><br><span class="line">  // 删除元素</span><br><span class="line">  remove: child =&gt; &#123;</span><br><span class="line">    const parent = child.parentNode</span><br><span class="line">    if (parent) &#123;</span><br><span class="line">      parent.removeChild(child)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 创建元素</span><br><span class="line">  createElement: (tag, isSVG, is, props): Element =&gt; &#123;</span><br><span class="line">    const el = isSVG</span><br><span class="line">      ? doc.createElementNS(svgNS, tag)</span><br><span class="line">      : doc.createElement(tag, is ? &#123; is &#125; : undefined)</span><br><span class="line"></span><br><span class="line">    if (tag === &apos;select&apos; &amp;&amp; props &amp;&amp; props.multiple != null) &#123;</span><br><span class="line">      ;(el as HTMLSelectElement).setAttribute(&apos;multiple&apos;, props.multiple)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return el</span><br><span class="line">  &#125;</span><br><span class="line">  //...其他操作函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在后面的代码中，我们通过 createRenderer 函数区创建了一个渲染器。通过参数 options 获取增删改查所有的函数以后，在内部的 render、mount、patch 等函数中，需要去渲染一个元素的时候，就可以通过 option.createElement 和 option.insert 来实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">export default function createRenderer(options) &#123;</span><br><span class="line">  const &#123;</span><br><span class="line">      insert: hostInsert,</span><br><span class="line">      remove: hostRemove,</span><br><span class="line">      patchProp: hostPatchProp,</span><br><span class="line">      createElement: hostCreateElement,</span><br><span class="line">      createText: hostCreateText,</span><br><span class="line">      createComment: hostCreateComment,</span><br><span class="line">      setText: hostSetText,</span><br><span class="line">      setElementText: hostSetElementText,</span><br><span class="line">      parentNode: hostParentNode,</span><br><span class="line">      nextSibling: hostNextSibling,</span><br><span class="line">      setScopeId: hostSetScopeId = NOOP,</span><br><span class="line">      cloneNode: hostCloneNode,</span><br><span class="line">      insertStaticContent: hostInsertStaticContent</span><br><span class="line">   &#125; = options</span><br><span class="line"></span><br><span class="line">  function render(vnode, container) &#123;  &#125;</span><br><span class="line"></span><br><span class="line">  function mount(vnode, container, isSVG, refNode) &#123;  &#125;</span><br><span class="line"></span><br><span class="line">  function mountElement(vnode, container, isSVG, refNode) &#123;  &#125;</span><br><span class="line"></span><br><span class="line">  function mountText(vnode, container) &#123;  &#125;</span><br><span class="line"></span><br><span class="line">  function patch(prevVNode, nextVNode, container) &#123;  &#125;</span><br><span class="line"></span><br><span class="line">  function replaceVNode(prevVNode, nextVNode, container) &#123;  &#125;</span><br><span class="line">  function patchElement(prevVNode, nextVNode, container) &#123;  &#125;</span><br><span class="line">  function patchChildren(</span><br><span class="line">    prevChildFlags,</span><br><span class="line">    nextChildFlags,</span><br><span class="line">    prevChildren,</span><br><span class="line">    nextChildren,</span><br><span class="line">    container</span><br><span class="line">  ) &#123;  &#125;</span><br><span class="line"></span><br><span class="line">  function patchText(prevVNode, nextVNode) &#123;  &#125;</span><br><span class="line">  function patchComponent(prevVNode, nextVNode, container) &#123;  &#125;</span><br><span class="line"></span><br><span class="line">  return &#123; render &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在每个函数实现的内部，比如 mountElement，我们之前的实现方式是调用浏览器的 API 创建。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function mountElement(vnode, container, isSVG, refNode) &#123;</span><br><span class="line">  const el = isSVG</span><br><span class="line">    ? document.createElementNS(....)</span><br><span class="line">    : document.createElement(vnode.tag)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对比一下，经过渲染器抽离之后，内部的 mountElement 就会把所有 document 的操作全部换成 options 传递进来的 hostCreate 函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function mountElement(vnode, container, isSVG, refNode) &#123;</span><br><span class="line">  const el = hostCreateElement(vnode.tag, isSVG)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们使用后面的代码创建一个具体平台的渲染器，这也是 Vue 3 中的 runtime-dom 包主要做的事。了解了 Vue 中自定义渲染器的实现方式后，我们还可以基于 Vue 3 的 runtime-core 包封装其他平台的渲染器，让其他平台也能使用 Vue 内部的响应式和组件化等优秀的特性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const &#123; render &#125; = createRenderer(&#123;</span><br><span class="line">  nodeOps: &#123;</span><br><span class="line">    createElement() &#123;   &#125;,</span><br><span class="line">    createText() &#123;   &#125;</span><br><span class="line">    // more...</span><br><span class="line">  &#125;,</span><br><span class="line">  patchData</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="自定义渲染"><a href="#自定义渲染" class="headerlink" title="自定义渲染"></a>自定义渲染</h3><p>自定义渲染器让 Vue 脱离了浏览器的限制，我们只需要实现平台内部的增删改查函数后，就可以直接对接 Vue 3。比方说，我们可以把 Vue 渲染到小程序平台；也可以渲染到 Canvas，实现 vue 3-canvas，把虚拟 dom 渲染成 Canvas；甚至还可以尝试把 Vue 3 渲染到 three.js 中，在 3D 世界使用响应式开发。</p>
<p>自定义渲染器的原理，就是把所有的增删改查操作暴露出去，使用的时候不需要知道内部的实现细节，我们只需要针对每个平台使用不同的 API 即可。</p>
<p>自定义渲染器也代表着适配器设计模式的一个实践。除了自定义渲染器 API 的学习，我们也要反思一下自己现在负责的项目中，有哪些地方为了不同的接口或者平台写了太多的判断代码，是否也可以使用类似自定义渲染器的逻辑和模式，把多个组件、平台、接口之间不同的操作方式封装成一个核心模块，去进行单独函数的扩展。</p>
<p>比如下面的代码中，我们对 three.js 进行一个渲染的尝试。它的实现逻辑和 Canvas 比较类似，通过对于对象的维护和 draw 函数实现最终的绘制。在 draw 函数内部，我们调用 three.js 的操作方法去创建 camera，sence，geometry 等概念，最后对外暴露 three.js 的 createApp 函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import &#123; createRenderer &#125; from &apos;@vue/runtime-core&apos;</span><br><span class="line">import * as THREE from &apos;three&apos;</span><br><span class="line">import &#123;nextTick&#125; from &apos;@vue/runtime-core&apos;</span><br><span class="line"></span><br><span class="line">let renderer</span><br><span class="line"></span><br><span class="line">function draw(obj) &#123;</span><br><span class="line">    const &#123;camera,cameraPos, scene, geometry,geometryArg,material,mesh,meshY,meshX&#125; = obj</span><br><span class="line">    if([camera,cameraPos, scene, geometry,geometryArg,material,mesh,meshY,meshX].filter(v=&gt;v).length&lt;9)&#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    let cameraObj = new THREE[camera]( 40, window.innerWidth / window.innerHeight, 0.1, 10 )</span><br><span class="line">    Object.assign(cameraObj.position,cameraPos)</span><br><span class="line"></span><br><span class="line">    let sceneObj = new THREE[scene]()</span><br><span class="line"></span><br><span class="line">    let geometryObj = new THREE[geometry]( ...geometryArg)</span><br><span class="line">    let materialObj = new THREE[material]()</span><br><span class="line"></span><br><span class="line">    let meshObj = new THREE[mesh]( geometryObj, materialObj )</span><br><span class="line">    meshObj.rotation.x = meshX</span><br><span class="line">    meshObj.rotation.y = meshY</span><br><span class="line">    sceneObj.add( meshObj )</span><br><span class="line">    renderer.render( sceneObj, cameraObj );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const &#123; createApp: originCa &#125; = createRenderer(&#123;</span><br><span class="line">  insert: (child, parent, anchor) =&gt; &#123;</span><br><span class="line">    if(parent.domElement)&#123;</span><br><span class="line">        draw(child)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  createElement(type, isSVG, isCustom) &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      type</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  setElementText(node, text) &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  patchProp(el, key, prev, next) &#123;</span><br><span class="line">    el[key] = next</span><br><span class="line">    draw(el)</span><br><span class="line">  &#125;,</span><br><span class="line">  parentNode: node =&gt; node,</span><br><span class="line">  nextSibling: node =&gt; node,</span><br><span class="line">  createText: text =&gt; text,</span><br><span class="line">  remove:node=&gt;node</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">function createApp(...args) &#123;</span><br><span class="line">  const app = originCa(...args)</span><br><span class="line">  return &#123;</span><br><span class="line">    mount(selector) &#123;</span><br><span class="line">        renderer = new THREE.WebGLRenderer( &#123; antialias: true &#125; );</span><br><span class="line">        renderer.setSize( window.innerWidth, window.innerHeight );</span><br><span class="line">        document.body.appendChild( renderer.domElement );</span><br><span class="line">        app.mount(renderer)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export &#123; createApp &#125;</span><br></pre></td></tr></table></figure>
<p>然后我们在 App.vue 中，使用下面的代码渲染出一个立方体，并且通过 ref 响应式对象控制立方体偏移的监督，再通过 setInterval 实现立方体的动画</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div</span><br><span class="line">        camera=&quot;PerspectiveCamera&quot;</span><br><span class="line">        :cameraPos=&#123;z:1&#125;</span><br><span class="line">        scene=&quot;Scene&quot;</span><br><span class="line">        geometry=&quot;BoxGeometry&quot;</span><br><span class="line">        :geometryArg=&quot;[0.2,0.2,0.2]&quot;</span><br><span class="line">        material=&quot;MeshNormalMaterial&quot;</span><br><span class="line">        mesh=&quot;Mesh&quot;</span><br><span class="line">        :meshY=&quot;y&quot;</span><br><span class="line">        :meshX=&quot;x&quot;</span><br><span class="line">    &gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123;ref&#125; from &apos;vue&apos;</span><br><span class="line">export default &#123;</span><br><span class="line">    setup()&#123;</span><br><span class="line">        const y = ref(0.3)</span><br><span class="line">        const x = ref(0.3)</span><br><span class="line">        setInterval(()=&gt;&#123;</span><br><span class="line">            y.value+=0.3</span><br><span class="line">            x.value+=0.5</span><br><span class="line">        &#125;,100)</span><br><span class="line">        return &#123;y,x&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="万能的面试题，怎么手写响应式系统"><a href="#万能的面试题，怎么手写响应式系统" class="headerlink" title="万能的面试题，怎么手写响应式系统"></a>万能的面试题，怎么手写响应式系统</h2><h3 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h3><p>响应式机制可以自动收集系统中数据的依赖，并且在修改数据之后自动执行更新，极大提高开发的效率。</p>
<p>响应式机制的主要功能就是，可以把普通的 JavaScript 对象封装成为响应式对象，拦截数据的获取和修改操作，实现依赖数据的自动化更新。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const &#123;effect, reactive&#125; = require(&apos;@vue/reactivity&apos;)</span><br><span class="line"></span><br><span class="line">let dummy</span><br><span class="line">const counter = reactive(&#123; num1: 1, num2: 2 &#125;)</span><br><span class="line">effect(() =&gt; &#123;</span><br><span class="line">  dummy = counter.num1 + counter.num2</span><br><span class="line">  console.log(dummy)// 每次counter.num1修改都会打印日志</span><br><span class="line">&#125;)</span><br><span class="line">setInterval(()=&gt;&#123;</span><br><span class="line">  counter.num1++</span><br><span class="line">&#125;,1000)</span><br><span class="line"></span><br><span class="line">在 effect 中获取 counter.num1 和 counter.num2 的时候，就会触发 counter 的 get 拦截函数；get 函数，会把当前的 effect 函数注册到一个全局的依赖地图中去。这样 counter.num1 在修改的时候，就会触发 set 拦截函数，去依赖地图中找到注册的 effect 函数，然后执行。</span><br></pre></td></tr></table></figure>
<h3 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">export function reactive(target) &#123;</span><br><span class="line">  if (typeof target!==&apos;object&apos;) &#123;</span><br><span class="line">    console.warn(`reactive  $&#123;target&#125; 必须是一个对象`);</span><br><span class="line">    return target</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return new Proxy(target, mutableHandlers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="mutableHandles"><a href="#mutableHandles" class="headerlink" title="mutableHandles"></a>mutableHandles</h3><p>我们使用 createGetter 和 createSetters 来创建 set 和 get 函数，mutableHandles 就是配置了 set 和 get 的对象返回。<br>get 中直接返回读取的数据，这里的 Reflect.get 和 target[key]实现的结果是一致的；并且返回值是对象的话，还会嵌套执行 reactive，并且调用 track 函数收集依赖。<br>set 中调用 trigger 函数，执行 track 收集的依赖。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const get = createGetter();</span><br><span class="line">const set = createSetter();</span><br><span class="line"></span><br><span class="line">function createGetter(shallow = false) &#123;</span><br><span class="line">  return function get(target, key, receiver) &#123;</span><br><span class="line">    const res = Reflect.get(target, key, receiver)</span><br><span class="line">    track(target, &quot;get&quot;, key)</span><br><span class="line">    if (isObject(res)) &#123;</span><br><span class="line">      // 值也是对象的话，需要嵌套调用reactive</span><br><span class="line">      // res就是target[key]</span><br><span class="line">      // 浅层代理，不需要嵌套</span><br><span class="line">      return shallow ? res : reactive(res)</span><br><span class="line">    &#125;</span><br><span class="line">    return res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createSetter() &#123;</span><br><span class="line">  return function set(target, key, value, receiver) &#123;</span><br><span class="line">    const result = Reflect.set(target, key, value, receiver)</span><br><span class="line">    // 在触发 set 的时候进行触发依赖</span><br><span class="line">    trigger(target, &quot;set&quot;, key)</span><br><span class="line">    return result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export const mutableHandles = &#123;</span><br><span class="line">  get,</span><br><span class="line">  set,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="track"><a href="#track" class="headerlink" title="track"></a>track</h3><p>在 track 函数中，我们可以使用一个巨大的 targetMap 去存储依赖关系。map 的 key 是我们要代理的 target 对象，值还是一个 depsMap，存储这每一个 key 依赖的函数，每一个 key 都可以依赖多个 effect。上面的代码执行完成，depsMap 中就有了 num1 和 num2 两个依赖。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">targetMap = &#123;</span><br><span class="line"> target： &#123;</span><br><span class="line">   key1: [回调函数1，回调函数2],</span><br><span class="line">   key2: [回调函数3，回调函数4],</span><br><span class="line"> &#125;  ,</span><br><span class="line">  target1： &#123;</span><br><span class="line">   key3: [回调函数5]</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const targetMap = new WeakMap()</span><br><span class="line"></span><br><span class="line">export function track(target, type, key) &#123;</span><br><span class="line"></span><br><span class="line">  // console.log(`触发 track -&gt; target: $&#123;target&#125; type:$&#123;type&#125; key:$&#123;key&#125;`)</span><br><span class="line"></span><br><span class="line">  // 1. 先基于 target 找到对应的 dep</span><br><span class="line">  // 如果是第一次的话，那么就需要初始化</span><br><span class="line">  // &#123;</span><br><span class="line">  //   target1: &#123;//depsmap</span><br><span class="line">  //     key:[effect1,effect2]</span><br><span class="line">  //   &#125;</span><br><span class="line">  // &#125;</span><br><span class="line">  let depsMap = targetMap.get(target)</span><br><span class="line">  if (!depsMap) &#123;</span><br><span class="line">    // 初始化 depsMap 的逻辑</span><br><span class="line">    // depsMap = new Map()</span><br><span class="line">    // targetMap.set(target, depsMap)</span><br><span class="line">    // 上面两行可以简写成下面的</span><br><span class="line">    targetMap.set(target, (depsMap = new Map()))</span><br><span class="line">  &#125;</span><br><span class="line">  let deps = depsMap.get(key)</span><br><span class="line">  if (!deps) &#123;</span><br><span class="line">    deps = new Set()</span><br><span class="line">  &#125;</span><br><span class="line">  if (!deps.has(activeEffect) &amp;&amp; activeEffect) &#123;</span><br><span class="line">    // 防止重复注册</span><br><span class="line">    deps.add(activeEffect)</span><br><span class="line">  &#125;</span><br><span class="line">  depsMap.set(key, deps)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="trigger"><a href="#trigger" class="headerlink" title="trigger"></a>trigger</h3><p>有了上面 targetMap 的实现机制，trigger 函数实现的思路就是从 targetMap 中，根据 target 和 key 找到对应的依赖函数集合 deps，然后遍历 deps 执行依赖函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">export function trigger(target, type, key) &#123;</span><br><span class="line">  // console.log(`触发 trigger -&gt; target:  type:$&#123;type&#125; key:$&#123;key&#125;`)</span><br><span class="line">  // 从targetMap中找到触发的函数，执行他</span><br><span class="line">  const depsMap = targetMap.get(target)</span><br><span class="line">  if (!depsMap) &#123;</span><br><span class="line">    // 没找到依赖</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  const deps = depsMap.get(key)</span><br><span class="line">  if (!deps) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  deps.forEach((effectFn) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    if (effectFn.scheduler) &#123;</span><br><span class="line">      effectFn.scheduler()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      effectFn()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="effect"><a href="#effect" class="headerlink" title="effect"></a>effect</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">export function effect(fn, options = &#123;&#125;) &#123;</span><br><span class="line">  // effect嵌套，通过队列管理</span><br><span class="line">  const effectFn = () =&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      activeEffect = effectFn</span><br><span class="line">      //fn执行的时候，内部读取响应式数据的时候，就能在get配置里读取到activeEffect</span><br><span class="line">      return fn()</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      activeEffect = null</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (!options.lazy) &#123;</span><br><span class="line">    //没有配置lazy 直接执行</span><br><span class="line">    effectFn()</span><br><span class="line">  &#125;</span><br><span class="line">  effectFn.scheduler = options.scheduler // 调度时机 watchEffect回用到</span><br><span class="line">  return effectFn</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>ref 的执行逻辑要比 reactive 要简单一些，不需要使用 Proxy 代理语法，直接使用对象语法的 getter 和 setter 配置，监听 value 属性即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">export function ref(val) &#123;</span><br><span class="line">  if (isRef(val)) &#123;</span><br><span class="line">    return val</span><br><span class="line">  &#125;</span><br><span class="line">  return new RefImpl(val)</span><br><span class="line">&#125;</span><br><span class="line">export function isRef(val) &#123;</span><br><span class="line">  return !!(val &amp;&amp; val.__isRef)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ref就是利用面向对象的getter和setters进行track和trigget</span><br><span class="line">class RefImpl &#123;</span><br><span class="line">  constructor(val) &#123;</span><br><span class="line">    this.__isRef = true</span><br><span class="line">    this._val = convert(val)</span><br><span class="line">  &#125;</span><br><span class="line">  get value() &#123;</span><br><span class="line">    track(this, &apos;value&apos;)</span><br><span class="line">    return this._val</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  set value(val) &#123;</span><br><span class="line">    if (val !== this._val) &#123;</span><br><span class="line">      this._val = convert(val)</span><br><span class="line">      trigger(this, &apos;value&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ref也可以支持复杂数据结构</span><br><span class="line">function convert(val) &#123;</span><br><span class="line">  return isObject(val) ? reactive(val) : val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你能很直观地看到，ref 函数实现的相对简单很多，只是利用面向对象的 getter 和 setter 拦截了 value 属性的读写，这也是为什么我们需要操作 ref 对象的 value 属性的原因。<br>值得一提的是，ref 也可以包裹复杂的数据结构，内部会直接调用 reactive 来实现。</p>
<h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><p>Vue 中的 computed 计算属性也是一种特殊的 effect 函数<br>computed 可以传递一个函数或者对象，实现计算属性的读取和修改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">export function computed(getterOrOptions) &#123;</span><br><span class="line">  // getterOrOptions可以是函数，也可以是一个对象，支持get和set</span><br><span class="line">  // 还记得清单应用里的全选checkbox就是一个对象配置的computed</span><br><span class="line">  let getter, setter</span><br><span class="line">  if (typeof getterOrOptions === &apos;function&apos;) &#123;</span><br><span class="line">    getter = getterOrOptions</span><br><span class="line">    setter = () =&gt; &#123;</span><br><span class="line">      console.warn(&apos;计算属性不能修改&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    getter = getterOrOptions.get</span><br><span class="line">    setter = getterOrOptions.set</span><br><span class="line">  &#125;</span><br><span class="line">  return new ComputedRefImpl(getter, setter)</span><br><span class="line">&#125;</span><br><span class="line">class ComputedRefImpl &#123;</span><br><span class="line">  constructor(getter, setter) &#123;</span><br><span class="line">    this._setter = setter</span><br><span class="line">    this._val = undefined</span><br><span class="line">    this._dirty = true</span><br><span class="line">    // computed就是一个特殊的effect，设置lazy和执行时机</span><br><span class="line">    this.effect = effect(getter, &#123;</span><br><span class="line">      lazy: true,</span><br><span class="line">      scheduler: () =&gt; &#123;</span><br><span class="line">        if (!this._dirty) &#123;</span><br><span class="line">          this._dirty = true</span><br><span class="line">          trigger(this, &apos;value&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  get value() &#123;</span><br><span class="line">    track(this, &apos;value&apos;)</span><br><span class="line">    if (this._dirty) &#123;</span><br><span class="line">      this._dirty = false</span><br><span class="line">      this._val = this.effect()</span><br><span class="line">    &#125;</span><br><span class="line">    return this._val</span><br><span class="line">  &#125;</span><br><span class="line">  set value(val) &#123;</span><br><span class="line">    this._setter(val)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行时：Vue-在浏览器里是怎么跑起来的？"><a href="#运行时：Vue-在浏览器里是怎么跑起来的？" class="headerlink" title="运行时：Vue 在浏览器里是怎么跑起来的？"></a>运行时：Vue 在浏览器里是怎么跑起来的？</h2><h3 id="首次渲染"><a href="#首次渲染" class="headerlink" title="首次渲染"></a>首次渲染</h3><p>想要启动一个 Vue 项目，只需要从 Vue 中引入 createApp，传入 App 组件，并且调用 createApp 返回的 App 实例的 mount 方法，就实现了项目的启动。这个时候 Vue 也完成了首次渲染。<br>所以 createApp 就是项目的初始化渲染入口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">export const createApp = ((...args) =&gt; &#123;</span><br><span class="line">  const app = ensureRenderer().createApp(...args)</span><br><span class="line">  const &#123; mount &#125; = app</span><br><span class="line">  // 重写mount</span><br><span class="line">  app.mount = (containerOrSelector: Element | ShadowRoot | string): any =&gt; &#123;</span><br><span class="line">    const container = normalizeContainer(containerOrSelector)</span><br><span class="line">    if (!container) return</span><br><span class="line"></span><br><span class="line">    const component = app._component</span><br><span class="line">    if (!isFunction(component) &amp;&amp; !component.render &amp;&amp; !component.template) &#123;</span><br><span class="line">      component.template = container.innerHTML</span><br><span class="line">    &#125;</span><br><span class="line">    container.innerHTML = &apos;&apos;</span><br><span class="line">    const proxy = mount(container, false, container instanceof SVGElement)</span><br><span class="line">    if (container instanceof Element) &#123;</span><br><span class="line">      container.removeAttribute(&apos;v-cloak&apos;)</span><br><span class="line">      container.setAttribute(&apos;data-v-app&apos;, &apos;&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    return proxy</span><br><span class="line">  &#125;</span><br><span class="line">  return app</span><br><span class="line">&#125;)</span><br><span class="line">function normalizeContainer(container)&#123;</span><br><span class="line">  if (isString(container)) &#123;</span><br><span class="line">    const res = document.querySelector(container)</span><br><span class="line">  &#125;</span><br><span class="line">  return container</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 ensureRenderer 函数，内部通过 createRenderer 函数，创建了一个浏览器的渲染器，并且缓存了渲染器 renderer，这种使用闭包做缓存的方式，你在日常开发中也可以借鉴这种思路。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 浏览器dom操作</span><br><span class="line">import &#123; nodeOps &#125; from &apos;./nodeOps&apos;</span><br><span class="line">// 浏览器dom属性更新</span><br><span class="line">import &#123; patchProp &#125; from &apos;./patchProp&apos;</span><br><span class="line">import &#123; createRenderer &#125; from &apos;@vue/runtime-core&apos;</span><br><span class="line">const rendererOptions = extend(&#123; patchProp &#125;, nodeOps)</span><br><span class="line"></span><br><span class="line">let renderer: Renderer&lt;Element | ShadowRoot&gt; | HydrationRenderer</span><br><span class="line"></span><br><span class="line">function ensureRenderer() &#123;</span><br><span class="line">  return (</span><br><span class="line">    renderer ||</span><br><span class="line">    (renderer = createRenderer&lt;Node, Element | ShadowRoot&gt;(rendererOptions))</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>createRenderer 是调用 baseCreateRenderer 创建的，baseCreateRenderer 首先获取了平台上所有的 insert、remove 函数，这些函数都是 nodeOps 传递进来的，然后定义了一些 patch、mount、unmount 函数，通过名字我们不难猜出，这就是 Vue 中更新、渲染组件的工具函数，比如 mountElement 就是渲染 DOM 元素、mountComponent 就是渲染组件 updateComponent 就是更新组件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">export function createRenderer&lt;</span><br><span class="line">  HostNode = RendererNode,</span><br><span class="line">  HostElement = RendererElement</span><br><span class="line">&gt;(options: RendererOptions&lt;HostNode, HostElement&gt;) &#123;</span><br><span class="line">  return baseCreateRenderer&lt;HostNode, HostElement&gt;(options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function baseCreateRenderer()&#123;</span><br><span class="line">    const &#123;</span><br><span class="line">    insert: hostInsert,</span><br><span class="line">    remove: hostRemove,</span><br><span class="line">    patchProp: hostPatchProp,</span><br><span class="line">    createElement: hostCreateElement,</span><br><span class="line">    createText: hostCreateText,</span><br><span class="line">    createComment: hostCreateComment,</span><br><span class="line">    setText: hostSetText,</span><br><span class="line">    setElementText: hostSetElementText,</span><br><span class="line">    parentNode: hostParentNode,</span><br><span class="line">    nextSibling: hostNextSibling,</span><br><span class="line">    setScopeId: hostSetScopeId = NOOP,</span><br><span class="line">    cloneNode: hostCloneNode,</span><br><span class="line">    insertStaticContent: hostInsertStaticContent</span><br><span class="line">  &#125; = options</span><br><span class="line">  const patch = ()=&gt;... //一个函数</span><br><span class="line">  const processText = ()=&gt;...</span><br><span class="line">  const processCommentNode = ()=&gt;...</span><br><span class="line">  const processElement = ()=&gt;...</span><br><span class="line">  const mountElement = ()=&gt;...</span><br><span class="line">  const mountChildren = ()=&gt;...</span><br><span class="line">  const patchElement = ()=&gt;...</span><br><span class="line">  const patchBlockChildren = ()=&gt;...</span><br><span class="line">  const patchProps = ()=&gt;...</span><br><span class="line">  const processComponent = ()=&gt;...</span><br><span class="line">  const mountComponent = ()=&gt;...</span><br><span class="line">  const updateComponent = ()=&gt;...</span><br><span class="line">  const setupRenderEffect = ()=&gt;...</span><br><span class="line">  const patchChildren = ()=&gt;...</span><br><span class="line">  const patchKeyedChildren = ()=&gt;...</span><br><span class="line">  const unmount = ()=&gt;...</span><br><span class="line">  const unmountComponent = ()=&gt;...</span><br><span class="line">  const unmountComponent = ()=&gt;...</span><br><span class="line">  const unmountComponent = ()=&gt;...</span><br><span class="line">  const unmountComponent = ()=&gt;...</span><br><span class="line">  const render: RootRenderFunction = (vnode, container, isSVG) =&gt; &#123;</span><br><span class="line">    if (vnode == null) &#123;</span><br><span class="line">      if (container._vnode) &#123;</span><br><span class="line">        unmount(container._vnode, null, null, true)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      patch(container._vnode || null, vnode, container, null, null, null, isSVG)</span><br><span class="line">    &#125;</span><br><span class="line">    flushPostFlushCbs()</span><br><span class="line">    container._vnode = vnode</span><br><span class="line">  &#125;</span><br><span class="line">  return &#123;</span><br><span class="line">    render,</span><br><span class="line">    hydrate,</span><br><span class="line">    createApp: createAppAPI(render, hydrate)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后返回的 createApp 方法，实际上是 createAPI 的返回值，并且给 createAPI 传递了 render 方法。render 方法内部很简单，就是判断 container 容器上有没有 _vnode 属性，如果有的话就执行 unmount 方法，没有的话就执行 patch 方法，最后把 vnode 信息存储在 container._vnode 上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">export function createAppAPI&lt;HostElement&gt;(</span><br><span class="line">  render: RootRenderFunction,</span><br><span class="line">  hydrate?: RootHydrateFunction</span><br><span class="line">): CreateAppFunction&lt;HostElement&gt; &#123;</span><br><span class="line">  return function createApp(rootComponent, rootProps = null) &#123;</span><br><span class="line">    const context = createAppContext()</span><br><span class="line">    let isMounted = false</span><br><span class="line"></span><br><span class="line">    const app: App = (context.app = &#123;</span><br><span class="line">      _context: context,</span><br><span class="line">      _instance: null,</span><br><span class="line">      use(plugin: Plugin, ...options: any[]) ,</span><br><span class="line">      component(name: string, component?: Component): any &#123;</span><br><span class="line">        if (!component) &#123;</span><br><span class="line">          return context.components[name]</span><br><span class="line">        &#125;</span><br><span class="line">        context.components[name] = component</span><br><span class="line">        return app</span><br><span class="line">      &#125;,</span><br><span class="line">      directive(name: string, directive?: Directive)</span><br><span class="line">      mount(</span><br><span class="line">        rootContainer: HostElement,</span><br><span class="line">        isHydrate?: boolean,</span><br><span class="line">        isSVG?: boolean</span><br><span class="line">      ): any &#123;</span><br><span class="line">        if (!isMounted) &#123;</span><br><span class="line">          const vnode = createVNode(</span><br><span class="line">            rootComponent as ConcreteComponent,</span><br><span class="line">            rootProps</span><br><span class="line">          )</span><br><span class="line">          vnode.appContext = context</span><br><span class="line">          // 核心的逻辑</span><br><span class="line">          if (isHydrate &amp;&amp; hydrate) &#123;</span><br><span class="line">            hydrate(vnode as VNode&lt;Node, Element&gt;, rootContainer as any)</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            render(vnode, rootContainer, isSVG)</span><br><span class="line">          &#125;</span><br><span class="line">          return getExposeProxy(vnode.component!) || vnode.component!.proxy</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      provide(key, value) &#123;</span><br><span class="line">        context.provides[key as string] = value</span><br><span class="line">        return app</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    return app</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="patch-函数"><a href="#patch-函数" class="headerlink" title="patch 函数"></a>patch 函数</h3><p>其中 n1 是上次渲染的虚拟 DOM，n2 是下次要渲染的虚拟 DOM。</p>
<p>首先可以把 n1 和 n2 做一次判断，如果虚拟 DOM 的节点类型不同，就直接 unmount 之前的节点。因为比如之前是 Button 组件，现在要渲染 Container 组件，就没有计算 diff 的必要，直接把 Button 组件销毁再渲染 Container 即可。</p>
<p>如果 n1 和 n2 类型相同，比如都是 Button 组件或者都是 div 标签，我们需要判断具体的类型再去执行不同的函数，比如 processText、processFragment、processElement 以及 processComponent 等函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const patch: PatchFn = (</span><br><span class="line">  n1,</span><br><span class="line">  n2,</span><br><span class="line">  container,</span><br><span class="line">  anchor = null,</span><br><span class="line">  parentComponent = null,</span><br><span class="line">  parentSuspense = null,</span><br><span class="line">  isSVG = false,</span><br><span class="line">  slotScopeIds = null,</span><br><span class="line">  optimized = __DEV__ &amp;&amp; isHmrUpdating ? false : !!n2.dynamicChildren</span><br><span class="line">) =&gt; &#123;</span><br><span class="line">  // 两次虚拟dom完全一样 啥也不用干</span><br><span class="line">  if (n1 === n2) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  // 虚拟dom节点类型不一样， unmount老的虚拟dom，并且n1赋值null</span><br><span class="line">  if (n1 &amp;&amp; !isSameVNodeType(n1, n2)) &#123;</span><br><span class="line">    anchor = getNextHostNode(n1)</span><br><span class="line">    unmount(n1, parentComponent, parentSuspense, true)</span><br><span class="line">    n1 = null</span><br><span class="line">  &#125;</span><br><span class="line">  // n2是要渲染的虚拟dom，我们获取type，ref和shapeFlag</span><br><span class="line">  const &#123; type, ref, shapeFlag &#125; = n2</span><br><span class="line">  switch (type) &#123;</span><br><span class="line">    case Text:</span><br><span class="line">      // 文本</span><br><span class="line">      processText(n1, n2, container, anchor)</span><br><span class="line">      break</span><br><span class="line">    case Comment:</span><br><span class="line">      // 注释</span><br><span class="line">      processCommentNode(n1, n2, container, anchor)</span><br><span class="line">      break</span><br><span class="line">    case Static:</span><br><span class="line">      // 静态节点</span><br><span class="line">      if (n1 == null) &#123;</span><br><span class="line">        mountStaticNode(n2, container, anchor, isSVG)</span><br><span class="line">      &#125; else if (__DEV__) &#123;</span><br><span class="line">        patchStaticNode(n1, n2, container, isSVG)</span><br><span class="line">      &#125;</span><br><span class="line">      break</span><br><span class="line">    case Fragment:</span><br><span class="line">      processFragment(</span><br><span class="line">        n1,</span><br><span class="line">        n2,</span><br><span class="line">        container,</span><br><span class="line">        anchor,</span><br><span class="line">        parentComponent,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        isSVG,</span><br><span class="line">        slotScopeIds,</span><br><span class="line">        optimized</span><br><span class="line">      )</span><br><span class="line">      break</span><br><span class="line">    default:</span><br><span class="line">      // 运运算判断操作类型</span><br><span class="line">      if (shapeFlag &amp; ShapeFlags.ELEMENT) &#123;</span><br><span class="line">        // html标签</span><br><span class="line">        processElement(</span><br><span class="line">          n1,</span><br><span class="line">          n2,</span><br><span class="line">          container,</span><br><span class="line">          anchor,</span><br><span class="line">          parentComponent,</span><br><span class="line">          parentSuspense,</span><br><span class="line">          isSVG,</span><br><span class="line">          slotScopeIds,</span><br><span class="line">          optimized</span><br><span class="line">        )</span><br><span class="line">      &#125; else if (shapeFlag &amp; ShapeFlags.COMPONENT) &#123;</span><br><span class="line">        // 组件</span><br><span class="line">        processComponent(</span><br><span class="line">          n1,</span><br><span class="line">          n2,</span><br><span class="line">          container,</span><br><span class="line">          anchor,</span><br><span class="line">          parentComponent,</span><br><span class="line">          parentSuspense,</span><br><span class="line">          isSVG,</span><br><span class="line">          slotScopeIds,</span><br><span class="line">          optimized</span><br><span class="line">        )</span><br><span class="line">      &#125; else if (shapeFlag &amp; ShapeFlags.TELEPORT) &#123;</span><br><span class="line">        ;(type as typeof TeleportImpl).process(</span><br><span class="line">          n1 as TeleportVNode,</span><br><span class="line">          n2 as TeleportVNode,</span><br><span class="line">          container,</span><br><span class="line">          anchor,</span><br><span class="line">          parentComponent,</span><br><span class="line">          parentSuspense,</span><br><span class="line">          isSVG,</span><br><span class="line">          slotScopeIds,</span><br><span class="line">          optimized,</span><br><span class="line">          internals</span><br><span class="line">        )</span><br><span class="line">      &#125; else if (__FEATURE_SUSPENSE__ &amp;&amp; shapeFlag &amp; ShapeFlags.SUSPENSE) &#123;</span><br><span class="line">        ;(type as typeof SuspenseImpl).process(</span><br><span class="line">          n1,</span><br><span class="line">          n2,</span><br><span class="line">          container,</span><br><span class="line">          anchor,</span><br><span class="line">          parentComponent,</span><br><span class="line">          parentSuspense,</span><br><span class="line">          isSVG,</span><br><span class="line">          slotScopeIds,</span><br><span class="line">          optimized,</span><br><span class="line">          internals</span><br><span class="line">        )</span><br><span class="line">      &#125; else if (__DEV__) &#123;</span><br><span class="line">        warn(&apos;Invalid VNode type:&apos;, type, `($&#123;typeof type&#125;)`)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // set ref</span><br><span class="line">  if (ref != null &amp;&amp; parentComponent) &#123;</span><br><span class="line">    setRef(ref, n1 &amp;&amp; n1.ref, parentSuspense, n2 || n1, !n2)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们首次渲染的 App 是一个组件，所以要执行的就是 processComponent 方法。</p>
<h3 id="processComponent-方法"><a href="#processComponent-方法" class="headerlink" title="processComponent 方法"></a>processComponent 方法</h3><p>那我们继续进入到 processComponent 代码内部，看下面的代码。首次渲染的时候，n1 就是 null，所以会执行 mountComponent；如果是更新组件的时候，n1 就是上次渲染的 vdom，需要执行 updateComponent。</p>
<p>进入 mountComponent 函数中，可以看到 mountComponent 函数内部会对组件的类型进行一系列的判断，还有一些对 Vue 2 的兼容代码，核心的渲染逻辑就是 setupComponent 函数和 setupRenderEffect 函数。</p>
<h3 id="setupComponent"><a href="#setupComponent" class="headerlink" title="setupComponent"></a>setupComponent</h3><p>内部先初始化了 props 和 slots，并且执行 setupStatefulComponent 创建组件，而这个函数内部从 component 中获取 setup 属性，也就是 script setup 内部实现的函数，就进入到我们组件内部的 reactive、ref 等函数实现的逻辑了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">export function setupComponent(</span><br><span class="line">  instance: ComponentInternalInstance,</span><br><span class="line">  isSSR = false</span><br><span class="line">) &#123;</span><br><span class="line">  isInSSRComponentSetup = isSSR</span><br><span class="line"></span><br><span class="line">  const &#123; props, children &#125; = instance.vnode</span><br><span class="line">  const isStateful = isStatefulComponent(instance)</span><br><span class="line">  initProps(instance, props, isStateful, isSSR)</span><br><span class="line">  initSlots(instance, children)</span><br><span class="line"></span><br><span class="line">  const setupResult = isStateful</span><br><span class="line">    ? setupStatefulComponent(instance, isSSR)</span><br><span class="line">    : undefined</span><br><span class="line">  isInSSRComponentSetup = false</span><br><span class="line">  return setupResult</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function setupStatefulComponent(</span><br><span class="line">  instance: ComponentInternalInstance,</span><br><span class="line">  isSSR: boolean</span><br><span class="line">) &#123;</span><br><span class="line">  const Component = instance.type as ComponentOptions</span><br><span class="line">  // 执行setup</span><br><span class="line">  const &#123; setup &#125; = Component</span><br><span class="line">  if (setup) &#123;</span><br><span class="line">    const setupContext = (instance.setupContext =</span><br><span class="line">      setup.length &gt; 1 ? createSetupContext(instance) : null)</span><br><span class="line"></span><br><span class="line">    setCurrentInstance(instance)</span><br><span class="line">    pauseTracking()</span><br><span class="line">    const setupResult = callWithErrorHandling(</span><br><span class="line">      setup,</span><br><span class="line">      instance,</span><br><span class="line">      ErrorCodes.SETUP_FUNCTION,</span><br><span class="line">      [instance.props, setupContext]</span><br><span class="line">    )</span><br><span class="line">    if (isPromise(setupResult)) &#123;</span><br><span class="line">      setupResult.then(unsetCurrentInstance, unsetCurrentInstance)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      handleSetupResult(instance, setupResult, isSSR)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    finishComponentSetup(instance, isSSR)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function callWithErrorHandling(</span><br><span class="line">  fn: Function,</span><br><span class="line">  instance: ComponentInternalInstance | null,</span><br><span class="line">  type: ErrorTypes,</span><br><span class="line">  args?: unknown[]</span><br><span class="line">) &#123;</span><br><span class="line">  let res</span><br><span class="line">  try &#123;</span><br><span class="line">    res = args ? fn(...args) : fn()</span><br><span class="line">  &#125; catch (err) &#123;</span><br><span class="line">    handleError(err, instance, type)</span><br><span class="line">  &#125;</span><br><span class="line">  return res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="setupRenderEffect"><a href="#setupRenderEffect" class="headerlink" title="setupRenderEffect"></a>setupRenderEffect</h3><p>在下面的核心代码中，我们通过 ReactiveEffect 创建了 effect 函数，这个概念上一讲我们手写过，然后执行 instance.update 赋值为 effect.run 方法，这样结合 setup 内部的 ref 和 reactive 绑定的数据，数据修改之后，就会触发 update 方法的执行，内部就会 componentUpdateFn，内部进行递归的 patch 调用执行每个组件内部的 update 方法实现组件的更新。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">if (!instance.isMounted) &#123;</span><br><span class="line">     patch(</span><br><span class="line">        null,</span><br><span class="line">        subTree,</span><br><span class="line">        container,</span><br><span class="line">        anchor,</span><br><span class="line">        instance,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        isSVG</span><br><span class="line">      )</span><br><span class="line">&#125;else&#123;</span><br><span class="line">  // updateComponent</span><br><span class="line">&#125;</span><br><span class="line">// create reactive effect for rendering</span><br><span class="line">const effect = new ReactiveEffect(</span><br><span class="line">  componentUpdateFn,</span><br><span class="line">  () =&gt; queueJob(instance.update),</span><br><span class="line">  instance.scope // track it in component&apos;s effect scope</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const update = (instance.update = effect.run.bind(effect) as SchedulerJob)</span><br><span class="line">update.id = instance.uid</span><br><span class="line"></span><br><span class="line">update()</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Vue 通过 createApp 创建应用，并且执行返回的 mount 方法实现在浏览器中的挂载，在 createApp 中，通过传递浏览器平台的操作方法 nodeOps 创建了浏览器的渲染器 renderer。</p>
<p>首次执行 Vue 项目的时候，通过 patch 实现组件的渲染，patch 函数内部根据节点的不同类型，去分别执行 processElement、processComponent、processText 等方法去递归处理不同类型的节点，最终通过 setupComponent 执行组件的 setup 函数，setupRenderEffect 中使用响应式的 effect 函数监听数据的变化。</p>
<h2 id="虚拟-DOM（上）：如何通过虚拟-DOM-更新页面？"><a href="#虚拟-DOM（上）：如何通过虚拟-DOM-更新页面？" class="headerlink" title="虚拟 DOM（上）：如何通过虚拟 DOM 更新页面？"></a>虚拟 DOM（上）：如何通过虚拟 DOM 更新页面？</h2><p>Vue 项目的首次渲染流程，在 mountComponent 中注册了 effect 函数，这样，在组件数据有更新的时候，就会通知到组件的 update 方法进行更新。</p>
<p>Vue 内部的虚拟 DOM，也就是 vnode，就是一个对象，通过 type、props、children 等属性描述整个节点</p>
<p>Vue 源码中的实现首次渲染和更新的逻辑都写在一起，我们在递归的时候如果对一个标签实现更新和渲染，就可以用一个函数实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const componentUpdateFn = ()=&gt;&#123;</span><br><span class="line">  if (!instance.isMounted) &#123;</span><br><span class="line">      //首次渲染</span><br><span class="line">      instance,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        isSVG</span><br><span class="line">      )</span><br><span class="line">      。。。</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    let &#123; next, bu, u, parent, vnode &#125; = instance</span><br><span class="line">    if (next) &#123;</span><br><span class="line">      next.el = vnode.el</span><br><span class="line">      updateComponentPreRender(instance, next, optimized)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      next = vnode</span><br><span class="line">    &#125;</span><br><span class="line">    const nextTree = renderComponentRoot(instance)</span><br><span class="line">      patch(</span><br><span class="line">        prevTree,</span><br><span class="line">        nextTree,</span><br><span class="line">        // parent may have changed if it&apos;s in a teleport</span><br><span class="line">        hostParentNode(prevTree.el!)!,</span><br><span class="line">        // anchor may have changed if it&apos;s in a fragment</span><br><span class="line">        getNextHostNode(prevTree),</span><br><span class="line">        instance,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        isSVG</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 注册effect函数</span><br><span class="line">const effect = new ReactiveEffect(</span><br><span class="line">  componentUpdateFn,</span><br><span class="line">  () =&gt; queueJob(instance.update),</span><br><span class="line">  instance.scope // track it in component&apos;s effect scope</span><br><span class="line">)</span><br><span class="line">const update = (instance.update = effect.run.bind(effect) as S      chedulerJob)</span><br><span class="line">update()</span><br><span class="line"></span><br><span class="line">  const updateComponentPreRender = (</span><br><span class="line">    instance: ComponentInternalInstance,</span><br><span class="line">    nextVNode: VNode,</span><br><span class="line">    optimized: boolean</span><br><span class="line">  ) =&gt; &#123;</span><br><span class="line">    nextVNode.component = instance</span><br><span class="line">    const prevProps = instance.vnode.props</span><br><span class="line">    instance.vnode = nextVNode</span><br><span class="line">    instance.next = null</span><br><span class="line">    updateProps(instance, nextVNode.props, prevProps, optimized)</span><br><span class="line">    updateSlots(instance, nextVNode.children, optimized)</span><br><span class="line"></span><br><span class="line">    pauseTracking()</span><br><span class="line">    // props update may have triggered pre-flush watchers.</span><br><span class="line">    // flush them before the render update.</span><br><span class="line">    flushPreFlushCbs(undefined, instance.update)</span><br><span class="line">    resetTracking()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="patch-函数-1"><a href="#patch-函数-1" class="headerlink" title="patch 函数"></a>patch 函数</h3><p>在 patch 函数中，会针对不同的组件类型执行不同的函数，组件我们会执行 processComponent，HTML 标签我们会执行 processElement</p>
<p>由于更新之后不是首次渲染了，patch 函数内部会执行 updateComponent，看下面的 updateComponent 函数内部，shouldUpdateComponent 会判断组件是否需要更新，实际执行的是 instance.update</p>
<p>组件的子元素是由 HTML 标签和组件构成，组件内部的递归处理最终也是对 HTML 标签的处理，所以，最后组件的更新都会进入到 processElement 内部的 patchElement 函数中。</p>
<h3 id="patchElement-函数"><a href="#patchElement-函数" class="headerlink" title="patchElement 函数"></a>patchElement 函数</h3><p>在函数 patchElement 中我们主要就做两件事，更新节点自己的属性和更新子元素。</p>
<h4 id="节点自身属性的更新"><a href="#节点自身属性的更新" class="headerlink" title="节点自身属性的更新"></a>节点自身属性的更新</h4><p>先看自身属性的更新，这里就能体现出 Vue 3 中性能优化的思想，通过 patchFlag 可以做到按需更新：<br>如果标记了 FULL_PROPS，就直接调用 patchProps。<br>如果标记了 CLASS，说明节点只有 class 属性是动态的，其他的 style 等属性都不需要进行判断和 DOM 操作。</p>
<p>Vue 3 的虚拟 DOM 真正做到了按需更新，这也是相比于 React 的一个优势。</p>
<h4 id="子元素的更新"><a href="#子元素的更新" class="headerlink" title="子元素的更新"></a>子元素的更新</h4><p>子元素的更新是 patchChildren 函数负责的，这个函数也是虚拟 DOM 中难度最高的一个函数。</p>
<p>首先我们把子元素分成了文本、数组和空三个状态，新老子元素分别是这三种状态的一个，构成了不同的执行逻辑。这样 patchChildren 内部大致有五种情况需要处理：<br>如果新的子元素是空， 老的子元素不为空，直接卸载 unmount 即可。<br>如果新的子元素不为空，老的子元素是空，直接创建加载即可。<br>如果新的子元素是文本，老的子元素如果是数组就需要全部 unmount，是文本的话就需要执行 hostSetElementText。<br>如果新的子元素是数组，比如是使用 v-for 渲染出来的列表，老的子元素如果是空或者文本，直接 unmount 后，渲染新的数组即可。<br>最复杂的情况就是新的子元素和老的子元素都是数组。</p>
<p>最朴实无华的思路就是把老的子元素全部 unmount，新的子元素全部 mount，这样虽然可以实现功能，但是没法复用已经存在的 DOM 元素，比如我们只是在数组中间新增了一个数据，全部 DOM 都销毁就有点太可惜了。</p>
<p>所以，我们需要判断出可以复用的 DOM 元素，如果一个虚拟 DOM 没有改动或者属性变了，不需要完全销毁重建，而是更新一下属性，最大化减少 DOM 的操作，这个任务就会交给 patchKeyedChildren 函数去完成。</p>
<p>patchKeyedChildren 函数，做的事情就是尽可能高效地把老的子元素更新成新的子元素，如何高效复用老的子元素中的 DOM 元素是 patchKeyedChildren 函数的难点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const patchChildren: PatchChildrenFn = (</span><br><span class="line">  n1,</span><br><span class="line">  n2,</span><br><span class="line">  container,</span><br><span class="line">  anchor,</span><br><span class="line">  parentComponent,</span><br><span class="line">  parentSuspense,</span><br><span class="line">  isSVG,</span><br><span class="line">  slotScopeIds,</span><br><span class="line">  optimized = false</span><br><span class="line">) =&gt; &#123;</span><br><span class="line">  const c1 = n1 &amp;&amp; n1.children</span><br><span class="line">  const prevShapeFlag = n1 ? n1.shapeFlag : 0</span><br><span class="line">  const c2 = n2.children</span><br><span class="line"></span><br><span class="line">  const &#123; patchFlag, shapeFlag &#125; = n2</span><br><span class="line">  // fast path</span><br><span class="line">  if (patchFlag &gt; 0) &#123;</span><br><span class="line">    if (patchFlag &amp; PatchFlags.KEYED_FRAGMENT) &#123;</span><br><span class="line">      // this could be either fully-keyed or mixed (some keyed some not)</span><br><span class="line">      // presence of patchFlag means children are guaranteed to be arrays</span><br><span class="line">      patchKeyedChildren(</span><br><span class="line">        c1 as VNode[],</span><br><span class="line">        c2 as VNodeArrayChildren,</span><br><span class="line">        container,</span><br><span class="line">        anchor,</span><br><span class="line">        parentComponent,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        isSVG,</span><br><span class="line">        slotScopeIds,</span><br><span class="line">        optimized</span><br><span class="line">      )</span><br><span class="line">      return</span><br><span class="line">    &#125; else if (patchFlag &amp; PatchFlags.UNKEYED_FRAGMENT) &#123;</span><br><span class="line">      // unkeyed</span><br><span class="line">      patchUnkeyedChildren(</span><br><span class="line">        c1 as VNode[],</span><br><span class="line">        c2 as VNodeArrayChildren,</span><br><span class="line">        container,</span><br><span class="line">        anchor,</span><br><span class="line">        parentComponent,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        isSVG,</span><br><span class="line">        slotScopeIds,</span><br><span class="line">        optimized</span><br><span class="line">      )</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // children has 3 possibilities: text, array or no children.</span><br><span class="line">  if (shapeFlag &amp; ShapeFlags.TEXT_CHILDREN) &#123;</span><br><span class="line">    // text children fast path</span><br><span class="line">    if (prevShapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) &#123;</span><br><span class="line">      unmountChildren(c1 as VNode[], parentComponent, parentSuspense)</span><br><span class="line">    &#125;</span><br><span class="line">    if (c2 !== c1) &#123;</span><br><span class="line">      hostSetElementText(container, c2 as string)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    if (prevShapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) &#123;</span><br><span class="line">      // prev children was array</span><br><span class="line">      if (shapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) &#123;</span><br><span class="line">        // two arrays, cannot assume anything, do full diff</span><br><span class="line">        patchKeyedChildren(</span><br><span class="line">          c1 as VNode[],</span><br><span class="line">          c2 as VNodeArrayChildren,</span><br><span class="line">          container,</span><br><span class="line">          anchor,</span><br><span class="line">          parentComponent,</span><br><span class="line">          parentSuspense,</span><br><span class="line">          isSVG,</span><br><span class="line">          slotScopeIds,</span><br><span class="line">          optimized</span><br><span class="line">        )</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        // no new children, just unmount old</span><br><span class="line">        unmountChildren(c1 as VNode[], parentComponent, parentSuspense, true)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // prev children was text OR null</span><br><span class="line">      // new children is array OR null</span><br><span class="line">      if (prevShapeFlag &amp; ShapeFlags.TEXT_CHILDREN) &#123;</span><br><span class="line">        hostSetElementText(container, &apos;&apos;)</span><br><span class="line">      &#125;</span><br><span class="line">      // mount new if array</span><br><span class="line">      if (shapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) &#123;</span><br><span class="line">        mountChildren(</span><br><span class="line">          c2 as VNodeArrayChildren,</span><br><span class="line">          container,</span><br><span class="line">          anchor,</span><br><span class="line">          parentComponent,</span><br><span class="line">          parentSuspense,</span><br><span class="line">          isSVG,</span><br><span class="line">          slotScopeIds,</span><br><span class="line">          optimized</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="patchChildren"><a href="#patchChildren" class="headerlink" title="patchChildren"></a>patchChildren</h3><p>最后就剩下 patchChildren 的实现了，这也是各类虚拟 DOM 框架中最难实现的函数，我们需要实现一个高效的更新算法，能够使用尽可能少的更新次数，来实现从老的子元素到新的子元素的更新。</p>
<p>举个例子，类似体育课站队的时候，大家一开始站一排，但是顺序是乱的，我们需要尽快把队伍按照个头左低右高排列。</p>
<p>在 React 中，这种场景的处理逻辑是先进行循环，使用的是单侧插入的算法，我们在排队的时候挨个对比，如果你站我右边，并且个头比我高一点，说明咱俩的相对位置和最终队伍的位置是一致的，暂时不需要变化，如果你比我个头矮，就需要去我左边找到一个正确的位置插队进去。<br>由于都只向单侧插入，最后我们就会把所有的节点移动到正确的位置之上，这就是 React15 框架内虚拟节点 diff 的逻辑，初步实现了 DOM 的复用；而 Vue 2 借鉴了 snabbdom 的算法，在此基础上做了第一层双端对比的优化。</p>
<p>首先 Web 场景之下对一个数组元素的操作，很少有直接全部替换的，比如我们操作一个表格，大概率是更关心表格某一行的一个字段、新增一行、删除一行，或者是对表格某个字段进行排序，所以我们可以从纯算法的场景之中加入实际应用的场景。</p>
<p>如果我们只是在表格里新增一行，那么可以不要一开始就开始循环，而是可以先进行节点的预判。</p>
<p>比如，在下面的例子中，新的节点就是在老的节点中新增和删除了几个元素，我们在循环之前，先进行头部元素的判断。在这个例子里，可以预判出头部元素的 a、b、c、d 是一样的节点，说明节点不需要重新创建，我们只需要进行属性的更新，然后进行队尾元素的预判，可以判断出 g 和 h 元素也是一样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">a b c d e f g h</span><br><span class="line">a b c d i f j g h</span><br></pre></td></tr></table></figure>
<p>这样我们虚拟 DOM diff 的逻辑就变成了下面的结构, 现在只需要比较 ef 和 ifg 的区别</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(a b c d) e f (g h)</span><br><span class="line">(a b c d) i f j (g h)</span><br></pre></td></tr></table></figure>
<p>相比于之前的对比场景，我们需要遍历的运算量就大大减小了。</p>
<p>双端对比的原理大致就是这样。</p>
<p>想让一个队伍尽快按照个头排好序，如果能够计算出，在队伍中，个头从低到高依次递增的最多的队列，让这些人站在原地不动，其余人穿插到他们中间，就可以最大化减少人员的移动，这就是一个最长底层子序列的算法问题。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>Vue 响应式驱动了组件之间的数据通信机制，数据更新之后，组件会执行 intance.update 方法，update 方法内部执行 patch 方法进行新老子树的 diff 计算。</p>
<p>在更新函数中，主要做了两件事，pathProps 更新节点自身的属性，这里面使用了 pathFlags 做到了按需更新；patchChildren 执行子元素的更新。其中 patch 函数内部会只对节点内部的动态属性做更新，这种按需更新的机制是 Vue 性能优秀的一个原因。</p>
<p>函数内部针对新老子元素不同的状态，执行不同的逻辑。根据子元素是否为空或者数组，以及新元素是否为空或者数组，分别执行对应的删除或者 mount 逻辑，其中最复杂的就是新的子元素和老的子元素都是数组。</p>
<p>为了最大化减少 DOM 操作，patchKeyedChildren 使用了最长递增子序列来实现，并且相比于 React 的虚拟 DOM diff，新增了双端的预先判断 + 最长递增子序列算法来实现，这也是 Vue 性能比较优秀的另外一个原因。</p>
<h2 id="虚拟-DOM（下）：想看懂虚拟-DOM-算法，先刷个算法题"><a href="#虚拟-DOM（下）：想看懂虚拟-DOM-算法，先刷个算法题" class="headerlink" title="虚拟 DOM（下）：想看懂虚拟 DOM 算法，先刷个算法题"></a>虚拟 DOM（下）：想看懂虚拟 DOM 算法，先刷个算法题</h2><p>将讲到如何使用位运算来实现 Vue 中的按需更新，让静态的节点可以越过虚拟 DOM 的计算逻辑，并且使用计算最长递增子序列的方式，来实现队伍的高效排序。</p>
<h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(13).toString(2) // 1101</span><br><span class="line"></span><br><span class="line">0 &amp; 0  // 0</span><br><span class="line">0 &amp; 1  // 0</span><br><span class="line">1 &amp; 0  // 0</span><br><span class="line">1 &amp; 1  // 1</span><br><span class="line"></span><br><span class="line">0 | 0  // 0</span><br><span class="line">0 | 1  // 1</span><br><span class="line">1 | 0  // 1</span><br><span class="line">1 | 1  // 1</span><br><span class="line"></span><br><span class="line">1 &lt;&lt; 2 // 1左移动两位，就是100</span><br></pre></td></tr></table></figure>
<p>二进制中，我们每个位置只能是 0 或者 1 这两个值，&amp; 和 | 的概念和 JavaScript 中的 &amp;&amp; 和 || 保持一致。两个二进制的 &amp; 运算就是只有两个二进制位置都是 1 的时候，结果是 1，其余情况运算结果都是 0；| 是按位置进行“或”运算，只有两个二进制位置都是 0 的时候，结果是 0，其余情况运算结果都是 1；并且，还可以通过左移 &lt;&lt; 和右移 &gt;&gt; 操作符，实现乘以 2 和除以 2 的效果。</p>
<p>由于这些都是在二进制上的计算，运算的性能通常会比字符串和数字的计算性能要好，这也是很多框架内部使用位运算的原因。</p>
<h4 id="为什么位运算性能更好"><a href="#为什么位运算性能更好" class="headerlink" title="为什么位运算性能更好"></a>为什么位运算性能更好</h4><p>我们来做一下 LeetCode231 题，题目描述很简单，判断数字 n 是不是 2 的幂次方，也就是说，判断数字 n 是不是 2 的整次方，比如 2、4、8。我们可以很轻松地写出 JavaScript 的解答，n 一直除以 2，如果有余数就是 false，否则就是 true：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var isPowerOfTwo = function(n) &#123;</span><br><span class="line">    if(n === 1) return true</span><br><span class="line">    while( n &gt; 2 )&#123;</span><br><span class="line">        n = n / 2</span><br><span class="line">        if(n % 2 !== 0) return false</span><br><span class="line">    &#125;</span><br><span class="line">    return n===2</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>2 的幂次方就是数字 1 左移动若干次，其余位置全部都是 0，所以 n-1 就是最高位变成 0，其余位置都变成 1，就像十进制里的 10000-1 = 9999。这样，n 和 n-1 每个二进制位的数字都不一样，我们可以很轻松地用按位“与”来判断这个题的答案，如果 n&amp;n-1 是 0 的话，数字 n 就符合 2 的整次幂的特点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">16</span><br><span class="line">10000</span><br><span class="line">16-1 = 15</span><br><span class="line">01111</span><br><span class="line">16&amp;15 == 0</span><br><span class="line"></span><br><span class="line">var isPowerOfTwo = function(n) &#123;</span><br><span class="line">    return n&gt;0 &amp;&amp; (n &amp; (n - 1)) === 0</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>所以我们使用位运算提高了代码的整体性能。</p>
<h4 id="如何运用位运算"><a href="#如何运用位运算" class="headerlink" title="如何运用位运算"></a>如何运用位运算</h4><p>比如，一个节点如果 TEXT 和 STYLE 都需要修改，我们只需要使用 | 运算符就可以得到 flag1 的权限表示，这就是为什么 Vue 3 中针对虚拟 DOM 类型以及虚拟 DOM 需要动态计算 diff 的树形都做了标记，你可以在 Vue 3 的源码中看到下面的配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const PatchFlags = &#123;</span><br><span class="line">  TEXT:1,      // 0001</span><br><span class="line">  CLASS: 1&lt;&lt;1, // 0010</span><br><span class="line">  STYLE:1&lt;&lt;2,  // 0100</span><br><span class="line">  PROPS:1&lt;&lt;3   // 1000</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const flag1 = PatchFlags.TEXT | PatchFlags.STYLE // 0101</span><br><span class="line"></span><br><span class="line">// 权限校验</span><br><span class="line"></span><br><span class="line">flag1 &amp; PatchFlags.TEXT  // 有权限，结果大于1</span><br><span class="line">flag1 &amp; PatchFlags.CLASS //没有权限 是0</span><br></pre></td></tr></table></figure>
<h3 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h3><p>我们看 LeetCode 第 300 题，题目描述如下, 需要在数组中找到最长底层的自序列长度：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给你一个整数数组 nums，找到其中最长严格递增子序列的长度。</span><br><span class="line"></span><br><span class="line">子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。</span><br><span class="line">例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</span><br><span class="line"></span><br><span class="line">=</span><br><span class="line">输入：nums = [10,9,2,5,3,7,101,18]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</span><br></pre></td></tr></table></figure>
<p>首先我们可以使用动态规划的思路，通过每一步的递推，使用 dp 数组，记录出每一步操作的最优解，最后得到全局最优解。<br>在这个例子中，我们可以把 dp[i]定义成 nums[0]到 nums[i]这个区间内，数组的最长递增子序列的长度，并且 dp 数组的初始值设为 1。<br>从左边向右递推，如果 nums[i+1]&gt;nums[i]，dp[i+1]就等于 dp[i]+1；如果 nums[i+1] &lt; nums[i]，就什么都不需要干，这样我们在遍历的过程中，就能根据数组当前位置之前的最长递增子序列长度推导出 i+1 位置的最长递增子序列长度。所以可以得到如下解法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">const lengthOfLIS = function(nums) &#123;</span><br><span class="line">    let n = nums.length;</span><br><span class="line">    if (n == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    let dp = new Array(n).fill(1);</span><br><span class="line">    for (let i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (let j = 0; j &lt; i; j++) &#123;</span><br><span class="line">            if (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                dp[i] = Math.max(dp[i], dp[j] + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return Math.max(...dp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于我们需要两层循环，所以这个解法的时间复杂度是 n 的平方，这个解法其实已经不错了，但是还有更优秀的解法，也就是 Vue 3 中用到的算法：贪心 + 二分。</p>
<h4 id="贪心-二分"><a href="#贪心-二分" class="headerlink" title="贪心 + 二分"></a>贪心 + 二分</h4><p>我们可以创建一个 arr 数组，用来保存这种策略下的最长递增子序列。<br>如果当前遍历的 nums[i]大于 arr 的最后一个元素，也就是大于 arr 的最大值时，我们把 nums[i]追加到后面即可，否则我们就在 arr 中寻找一个第一个大于 num[i]的数字并替换它。因为是 arr 是递增的数列，所以在寻找插入位置的时候，我们可以使用二分查找的方式，把整个算法的复杂度变成 O(nlgn)。</p>
<p>下面的代码就是贪心 + 二分的解法，我们可以得到正确的最长递增子序列的长度：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">const lengthOfLIS = function(nums) &#123;</span><br><span class="line">    let len = nums.length</span><br><span class="line">    if (len &lt;= 1) &#123;</span><br><span class="line">        return len</span><br><span class="line">    &#125;</span><br><span class="line">    let arr = [nums[0]]</span><br><span class="line">    for (let i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        // nums[i] 大于 arr 尾元素时，直接追加到后面，递增序列长度+1</span><br><span class="line">        if (nums[i] &gt; arr[arr.length - 1]) &#123;</span><br><span class="line">            arr.push(nums[i])</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 否则，查找递增子序列中第一个大于numsp[i]的元素 替换它</span><br><span class="line">            // 递增序列，可以使用二分查找</span><br><span class="line">            let left = 0</span><br><span class="line">            let right = arr.length - 1</span><br><span class="line">            while (left &lt; right) &#123;</span><br><span class="line">                let mid = (left + right) &gt;&gt; 1</span><br><span class="line">                if (arr[mid] &lt; nums[i]) &#123;</span><br><span class="line">                    left = mid + 1</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    right = mid</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[left] = nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr.length</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但是贪心 + 二分的这种解法，现在只能得到最长递增子序列的长度，但是最后得到的 arr 并不一定是最长递增子序列，因为我们移动的 num[i]位置可能会不正确，只是得到的数组长度是正确的，所以我们需要对这个算法改造一下，把整个数组复制一份之后，最后也能得到正确的最长递增子序列。</p>
<p>具体代码怎么写呢？我们来到 Vue 3 的 renderer.ts 文件中，函数 getSquenece 就是用来生成最长递增子序列，看下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// https://en.wikipedia.org/wiki/Longest_increasing_subsequence</span><br><span class="line">  function getSequence(arr: number[]): number[] &#123;</span><br><span class="line">    const p = arr.slice() //赋值一份arr</span><br><span class="line">    const result = [0]</span><br><span class="line">    let i, j, u, v, c</span><br><span class="line">    const len = arr.length</span><br><span class="line">    for (i = 0; i &lt; len; i++) &#123;</span><br><span class="line">      const arrI = arr[i]</span><br><span class="line">      if (arrI !== 0) &#123;</span><br><span class="line">        j = result[result.length - 1]</span><br><span class="line">        if (arr[j] &lt; arrI) &#123;</span><br><span class="line">          p[i] = j  // 存储在result最后一个索引的值</span><br><span class="line">          result.push(i)</span><br><span class="line">          continue</span><br><span class="line">        &#125;</span><br><span class="line">        u = 0</span><br><span class="line">        v = result.length - 1</span><br><span class="line">          // 二分查找，查找比arrI小的节点，更新result的值</span><br><span class="line">        while (u &lt; v) &#123;</span><br><span class="line">          c = (u + v) &gt;&gt; 1</span><br><span class="line">          if (arr[result[c]] &lt; arrI) &#123;</span><br><span class="line">            u = c + 1</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            v = c</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (arrI &lt; arr[result[u]]) &#123;</span><br><span class="line">          if (u &gt; 0) &#123;</span><br><span class="line">              //索引存储 有一丢丢复杂</span><br><span class="line">            p[i] = result[u - 1]</span><br><span class="line">          &#125;</span><br><span class="line">          result[u] = i</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    u = result.length</span><br><span class="line">    v = result[u - 1]</span><br><span class="line">      // 查找数组p 找到最终的索引</span><br><span class="line">    while (u-- &gt; 0) &#123;</span><br><span class="line">      result[u] = v</span><br><span class="line">      v = p[v]</span><br><span class="line">    &#125;</span><br><span class="line">    return result</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这段代码就是 Vue 3 里的实现，result 存储的就是长度是 i 的递增子序列最小末位置的索引，最后计算出最长递增子序列。</p>
<p>我们得到 increasingNewIndexSequence 队列后，再去遍历数组进行 patch 操作就可以实现完整的 diff 流程了。</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>首先我们分析了 Vue 3 中虚拟 DOM diff 中的静态标记功能，标记后通过位运算，可以快速判断出一个节点的类型是 HTML 标签还是 Vue 组件，然后去执行不同的操作方法；在节点更新的流程中，也可以通过位运算的方式确定需要更新的范围。</p>
<p>位运算就是通过二进制上的与和或运算，能够高效地进行权限的判断，我们在工作中如果涉及权限的判断，也可以借鉴类似的思路，Linux 中的读写权限也是通过位运算的方式来实现的。</p>
<p>patchKeyedChildren 的核心逻辑就是在进行双端对比后，对无法预判的序列计算出最长递增子序列之后，我们通过编译数组，对其余的元素进行 patch 或者 move 的操作，完整实现了虚拟 DOM 的 diff。</p>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2022/01/01/vue3/">vue3学习</a></p>
        <p><span>文章作者:</span><a href="/" title="访问 DiamondsZz 的个人博客">DiamondsZz</a></p>
        <p><span>发布时间:</span>2022年01月01日</p>
        <p><span>最后更新:</span>2022年01月09日 - 16时29分</p>    
    </div>



<nav id="article-nav">
  
  
    <a href="/2021/09/01/interview/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">起个名字真难</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>


  
</article>

    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#宏观视角：从前端框架发展史聊聊为什么要学-Vue-3？"><span class="toc-number">1.</span> <span class="toc-text">宏观视角：从前端框架发展史聊聊为什么要学 Vue 3？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-与-React-框架的对比"><span class="toc-number">1.1.</span> <span class="toc-text">Vue 与 React 框架的对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#新特性：初探-Vue-3-新特性"><span class="toc-number">2.</span> <span class="toc-text">新特性：初探 Vue 3 新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#响应式系统"><span class="toc-number">2.1.</span> <span class="toc-text">响应式系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义渲染器"><span class="toc-number">2.2.</span> <span class="toc-text">自定义渲染器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#全部模块使用-TypeScript-重构"><span class="toc-number">2.3.</span> <span class="toc-text">全部模块使用 TypeScript 重构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Composition-API-组合语法"><span class="toc-number">2.4.</span> <span class="toc-text">Composition API 组合语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#新的组件"><span class="toc-number">2.5.</span> <span class="toc-text">新的组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#新一代工程化工具-Vite"><span class="toc-number">2.6.</span> <span class="toc-text">新一代工程化工具 Vite</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#巧妙的响应式：深入理解-Vue-3-的响应式机制"><span class="toc-number">3.</span> <span class="toc-text">巧妙的响应式：深入理解 Vue 3 的响应式机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据流：如何使用-Vuex-设计你的数据流"><span class="toc-number">4.</span> <span class="toc-text">数据流：如何使用 Vuex 设计你的数据流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#手写迷你-Vuex"><span class="toc-number">4.1.</span> <span class="toc-text">手写迷你 Vuex</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#路由：新一代-vue-router-带来什么变化"><span class="toc-number">5.</span> <span class="toc-text">路由：新一代 vue-router 带来什么变化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#手写迷你-vue-router"><span class="toc-number">5.1.</span> <span class="toc-text">手写迷你 vue-router</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是好的项目？"><span class="toc-number">6.</span> <span class="toc-text">什么是好的项目？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#给项目骨干开发者的优化建议"><span class="toc-number">6.1.</span> <span class="toc-text">给项目骨干开发者的优化建议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何打包发布你的-Vue-3-应用？"><span class="toc-number">7.</span> <span class="toc-text">如何打包发布你的 Vue 3 应用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何设计你自己的通用组件库？"><span class="toc-number">8.</span> <span class="toc-text">如何设计你自己的通用组件库？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#环境搭建"><span class="toc-number">8.1.</span> <span class="toc-text">环境搭建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#布局组件"><span class="toc-number">8.2.</span> <span class="toc-text">布局组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#组件注册"><span class="toc-number">8.3.</span> <span class="toc-text">组件注册</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何使用-TDD-开发一个组件？"><span class="toc-number">9.</span> <span class="toc-text">如何使用 TDD 开发一个组件？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何实现-Vue-的跨端渲染-？"><span class="toc-number">10.</span> <span class="toc-text">如何实现 Vue 的跨端渲染 ？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是渲染器"><span class="toc-number">10.1.</span> <span class="toc-text">什么是渲染器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义渲染"><span class="toc-number">10.2.</span> <span class="toc-text">自定义渲染</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#万能的面试题，怎么手写响应式系统"><span class="toc-number">11.</span> <span class="toc-text">万能的面试题，怎么手写响应式系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#响应式"><span class="toc-number">11.1.</span> <span class="toc-text">响应式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reactive"><span class="toc-number">11.2.</span> <span class="toc-text">reactive</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mutableHandles"><span class="toc-number">11.3.</span> <span class="toc-text">mutableHandles</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#track"><span class="toc-number">11.4.</span> <span class="toc-text">track</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#trigger"><span class="toc-number">11.5.</span> <span class="toc-text">trigger</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#effect"><span class="toc-number">11.6.</span> <span class="toc-text">effect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ref"><span class="toc-number">11.7.</span> <span class="toc-text">ref</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#computed"><span class="toc-number">11.8.</span> <span class="toc-text">computed</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#运行时：Vue-在浏览器里是怎么跑起来的？"><span class="toc-number">12.</span> <span class="toc-text">运行时：Vue 在浏览器里是怎么跑起来的？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#首次渲染"><span class="toc-number">12.1.</span> <span class="toc-text">首次渲染</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#patch-函数"><span class="toc-number">12.2.</span> <span class="toc-text">patch 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#processComponent-方法"><span class="toc-number">12.3.</span> <span class="toc-text">processComponent 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setupComponent"><span class="toc-number">12.4.</span> <span class="toc-text">setupComponent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setupRenderEffect"><span class="toc-number">12.5.</span> <span class="toc-text">setupRenderEffect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-number">12.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚拟-DOM（上）：如何通过虚拟-DOM-更新页面？"><span class="toc-number">13.</span> <span class="toc-text">虚拟 DOM（上）：如何通过虚拟 DOM 更新页面？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#patch-函数-1"><span class="toc-number">13.1.</span> <span class="toc-text">patch 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#patchElement-函数"><span class="toc-number">13.2.</span> <span class="toc-text">patchElement 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#节点自身属性的更新"><span class="toc-number">13.2.1.</span> <span class="toc-text">节点自身属性的更新</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#子元素的更新"><span class="toc-number">13.2.2.</span> <span class="toc-text">子元素的更新</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#patchChildren"><span class="toc-number">13.3.</span> <span class="toc-text">patchChildren</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结-1"><span class="toc-number">13.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚拟-DOM（下）：想看懂虚拟-DOM-算法，先刷个算法题"><span class="toc-number">14.</span> <span class="toc-text">虚拟 DOM（下）：想看懂虚拟 DOM 算法，先刷个算法题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#位运算"><span class="toc-number">14.1.</span> <span class="toc-text">位运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么位运算性能更好"><span class="toc-number">14.1.1.</span> <span class="toc-text">为什么位运算性能更好</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何运用位运算"><span class="toc-number">14.1.2.</span> <span class="toc-text">如何运用位运算</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最长递增子序列"><span class="toc-number">14.2.</span> <span class="toc-text">最长递增子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#贪心-二分"><span class="toc-number">14.2.1.</span> <span class="toc-text">贪心 + 二分</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结-2"><span class="toc-number">14.3.</span> <span class="toc-text">总结</span></a></li></ol></li></ol>
</div>
<style>
    .left-col .switch-btn {
        display: none;
    }
    .left-col .switch-area {
        display: none;
    }
</style>
<input type="button" id="tocButton" value="隐藏目录" title="点击按钮隐藏或者显示文章目录">

<script src="https://www.unpkg.com/jquery@3.6.0/dist/jquery.js"></script>

<script>
    var valueHide = "隐藏目录";
    var valueShow = "显示目录";
    if ($(".left-col").is(":hidden")) {
        $("#tocButton").attr("value", valueShow);
    }
    $("#tocButton").click(function() {
        if ($("#toc").is(":hidden")) {
            $("#tocButton").attr("value", valueHide);
            $("#toc").slideDown(320);
            $(".switch-btn, .switch-area").fadeOut(300);
        }
        else {
            $("#tocButton").attr("value", valueShow);
            $("#toc").slideUp(350);
            $(".switch-btn, .switch-area").fadeIn(500);
        }
    })
    if ($(".toc").length < 1) {
        $("#toc, #tocButton").hide();
        $(".switch-btn, .switch-area").show();
    }
</script>






    



    <div class="scroll" id="post-nav-button">
        
            <a href="/" title="回到主页"><i class="fa fa-home"></i></a>
        
        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>
        
            <a href="/2021/09/01/interview/" title="下一篇: 起个名字真难">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>
    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2022/01/01/vue3/">vue3学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/09/01/interview/">起个名字真难</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/08/01/optimize/">前端性能优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/08/01/test/">前端测试</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/07/18/node/">node学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/01/performance/">performance</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/25/http/">http协议</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/25/react/">react进阶</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/25/vue/">vue进阶</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/25/core/">核心进阶</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/25/browser/">浏览器工作原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/08/module_webpack/">模块化/webpack</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/08/yeoman/">脚手架/yeoman/gulp</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/16/question/">知识点</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/02/life/">记录生活</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/03/wfe/">前端笔记（旧）</a></li></ul>
    
<script src="https://www.unpkg.com/jquery@3.6.0/dist/jquery.js"></script>

    <script>
        $(".post-list").addClass("toc-article");
        // $(".post-list-item a").attr("target","_blank");
        $("#post-nav-button > a:nth-child(2)").click(function() {
            $(".fa-bars, .fa-times").toggle();
            $(".post-list").toggle(300);
            if ($(".toc").length > 0) {
                $("#toc, #tocButton").toggle(200, function() {
                    if ($(".switch-area").is(":visible")) {
                        $("#toc, .switch-btn, .switch-area").toggle();
                        $("#tocButton").attr("value", valueHide);
                        }
                    })
            }
            else {
                $(".switch-btn, .switch-area").fadeToggle(300);
            }
        })
    </script>




    <script>
        
    </script>

</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2022 DiamondsZz
            </div>        
        </div>
    </div>
</footer>

    </div>
    
<script src="https://www.unpkg.com/jquery@3.6.0/dist/jquery.js"></script>

<script src="/js/main.js"></script>

    <script>
        $(document).ready(function() {
            var backgroundnum = 1;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>






<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" "="">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(
            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


  </div>
</body>
</html>