<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  <meta name="baidu-site-verification" content="L6Lm9d5Crl">
  
  
  
  
  <title>算法 | DiamondsZz</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="/*  假设有任意多张面额为 2 元、3 元、7 元的货币，现要用它们凑出 100 元，求总共有多少种可能性。 */ 12345678910111213141516function test1() &amp;#123;  let count = 0;  for (let i = 0; i &amp;lt;= 100 / 7; i++) &amp;#123;    //这里针对j可以优化一波    for (let j =">
<meta name="keywords" content="资源,学习,网站">
<meta property="og:type" content="article">
<meta property="og:title" content="算法">
<meta property="og:url" content="https://DiamondsZz.github.io/2021/03/29/algorithm/index.html">
<meta property="og:site_name" content="DiamondsZz">
<meta property="og:description" content="/*  假设有任意多张面额为 2 元、3 元、7 元的货币，现要用它们凑出 100 元，求总共有多少种可能性。 */ 12345678910111213141516function test1() &amp;#123;  let count = 0;  for (let i = 0; i &amp;lt;= 100 / 7; i++) &amp;#123;    //这里针对j可以优化一波    for (let j =">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2021-04-02T14:05:39.341Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="算法">
<meta name="twitter:description" content="/*  假设有任意多张面额为 2 元、3 元、7 元的货币，现要用它们凑出 100 元，求总共有多少种可能性。 */ 12345678910111213141516function test1() &amp;#123;  let count = 0;  for (let i = 0; i &amp;lt;= 100 / 7; i++) &amp;#123;    //这里针对j可以优化一波    for (let j =">
  
    <link rel="alternative" href="/atom.xml" title="DiamondsZz" type="application/atom+xml">
  
  
  
  <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet">
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: false,
          isPost: true,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>

        <a href="/" class="profilepic">
            
            <img lazy-src="/img/iu.jpeg" class="js-avatar">
            
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">DiamondsZz</a></h1>
        </hgroup>
        
        <p class="header-subtitle">DiamondsZz</p>
        
        
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        
        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                        </ul>
                    </nav>
                </section>
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/css/" style="font-size: 13.33px;">css</a> <a href="/tags/js/" style="font-size: 20px;">js</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/学习/" style="font-size: 16.67px;">学习</a> <a href="/tags/生活，心情/" style="font-size: 10px;">生活，心情</a> <a href="/tags/网站/" style="font-size: 16.67px;">网站</a> <a href="/tags/资源/" style="font-size: 16.67px;">资源</a>
                    </div>
                </section>
                
                
                
                
                <section class="switch-part switch-part3">
                
                    <div id="js-aboutme">矮穷矬!</div>
                </section>
                
            </div>
        </div>
    </header>
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">DiamondsZz</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/img/iu.jpeg" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">DiamondsZz</a></h1>
            </hgroup>
            
            <p class="header-subtitle">DiamondsZz</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                </div>
            </nav>
        </header>
    </div>
</nav>
      <div class="body-wrap"><article id="post-algorithm" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2021/03/29/algorithm/" class="article-date">
      <time datetime="2021-03-28T16:00:00.000Z" itemprop="datePublished">2021-03-29</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      算法
    </h1>
  


      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/学习/">学习</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/学习/">学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网站/">网站</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/资源/">资源</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>/*<em>
 </em>假设有任意多张面额为 2 元、3 元、7 元的货币，现要用它们凑出 100 元，求总共有多少种可能性。<br> */<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function test1() &#123;</span><br><span class="line">  let count = 0;</span><br><span class="line">  for (let i = 0; i &lt;= 100 / 7; i++) &#123;</span><br><span class="line">    //这里针对j可以优化一波</span><br><span class="line">    for (let j = 0; j &lt;= 100 / 3; j++) &#123;</span><br><span class="line">      if (100 - i * 7 - j * 3 &gt;= 0 &amp;&amp; (100 - i * 7 - j * 3) % 2 == 0) &#123;</span><br><span class="line">        count += 1;</span><br><span class="line">        console.log(</span><br><span class="line">          `$&#123;count&#125;:7元:$&#123;i&#125;张,3元:$&#123;j&#125;张,2元:$&#123;(100 - i * 7 - j * 3) / 2&#125;张`</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(`一共有$&#123;count&#125;种可能性`);</span><br><span class="line">&#125;</span><br><span class="line">//test1();</span><br></pre></td></tr></table></figure></p>
<p>/**</p>
<ul>
<li>查找出一个数组中，出现次数最多的那个元素的数值。</li>
<li>例如，输入数组 a = [1,2,3,4,5,5,6 ] 中，查找出现次数最多的数值。</li>
<li>从数组中可以看出，只有 5 出现了 2 次，其余都是 1 次。显然 5 出现的次数最多，则输出 5。<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function test2(arr) &#123;</span><br><span class="line">  //记录数组元素出现次数  采用map数据结构，查找的时间复杂度是o(1)</span><br><span class="line">  let res = new Map();</span><br><span class="line">  //出现最多次数</span><br><span class="line">  let max = -1;</span><br><span class="line">  for (let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">    if (res.has(arr[i])) &#123;</span><br><span class="line">      res.set(arr[i], res.get(arr[i]) + 1);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      res.set(arr[i], 1);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  //获取出现次数的最大值</span><br><span class="line">  max = Math.max.apply(null, [...res.values()]);</span><br><span class="line">  for (let [key, value] of res) &#123;</span><br><span class="line">    if (value === max) console.log(`$&#123;key&#125;出现的次数最多，出现了$&#123;value&#125;次`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//test2([1, 2, 3, 4, 5, 5, 6]);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</li>
<li>有效字符串需满足：左括号必须与相同类型的右括号匹配，左括号必须以正确的顺序匹配。</li>
<li>例如，{ [ ( ) ( ) ] } 是合法的，而 { ( [ ) ] } 是非法的。</li>
<li>思路：</li>
<li>从左到右顺序遍历字符串。</li>
<li>当出现左括号时，压栈。</li>
<li>当出现右括号时，出栈。</li>
<li>并且判断当前右括号，和被出栈的左括号是否是互相匹配的一对。</li>
<li>如果不是，则字符串非法。当遍历完成之后，如果栈为空。则合法。<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function test3(data) &#123;</span><br><span class="line">  //左括号</span><br><span class="line">  const typesLeft = [&quot;(&quot;, &quot;[&quot;, &quot;&#123;&quot;];</span><br><span class="line">  //右括号</span><br><span class="line">  const typesRight = [&quot;)&quot;, &quot;]&quot;, &quot;&#125;&quot;];</span><br><span class="line">  //括号</span><br><span class="line">  const types = [&quot;()&quot;, &quot;[]&quot;, &quot;&#123;&#125;&quot;];</span><br><span class="line"></span><br><span class="line">  //存储 模拟栈</span><br><span class="line">  const store = [];</span><br><span class="line"></span><br><span class="line">  for (let type of data) &#123;</span><br><span class="line">      //匹配到左括号时，进行入栈操作</span><br><span class="line">    if (typesLeft.includes(type)) &#123;</span><br><span class="line">      store.push(type);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      //匹配到右括号时，进行出栈操作，检验当前括号是否合法</span><br><span class="line">      const left = store.pop();</span><br><span class="line">      if (!types.includes(`$&#123;left&#125;$&#123;type&#125;`)) &#123;</span><br><span class="line">        console.log(&quot;非法字符串&quot;);</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//test3([&apos;(&apos;,&apos;&#123;&apos;,&apos;&#125;&apos;,&apos;&#125;&apos;,&apos;)&apos;])</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>约瑟夫环是一个数学的应用问题，具体为，已知 n 个人（以编号 1，2，3…n 分别表示）围坐在一张圆桌周围。</li>
<li>从编号为 k 的人开始报数，数到 m 的那个人出列；</li>
<li>他的下一个人又从 1 开始报数，数到 m 的那个人又出列；</li>
<li>依此规律重复下去，直到圆桌周围的人全部出列。</li>
<li>这个问题的输入变量就是 n 和 m，即 n 个人和数到 m 的出列的人。输出的结果，就是 n 个人出列的顺序。</li>
<li>这个问题，用队列的方法实现是个不错的选择。它的结果就是出列的顺序，恰好满足队列对处理顺序敏感的前提。因此，求解方式也是基于队列的先进先出原则。</li>
<li>解法如下：</li>
<li>先把所有人都放入循环队列中。注意这个循环队列的长度要大于或者等于 n。</li>
<li>从第一个人开始依次出队列，出队列一次则计数变量 i 自增。如果 i 比 m 小，则还需要再入队列。</li>
<li>直到i等于 m 的人出队列时，就不用再让这个人进队列了。而是放入一个用来记录出队列顺序的数组中。</li>
<li>直到数完 n 个人为止。当队列为空时，则表示队列中的 n 个人都出队列了，这时结束队列循环，输出数组内记录的元素。<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">//n个人，从编号为k的人开始报数，</span><br><span class="line">function test4(persons, k, m) &#123;</span><br><span class="line">  //退出的人</span><br><span class="line">  const exitPersons = [];</span><br><span class="line">  //计数器</span><br><span class="line">  let count = 1;</span><br><span class="line"></span><br><span class="line">  //第一次</span><br><span class="line">  for (let &#123; name, num &#125; of persons) &#123;</span><br><span class="line">    if (num &lt; k) &#123;</span><br><span class="line">      persons.shift();</span><br><span class="line">      persons.push(&#123;</span><br><span class="line">        name,</span><br><span class="line">        num,</span><br><span class="line">      &#125;);</span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br><span class="line">    break;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //还有人时</span><br><span class="line">  while (persons.length) &#123;</span><br><span class="line">    const person = persons.shift();</span><br><span class="line">    if (count &lt; m) &#123;</span><br><span class="line">      persons.push(person);</span><br><span class="line">      count++;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      //找到目标后，重置计数器</span><br><span class="line">      count = 1;</span><br><span class="line">      exitPersons.push(person);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  //console.log(exitPersons);</span><br><span class="line">&#125;</span><br><span class="line">// test4(</span><br><span class="line">//   [</span><br><span class="line">//     &#123; name: &quot;赵一&quot;, num: 1 &#125;,</span><br><span class="line">//     &#123; name: &quot;钱二&quot;, num: 2 &#125;,</span><br><span class="line">//     &#123; name: &quot;孙三&quot;, num: 3 &#125;,</span><br><span class="line">//     &#123; name: &quot;李四&quot;, num: 4 &#125;,</span><br><span class="line">//     &#123; name: &quot;周五&quot;, num: 5 &#125;,</span><br><span class="line">//     &#123; name: &quot;吴六&quot;, num: 6 &#125;,</span><br><span class="line">//     &#123; name: &quot;郑七&quot;, num: 7 &#125;,</span><br><span class="line">//     &#123; name: &quot;王八&quot;, num: 8 &#125;,</span><br><span class="line">//   ],</span><br><span class="line">//   2,</span><br><span class="line">//   4</span><br><span class="line">// );</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>10</li>
<li>/  \</li>
<li>8   12</li>
<li>/ \  / \</li>
<li>6   9 11 13</li>
<li>给定一棵树，按照层次顺序遍历并打印这棵树。<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">const root = &#123;</span><br><span class="line">  value: 10,</span><br><span class="line">  left: &#123; value: 8, left: &#123; value: 6 &#125;, right: &#123; value: 9 &#125; &#125;,</span><br><span class="line">  right: &#123; value: 12, left: &#123; value: 11 &#125;, right: &#123; value: 13 &#125; &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">function test5(root) &#123;</span><br><span class="line">  //模拟队列</span><br><span class="line">  const queue = [];</span><br><span class="line">  //根节点入队列</span><br><span class="line">  queue.push(root);</span><br><span class="line">  while (queue.length) &#123;</span><br><span class="line">    //当前节点</span><br><span class="line">    const current = queue.shift();</span><br><span class="line">    console.log(current.value);</span><br><span class="line">    //左节点</span><br><span class="line">    if (current.left) &#123;</span><br><span class="line">      queue.push(current.left);</span><br><span class="line">    &#125;</span><br><span class="line">    //右节点</span><br><span class="line">    if (current.right) &#123;</span><br><span class="line">      queue.push(current.right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//test5(root);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>10</li>
<li>/  \</li>
<li>8   12</li>
<li>/ \  / \</li>
<li>6   9 11 13</li>
<li>二叉树的三种遍历方式<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//前序</span><br><span class="line">function test6(node) &#123;</span><br><span class="line">  if (!node) return;</span><br><span class="line">  console.log(node.value);</span><br><span class="line">  test6(node.left);</span><br><span class="line">  test6(node.right);</span><br><span class="line">&#125;</span><br><span class="line">//test6(root)</span><br><span class="line">//中序</span><br><span class="line">function test7(node) &#123;</span><br><span class="line">  if (!node) return;</span><br><span class="line">  test7(node.left);</span><br><span class="line">  console.log(node.value);</span><br><span class="line">  test7(node.right);</span><br><span class="line">&#125;</span><br><span class="line">//test7(root)</span><br><span class="line">//后序</span><br><span class="line">function test8(node) &#123;</span><br><span class="line">  if (!node) return;</span><br><span class="line">  test8(node.left);</span><br><span class="line">  test8(node.right);</span><br><span class="line">  console.log(node.value);</span><br><span class="line">&#125;</span><br><span class="line">//test8(root)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>给定一个整数数组 arr 和一个目标值 target，请你在该数组中找出加和等于目标值的那两个整数，并返回它们的在数组中下标。</li>
<li>你可以假设，原数组中没有重复元素，而且有且只有一组答案。但是，数组中的元素只能使用一次。例如，arr = [1, 2, 3, 4, 5, 6]，target = 4。因为，arr[0] + arr[2] = 1 + 3 = 4 = target，则输出 0，2。<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function test9(data, target) &#123;</span><br><span class="line">  for (const item of data) &#123;</span><br><span class="line">    if (data.includes(target - item) &amp;&amp; target - item !== item)</span><br><span class="line">      console.log(`$&#123;target&#125;=$&#123;item&#125;+$&#123;target - item&#125;`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//test9([1,2,3,4,5,6],4)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>汉诺塔问题(递归)</li>
<li>从左到右有 x、y、z 三根柱子，其中 x 柱子上面有从小叠到大的 n 个圆盘。现要求将 x 柱子上的圆盘移到 z 柱子上去。要求是，每次只能移动一个盘子，且大盘子不能被放在小盘子上面。求移动的步骤。</li>
<li><hr>
</li>
<li>我们的原问题是，把从小到大的 n 个盘子，从 x 移动到 z。</li>
<li>我们可以将这个大问题拆解为以下 3 个小问题：</li>
<li>把从小到大的 n-1 个盘子，从 x 移动到 y；</li>
<li>接着把最大的一个盘子，从 x 移动到 z；</li>
<li>再把从小到大的 n-1 个盘子，从 y 移动到 z。</li>
<li><hr>
</li>
<li>经过仔细分析可见，汉诺塔问题是完全可以用递归实现的。我们定义汉诺塔的递归函数为 hanio()。这个函数的输入参数包括了：</li>
<li>3 根柱子的标记 x、y、z；</li>
<li>待移动的盘子数量 n。</li>
<li><hr>
</li>
<li>具体代码如下所示，在代码中，hanio(n, x, y, z)，代表了把 n 个盘子由 x 移动到 z。根据分析，我们知道递归体包含 3 个步骤：</li>
<li>把从小到大的 n-1 个盘子从 x 移动到 y，那么代码就是 hanio(n-1, x, z, y)；</li>
<li>再把最大的一个盘子从 x 移动到 z，那么直接完成一次移动的动作就可以了；</li>
<li>再把从小到大的 n-1 个盘子从 y 移动到 z，那么代码就是 hanio(n-1, y, x, z)。对于终止条件则需要判断 n 的大小。如果 n 等于 1，那么同样直接移动就可以了。<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function test10(n, x, y, z) &#123;</span><br><span class="line">  if (n &lt; 1) return console.log(&quot;汉诺塔层数不能小于1&quot;);</span><br><span class="line">  if (n === 1) return console.log(`移动$&#123;x&#125;到$&#123;z&#125;`);</span><br><span class="line">  test10(n - 1, x, z, y);</span><br><span class="line">  console.log(`移动$&#123;x&#125;到$&#123;z&#125;`);</span><br><span class="line">  test10(n - 1, y, x, z);</span><br><span class="line">&#125;</span><br><span class="line">//test10(3, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>斐波那契数列。(递归)</li>
<li>斐波那契数列是：0，1，1，2，3，5，8，13，21，34，55，89，144……。</li>
<li>你会发现，这个数列中元素的性质是，某个数等于它前面两个数的和；</li>
<li>也就是 a[n+2] = a[n+1] + a[n]。至于起始两个元素，则分别为 0 和 1。</li>
<li>在这个数列中的数字，就被称为斐波那契数。</li>
<li><hr>
</li>
<li>写一个函数，输入 x，输出斐波那契数列中第 x 位的元素。</li>
<li>例如，输入 4，输出 2；输入 9，输出 21。</li>
<li>要求：需要用递归的方式来实现。<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const target = 9;</span><br><span class="line">const data = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144];</span><br><span class="line">function test11(data, x) &#123;</span><br><span class="line">  if (x === 1) return 0;</span><br><span class="line">  if (x === 2) return 1;</span><br><span class="line">  if (x &gt; 2) data[x] = test11(data, x - 1) + test11(data, x - 2);</span><br><span class="line">  //输出结果</span><br><span class="line">  if (x === target) console.log(data[x]);</span><br><span class="line">  return data[x];</span><br><span class="line">&#125;</span><br><span class="line">//test11(data, target);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>/*<em>
 </em>二分 (基于有序)<br> */<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function test12(data, target) &#123;</span><br><span class="line">  //低</span><br><span class="line">  let low = 0;</span><br><span class="line">  //高</span><br><span class="line">  let high = data.length - 1;</span><br><span class="line">  //中</span><br><span class="line">  let middle = 0;</span><br><span class="line">  //计数器</span><br><span class="line">  let count = 1;</span><br><span class="line">  while (low &lt;= high) &#123;</span><br><span class="line">    middle = Math.floor((low + high) / 2);</span><br><span class="line">    if (target === data[middle]) &#123;</span><br><span class="line">      console.log(`找了$&#123;count&#125;次`);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (target &gt; data[middle]) &#123;</span><br><span class="line">      low = middle + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (target &lt; data[middle]) &#123;</span><br><span class="line">      high = middle - 1;</span><br><span class="line">    &#125;</span><br><span class="line">    count++;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(&quot;没有找到&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//test12([2, 4, 6, 7], 4);</span><br></pre></td></tr></table></figure></p>
<p>/*<em>
 </em>在一个有序数组中，查找出第一个大于 9 的数字，假设一定存在。<br> <em>例如，arr = { -1, 3, 3, 7, 10, 14, 14 }; 则返回 10。
 </em>查找的目标数字具备这样的性质：<br> <em>第一，它比 9 大；
 </em>第二，它前面的数字（除非它是第一个数字），比 9 小。<br> <em>因此，当我们作出向左走或向右走的决策时，必须满足这两个条件。
 </em>/<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function test13(data, target) &#123;</span><br><span class="line">  let low = 0;</span><br><span class="line">  let high = data.length - 1;</span><br><span class="line">  let middle = 0;</span><br><span class="line">  while (low &lt;= high) &#123;</span><br><span class="line">    middle = Math.floor((low + high) / 2);</span><br><span class="line">    if (target &gt;= data[middle]) &#123;</span><br><span class="line">      if (target &lt; data[middle + 1]) return data[middle + 1];</span><br><span class="line">      low = middle + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (target &lt; data[middle]) &#123;</span><br><span class="line">      if (target &gt; data[middle - 1]) return data[middle];</span><br><span class="line">      high = middle - 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//console.log(test13([-1, 3, 3, 7, 10, 14, 14], 9));</span><br></pre></td></tr></table></figure></p>
<p>/**</p>
<ul>
<li>冒泡排序<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function test14(data) &#123;</span><br><span class="line">  for (let i = 0; i &lt; data.length; i++) &#123;</span><br><span class="line">    //j &lt; data.length - i 每一轮都会筛选出一个最值，减少没有必要的比较次数</span><br><span class="line">    for (let j = 0; j &lt; data.length - i; j++) &#123;</span><br><span class="line">      //交换位置</span><br><span class="line">      if (data[j] &gt; data[j + 1]) &#123;</span><br><span class="line">        data[j + 1] = data[j] + data[j + 1];</span><br><span class="line">        data[j] = data[j + 1] - data[j];</span><br><span class="line">        data[j + 1] = data[j + 1] - data[j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(data);</span><br><span class="line">&#125;</span><br><span class="line">//test14([-1, 3, -3, 7, 10, 14, 14]);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>插入排序</li>
<li>选取未排序的元素，插入到已排序区间的合适位置，直到未排序区间为空。</li>
<li>插入排序顾名思义，就是从左到右维护一个已经排好序的序列。直到所有的待排数据全都完成插入的动作。<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">function test15(data) &#123;</span><br><span class="line">  for (let i = 1; i &lt; data.length; i++) &#123;</span><br><span class="line">    //记录当前遍历的元素</span><br><span class="line">    let current = data[i];</span><br><span class="line">    for (let j = i - 1; j &gt;= 0; j--) &#123;</span><br><span class="line">      if (data[j] &gt; current) &#123;</span><br><span class="line">        data[j + 1] = data[j] + data[j + 1];</span><br><span class="line">        data[j] = data[j + 1] - data[j];</span><br><span class="line">        data[j + 1] = data[j + 1] - data[j];</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//test15([-1, 3, -3, 7, 10, 14, 14]);</span><br><span class="line">function test16(data) &#123;</span><br><span class="line">  for (let i = 1; i &lt; data.length; i++) &#123;</span><br><span class="line">    //记录当前遍历的元素</span><br><span class="line">    let current = data[i];</span><br><span class="line">    let j = i - 1;</span><br><span class="line">    for (; j &gt;= 0; j--) &#123;</span><br><span class="line">      if (data[j] &gt; current) &#123;</span><br><span class="line">        data[j + 1] = data[j];</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    data[j + 1] = current;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//test16([-1, 3, -3, 7, 10, 14, 14]);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>归并排序</li>
<li>归并排序的原理就是分治法。</li>
<li>它首先将数组不断地二分，直到最后每个部分只包含 1 个数据。</li>
<li>然后再对每个部分分别进行排序，最后将排序好的相邻的两部分合并在一起，这样整个数组就有序了。<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">function test17(data) &#123;</span><br><span class="line">  //临时数组</span><br><span class="line">  let temp = [];</span><br><span class="line">  //开始下标</span><br><span class="line">  let start = 0;</span><br><span class="line">  //结束下标</span><br><span class="line">  let end = data.length - 1;</span><br><span class="line"></span><br><span class="line">  //拆分</span><br><span class="line">  function split(data, temp, start, end) &#123;</span><br><span class="line">    if (start &lt; end) &#123;</span><br><span class="line">      //中间下标</span><br><span class="line">      let mid = Math.floor((start + end) / 2);</span><br><span class="line"></span><br><span class="line">      //对左边进行拆分</span><br><span class="line">      split(data, temp, start, mid);</span><br><span class="line">      //对右边进行拆分</span><br><span class="line">      split(data, temp, mid + 1, end);</span><br><span class="line">      //合并左右部分</span><br><span class="line">      merge(data, temp, start, mid, end);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //合并</span><br><span class="line">  function merge(data, temp, start, mid, end) &#123;</span><br><span class="line">    //左边开始下标</span><br><span class="line">    let leftStart = start;</span><br><span class="line">    //右边开始下标</span><br><span class="line">    let rightStart = mid + 1;</span><br><span class="line">    //临时数组开始下标</span><br><span class="line">    let left = start;</span><br><span class="line"></span><br><span class="line">    //左边部分和右边部分都未走完时</span><br><span class="line">    while (leftStart &lt;= mid &amp;&amp; rightStart &lt;= end) &#123;</span><br><span class="line">      if (data[leftStart] &gt; data[rightStart]) &#123;</span><br><span class="line">        temp[left++] = data[rightStart++];</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        temp[left++] = data[leftStart++];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //左边部分未走完时</span><br><span class="line">    while (leftStart &lt;= mid) &#123;</span><br><span class="line">      temp[left++] = data[leftStart++];</span><br><span class="line">    &#125;</span><br><span class="line">    //右边部分未走完时</span><br><span class="line">    while (rightStart &lt;= end) &#123;</span><br><span class="line">      temp[left++] = data[rightStart++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //每次合并完更新原数据</span><br><span class="line">    for (let i = 0; i &lt; temp.length; i++) &#123;</span><br><span class="line">      data[i] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  split(data, temp, start, end);</span><br><span class="line">  console.log(data);</span><br><span class="line">&#125;</span><br><span class="line">//test17([-1, -3, -3, 7, 10, 14, 14]);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>快速排序</li>
<li>快速排序法的原理也是分治法。</li>
<li>它的每轮迭代，会选取数组中任意一个数据作为分区点，将小于它的元素放在它的左侧，大于它的放在它的右侧。</li>
<li>再利用分治思想，继续分别对左右两侧进行同样的操作，直至每个区间缩小为 1，则完成排序。<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">function test18(data, start, end) &#123;</span><br><span class="line">  if (start &gt;= end) return;</span><br><span class="line"></span><br><span class="line">  //取数据第一个值作为参考值</span><br><span class="line">  let temp = data[start];</span><br><span class="line">  //左指针</span><br><span class="line">  let left = start;</span><br><span class="line">  //右指针</span><br><span class="line">  let right = end;</span><br><span class="line">  while (left &lt; right) &#123;</span><br><span class="line">    //从右</span><br><span class="line">    while (temp &lt;= data[right] &amp;&amp; left &lt; right) &#123;</span><br><span class="line">      right--;</span><br><span class="line">    &#125;</span><br><span class="line">    //从左</span><br><span class="line">    while (temp &gt;= data[left] &amp;&amp; left &lt; right) &#123;</span><br><span class="line">      left++;</span><br><span class="line">    &#125;</span><br><span class="line">    //此时的left和right位置元素交换位置</span><br><span class="line">    /**</span><br><span class="line">     * 1.可以使用变量交换两个元素</span><br><span class="line">     * 2.这里的交换方法针对left和right相同情况时做了一层判断</span><br><span class="line">     */</span><br><span class="line">    if (left !== right) &#123;</span><br><span class="line">      data[right] = data[left] + data[right];</span><br><span class="line">      data[left] = data[right] - data[left];</span><br><span class="line">      data[right] = data[right] - data[left];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  //参考值与此时的结束位置元素交换位置  (判断情况与上面类似)</span><br><span class="line">  if (start !== left) &#123;</span><br><span class="line">    data[start] = data[left] + data[start];</span><br><span class="line">    data[left] = data[start] - data[left];</span><br><span class="line">    data[start] = data[start] - data[left];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  test18(data, start, left - 1);</span><br><span class="line">  test18(data, left + 1, end);</span><br><span class="line">  console.log(data);</span><br><span class="line">&#125;</span><br><span class="line">//test18([-1, -3, -3, 7, 10, 14, 14], 0, 6);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>假设有且仅有 1 个最大公共子串。</li>
<li>比如，输入 a = “13452439”， b = “123456”。由于字符串 “345” 同时在 a 和 b 中出现，且是同时出现在 a 和 b 中的最长子串。因此输出 “345”。<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function test19(strA, strB) &#123;</span><br><span class="line">  //记录字符串a的下标</span><br><span class="line">  let indexB = -1;</span><br><span class="line">  //记录字符串b的下标</span><br><span class="line">  let indexA = -1;</span><br><span class="line">  let map = new Map();</span><br><span class="line">  for (let i = 0; i &lt; strA.length; i++) &#123;</span><br><span class="line">    indexA = i;</span><br><span class="line">    indexB = strB.indexOf(strA[i]);</span><br><span class="line">    //strA[i]是否存在strB中</span><br><span class="line">    if (indexB !== -1) &#123;</span><br><span class="line">      let str = strA[i];</span><br><span class="line">      map.set(str, str.length);</span><br><span class="line">      for (let j = indexB + 1; j &lt; strB.length; j++) &#123;</span><br><span class="line">        if (strA[++indexA] === strB[j]) &#123;</span><br><span class="line">          str += strB[j];</span><br><span class="line">          map.set(str, str.length);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  for (const [key, value] of map) &#123;</span><br><span class="line">    if (value === Math.max.apply(null, [...map.values()])) &#123;</span><br><span class="line">      console.log(`最大公共字符串为：$&#123;key&#125;`);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//test19(&quot;13145612439&quot;, &quot;1234562&quot;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>两个有序数组查找合并之后的中位数。给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出这两个正序数组合在一起之后的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</li>
<li>你可以假设 nums1 和 nums2 不会同时为空，所有的数字全都不相等。还可以再假设，如果数字个数为偶数个，中位数就是中间偏左的那个元素。</li>
<li>例如：nums1 = [1, 3, 5, 7, 9]</li>
<li>nums2 = [2, 4, 8, 12]</li>
<li>输出 5。<br>*/</li>
</ul>
<p>/**</p>
<ul>
<li>小明从小就喜欢数学，喜欢在笔记里记录很多表达式。他觉得现在的表达式写法很麻烦，为了提高运算符优先级，不得不添加很多括号。如果不小心漏了一个右括号的话，就差之毫厘，谬之千里了。</li>
<li>因此他改用前缀表达式，例如把 (2 + 3) <em> 4写成</em> + 2 3 4，这样就能避免使用括号了。这样的表达式虽然书写简单，但计算却不够直观。请你写一个程序帮他计算这些前缀表达式。</li>
<li>在这个题目中，输入就是前缀表达式，输出就是计算的结果。你可以假设除法为整除，即“5/3=1”。例如，输入字符串为 + 2 3，输出 5；输入字符串为 <em> + 2 2 3，输出为 12；输入字符串为 </em> 2 + 2 3，输出为 10。</li>
<li>我们给出一些提示。假设输入字符串为 <em> 2 + 2 3，即 2</em>(2+3)。第一个字符为运算符号 *，它将对两个数字进行乘法。如果后面紧接着的字符不全是数字字符，那就需要暂存下来，先计算后面的算式。一旦后面的计算完成，就需要接着从后往前去继续计算。</li>
<li>因为从后往前是一种逆序动作，我们能够很自然地想到可以用栈的数据结构进行存储。你可以尝试利用栈，去解决这个问题。<br>*/</li>
</ul>
<p>/**</p>
<ul>
<li>给定一个方格棋盘，从左上角出发到右下角有多少种方法</li>
<li>在一个方格棋盘里，左上角是起点，右下角是终点。每次只能向右或向下，移向相邻的格子。同时，棋盘中有若干个格子是陷阱，不可经过，必须绕开行走。</li>
<li>要求用动态规划的方法，求出从起点到终点总共有多少种不同的路径。例如，输入二维矩阵 m 代表棋盘，其中，1 表示格子可达，-1 表示陷阱。输出可行的路径数量为 2。<br>*/</li>
</ul>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2021/03/29/algorithm/">算法</a></p>
        <p><span>文章作者:</span><a href="/" title="访问 DiamondsZz 的个人博客">DiamondsZz</a></p>
        <p><span>发布时间:</span>2021年03月29日</p>
        <p><span>最后更新:</span>2021年04月02日 - 22时05分</p>    
    </div>



<nav id="article-nav">
  
  
    <a href="/2021/03/25/vue/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">vue进阶</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>


  
</article>

    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    
</div>
<style>
    .left-col .switch-btn {
        display: none;
    }
    .left-col .switch-area {
        display: none;
    }
</style>
<input type="button" id="tocButton" value="隐藏目录" title="点击按钮隐藏或者显示文章目录">

<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>

<script>
    var valueHide = "隐藏目录";
    var valueShow = "显示目录";
    if ($(".left-col").is(":hidden")) {
        $("#tocButton").attr("value", valueShow);
    }
    $("#tocButton").click(function() {
        if ($("#toc").is(":hidden")) {
            $("#tocButton").attr("value", valueHide);
            $("#toc").slideDown(320);
            $(".switch-btn, .switch-area").fadeOut(300);
        }
        else {
            $("#tocButton").attr("value", valueShow);
            $("#toc").slideUp(350);
            $(".switch-btn, .switch-area").fadeIn(500);
        }
    })
    if ($(".toc").length < 1) {
        $("#toc, #tocButton").hide();
        $(".switch-btn, .switch-area").show();
    }
</script>






    



    <div class="scroll" id="post-nav-button">
        
            <a href="/" title="回到主页"><i class="fa fa-home"></i></a>
        
        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>
        
            <a href="/2021/03/25/vue/" title="下一篇: vue进阶">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>
    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/03/29/algorithm/">算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/25/vue/">vue进阶</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/25/core/">核心进阶</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/08/module_webpack/">模块化/webpack</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/08/yeoman/">脚手架/yeoman/gulp</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/01/10/question_five/">知识点五</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/01/10/question_four/">知识点四</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/01/10/question_two/">知识点二</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/01/10/question_one/">知识点一</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/16/question/">知识点</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/24/question_three/">知识点三</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/02/life/">记录生活</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/30/bug/">遇到的一些坑</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/10/store/">杂货铺</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/03/wfe/">前端笔记（旧）</a></li></ul>
    
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>

    <script>
        $(".post-list").addClass("toc-article");
        // $(".post-list-item a").attr("target","_blank");
        $("#post-nav-button > a:nth-child(2)").click(function() {
            $(".fa-bars, .fa-times").toggle();
            $(".post-list").toggle(300);
            if ($(".toc").length > 0) {
                $("#toc, #tocButton").toggle(200, function() {
                    if ($(".switch-area").is(":visible")) {
                        $("#toc, .switch-btn, .switch-area").toggle();
                        $("#tocButton").attr("value", valueHide);
                        }
                    })
            }
            else {
                $(".switch-btn, .switch-area").fadeToggle(300);
            }
        })
    </script>




    <script>
        
    </script>

</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2021 DiamondsZz
            </div>        
        </div>
    </div>
</footer>

    </div>
    
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>

<script src="/js/main.js"></script>

    <script>
        $(document).ready(function() {
            var backgroundnum = 1;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>






<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" "="">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(
            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


  </div>
</body>
</html>