<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  <meta name="baidu-site-verification" content="L6Lm9d5Crl">
  
  
  
  
  <title>核心进阶 | DiamondsZz</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="数据类型 基础类型存储在栈内存，被引用或拷贝时，会创建一个完全相等的变量； Undefined Null String Number Boolean Symbol BigInt   引用类型存储在堆内存，存储的是地址，多个引用指向同一个地址，这里会涉及一个“共享”的概念。 ObjectArray Date RegExp Function Math    1234567891011121314151">
<meta name="keywords" content="资源,学习,网站">
<meta property="og:type" content="article">
<meta property="og:title" content="核心进阶">
<meta property="og:url" content="https://DiamondsZz.github.io/2021/03/25/core/index.html">
<meta property="og:site_name" content="DiamondsZz">
<meta property="og:description" content="数据类型 基础类型存储在栈内存，被引用或拷贝时，会创建一个完全相等的变量； Undefined Null String Number Boolean Symbol BigInt   引用类型存储在堆内存，存储的是地址，多个引用指向同一个地址，这里会涉及一个“共享”的概念。 ObjectArray Date RegExp Function Math    1234567891011121314151">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2021-04-21T13:20:46.416Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="核心进阶">
<meta name="twitter:description" content="数据类型 基础类型存储在栈内存，被引用或拷贝时，会创建一个完全相等的变量； Undefined Null String Number Boolean Symbol BigInt   引用类型存储在堆内存，存储的是地址，多个引用指向同一个地址，这里会涉及一个“共享”的概念。 ObjectArray Date RegExp Function Math    1234567891011121314151">
  
    <link rel="alternative" href="/atom.xml" title="DiamondsZz" type="application/atom+xml">
  
  
  
  <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet">
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: false,
          isPost: true,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>

        <a href="/" class="profilepic">
            
            <img lazy-src="/img/iu.jpeg" class="js-avatar">
            
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">DiamondsZz</a></h1>
        </hgroup>
        
        <p class="header-subtitle">DiamondsZz</p>
        
        
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        
        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                        </ul>
                    </nav>
                </section>
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/css/" style="font-size: 13.33px;">css</a> <a href="/tags/js/" style="font-size: 16.67px;">js</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/学习/" style="font-size: 20px;">学习</a> <a href="/tags/生活，心情/" style="font-size: 10px;">生活，心情</a> <a href="/tags/网站/" style="font-size: 20px;">网站</a> <a href="/tags/资源/" style="font-size: 20px;">资源</a>
                    </div>
                </section>
                
                
                
                
                <section class="switch-part switch-part3">
                
                    <div id="js-aboutme">矮穷矬!</div>
                </section>
                
            </div>
        </div>
    </header>
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">DiamondsZz</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/img/iu.jpeg" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">DiamondsZz</a></h1>
            </hgroup>
            
            <p class="header-subtitle">DiamondsZz</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                </div>
            </nav>
        </header>
    </div>
</nav>
      <div class="body-wrap"><article id="post-core" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2021/03/25/core/" class="article-date">
      <time datetime="2021-03-24T16:00:00.000Z" itemprop="datePublished">2021-03-25</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      核心进阶
    </h1>
  


      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/学习/">学习</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/学习/">学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网站/">网站</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/资源/">资源</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ol>
<li>基础类型存储在栈内存，被引用或拷贝时，会创建一个完全相等的变量；<blockquote>
<p><code>Undefined</code> <code>Null</code> <code>String</code> <code>Number</code> <code>Boolean</code> <code>Symbol</code> <code>BigInt</code></p>
</blockquote>
</li>
<li>引用类型存储在堆内存，存储的是地址，多个引用指向同一个地址，这里会涉及一个“共享”的概念。<blockquote>
<p><code>Object</code><br><code>Array</code> <code>Date</code> <code>RegExp</code> <code>Function</code> <code>Math</code></p>
</blockquote>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">let a = &#123;</span><br><span class="line">  name: &quot;Julia&quot;,</span><br><span class="line"></span><br><span class="line">  age: 20,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function change(o) &#123;</span><br><span class="line">  o.age = 24;</span><br><span class="line">  //关键   变量o改变内存指向 跟a已经没有关系</span><br><span class="line">  o = &#123;</span><br><span class="line">    name: &quot;Kath&quot;,</span><br><span class="line">    age: 30,</span><br><span class="line">  &#125;;</span><br><span class="line">  return o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let b = change(a);</span><br><span class="line"></span><br><span class="line">console.log(b.age); // 第一个console   30</span><br><span class="line"></span><br><span class="line">console.log(a.age); // 第二个console   24</span><br></pre></td></tr></table></figure>
<h2 id="数据类型检测"><a href="#数据类型检测" class="headerlink" title="数据类型检测"></a>数据类型检测</h2><ol>
<li>typeof<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">typeof 1 // &apos;number&apos;</span><br><span class="line"></span><br><span class="line">typeof &apos;1&apos; // &apos;string&apos;</span><br><span class="line"></span><br><span class="line">typeof undefined // &apos;undefined&apos;</span><br><span class="line"></span><br><span class="line">typeof true // &apos;boolean&apos;</span><br><span class="line"></span><br><span class="line">typeof Symbol() // &apos;symbol&apos;</span><br><span class="line"></span><br><span class="line">typeof null // &apos;object&apos;       !!!!!!!!!!!!!!!!</span><br><span class="line"></span><br><span class="line">typeof [] // &apos;object&apos;</span><br><span class="line"></span><br><span class="line">typeof &#123;&#125; // &apos;object&apos;</span><br><span class="line"></span><br><span class="line">typeof console // &apos;object&apos;</span><br><span class="line"></span><br><span class="line">typeof console.log // &apos;function&apos;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>虽然 typeof null 会输出 object，但这只是 JS 存在的一个悠久 Bug，不代表 null 就是引用数据类型，并且 null 本身也不是对象。因此，null 在 typeof 之后返回的是有问题的结果，不能作为判断 null 的方法。如果你需要在 if 语句中判断是否为 null，直接通过 ‘===null’来判断就好。</li>
<li>引用数据类型 Object，用 typeof 来判断的话，除了 function 会判断为 OK 以外，其余都是 ‘object’，是无法判断出来的。</li>
</ul>
<ol start="2">
<li>instanceof<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">let Car = function() &#123;&#125;</span><br><span class="line"></span><br><span class="line">let benz = new Car()</span><br><span class="line"></span><br><span class="line">benz instanceof Car // true</span><br><span class="line"></span><br><span class="line">let car = new String(&apos;Mercedes Benz&apos;)</span><br><span class="line"></span><br><span class="line">car instanceof String // true</span><br><span class="line"></span><br><span class="line">let str = &apos;Covid-19&apos;</span><br><span class="line"></span><br><span class="line">str instanceof String // false</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------------------------------</span><br><span class="line"></span><br><span class="line">function myInstanceof(left, right) &#123;</span><br><span class="line"></span><br><span class="line">  // 这里先用typeof来判断基础数据类型，如果是，直接返回false</span><br><span class="line"></span><br><span class="line">  if(typeof left !== &apos;object&apos; || left === null) return false;</span><br><span class="line"></span><br><span class="line">  // getPrototypeOf是Object对象自带的API，能够拿到参数的原型对象</span><br><span class="line"></span><br><span class="line">  let proto = Object.getPrototypeOf(left);</span><br><span class="line"></span><br><span class="line">  while(true) &#123;                  //循环往下寻找，直到找到相同的原型对象</span><br><span class="line"></span><br><span class="line">    if(proto === null) return false;</span><br><span class="line"></span><br><span class="line">    if(proto === right.prototype) return true;//找到相同原型对象，返回true</span><br><span class="line"></span><br><span class="line">    proto = Object.getPrototypeof(proto);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 验证一下自己实现的myInstanceof是否OK</span><br><span class="line"></span><br><span class="line">console.log(myInstanceof(new Number(123), Number));    // true</span><br><span class="line"></span><br><span class="line">console.log(myInstanceof(123, Number));                // false</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>instanceof 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型；</li>
<li>而 typeof 也存在弊端，它虽然可以判断基础数据类型（null 除外），但是引用数据类型中，除了 function 类型以外，其他的也无法判断。</li>
</ul>
<ol start="3">
<li>Object.prototype.toString<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString(&#123;&#125;)       // &quot;[object Object]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(&#123;&#125;)  // 同上结果，加上call也ok</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(1)    // &quot;[object Number]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(&apos;1&apos;)  // &quot;[object String]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(true)  // &quot;[object Boolean]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(function()&#123;&#125;)  // &quot;[object Function]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(null)   //&quot;[object Null]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(undefined) //&quot;[object Undefined]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(/123/g)    //&quot;[object RegExp]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(new Date()) //&quot;[object Date]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call([])       //&quot;[object Array]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(document)  //&quot;[object HTMLDocument]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(window)   //&quot;[object Window]&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function getType(obj)&#123;</span><br><span class="line">  let type  = typeof obj;</span><br><span class="line">  if (type !== &quot;object&quot;) &#123;    // 先进行typeof判断，如果是基础数据类型，直接返回</span><br><span class="line">    return type;</span><br><span class="line">  &#125;</span><br><span class="line">  // 对于typeof返回结果是object的，再进行如下的判断，正则返回结果</span><br><span class="line">  return Object.prototype.toString.call(obj).replace(/^\[object (\S+)\]$/, &apos;$1&apos;);  // 注意正则中间有个空格</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><ol>
<li>强制类型转换 Number()、parseInt()、parseFloat()、toString()、String()、Boolean()<blockquote>
<p>Number() 方法的强制转换规则<br>如果是布尔值，true 和 false 分别被转换为 1 和 0；<br>如果是数字，返回自身；<br>如果是 null，返回 0；<br>如果是 undefined，返回 NaN；<br>如果是字符串，遵循以下规则：如果字符串中只包含数字（或者是 0X / 0x 开头的十六进制数字字符串，允许包含正负号），则将其转换为十进制；如果字符串中包含有效的浮点格式，将其转换为浮点数值；如果是空字符串，将其转换为 0；如果不是以上格式的字符串，均返回 NaN；<br>如果是 Symbol，抛出错误；<br>如果是对象，并且部署了 [Symbol.toPrimitive] ，那么调用此方法，否则调用对象的 valueOf() 方法，然后依据前面的规则转换返回的值；如果转换的结果是 NaN ，则调用对象的 toString() 方法，再次依照前面的顺序转换返回对应的值</p>
</blockquote>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Number(true);        // 1</span><br><span class="line"></span><br><span class="line">Number(false);       // 0</span><br><span class="line"></span><br><span class="line">Number(&apos;0111&apos;);      //111</span><br><span class="line"></span><br><span class="line">Number(null);        //0</span><br><span class="line"></span><br><span class="line">Number(&apos;&apos;);          //0</span><br><span class="line"></span><br><span class="line">Number(&apos;1a&apos;);        //NaN</span><br><span class="line"></span><br><span class="line">Number(-0X11);       //-17</span><br><span class="line"></span><br><span class="line">Number(&apos;0X11&apos;)       //17</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Boolean() 方法的强制转换规则<br>除了 undefined、 null、 false、 ‘’、 0（包括 +0，-0）、 NaN 转换出来是 false，其他都是 true。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Boolean(0)          //false</span><br><span class="line"></span><br><span class="line">Boolean(null)       //false</span><br><span class="line"></span><br><span class="line">Boolean(undefined)  //false</span><br><span class="line"></span><br><span class="line">Boolean(NaN)        //false</span><br><span class="line"></span><br><span class="line">Boolean(1)          //true</span><br><span class="line"></span><br><span class="line">Boolean(13)         //true</span><br><span class="line"></span><br><span class="line">Boolean(&apos;12&apos;)       //true</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>‘==’ 的隐式类型转换规则</li>
</ol>
<ul>
<li>如果类型相同，无须进行类型转换；</li>
<li>如果其中一个操作值是 null 或者 undefined，那么另一个操作符必须为 null 或者 undefined，才会返回 true，否则都返回 false；</li>
<li>如果其中一个是 Symbol 类型，那么返回 false；</li>
<li>两个操作值如果为 string 和 number 类型，那么就会将字符串转换为 number；</li>
<li>如果一个操作值是 boolean，那么转换成 number；</li>
<li>如果一个操作值为 object 且另一方为 string、number 或者 symbol，就会把 object 转为原始类型再进行判断（调用 object 的 valueOf/toString 方法进行转换）。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">null == undefined       // true  规则2</span><br><span class="line"></span><br><span class="line">null == 0               // false 规则2</span><br><span class="line"></span><br><span class="line">&apos;&apos; == null              // false 规则2</span><br><span class="line"></span><br><span class="line">&apos;&apos; == 0                 // true  规则4 字符串转隐式转换成Number之后再对比</span><br><span class="line"></span><br><span class="line">&apos;123&apos; == 123            // true  规则4 字符串转隐式转换成Number之后再对比</span><br><span class="line"></span><br><span class="line">0 == false              // true  e规则 布尔型隐式转换成Number之后再对比</span><br><span class="line"></span><br><span class="line">1 == true               // true  e规则 布尔型隐式转换成Number之后再对比</span><br><span class="line"></span><br><span class="line">var a = &#123;</span><br><span class="line"></span><br><span class="line">  value: 0,</span><br><span class="line"></span><br><span class="line">  valueOf: function() &#123;</span><br><span class="line"></span><br><span class="line">    this.value++;</span><br><span class="line"></span><br><span class="line">    return this.value;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 注意这里a又可以等于1、2、3</span><br><span class="line"></span><br><span class="line">console.log(a == 1 &amp;&amp; a == 2 &amp;&amp; a ==3);  //true f规则 Object隐式转换</span><br><span class="line"></span><br><span class="line">// 注：但是执行过3遍之后，再重新执行a==3或之前的数字就是false，因为value已经加上去了，这里需要注意一下</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="3">
<li>‘+’ 的隐式类型转换规则</li>
</ol>
<ul>
<li>如果其中有一个是字符串，另外一个是 undefined、null 或布尔型，则调用 toString() 方法进行字符串拼接；如果是纯对象、数组、正则等，则默认调用对象的转换方法会存在优先级，然后再进行拼接。</li>
<li>如果其中有一个是数字，另外一个是 undefined、null、布尔型或数字，则会将其转换成数字进行加法运算，对象的情况还是参考上一条规则。</li>
<li>如果其中一个是字符串、一个是数字，则按照字符串规则进行拼接</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1 + 2        // 3  常规情况</span><br><span class="line"></span><br><span class="line">&apos;1&apos; + &apos;2&apos;    // &apos;12&apos; 常规情况</span><br><span class="line"></span><br><span class="line">// 下面看一下特殊情况</span><br><span class="line"></span><br><span class="line">&apos;1&apos; + undefined   // &quot;1undefined&quot; 规则1，undefined转换字符串</span><br><span class="line"></span><br><span class="line">&apos;1&apos; + null        // &quot;1null&quot; 规则1，null转换字符串</span><br><span class="line"></span><br><span class="line">&apos;1&apos; + true        // &quot;1true&quot; 规则1，true转换字符串</span><br><span class="line"></span><br><span class="line">&apos;1&apos; + 1n          // &apos;11&apos; 比较特殊字符串和BigInt相加，BigInt转换为字符串</span><br><span class="line"></span><br><span class="line">1 + undefined     // NaN  规则2，undefined转换数字相加NaN</span><br><span class="line"></span><br><span class="line">1 + null          // 1    规则2，null转换为0</span><br><span class="line"></span><br><span class="line">1 + true          // 2    规则2，true转换为1，二者相加为2</span><br><span class="line"></span><br><span class="line">1 + 1n            // 错误  不能把BigInt和Number类型直接混合相加</span><br><span class="line"></span><br><span class="line">&apos;1&apos; + 3           // &apos;13&apos; 规则3，字符串拼接</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>Object 的转换规则</li>
</ol>
<ul>
<li>如果部署了 Symbol.toPrimitive 方法，优先调用再返回；</li>
<li>调用 valueOf()，如果转换为基础类型，则返回；</li>
<li>调用 toString()，如果转换为基础类型，则返回；</li>
<li>如果都没有返回基础类型，会报错。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line"></span><br><span class="line">  value: 1,</span><br><span class="line"></span><br><span class="line">  valueOf() &#123;</span><br><span class="line"></span><br><span class="line">    return 2;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line"></span><br><span class="line">    return &apos;3&apos;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  [Symbol.toPrimitive]() &#123;</span><br><span class="line"></span><br><span class="line">    return 4</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(obj + 1); // 输出5</span><br><span class="line"></span><br><span class="line">// 因为有Symbol.toPrimitive，就优先执行这个；如果Symbol.toPrimitive这段代码删掉，则执行valueOf打印结果为3；如果valueOf也去掉，则调用toString返回&apos;31&apos;(字符串拼接)</span><br><span class="line"></span><br><span class="line">// 再看两个特殊的case：</span><br><span class="line"></span><br><span class="line">10 + &#123;&#125;</span><br><span class="line"></span><br><span class="line">// &quot;10[object Object]&quot;，注意：&#123;&#125;会默认调用valueOf是&#123;&#125;，不是基础类型继续转换，调用toString，返回结果&quot;[object Object]&quot;，于是和10进行&apos;+&apos;运算，按照字符串拼接规则来，参考&apos;+&apos;的规则C</span><br><span class="line"></span><br><span class="line">[1,2,undefined,4,5] + 10</span><br><span class="line"></span><br><span class="line">// &quot;1,2,,4,510&quot;，注意[1,2,undefined,4,5]会默认先调用valueOf结果还是这个数组，不是基础数据类型继续转换，也还是调用toString，返回&quot;1,2,,4,5&quot;，然后再和10进行运算，还是按照字符串拼接规则，参考&apos;+&apos;的第3条规则</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h2><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><ol>
<li>Object.assign<br><em>注意点</em></li>
</ol>
<ul>
<li>它不会拷贝对象的继承属性；</li>
<li>它不会拷贝对象的不可枚举的属性；</li>
<li>可以拷贝 Symbol 类型的属性。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">let obj1 = &#123; a:&#123; b:1 &#125;, sym:Symbol(1)&#125;; </span><br><span class="line"></span><br><span class="line">Object.defineProperty(obj1, &apos;innumerable&apos; ,&#123;</span><br><span class="line"></span><br><span class="line">    value:&apos;不可枚举属性&apos;,</span><br><span class="line"></span><br><span class="line">    enumerable:false</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">let obj2 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Object.assign(obj2,obj1)</span><br><span class="line"></span><br><span class="line">obj1.a.b = 2;</span><br><span class="line"></span><br><span class="line">console.log(&apos;obj1&apos;,obj1);</span><br><span class="line"></span><br><span class="line">console.log(&apos;obj2&apos;,obj2);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="2">
<li>扩展运算符<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/* 对象的拷贝 */</span><br><span class="line"></span><br><span class="line">let obj = &#123;a:1,b:&#123;c:1&#125;&#125;</span><br><span class="line"></span><br><span class="line">let obj2 = &#123;...obj&#125;</span><br><span class="line"></span><br><span class="line">obj.a = 2</span><br><span class="line"></span><br><span class="line">console.log(obj)  //&#123;a:2,b:&#123;c:1&#125;&#125; console.log(obj2); //&#123;a:1,b:&#123;c:1&#125;&#125;</span><br><span class="line"></span><br><span class="line">obj.b.c = 2</span><br><span class="line"></span><br><span class="line">console.log(obj)  //&#123;a:2,b:&#123;c:2&#125;&#125; console.log(obj2); //&#123;a:1,b:&#123;c:2&#125;&#125;</span><br><span class="line"></span><br><span class="line">/* 数组的拷贝 */</span><br><span class="line"></span><br><span class="line">let arr = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">let newArr = [...arr]; //跟arr.slice()是一样的效果</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>扩展运算符 和 object.assign 有同样的缺陷，也就是实现的浅拷贝的功能差不多，但是如果属性都是基本类型的值，使用扩展运算符进行浅拷贝会更加方便。</li>
</ul>
<ol start="3">
<li>concat 拷贝数组<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">let newArr = arr.concat();</span><br><span class="line"></span><br><span class="line">newArr[1] = 100;</span><br><span class="line"></span><br><span class="line">console.log(arr);  // [ 1, 2, 3 ]</span><br><span class="line"></span><br><span class="line">console.log(newArr); // [ 1, 100, 3 ]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>concat 只能用于数组的浅拷贝，使用场景比较局限。</li>
</ul>
<ol start="4">
<li>slice 拷贝数组</li>
</ol>
<ul>
<li>slice 方法也比较有局限性，因为它仅仅针对数组类型。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, 2, &#123;val: 4&#125;];</span><br><span class="line"></span><br><span class="line">let newArr = arr.slice();</span><br><span class="line"></span><br><span class="line">newArr[2].val = 1000;</span><br><span class="line"></span><br><span class="line">console.log(arr);  //[ 1, 2, &#123; val: 1000 &#125; ]</span><br></pre></td></tr></table></figure>
<ul>
<li>浅拷贝只能拷贝一层对象。如果存在对象的嵌套，那么浅拷贝将无能为力。因此深拷贝就是为了解决这个问题而生的，它能解决多层对象嵌套问题，彻底实现拷贝。</li>
</ul>
<ol start="5">
<li>浅拷贝</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">const shallowClone = (target) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  if (typeof target === &apos;object&apos; &amp;&amp; target !== null) &#123;</span><br><span class="line"></span><br><span class="line">    const cloneTarget = Array.isArray(target) ? []: &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    for (let prop in target) &#123;</span><br><span class="line"></span><br><span class="line">      //是否是自有属性</span><br><span class="line">      if (target.hasOwnProperty(prop)) &#123;</span><br><span class="line"></span><br><span class="line">          cloneTarget[prop] = target[prop];</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return cloneTarget;</span><br><span class="line"></span><br><span class="line">  &#125; else &#123;</span><br><span class="line"></span><br><span class="line">    return target;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><ol>
<li>JSON.stringify()<br><em>弊端</em></li>
</ol>
<ul>
<li>拷贝的对象的值中如果有函数、undefined、symbol 这几种类型，经过 JSON.stringify 序列化之后的字符串中这个键值对会消失；</li>
<li>拷贝 Date 引用类型会变成字符串；</li>
<li>无法拷贝不可枚举的属性；</li>
<li>无法拷贝对象的原型链；</li>
<li>拷贝 RegExp 引用类型会变成空对象；</li>
<li>对象中含有 NaN、Infinity 以及 -Infinity，JSON 序列化的结果会变成 null；</li>
<li>无法拷贝对象的循环应用，即对象成环 (obj[key] = obj)。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">function Obj() &#123; </span><br><span class="line"></span><br><span class="line">  this.func = function () &#123; alert(1) &#125;; </span><br><span class="line"></span><br><span class="line">  this.obj = &#123;a:1&#125;;</span><br><span class="line"></span><br><span class="line">  this.arr = [1,2,3];</span><br><span class="line"></span><br><span class="line">  this.und = undefined; </span><br><span class="line"></span><br><span class="line">  this.reg = /123/; </span><br><span class="line"></span><br><span class="line">  this.date = new Date(0); </span><br><span class="line"></span><br><span class="line">  this.NaN = NaN;</span><br><span class="line"></span><br><span class="line">  this.infinity = Infinity;</span><br><span class="line"></span><br><span class="line">  this.sym = Symbol(1);</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">let obj1 = new Obj();</span><br><span class="line"></span><br><span class="line">Object.defineProperty(obj1,&apos;innumerable&apos;,&#123; </span><br><span class="line"></span><br><span class="line">  enumerable:false,</span><br><span class="line"></span><br><span class="line">  value:&apos;innumerable&apos;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&apos;obj1&apos;,obj1);</span><br><span class="line"></span><br><span class="line">let str = JSON.stringify(obj1);</span><br><span class="line"></span><br><span class="line">let obj2 = JSON.parse(str);</span><br><span class="line"></span><br><span class="line">console.log(&apos;obj2&apos;,obj2);</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 JSON.stringify 方法实现深拷贝对象，虽然到目前为止还有很多无法实现的功能，但是这种方法足以满足日常的开发需求，并且是最简单和快捷的。</li>
</ul>
<ol start="2">
<li>手写递归实现<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">let obj1 = &#123;</span><br><span class="line"></span><br><span class="line">  a:&#123;</span><br><span class="line"></span><br><span class="line">    b:1</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function deepClone(obj) &#123; </span><br><span class="line"></span><br><span class="line">  let cloneObj = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  for(let key in obj) &#123;                 //遍历</span><br><span class="line"></span><br><span class="line">    if(typeof obj[key] ===&apos;object&apos;) &#123; </span><br><span class="line"></span><br><span class="line">      cloneObj[key] = deepClone(obj[key])  //是对象就再次调用该函数递归</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">      cloneObj[key] = obj[key]  //基本类型的话直接复制值</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return cloneObj</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let obj2 = deepClone(obj1);</span><br><span class="line"></span><br><span class="line">obj1.a.b = 2;</span><br><span class="line"></span><br><span class="line">console.log(obj2);   //  &#123;a:&#123;b:1&#125;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><em>弊端</em></p>
<ul>
<li>这个深拷贝函数并不能复制不可枚举的属性以及 Symbol 类型；</li>
<li>这种方法只是针对普通的引用类型的值做递归复制，而对于 Array、Date、RegExp、Error、Function 这样的引用类型并不能正确地拷贝；</li>
<li>对象的属性里面成环，即循环引用没有解决。</li>
</ul>
<ol start="3">
<li>改进后递归实现<br><em>注意点</em></li>
</ol>
<ul>
<li>针对能够遍历对象的不可枚举属性以及 Symbol 类型，我们可以使用 Reflect.ownKeys 方法；</li>
<li>当参数为 Date、RegExp 类型，则直接生成一个新的实例返回；</li>
<li>利用 Object 的 getOwnPropertyDescriptors 方法可以获得对象的所有属性，以及对应的特性，顺便结合 Object 的 create 方法创建一个新对象，并继承传入原对象的原型链；</li>
<li>利用 WeakMap 类型作为 Hash 表，因为 WeakMap 是弱引用类型，可以有效防止内存泄漏（你可以关注一下 Map 和 weakMap 的关键区别，这里要用 weakMap），作为检测循环引用很有帮助，如果存在循环，则引用直接返回 WeakMap 存储的值。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">const isComplexDataType = obj =&gt; (typeof obj === &apos;object&apos; || typeof obj === &apos;function&apos;) &amp;&amp; (obj !== null)</span><br><span class="line"></span><br><span class="line">const deepClone = function (obj, hash = new WeakMap()) &#123;</span><br><span class="line"></span><br><span class="line">  if (obj.constructor === Date) </span><br><span class="line"></span><br><span class="line">  return new Date(obj)       // 日期对象直接返回一个新的日期对象</span><br><span class="line"></span><br><span class="line">  if (obj.constructor === RegExp)</span><br><span class="line"></span><br><span class="line">  return new RegExp(obj)     //正则对象直接返回一个新的正则对象</span><br><span class="line"></span><br><span class="line">  //如果循环引用了就用 weakMap 来解决</span><br><span class="line"></span><br><span class="line">  if (hash.has(obj)) return hash.get(obj)</span><br><span class="line"></span><br><span class="line">  let allDesc = Object.getOwnPropertyDescriptors(obj)</span><br><span class="line"></span><br><span class="line">  //遍历传入参数所有键的特性</span><br><span class="line"></span><br><span class="line">  let cloneObj = Object.create(Object.getPrototypeOf(obj), allDesc)</span><br><span class="line"></span><br><span class="line">  //继承原型链</span><br><span class="line"></span><br><span class="line">  hash.set(obj, cloneObj)</span><br><span class="line"></span><br><span class="line">  for (let key of Reflect.ownKeys(obj)) &#123; </span><br><span class="line"></span><br><span class="line">    cloneObj[key] = (isComplexDataType(obj[key]) &amp;&amp; typeof obj[key] !== &apos;function&apos;) ? deepClone(obj[key], hash) : obj[key]</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return cloneObj</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 下面是验证代码</span><br><span class="line"></span><br><span class="line">let obj = &#123;</span><br><span class="line"></span><br><span class="line">  num: 0,</span><br><span class="line"></span><br><span class="line">  str: &apos;&apos;,</span><br><span class="line"></span><br><span class="line">  boolean: true,</span><br><span class="line"></span><br><span class="line">  unf: undefined,</span><br><span class="line"></span><br><span class="line">  nul: null,</span><br><span class="line"></span><br><span class="line">  obj: &#123; name: &apos;我是一个对象&apos;, id: 1 &#125;,</span><br><span class="line"></span><br><span class="line">  arr: [0, 1, 2],</span><br><span class="line"></span><br><span class="line">  func: function () &#123; console.log(&apos;我是一个函数&apos;) &#125;,</span><br><span class="line"></span><br><span class="line">  date: new Date(0),</span><br><span class="line"></span><br><span class="line">  reg: new RegExp(&apos;/我是一个正则/ig&apos;),</span><br><span class="line"></span><br><span class="line">  [Symbol(&apos;1&apos;)]: 1,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.defineProperty(obj, &apos;innumerable&apos;, &#123;</span><br><span class="line"></span><br><span class="line">  enumerable: false, value: &apos;不可枚举属性&apos; &#125;</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">obj = Object.create(obj, Object.getOwnPropertyDescriptors(obj))</span><br><span class="line"></span><br><span class="line">obj.loop = obj    // 设置loop成循环引用的属性</span><br><span class="line"></span><br><span class="line">let cloneObj = deepClone(obj)</span><br><span class="line"></span><br><span class="line">cloneObj.arr.push(4)</span><br><span class="line"></span><br><span class="line">console.log(&apos;obj&apos;, obj)</span><br><span class="line"></span><br><span class="line">console.log(&apos;cloneObj&apos;, cloneObj)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ol>
<li>原型链继承<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function Parent1() &#123;</span><br><span class="line"></span><br><span class="line">  this.name = &apos;parent1&apos;;</span><br><span class="line"></span><br><span class="line">  this.play = [1, 2, 3]</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child1() &#123;</span><br><span class="line"></span><br><span class="line">  this.type = &apos;child2&apos;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child1.prototype = new Parent1();</span><br><span class="line">let c1=new Child1()</span><br><span class="line">let c2=new Child1()</span><br><span class="line">console.log(c1.__proto__===c2.__proto__); //true</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>两个实例使用的是同一个原型对象。它们的内存空间是共享的，当一个发生变化的时候，另外一个也随之进行了变化，这就是使用原型链继承方式的一个缺点。</p>
<ol start="2">
<li>构造函数继承（借助 call）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">function Parent1()&#123;</span><br><span class="line"></span><br><span class="line">  this.name = &apos;parent1&apos;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Parent1.prototype.getName = function () &#123;</span><br><span class="line"></span><br><span class="line">  return this.name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function Child1()&#123;</span><br><span class="line"></span><br><span class="line">  Parent1.call(this);</span><br><span class="line"></span><br><span class="line">  this.type = &apos;child1&apos;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let child = new Child1();</span><br><span class="line"></span><br><span class="line">console.log(child);  // 没问题</span><br><span class="line"></span><br><span class="line">console.log(child.getName());  // 会报错</span><br></pre></td></tr></table></figure>
<p>构造函数实现继承的优缺点，它使父类的引用属性不会被共享，优化了第一种继承方式的弊端；<br>但是随之而来的缺点也比较明显——只能继承父类的实例属性和方法，不能继承原型属性或者方法。</p>
<ol start="3">
<li><p>组合继承（前两种组合）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">function Parent3 () &#123;</span><br><span class="line"></span><br><span class="line">  this.name = &apos;parent3&apos;;</span><br><span class="line"></span><br><span class="line">  this.play = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Parent3.prototype.getName = function () &#123;</span><br><span class="line"></span><br><span class="line">  return this.name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child3() &#123;</span><br><span class="line"></span><br><span class="line">  // 第二次调用 Parent3()</span><br><span class="line"></span><br><span class="line">  Parent3.call(this);</span><br><span class="line"></span><br><span class="line">  this.type = &apos;child3&apos;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 第一次调用 Parent3()</span><br><span class="line"></span><br><span class="line">Child3.prototype = new Parent3();</span><br><span class="line"></span><br><span class="line">// 手动挂上构造器，指向自己的构造函数</span><br><span class="line"></span><br><span class="line">Child3.prototype.constructor = Child3;</span><br><span class="line"></span><br><span class="line">var s3 = new Child3();</span><br><span class="line"></span><br><span class="line">var s4 = new Child3();</span><br><span class="line"></span><br><span class="line">s3.play.push(4);</span><br><span class="line"></span><br><span class="line">console.log(s3.play, s4.play);  // 不互相影响</span><br><span class="line"></span><br><span class="line">console.log(s3.getName()); // 正常输出&apos;parent3&apos;</span><br><span class="line"></span><br><span class="line">console.log(s4.getName()); // 正常输出&apos;parent3&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>原型式继承</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">let parent4 = &#123;</span><br><span class="line"></span><br><span class="line">  name: &quot;parent4&quot;,</span><br><span class="line"></span><br><span class="line">  friends: [&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;],</span><br><span class="line"></span><br><span class="line">  getName: function() &#123;</span><br><span class="line"></span><br><span class="line">    return this.name;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let person4 = Object.create(parent4);</span><br><span class="line"></span><br><span class="line">person4.name = &quot;tom&quot;;</span><br><span class="line"></span><br><span class="line">person4.friends.push(&quot;jerry&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let person5 = Object.create(parent4);</span><br><span class="line"></span><br><span class="line">person5.friends.push(&quot;lucy&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">console.log(person4.name);</span><br><span class="line"></span><br><span class="line">console.log(person4.name === person4.getName());</span><br><span class="line"></span><br><span class="line">console.log(person5.name);</span><br><span class="line"></span><br><span class="line">console.log(person4.friends);</span><br><span class="line"></span><br><span class="line">console.log(person5.friends);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>最后两个输出结果是一样的，关于引用数据类型“共享”的问题，其实 Object.create 方法是可以为一些对象实现浅拷贝的。<br>关于这种继承方式的缺点也很明显，多个实例的引用类型属性指向相同的内存，存在篡改的可能。</p>
<ol start="5">
<li>寄生式继承</li>
</ol>
<ul>
<li><p>使用原型式继承可以获得一份目标对象的浅拷贝，然后利用这个浅拷贝的能力再进行增强，添加一些方法，这样的继承方式就叫作寄生式继承。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"> let parent5 = &#123;</span><br><span class="line"></span><br><span class="line">  name: &quot;parent5&quot;,</span><br><span class="line"></span><br><span class="line">  friends: [&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;],</span><br><span class="line"></span><br><span class="line">  getName: function() &#123;</span><br><span class="line"></span><br><span class="line">    return this.name;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function clone(original) &#123;</span><br><span class="line"></span><br><span class="line">  let clone = Object.create(original);</span><br><span class="line"></span><br><span class="line">  clone.getFriends = function() &#123;</span><br><span class="line"></span><br><span class="line">    return this.friends;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return clone;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let person5 = clone(parent5);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">console.log(person5.getName());</span><br><span class="line"></span><br><span class="line">console.log(person5.getFriends());</span><br></pre></td></tr></table></figure>
</li>
<li><p>虽然其优缺点和原型式继承一样，但是对于普通对象的继承方式来说，寄生式继承相比于原型式继承，还是在父类基础上添加了更多的方法。</p>
</li>
</ul>
<ol start="6">
<li>寄生组合式继承</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">function clone (parent, child) &#123;</span><br><span class="line"></span><br><span class="line">  // 这里改用 Object.create 就可以减少组合继承中多进行一次构造的过程</span><br><span class="line"></span><br><span class="line">  child.prototype = Object.create(parent.prototype);</span><br><span class="line"></span><br><span class="line">  child.prototype.constructor = child;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function Parent6() &#123;</span><br><span class="line"></span><br><span class="line">  this.name = &apos;parent6&apos;;</span><br><span class="line"></span><br><span class="line">  this.play = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> Parent6.prototype.getName = function () &#123;</span><br><span class="line"></span><br><span class="line">  return this.name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child6() &#123;</span><br><span class="line"></span><br><span class="line">  Parent6.call(this);</span><br><span class="line"></span><br><span class="line">  this.friends = &apos;child5&apos;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">clone(Parent6, Child6);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Child6.prototype.getFriends = function () &#123;</span><br><span class="line"></span><br><span class="line">  return this.friends;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let person6 = new Child6();</span><br><span class="line"></span><br><span class="line">console.log(person6);</span><br><span class="line"></span><br><span class="line">console.log(person6.getName());</span><br><span class="line"></span><br><span class="line">console.log(person6.getFriends());</span><br></pre></td></tr></table></figure>
<ul>
<li>这种寄生组合式继承方式，基本可以解决前几种继承方式的缺点，较好地实现了继承想要的结果，同时也减少了构造次数，减少了性能的开销</li>
</ul>
<ol start="7">
<li>ES6 的 extends 关键字实现逻辑<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line"></span><br><span class="line">  constructor(name) &#123;</span><br><span class="line"></span><br><span class="line">    this.name = name</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 原型方法</span><br><span class="line"></span><br><span class="line">  // 即 Person.prototype.getName = function() &#123; &#125;</span><br><span class="line"></span><br><span class="line">  // 下面可以简写为 getName() &#123;...&#125;</span><br><span class="line"></span><br><span class="line">  getName = function () &#123;</span><br><span class="line"></span><br><span class="line">    console.log(&apos;Person:&apos;, this.name)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Gamer extends Person &#123;</span><br><span class="line"></span><br><span class="line">  constructor(name, age) &#123;</span><br><span class="line"></span><br><span class="line">    // 子类中存在构造函数，则需要在使用“this”之前首先调用 super()。</span><br><span class="line"></span><br><span class="line">    super(name)</span><br><span class="line"></span><br><span class="line">    this.age = age</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const asuna = new Gamer(&apos;Asuna&apos;, 20)</span><br><span class="line"></span><br><span class="line">asuna.getName() // 成功访问到父类的方法</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>利用 babel 这个编译工具，将 ES6 的代码编译成 ES5</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">function _possibleConstructorReturn (self, call) &#123; </span><br><span class="line"></span><br><span class="line">		// ...</span><br><span class="line"></span><br><span class="line">		return call &amp;&amp; (typeof call === &apos;object&apos; || typeof call === &apos;function&apos;) ? call : self; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _inherits (subClass, superClass) &#123; </span><br><span class="line"></span><br><span class="line">    // 这里可以看到</span><br><span class="line"></span><br><span class="line">	subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, &#123; </span><br><span class="line"></span><br><span class="line">		constructor: &#123; </span><br><span class="line"></span><br><span class="line">			value: subClass, </span><br><span class="line"></span><br><span class="line">			enumerable: false, </span><br><span class="line"></span><br><span class="line">			writable: true, </span><br><span class="line"></span><br><span class="line">			configurable: true </span><br><span class="line"></span><br><span class="line">		&#125; </span><br><span class="line"></span><br><span class="line">	&#125;); </span><br><span class="line"></span><br><span class="line">	if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var Parent = function Parent () &#123;</span><br><span class="line"></span><br><span class="line">	// 验证是否是 Parent 构造出来的 this</span><br><span class="line"></span><br><span class="line">	_classCallCheck(this, Parent);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var Child = (function (_Parent) &#123;</span><br><span class="line"></span><br><span class="line">	_inherits(Child, _Parent);</span><br><span class="line"></span><br><span class="line">	function Child () &#123;</span><br><span class="line"></span><br><span class="line">		_classCallCheck(this, Child);</span><br><span class="line"></span><br><span class="line">		return _possibleConstructorReturn(this, (Child.__proto__ || Object.getPrototypeOf(Child)).apply(this, arguments));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	return Child;</span><br><span class="line"></span><br><span class="line">&#125;(Parent));</span><br></pre></td></tr></table></figure>
<p>从上面编译完成的源码中可以看到，它采用的也是寄生组合继承方式，因此也证明了这种方式是较优的解决继承的方式。</p>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><ul>
<li>不管是什么样的计算机程序语言，运行在对应的代码引擎上，对应的使用内存过程大致逻辑是一样的，可以分为这三个步骤：</li>
</ul>
<ol>
<li>分配你所需要的系统内存空间；</li>
<li>使用分配到的内存进行读或者写等操作；</li>
<li>不需要使用内存时，将其空间释放或者归还。</li>
</ol>
<ul>
<li><p>在 JavaScript 中，当我们创建变量（对象，字符串等）的时候，系统会自动给对象分配对应的内存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var a = 123; // 给数值变量分配栈内存</span><br><span class="line"></span><br><span class="line">var etf = &quot;ARK&quot;; // 给字符串分配栈内存</span><br><span class="line"></span><br><span class="line">// 给对象及其包含的值分配堆内存</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line"></span><br><span class="line">  name: &apos;tom&apos;,</span><br><span class="line"></span><br><span class="line">  age: 13</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">// 给数组及其包含的值分配内存（就像对象一样）</span><br><span class="line"></span><br><span class="line">var a = [1, null, &quot;PSAC&quot;]; </span><br><span class="line"></span><br><span class="line">// 给函数（可调用的对象）分配内存</span><br><span class="line"></span><br><span class="line">function sum(a, b)&#123;</span><br><span class="line"></span><br><span class="line">  return a + b;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>栈内存中的基本类型，可以通过操作系统直接处理；<br>而堆内存中的引用类型，正是由于可以经常变化，大小不固定，因此需要 JavaScript 的引擎通过垃圾回收机制来处理。</p>
<h3 id="chrome内存回收机制"><a href="#chrome内存回收机制" class="headerlink" title="chrome内存回收机制"></a>chrome内存回收机制</h3></li>
<li>在 Chrome 浏览器中，JavaScript 的 V8 引擎被限制了内存的使用，根据不同的操作系统（操作系统有 64 位和 32 位的）内存大小会不同，大的可以到 1.4G 的空间，小的只能到 0.7G 的空间。</li>
<li>为什么要去限制内存使用呢？<br>大致是两个原因：V8 最开始是为浏览器而设计的引擎，早些年由于 Web 应用都比较简单，其实并未考虑占据过多的内存空间；<br>另外又由于被 V8 的垃圾回收机制所限制，比如清理大量的内存时会耗费很多时间，这样会引起 JavaScript 执行的线程被挂起，会影响当前执行的页面应用的性能。<h4 id="新生代内存回收"><a href="#新生代内存回收" class="headerlink" title="新生代内存回收"></a>新生代内存回收</h4></li>
<li>新生代的内存回收的空间，在 64 位操作系统下分配为 32MB，正是因为新生代中的变量存活时间短，不太容易产生太大的内存压力，因此不够大也是可以理解的。</li>
<li>系统会将分配给新生代的内存空间分为两部分：正在使用的内存空间[1]，闲置的内存空间[2]<br>当浏览器开始进行内存的垃圾回收时，JavaScript 的 V8 引擎会将[1]的对象检查一遍。如果引擎检测是存活对象，那么会复制到[2]去；如果不是存活的对象，则直接进行系统回收。当所有[1]的对象没有了的时候，等再有新生代的对象产生时，[1][2]对调，这样来循环处理。</li>
<li><code>算法 Scavenge</code>，它主要就是解决内存碎片<h4 id="老生代内存回收"><a href="#老生代内存回收" class="headerlink" title="老生代内存回收"></a>老生代内存回收</h4></li>
<li>新生代中的变量如果经过回收之后依然一直存在，那么就会被放入到老生代内存中。</li>
<li>只要是已经经历过一次 Scavenge 算法回收的，就可以晋升为老生代内存的对象</li>
<li>对于内存空间比较大的，就不适合用 Scavenge 算法了。</li>
<li>老生代内存中的垃圾回收,采用了 <code>Mark-Sweep（标记清除）</code> 和 <code>Mark-Compact（标记整理）</code>的策略</li>
</ul>
<ol>
<li>标记清除（Mark-Sweep）<br>分为两个阶段：标记阶段和清除阶段。<br>首先它会遍历堆上的所有的对象，分别对它们打上标记；然后在代码执行过程结束之后，对使用过的变量取消标记。<br>那么没取消标记的就是没有使用过的变量，因此在清除阶段，就会把还有标记的进行整体清除，从而释放内存空间。</li>
</ol>
<p>通过标记清除之后，还是会出现内存碎片的问题。标记整理策略（Mark-Compact）用来解决内存碎片的问题。</p>
<ol start="2">
<li>标记整理（Mark-Compact）<br>标记整理添加了活动对象整理阶段，处理过程中会将所有的活动对象往一端靠拢，整体移动完成后，直接清理掉边界外的内存。<br>Scavenge 算法比较适合内存较小的情况处理；而对于老生代内存较大、变量较多的时候，还是需要采用“标记-清除”结合“标记-整理”这样的方式处理内存问题，并尽量避免内存碎片的产生。<h3 id="内存泄漏与优化"><a href="#内存泄漏与优化" class="headerlink" title="内存泄漏与优化"></a>内存泄漏与优化</h3></li>
</ol>
<ul>
<li>内存泄漏的场景：</li>
</ul>
<ol>
<li>过多的缓存未释放；</li>
<li>闭包太多未释放；</li>
<li>定时器或者回调太多未释放；</li>
<li>太多无效的 DOM 未释放；</li>
<li>全局变量太多未被发现。</li>
</ol>
<h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><h3 id="时间、空间复杂度"><a href="#时间、空间复杂度" class="headerlink" title="时间、空间复杂度"></a>时间、空间复杂度</h3><p>通常，复杂度的计算方法遵循以下几个原则：</p>
<ol>
<li>首先，复杂度与具体的常系数无关，例如 O(n) 和 O(2n) 表示的是同样的复杂度。<br>我们详细分析下，O(2n) 等于 O(n+n)，也等于 O(n) + O(n)。<br>也就是说，一段 O(n) 复杂度的代码只是先后执行两遍 O(n)，其复杂度是一致的。</li>
<li>其次，多项式级的复杂度相加的时候，选择高者作为结果，例如 O(n²)+O(n) 和 O(n²) 表示的是同样的复杂度。<br>具体分析一下就是，O(n²)+O(n) = O(n²+n)。随着 n 越来越大，二阶多项式的变化率是要比一阶多项式更大的。<br>因此，只需要通过更大变化率的二阶多项式来表征复杂度就可以了。</li>
<li>值得一提的是，O(1) 也是表示一个特殊复杂度，含义为某个任务通过有限可数的资源即可完成。<br>此处有限可数的具体意义是，与输入数据量 n 无关。</li>
<li>一个顺序结构的代码，时间复杂度是 O(1)。</li>
<li>二分查找，或者更通用地说是采用分而治之的二分策略，时间复杂度都是 O(logn)。这个我们会在后续课程讲到。</li>
<li>一个简单的 for 循环，时间复杂度是 O(n)。</li>
<li>两个顺序执行的 for 循环，时间复杂度是 O(n)+O(n)=O(2n)，其实也是 O(n)。</li>
<li>两个嵌套的 for 循环，时间复杂度是 O(n²)。</li>
<li>程序优化的最核心的思路，简单梳理如下：<br>第一步，暴力解法。在没有任何时间、空间约束下，完成代码任务的开发。<br>第二步，无效操作处理。将代码中的无效计算、无效存储剔除，降低时间或空间复杂度。<br>第三步，时空转换。设计合理数据结构，完成时间复杂度向空间复杂度的转移。<h3 id="增删查"><a href="#增删查" class="headerlink" title="增删查"></a>增删查</h3></li>
<li>链表和数组一样，都是 O(n) 空间复杂度的复杂数据结构。但其区别之一就是，数组有 index 的索引，而链表没有。<br>① 有了 index 的索引，所以我们就可以直接进行查找操作来，这里的时间复杂度为 O(1)。<br>② 链表因为没有索引，只能“一个接一个”地按照位置条件查找，在这种情况下时间复杂度就是 O (n)。</li>
<li>数据处理的基本操作只有 3 个，分别是增、删、查。其中，增和删又可以细分为在数据结构中间的增和删，以及在数据结构最后的增和删。<br>区别就在于原数据的位置是否发生改变。查找又可以细分为按照位置条件的查找和按照数据数值特征的查找。<br>几乎所有的数据处理，都是这些基本操作的组合和叠加。<h3 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h3></li>
</ol>
<ul>
<li>最常用的是链式表达，通常也叫作线性链表或者链表。</li>
</ul>
<ol>
<li>虽然链表在新增和删除数据上有优势，但仔细思考就会发现，这个优势并不实用。这主要是因为，在新增数据时，通常会伴随一个查找的动作。例如，在第五个结点后，新增一个新的数据结点，那么执行的操作就包含两个步骤：<br>①第一步，查找第五个结点；<br>②第二步，再新增一个数据结点。整体的复杂度就是 O(n) + O(1)，也就是O(n)。</li>
<li>线性表真正的价值在于，它对数据的存储方式是按照顺序的存储。<br>如果数据的元素个数不确定，且需要经常进行数据的新增和删除时，那么链表会比较合适。<br>如果数据元素大小确定，删除插入的操作并不多，那么数组可能更适合些。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">例 1，链表的翻转。给定一个链表，输出翻转后的链表。例如，输入1 -&gt;2 -&gt; 3 -&gt; 4 -&gt;5，输出 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1。</span><br><span class="line">我们来仔细看一下这个问题的难点在哪里，这里有两种情况：</span><br><span class="line">如果是数组的翻转，这会非常容易。原因在于，数组在连续的空间进行存储，可以直接求解出数组的长度。而且，数组可以通过索引值去查找元素，然后对相应的数据进行交换操作而完成翻转。</span><br><span class="line">但对于某个单向链表，它的指针结构造成了它的数据通路有去无回，一旦修改了某个指针，后面的数据就会造成失联的状态。为了解决这个问题，我们需要构造三个指针 prev、curr 和 next，对当前结点、以及它之前和之后的结点进行缓存，再完成翻转动作。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">例 2，给定一个奇数个元素的链表，查找出这个链表中间位置的结点的数值。</span><br><span class="line">这个问题也是利用了链表的长度无法直接获取的不足做文章，解决办法如下：</span><br><span class="line">一个暴力的办法是，先通过一次遍历去计算链表的长度，这样我们就知道了链表中间位置是第几个。接着再通过一次遍历去查找这个位置的数值。</span><br><span class="line">除此之外，还有一个巧妙的办法，就是利用快慢指针进行处理。其中快指针每次循环向后跳转两次，而慢指针每次向后跳转一次。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">例 3，判断链表是否有环。</span><br><span class="line">假设链表有环，这个环里面就像是一个跑步赛道的操场一样。经过多次循环之后，快指针和慢指针都会进入到这个赛道中，就好像两个跑步选手在比赛。</span><br><span class="line">快指针每次走两格，而慢指针每次走一格，相对而言，快指针每次循环会多走一步。</span><br><span class="line">这就意味着：如果链表存在环，快指针和慢指针一定会在环内相遇，即 fast == slow 的情况一定会发生。</span><br><span class="line">反之，则最终会完成循环，二者从未相遇。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><h4 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h4><ol>
<li>栈的顺序存储可以借助数组来实现。一般来说，会把数组的首元素存在栈底，最后一个元素放在栈顶。<br>然后定义一个 top 指针来指示栈顶元素在数组中的位置。假设栈中只有一个数据元素，则 top = 0。<br>一般以 top 是否为 -1 来判定是否为空栈。<br>当定义了栈的最大容量为 StackSize 时，则栈顶 top 必须小于 StackSize。</li>
<li>对于查找操作，栈没有额外的改变，跟线性表一样，它也需要遍历整个栈来完成基于某些条件的数值查找。</li>
<li>删除数据元素，即出栈操作，只需要 top - 1 就可以了。<h4 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h4></li>
<li>关于链式栈，就是用链表的方式对栈的表示。</li>
<li>在链式栈中进行删除操作时，只能在栈顶进行操作。因此，将栈顶的 top 指针指向栈顶元素的 next 指针即可完成删除。</li>
<li>对于链式栈来说，新增删除数据元素没有任何循环操作，其时间复杂度均为 O(1)。</li>
</ol>
<ul>
<li>不管是顺序栈还是链栈，数据的新增、删除、查找与线性表的操作原理极为相似，时间复杂度完全一样，都依赖当前位置的指针来进行数据对象的操作。区别仅仅在于新增和删除的对象，只能是栈顶的数据结点。<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3>队列也存在这两种存储方式，即顺序队列和链式队列：</li>
</ul>
<ol>
<li>顺序队列，依赖数组来实现，其中的数据在内存中也是顺序存储。</li>
<li>而链式队列，则依赖链表来实现，其中的数据依赖每个结点的指针互联，在内存中并不是顺序存储。链式队列，实际上就是只能尾进头出的线性表的单链表。</li>
<li>队列从队头（front）删除元素，从队尾（rear）插入元素。</li>
<li>队列新增数据的操作，就是利用 rear 指针在队尾新增一个数据元素。这个过程不会影响其他数据，时间复杂度为 O(1)</li>
<li>队列删除数据的操作与栈不同。队列元素出口在队列头部，即下标为 0 的位置。当利用 front 指针删除一个数据时，队列中剩余的元素都需要向前移动一个位置，以保证队列头部下标为 0 的位置不为空，此时时间复杂度就变成 O(n) <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">采用顺序存储的队列时，我们可以通过移动指针的方式来删除数据，这样就不需要移动剩余的数据了。</span><br><span class="line">但是，这样的操作，也可能会产生数组越界的问题。</span><br><span class="line">两个简单粗暴的解决方法就是：</span><br><span class="line">1. 不惜消耗 O(n) 的时间复杂度去移动数据；</span><br><span class="line">2. 或者开辟足够大的内存空间确保数组不会越界。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h4><ol>
<li>循环队列进行新增数据元素操作时，首先判断队列是否为满。<br>如果不满，则可以将新元素赋值给队尾，然后让 rear 指针向后移动一个位置。<br>如果已经排到队列最后的位置，则 rea r指针重新指向头部。</li>
<li>循环队列进行删除操作时，即出队列操作，需要判断队列是否为空，然后将队头元素赋值给返回值，front 指针向后移一个位置。<br>如果已经排到队列最后的位置，就把 front 指针重新指向到头部。<br>这个过程就好像钟表的指针转到了表盘的尾部 12 点的位置后，又重新回到了表盘头部 1 点钟的位置。<br>这样就能在不开辟大量存储空间的前提下，不采用 O(n) 的操作，也能通过移动数据来完成频繁的新增和删除数据。</li>
<li>此时，又会产生新的问题，即当队列为空时，有 front 指针和 rear 指针相等。<br>而现在的队列是满的，同样有 front 指针和 rear 指针相等。<br>那么怎样判断队列到底是空还是满呢？常用的方法是，设置一个标志变量 flag 来区别队列是空还是满。<h4 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h4></li>
<li>链式队列就是一个单链表，同时增加了 front 指针和 rear 指针。<br>链式队列和单链表一样，通常会增加一个头结点，并另 front 指针指向头结点。<br>头结点不存储数据，只是用来辅助标识。</li>
<li>特别值得一提的是，如果这个链表除去头结点外只剩一个元素，那么删除仅剩的一个元素后，rear 指针就变成野指针了。<br>这时候，需要让 rear 指针指向头结点。也许你前面会对头结点存在的意义产生怀疑，似乎没有它也不影响增删的操作。</li>
<li>那么为何队列还特被强调要有头结点呢？<br>这主要是为了防止删除最后一个有效数据结点后， front 指针和 rear 指针变成野指针，导致队列没有意义了。<br>有了头结点后，哪怕队列为空，头结点依然存在，能让 front 指针和 rear 指针依然有意义。</li>
</ol>
<ul>
<li>空间性能方面，循环队列必须有一个固定的长度，因此存在存储元素数量和空间的浪费问题，而链式队列不存在这种问题，所以在空间上，链式队列更为灵活一些。</li>
<li>通常情况下，在可以确定队列长度最大值时，建议使用循环队列。无法确定队列长度时，应考虑使用链式队列。队列具有先进先出的特点，很像现实中人们排队买票的场景。在面对数据处理顺序非常敏感的问题时，队列一定是个不错的技术选型。<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3></li>
<li>树是由结点和边组成的，不存在环的一种数据结构。</li>
<li>没有父结点，则可以称为根结点</li>
<li>没有子结点，则称为叶子结点</li>
<li>树中结点的最大层次数，就是这棵树的树深（称为深度，也称为高度）</li>
<li>树数据的查找操作和链表一样，都需要遍历每一个数据去判断，所以时间复杂度是 O(n)。</li>
<li>对于查找操作，如果是普通二叉树，则查找的时间复杂度和遍历一样，都是 O(n)。如果是二叉查找树，则可以在 O(logn) 的时间复杂度内完成查找动作。<h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4></li>
<li>在二叉树中，每个结点最多有两个分支，即每个结点最多有两个子结点，分别称作左子结点和右子结点。</li>
<li>满二叉树，定义为除了叶子结点外，所有结点都有 2 个子结点。</li>
<li>完全二叉树，定义为除了最后一层以外，其他层的结点个数都达到最大，并且最后一层的叶子结点都靠左排列。之所以称为完全二叉树，是从存储空间利用效率的视角来看的。对于一棵完全二叉树而言，仅仅浪费了下标为 0 的存储位置。而如果是一棵非完全二叉树，则会浪费大量的存储空间。</li>
<li>存储二叉树有两种办法，一种是基于指针的链式存储法，另一种是基于数组的顺序存储法。</li>
<li>根据基于数组的顺序存储法，我们可以发现如果结点 X 的下标为 i，那么 X 的左子结点总是存放在 2 <em> i 的位置，X 的右子结点总是存放在 2 </em> i + 1 的位置。<h5 id="二叉查找树（二叉搜索树）"><a href="#二叉查找树（二叉搜索树）" class="headerlink" title="二叉查找树（二叉搜索树）"></a>二叉查找树（二叉搜索树）</h5></li>
<li>在二叉查找树中的任意一个结点，其左子树中的每个结点的值，都要小于这个结点的值。</li>
<li>在二叉查找树中的任意一个结点，其右子树中每个结点的值，都要大于这个结点的值。</li>
<li>在二叉查找树中，会尽可能规避两个结点数值相等的情况。</li>
<li>对二叉查找树进行中序遍历，就可以输出一个从小到大的有序数据队列。</li>
<li>在利用二叉查找树执行查找操作时，我们可以进行以下判断：</li>
</ul>
<ol>
<li>首先判断根结点是否等于要查找的数据，如果是就返回。</li>
<li>如果根结点大于要查找的数据，就在左子树中递归执行查找动作，直到叶子结点。</li>
<li>如果根结点小于要查找的数据，就在右子树中递归执行查找动作，直到叶子结点。</li>
<li>这样的“二分查找”所消耗的时间复杂度就可以降低为 O(logn)。</li>
</ol>
<ul>
<li>二叉查找树插入数据的时间复杂度是 O(logn)。但这并不意味着它比普通二叉树要复杂。原因在于这里的时间复杂度更多是消耗在了遍历数据去找到查找位置上，真正执行插入动作的时间复杂度仍然是 O(1)。</li>
<li>二叉查找树的删除操作会比较复杂，这是因为删除完某个结点后的树，仍然要满足二叉查找树的性质。</li>
</ul>
<ol>
<li>情况一，如果要删除的结点是某个叶子结点，则直接删除，将其父结点指针指向 null 即可。</li>
<li>情况二，如果要删除的结点只有一个子结点，只需要将其父结点指向的子结点的指针换成其子结点的指针即可。</li>
<li>情况三，如果要删除的结点有两个子结点，则有两种可行的操作方式。①找到这个结点的左子树中最大的结点，替换要删除的结点。②找到这个结点的右子树中最小的结点，替换要删除的结点。<h5 id="Trie-树，或字典树"><a href="#Trie-树，或字典树" class="headerlink" title="Trie 树，或字典树"></a>Trie 树，或字典树</h5></li>
</ol>
<ul>
<li>根结点不包含字符</li>
<li>除根结点外每一个结点都只包含一个字符；</li>
<li>从根结点到某一叶子结点，路径上经过的字符连接起来，即为集合中的某个字符串。<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3></li>
<li>哈希表的设计采用了函数映射的思想，将记录的存储位置与记录的关键字关联起来。这样的设计方式，能够快速定位到想要查找的记录，而且不需要与表中存在的记录的关键字比较后再来进行查找。</li>
<li>如果有一种方法，可以实现“地址 = f (关键字)”的映射关系，那么就可以快速完成基于数据的数值的查找了。这就是哈希表的核心思想</li>
<li>Hash 函数设计的好坏会直接影响到对哈希表的操作效率。</li>
<li>哈希冲突，是需要在设计哈希函数时进行规避的</li>
<li>常用的设计哈希函数的方法：</li>
</ul>
<ol>
<li>直接定制法<br>哈希函数为关键字到地址的线性函数。如，H (key) = a*key + b。 这里，a 和 b 是设置好的常数。</li>
<li>数字分析法<br>假设关键字集合中的每个关键字 key 都是由 s 位数字组成（k1,k2,…,Ks），并从中提取分布均匀的若干位组成哈希地址。上面张一、张二、张三、张四的手机号信息存储，就是使用的这种方法。</li>
<li>平方取中法<br>如果关键字的每一位都有某些数字重复出现，并且频率很高，我们就可以先求关键字的平方值，通过平方扩大差异，然后取中间几位作为最终存储地址。</li>
<li>折叠法<br>如果关键字的位数很多，可以将关键字分割为几个等长的部分，取它们的叠加和的值（舍去进位）作为哈希地址。</li>
<li>除留余数法<br>预先设置一个数 p，然后对关键字进行取余运算。即地址为 key mod p。</li>
</ol>
<ul>
<li>解决哈希冲突</li>
</ul>
<ol>
<li>开放定址法<br>即当一个关键字和另一个关键字发生冲突时，使用某种探测技术在哈希表中形成一个探测序列，然后沿着这个探测序列依次查找下去。当碰到一个空的单元时，则插入其中。<br>常用的探测方法是线性探测法。<br>比如有一组关键字 {12，13，25，23}，采用的哈希函数为 key mod 11。<br>当插入 12，13，25 时可以直接插入，地址分别为 1、2、3。而当插入 23 时，哈希地址为 23 mod 11 = 1。然而，地址 1 已经被占用，因此沿着地址 1 依次往下探测，直到探测到地址 4，发现为空，则将 23 插入其中。</li>
<li>链地址法<br>将哈希地址相同的记录存储在一张线性链表中。</li>
</ol>
<ul>
<li>哈希表相对于其他数据结构有很多的优势。它可以提供非常快速的插入-删除-查找操作，无论多少数据，插入和删除值需要接近常量的时间。在查找方面，哈希表的速度比树还要快，基本可以瞬间查找到想要的元素。</li>
<li>哈希表也有一些不足。哈希表中的数据是没有顺序概念的，所以不能以一种固定的方式（比如从小到大）来遍历其中的元素。在数据处理顺序敏感的问题时，选择哈希表并不是个好的处理方法。同时，哈希表中的 key 是不允许重复的，在重复性非常高的数据中，哈希表也不是个好的选择。<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3></li>
<li>递归的核心思想是把规模大的问题转化为规模小的相似的子问题来解决。</li>
<li>当一个问题同时满足以下 2 个条件时，就可以使用递归的方法求解：</li>
</ul>
<ol>
<li>可以拆解为除了数据规模以外，求解思路完全相同的子问题；</li>
<li>存在终止条件。<h3 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h3></li>
</ol>
<ul>
<li>分治法的核心思想就是“分而治之”。</li>
<li>利用分而治之的思想，就可以把一个大规模、高难度的问题，分解为若干个小规模、低难度的小问题。随后，开发者将面对多个简单的问题，并很快地找到答案各个击破。在把这些简单问题解决好之后，我们通过把这些小问题的答案合并，就得到了原问题的答案。</li>
<li>二分查找，则是利用分治法去解决查找问题。通常二分查找需要一个前提，那就是输入的数列是有序的。</li>
<li>二分查找的时间复杂度是 O(logn)，这也是分治法普遍具备的特性。当你面对某个代码题，而且约束了时间复杂度是 O(logn) 或者是 O(nlogn) 时，可以想一下分治法是否可行。</li>
<li>二分查找的循环次数并不确定。一般是达到某个条件就跳出循环。因此，编码的时候，多数会采用 while 循环加 break 跳出的代码结构。</li>
<li>二分查找处理的原问题必须是有序的。因此，当你在一个有序数据环境中处理问题时，可以考虑分治法。相反，如果原问题中的数据并不是有序的，则使用分治法的可能性就会很低了。<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3></li>
<li>衡量一个排序算法的优劣，我们主要会从以下 3 个角度进行分析：</li>
</ul>
<ol>
<li>时间复杂度，具体包括，最好时间复杂度、最坏时间复杂度以及平均时间复杂度。</li>
<li>空间复杂度，如果空间复杂度为 1，也叫作原地排序。</li>
<li>稳定性，排序的稳定性是指相等的数据对象，在排序之后，顺序是否能保证不变。</li>
<li>排序最暴力的方法，时间复杂度是 O(n*n)。这恰如冒泡排序和插入排序。</li>
<li>当我们利用算法思维去解决问题时，就会想到尝试分治法。此时，利用归并排序就能让时间复杂度降低到 O(nlogn)。然而，归并排序需要额外开辟临时空间。一方面是为了保证稳定性，另一方面则是在归并时，由于在数组中插入元素导致了数据挪移的问题。</li>
<li>为了规避因此而带来的时间损耗，此时我们采用快速排序。通过交换操作，可以解决插入元素导致的数据挪移问题，而且降低了不必要的空间开销。但是由于其动态二分的交换数据，导致了由此得出的排序结果并不稳定。</li>
<li>如果对数据规模比较小的数据进行排序，可以选择时间复杂度为 O(n<em>n) 的排序算法。因为当数据规模小的时候，时间复杂度 O(nlogn) 和 O(n</em>n) 的区别很小，它们之间仅仅相差几十毫秒，因此对实际的性能影响并不大。</li>
<li>但对数据规模比较大的数据进行排序，就需要选择时间复杂度为 O(nlogn) 的排序算法了。归并排序的空间复杂度为 O(n)，也就意味着当排序 100M 的数据，就需要 200M 的空间，所以对空间资源消耗会很多。快速排序在平均时间复杂度为 O(nlogn)，但是如果分区点选择不好的话，最坏的时间复杂度也有可能逼近 O(n*n)。而且快速排序不具备稳定性，这也需要看你所面对的问题是否有稳定性的需求。<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4></li>
</ol>
<ul>
<li>冒泡排序最好时间复杂度是 O(n)，也就是当输入数组刚好是顺序的时候，只需要挨个比较一遍就行了，不需要做交换操作，所以时间复杂度为 O(n)。</li>
<li>冒泡排序最坏时间复杂度会比较惨，是 O(n<em>n)。也就是说当数组刚好是完全逆序的时候，每轮排序都需要挨个比较 n 次，并且重复 n 次，所以时间复杂度为 O(n</em>n)。</li>
<li>很显然，当输入数组杂乱无章时，它的平均时间复杂度也是 O(n*n)。</li>
<li>冒泡排序不需要额外的空间，所以空间复杂度是 O(1)。冒泡排序过程中，当元素相同时不做交换，所以冒泡排序是稳定的排序算法。<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4></li>
<li>选取未排序的元素，插入到已排序区间的合适位置，直到未排序区间为空。插入排序顾名思义，就是从左到右维护一个已经排好序的序列。直到所有的待排数据全都完成插入的动作。</li>
<li>插入排序最好时间复杂度是 O(n)，即当数组刚好是完全顺序时，每次只用比较一次就能找到正确的位置。这个过程重复 n 次，就可以清空未排序区间。</li>
<li>插入排序最坏时间复杂度则需要 O(n<em>n)。即当数组刚好是完全逆序时，每次都要比较 n 次才能找到正确位置。这个过程重复 n 次，就可以清空未排序区间，所以最坏时间复杂度为 O(n</em>n)。</li>
<li>插入排序的平均时间复杂度是 O(n<em>n)。这是因为往数组中插入一个元素的平均时间复杂度为 O(n)，而插入排序可以理解为重复 n 次的数组插入操作，所以平均时间复杂度为 O(n</em>n)。</li>
<li>插入排序不需要开辟额外的空间，所以空间复杂度是 O(1)。<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4></li>
<li>归并排序法的原理是分治法。</li>
<li>对于归并排序，它采用了二分的迭代方式，复杂度是 logn。</li>
<li>每次的迭代，需要对两个有序数组进行合并，这样的动作在 O(n) 的时间复杂度下就可以完成。因此，归并排序的复杂度就是二者的乘积 O(nlogn)。同时，它的执行频次与输入序列无关，因此，归并排序最好、最坏、平均时间复杂度都是 O(nlogn)。</li>
<li>空间复杂度方面，由于每次合并的操作都需要开辟基于数组的临时内存空间，所以空间复杂度为 O(n)。归并排序合并的时候，相同元素的前后顺序不变，所以归并是稳定的排序算法。<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4></li>
<li>快速排序法的原理也是分治法。</li>
<li>的每轮迭代，会选取数组中任意一个数据作为分区点，将小于它的元素放在它的左侧，大于它的放在它的右侧。再利用分治思想，继续分别对左右两侧进行同样的操作，直至每个区间缩小为 1，则完成排序。</li>
<li>在快排的最好时间的复杂度下，如果每次选取分区点时，都能选中中位数，把数组等分成两个，那么此时的时间复杂度和归并一样，都是 O(n*logn)。</li>
<li>而在最坏的时间复杂度下，也就是如果每次分区都选中了最小值或最大值，得到不均等的两组。那么就需要 n 次的分区操作，每次分区平均扫描 n / 2 个元素，此时时间复杂度就退化为 O(n*n) 了。</li>
<li>快速排序法在大部分情况下，统计上是很难选到极端情况的。因此它平均的时间复杂度是 O(n*logn)。</li>
<li>快速排序法的空间方面，使用了交换法，因此空间复杂度为 O(1)。</li>
<li>很显然，快速排序的分区过程涉及交换操作，所以快排是不稳定的排序算法。<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3></li>
<li>从数学的视角来看，动态规划是一种运筹学方法，是在多轮决策过程中的最优方法。</li>
<li>从分治法的视角来看，每个子问题必须相互独立。但在多轮决策中，这个假设显然不成立。这也是动态规划方法产生的原因之一。</li>
<li>动态规划有一个重要概念叫作状态。</li>
<li>一般而言，具有如下几个特征的问题，可以采用动态规划求解：</li>
</ul>
<ol>
<li>最优子结构。它的含义是，原问题的最优解所包括的子问题的解也是最优的。例如，某个策略使得 A 到 G 是最优的。假设它途径了 Fi，那么它从 A 到 Fi 也一定是最优的。</li>
<li>无后效性。某阶段的决策，无法影响先前的状态。可以理解为今天的动作改变不了历史。</li>
<li>有重叠子问题。也就是，子问题之间不独立。这个性质是动态规划区别于分治法的条件。如果原问题不满足这个特征，也是可以用动态规划求解的，无非就是杀鸡用了宰牛刀。<h2 id="new-apply-call-bind"><a href="#new-apply-call-bind" class="headerlink" title="new/apply/call/bind"></a>new/apply/call/bind</h2><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3></li>
</ol>
<ul>
<li>new 关键词的主要作用就是执行一个构造函数、返回一个实例对象，在 new 的过程中，根据构造函数的情况，来确定是否可以接受参数的传递。</li>
<li>new 在这个生成实例的过程中,大致分为以下几个步骤:</li>
</ul>
<ol>
<li>创建一个新对象；</li>
<li>将构造函数的作用域赋给新对象（this 指向新对象）；</li>
<li>执行构造函数中的代码（为这个新对象添加属性）；</li>
<li>返回新对象。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//如果不用 new 这个关键词，会发生什么样的变化呢？</span><br><span class="line">function Person()&#123;</span><br><span class="line"></span><br><span class="line">  this.name = &apos;Jack&apos;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p = Person();</span><br><span class="line"></span><br><span class="line">console.log(p) // undefined</span><br><span class="line"></span><br><span class="line">console.log(name) // Jack</span><br><span class="line"></span><br><span class="line">console.log(p.name) // &apos;name&apos; of undefined</span><br><span class="line"></span><br><span class="line">//当构造函数中有 return 一个对象的操作，结果又会是什么样子呢？</span><br><span class="line">function Person()&#123;</span><br><span class="line"></span><br><span class="line">   this.name = &apos;Jack&apos;; </span><br><span class="line"></span><br><span class="line">   return &#123;age: 18&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p = new Person(); </span><br><span class="line"></span><br><span class="line">console.log(p)  // &#123;age: 18&#125;</span><br><span class="line"></span><br><span class="line">console.log(p.name) // undefined</span><br><span class="line"></span><br><span class="line">console.log(p.age) // 18</span><br></pre></td></tr></table></figure>
<ul>
<li><p>构造函数必须是返回一个对象，如果返回的不是对象，那么还是会按照 new 的实现步骤，返回新生成的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line"></span><br><span class="line">   this.name = &apos;Jack&apos;; </span><br><span class="line"></span><br><span class="line">   return &apos;tom&apos;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p = new Person(); </span><br><span class="line"></span><br><span class="line">console.log(p)  // &#123;name: &apos;Jack&apos;&#125;</span><br><span class="line"></span><br><span class="line">console.log(p.name) // Jack</span><br></pre></td></tr></table></figure>
</li>
<li><p>new 关键词执行之后总是会返回一个对象，要么是实例对象，要么是 return 语句指定的对象。</p>
<h3 id="call-apply-bind"><a href="#call-apply-bind" class="headerlink" title="call/apply/bind"></a>call/apply/bind</h3></li>
<li><p>call、apply 和 bind 是挂在 Function 对象上的三个方法，调用这三个方法的必须是一个函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func.call(thisArg, param1, param2, ...)</span><br><span class="line"></span><br><span class="line">func.apply(thisArg, [param1,param2,...])</span><br><span class="line"></span><br><span class="line">func.bind(thisArg, param1, param2, ...)</span><br></pre></td></tr></table></figure>
</li>
<li><p>bind 虽然改变了 func 的 this 指向，但不是马上执行，而这两个（call、apply）是在改变了函数的 this 指向之后立马执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">let a = &#123;</span><br><span class="line"></span><br><span class="line">  name: &apos;jack&apos;,</span><br><span class="line"></span><br><span class="line">  getName: function(msg) &#123;</span><br><span class="line"></span><br><span class="line">    return msg + this.name;</span><br><span class="line"></span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let b = &#123;</span><br><span class="line"></span><br><span class="line">  name: &apos;lily&apos;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(a.getName(&apos;hello~&apos;));  // hello~jack</span><br><span class="line"></span><br><span class="line">console.log(a.getName.call(b, &apos;hi~&apos;));  // hi~lily</span><br><span class="line"></span><br><span class="line">console.log(a.getName.apply(b, [&apos;hi~&apos;]))  // hi~lily</span><br><span class="line"></span><br><span class="line">let name = a.getName.bind(b, &apos;hello~&apos;);</span><br><span class="line"></span><br><span class="line">console.log(name());  // hello~lily</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="手写实现"><a href="#手写实现" class="headerlink" title="手写实现"></a>手写实现</h3><h4 id="new-1"><a href="#new-1" class="headerlink" title="new"></a>new</h4><ul>
<li>new 被调用后大致做了哪几件事情。</li>
</ul>
<ol>
<li>让实例可以访问到私有属性；</li>
<li>让实例可以访问构造函数原型（constructor.prototype）所在原型链上的属性；</li>
<li>构造函数返回的最后结果是引用数据类型。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function _new(ctor, ...args) &#123;</span><br><span class="line"></span><br><span class="line">    if(typeof ctor !== &apos;function&apos;) &#123;</span><br><span class="line"></span><br><span class="line">      throw &apos;ctor must be a function&apos;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let obj = new Object();</span><br><span class="line"></span><br><span class="line">    obj.__proto__ = Object.create(ctor.prototype);</span><br><span class="line"></span><br><span class="line">    //关键  this指向</span><br><span class="line">    let res = ctor.apply(obj,  [...args]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    let isObject = typeof res === &apos;object&apos; &amp;&amp; res !== null;</span><br><span class="line"></span><br><span class="line">    let isFunction = typeof res === &apos;function&apos;;</span><br><span class="line"></span><br><span class="line">    return isObject || isFunction ? res : obj;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="call-apply"><a href="#call-apply" class="headerlink" title="call/apply"></a>call/apply</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.call = function (context, ...args) &#123;</span><br><span class="line"></span><br><span class="line">  var context = context || window;</span><br><span class="line">  //当前this指向Function.prototype上面的方法</span><br><span class="line">  context.fn = this;</span><br><span class="line"></span><br><span class="line">  var result = eval(&apos;context.fn(...args)&apos;);</span><br><span class="line"></span><br><span class="line">  delete context.fn</span><br><span class="line"></span><br><span class="line">  return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Function.prototype.apply = function (context, args) &#123;</span><br><span class="line"></span><br><span class="line">  let context = context || window;</span><br><span class="line">  //当前this指向Function.prototype上面的方法</span><br><span class="line">  context.fn = this;</span><br><span class="line"></span><br><span class="line">  let result = eval(&apos;context.fn(...args)&apos;);</span><br><span class="line"></span><br><span class="line">  delete context.fn</span><br><span class="line"></span><br><span class="line">  return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind = function (context, ...args) &#123;</span><br><span class="line"></span><br><span class="line">    if (typeof this !== &quot;function&quot;) &#123;</span><br><span class="line"></span><br><span class="line">      throw new Error(&quot;this must be a function&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var self = this;</span><br><span class="line"></span><br><span class="line">    var fbound = function () &#123;</span><br><span class="line"></span><br><span class="line">        self.apply(this instanceof fbound ? this : context, args.concat(Array.prototype.slice.call(arguments)));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(this.prototype) &#123;</span><br><span class="line"></span><br><span class="line">      fbound.prototype = Object.create(this.prototype);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return fbound;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//new (Math.max.bind(this))();</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>方法特征</th>
<th>call</th>
<th>apply</th>
<th>bind</th>
</tr>
</thead>
<tbody>
<tr>
<td>方法参数</td>
<td>多个</td>
<td>单个数组</td>
<td>多个</td>
</tr>
<tr>
<td>方法功能</td>
<td>函数调用改变this</td>
<td>函数调用改变this</td>
<td>函数调用改变this</td>
</tr>
<tr>
<td>返回结果</td>
<td>直接执行</td>
<td>直接执行</td>
<td>返回待执行函数</td>
</tr>
<tr>
<td>底层实现</td>
<td>通过eval</td>
<td>通过eval</td>
<td>间接调用apply</td>
</tr>
</tbody>
</table>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><ul>
<li>红宝书闭包的定义：闭包是指有权访问另外一个函数作用域中的变量的函数。MDN：一个函数和对其周围状态的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。</li>
<li>作用域链，即当前函数一般都会存在上层函数的作用域的引用，那么他们就形成了一条作用域链。 </li>
<li><p>闭包产生的本质就是：当前环境中存在指向父级作用域的引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">function fun1() &#123;</span><br><span class="line"></span><br><span class="line">  var a = 2</span><br><span class="line"></span><br><span class="line">  function fun2() &#123;</span><br><span class="line"></span><br><span class="line">    console.log(a);  //2</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return fun2;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var result = fun1();</span><br><span class="line"></span><br><span class="line">result();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">是不是只有返回函数才算是产生了闭包呢？其实也不是，回到闭包的本质，我们只需要让父级作用域的引用存在即可，因此还可以这么改代码，如下所示。</span><br><span class="line"></span><br><span class="line">var fun3;</span><br><span class="line"></span><br><span class="line">function fun1() &#123;</span><br><span class="line"></span><br><span class="line">  var a = 2</span><br><span class="line"></span><br><span class="line">  fun3 = function() &#123;</span><br><span class="line"></span><br><span class="line">    console.log(a);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun1();</span><br><span class="line"></span><br><span class="line">fun3();</span><br></pre></td></tr></table></figure>
</li>
<li><p>闭包的表现形式</p>
</li>
</ul>
<ol>
<li>返回一个函数</li>
<li><p>在定时器、事件监听、Ajax 请求、Web Workers 或者任何异步中，只要使用了回调函数，实际上就是在使用闭包。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 定时器</span><br><span class="line"></span><br><span class="line">setTimeout(function handler()&#123;</span><br><span class="line"></span><br><span class="line">  console.log(&apos;1&apos;);</span><br><span class="line"></span><br><span class="line">&#125;，1000);</span><br><span class="line"></span><br><span class="line">// 事件监听</span><br><span class="line"></span><br><span class="line">$(&apos;#app&apos;).click(function()&#123;</span><br><span class="line"></span><br><span class="line">  console.log(&apos;Event Listener&apos;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>作为函数参数传递的形式</p>
</li>
<li>IIFE（立即执行函数），创建了闭包，保存了全局作用域（window）和当前函数的作用域，因此可以输出全局的变量<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a = 2;</span><br><span class="line"></span><br><span class="line">(function IIFE()&#123;</span><br><span class="line"></span><br><span class="line">  console.log(a);  // 输出2</span><br><span class="line"></span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">IIFE 这个函数会稍微有些特殊，算是一种自执行匿名函数，这个匿名函数拥有独立的作用域。这不仅可以避免了外界访问此 IIFE 中的变量，而且又不会污染全局作用域，</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>如何解决循环输出问题？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">for(var i = 1; i &lt;= 5; i ++)&#123;</span><br><span class="line"></span><br><span class="line">  setTimeout(function() &#123;</span><br><span class="line"></span><br><span class="line">    console.log(i)</span><br><span class="line"></span><br><span class="line">  &#125;, 0)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">1.setTimeout 为宏任务，由于 JS 中单线程 eventLoop 机制，在主线程同步任务执行完后才去执行宏任务，因此循环结束后 setTimeout 中的回调才依次执行。</span><br><span class="line">2.因为 setTimeout 函数也是一种闭包，往上找它的父级作用域链就是 window，变量 i 为 window 上的全局变量，开始执行 setTimeout 之前变量 i 已经就是 6 了，因此最后输出的连续就都是 6。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li><p>利用 IIFE</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">for(var i = 1;i &lt;= 5;i++)&#123;</span><br><span class="line"></span><br><span class="line">  (function(j)&#123;</span><br><span class="line"></span><br><span class="line">    setTimeout(function timer()&#123;</span><br><span class="line"></span><br><span class="line">      console.log(j)</span><br><span class="line"></span><br><span class="line">    &#125;, 0)</span><br><span class="line"></span><br><span class="line">  &#125;)(i)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 ES6 中的 let</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for(let i = 1; i &lt;= 5; i++)&#123;</span><br><span class="line"></span><br><span class="line">  setTimeout(function() &#123;</span><br><span class="line"></span><br><span class="line">    console.log(i);</span><br><span class="line"></span><br><span class="line">  &#125;,0)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">ES6 中新增的 let 定义变量的方式，使得 ES6 之后 JS 发生革命性的变化，让 JS 有了块级作用域，代码的作用域以块级为单位进行执行。</span><br></pre></td></tr></table></figure>
</li>
<li><p>定时器传入第三个参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for(var i=1;i&lt;=5;i++)&#123;</span><br><span class="line"></span><br><span class="line">  setTimeout(function(j) &#123;</span><br><span class="line"></span><br><span class="line">    console.log(j)</span><br><span class="line"></span><br><span class="line">  &#125;, 0, i)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>由于闭包会使一些变量一直保存在内存中不会自动释放，所以如果大量使用的话就会消耗大量内存，从而影响网页性能。<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><h3 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse"></a>JSON.parse</h3></li>
<li><code>JSON.parse(text[, reviver])</code>第一个参数是需要解析处理的 JSON 字符串，第二个参数是可选参数提供可选的 reviver 函数，用在返回之前对所得到的对象执行变换操作。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const json = &apos;&#123;&quot;result&quot;:true, &quot;count&quot;:2&#125;&apos;;</span><br><span class="line"></span><br><span class="line">const obj = JSON.parse(json);</span><br><span class="line"></span><br><span class="line">console.log(obj.count);</span><br><span class="line"></span><br><span class="line">// 2</span><br><span class="line"></span><br><span class="line">console.log(obj.result);</span><br><span class="line"></span><br><span class="line">// true</span><br><span class="line"></span><br><span class="line">/* 带第二个参数的情况 */</span><br><span class="line"></span><br><span class="line">JSON.parse(&apos;&#123;&quot;p&quot;: 5&#125;&apos;, function (k, v) &#123;</span><br><span class="line"></span><br><span class="line">    if(k === &apos;&apos;) return v;     // 如果k不是空，</span><br><span class="line"></span><br><span class="line">    return v * 2;              // 就将属性值变为原来的2倍返回</span><br><span class="line"></span><br><span class="line">&#125;);                            // &#123; p: 10 &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify"></a>JSON.stringify</h3><ul>
<li><p>JSON.stringify 方法是将一个 JavaScript 对象或值转换为 JSON 字符串，默认该方法其实有三个参数：第一个参数是必选，后面两个是可选参数非必选。第一个参数传入的是要转换的对象；第二个是一个 replacer 函数，比如指定的 replacer 是数组，则可选择性地仅处理包含数组指定的属性；第三个参数用来控制结果字符串里面的间距，后面两个参数整体用得比较少。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">JSON.stringify(&#123; x: 1, y: 2 &#125;);</span><br><span class="line"></span><br><span class="line">// &quot;&#123;&quot;x&quot;:1,&quot;y&quot;:2&#125;&quot;</span><br><span class="line"></span><br><span class="line">JSON.stringify(&#123; x: [10, undefined, function()&#123;&#125;, Symbol(&apos;&apos;)] &#125;)</span><br><span class="line"></span><br><span class="line">// &quot;&#123;&quot;x&quot;:[10,null,null,null]&#125;&quot;</span><br><span class="line"></span><br><span class="line">/* 第二个参数的例子 */</span><br><span class="line"></span><br><span class="line">function replacer(key, value) &#123;</span><br><span class="line"></span><br><span class="line">  if (typeof value === &quot;string&quot;) &#123;</span><br><span class="line"></span><br><span class="line">    return undefined;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return value;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var foo = &#123;foundation: &quot;Mozilla&quot;, model: &quot;box&quot;, week: 4, transport: &quot;car&quot;, month: 7&#125;;</span><br><span class="line"></span><br><span class="line">var jsonString = JSON.stringify(foo, replacer);</span><br><span class="line"></span><br><span class="line">console.log(jsonString);</span><br><span class="line"></span><br><span class="line">// &quot;&#123;&quot;week&quot;:4,&quot;month&quot;:7&#125;&quot;</span><br><span class="line"></span><br><span class="line">/* 第三个参数的例子 */</span><br><span class="line"></span><br><span class="line">JSON.stringify(&#123; a: 2 &#125;, null, &quot; &quot;);</span><br><span class="line"></span><br><span class="line">/* &quot;&#123;</span><br><span class="line"></span><br><span class="line"> &quot;a&quot;: 2</span><br><span class="line"></span><br><span class="line">&#125;&quot;*/</span><br><span class="line"></span><br><span class="line">JSON.stringify(&#123; a: 2 &#125;, null, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">// &quot;&#123;&quot;a&quot;:2&#125;&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">从上面的代码中可以看到，增加第二个参数 replacer 带来的变化：通过替换方法把对象中的属性为字符串的过滤掉，在 stringify 之后返回的仅为数字的属性变成字符串之后的结果；</span><br><span class="line">当第三个参数传入的是多个空格的时候，则会增加结果字符串里面的间距数量，从最后一段代码中可以看到结果。</span><br></pre></td></tr></table></figure>
</li>
<li><p>手动实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line">function jsonStringify(data) &#123;</span><br><span class="line"></span><br><span class="line">  let type = typeof data;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  if(type !== &apos;object&apos;) &#123;</span><br><span class="line"></span><br><span class="line">    let result = data;</span><br><span class="line"></span><br><span class="line">    //data 可能是基础数据类型的情况在这里处理</span><br><span class="line"></span><br><span class="line">    if (Number.isNaN(data) || data === Infinity) &#123;</span><br><span class="line"></span><br><span class="line">       //NaN 和 Infinity 序列化返回 &quot;null&quot;</span><br><span class="line"></span><br><span class="line">       result = &quot;null&quot;;</span><br><span class="line"></span><br><span class="line">    &#125; else if (type === &apos;function&apos; || type === &apos;undefined&apos; || type === &apos;symbol&apos;) &#123;</span><br><span class="line"></span><br><span class="line">      // 由于 function 序列化返回 undefined，因此和 undefined、symbol 一起处理</span><br><span class="line"></span><br><span class="line">       return undefined;</span><br><span class="line"></span><br><span class="line">    &#125; else if (type === &apos;string&apos;) &#123;</span><br><span class="line"></span><br><span class="line">       result = &apos;&quot;&apos; + data + &apos;&quot;&apos;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return String(result);</span><br><span class="line"></span><br><span class="line">  &#125; else if (type === &apos;object&apos;) &#123;</span><br><span class="line"></span><br><span class="line">     if (data === null) &#123;</span><br><span class="line"></span><br><span class="line">        return &quot;null&quot;  // 第01讲有讲过 typeof null 为&apos;object&apos;的特殊情况</span><br><span class="line"></span><br><span class="line">     &#125; else if (data.toJSON &amp;&amp; typeof data.toJSON === &apos;function&apos;) &#123;</span><br><span class="line"></span><br><span class="line">        return jsonStringify(data.toJSON());</span><br><span class="line"></span><br><span class="line">     &#125; else if (data instanceof Array) &#123;</span><br><span class="line"></span><br><span class="line">        let result = [];</span><br><span class="line"></span><br><span class="line">        //如果是数组，那么数组里面的每一项类型又有可能是多样的</span><br><span class="line"></span><br><span class="line">        data.forEach((item, index) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">        if (typeof item === &apos;undefined&apos; || typeof item === &apos;function&apos; || typeof item === &apos;symbol&apos;) &#123;</span><br><span class="line"></span><br><span class="line">               result[index] = &quot;null&quot;;</span><br><span class="line"></span><br><span class="line">           &#125; else &#123;</span><br><span class="line"></span><br><span class="line">               result[index] = jsonStringify(item);</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">         &#125;);</span><br><span class="line"></span><br><span class="line">         result = &quot;[&quot; + result + &quot;]&quot;;</span><br><span class="line"></span><br><span class="line">         return result.replace(/&apos;/g, &apos;&quot;&apos;);</span><br><span class="line"></span><br><span class="line">      &#125; else &#123;</span><br><span class="line"></span><br><span class="line">         // 处理普通对象</span><br><span class="line"></span><br><span class="line">         let result = [];</span><br><span class="line"></span><br><span class="line">         Object.keys(data).forEach((item, index) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">            if (typeof item !== &apos;symbol&apos;) &#123;</span><br><span class="line"></span><br><span class="line">              //key 如果是 symbol 对象，忽略</span><br><span class="line"></span><br><span class="line">              if (data[item] !== undefined &amp;&amp; typeof data[item] !== &apos;function&apos; &amp;&amp; typeof data[item] !== &apos;symbol&apos;) &#123;</span><br><span class="line"></span><br><span class="line">                //键值如果是 undefined、function、symbol 为属性值，忽略</span><br><span class="line"></span><br><span class="line">                result.push(&apos;&quot;&apos; + item + &apos;&quot;&apos; + &quot;:&quot; + jsonStringify(data[item]));</span><br><span class="line"></span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">         &#125;);</span><br><span class="line"></span><br><span class="line">         return (&quot;&#123;&quot; + result + &quot;&#125;&quot;).replace(/&apos;/g, &apos;&quot;&apos;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">手工实现一个 JSON.stringify 方法的基本代码如上面所示，有几个问题还是需要注意一下：</span><br><span class="line">1.由于 function 返回 &apos;null&apos;， 并且 typeof function 能直接返回精确的判断，故在整体逻辑处理基础数据类型的时候，会随着 undefined，symbol 直接处理了；</span><br><span class="line">2.由于 typeof null 的时候返回&apos;object&apos;，故 null 的判断逻辑整体在处理引用数据类型的逻辑里面；</span><br><span class="line">3.关于引用数据类型中的数组，由于数组的每一项的数据类型又有很多的可能性，故在处理数组过程中又将 undefined，symbol，function 作为数组其中一项的情况做了特殊处理；</span><br><span class="line">4.同样在最后处理普通对象的时候，key （键值）也存在和数组一样的问题，故又需要再针对上面这几种情况（undefined，symbol，function）做特殊处理；</span><br><span class="line">5.最后在处理普通对象过程中，对于循环引用的问题暂未做检测，如果是有循环引用的情况，需要抛出 Error；</span><br><span class="line">6.根据官方给出的 JSON.stringify 的第二个以及第三个参数的实现，本段模拟实现的代码并未实现。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">上面实现的这个 jsonStringify 方法和真正的 JSON.stringify 想要得到的效果是否一样呢？请看下面的测试结果。</span><br><span class="line">let nl = null;</span><br><span class="line"></span><br><span class="line">console.log(jsonStringify(nl) === JSON.stringify(nl));</span><br><span class="line"></span><br><span class="line">// true</span><br><span class="line"></span><br><span class="line">let und = undefined;</span><br><span class="line"></span><br><span class="line">console.log(jsonStringify(undefined) === JSON.stringify(undefined));</span><br><span class="line"></span><br><span class="line">// true</span><br><span class="line"></span><br><span class="line">let boo = false;</span><br><span class="line"></span><br><span class="line">console.log(jsonStringify(boo) === JSON.stringify(boo));</span><br><span class="line"></span><br><span class="line">// true</span><br><span class="line"></span><br><span class="line">let nan = NaN;</span><br><span class="line"></span><br><span class="line">console.log(jsonStringify(nan) === JSON.stringify(nan));</span><br><span class="line"></span><br><span class="line">// true</span><br><span class="line"></span><br><span class="line">let inf = Infinity;</span><br><span class="line"></span><br><span class="line">console.log(jsonStringify(Infinity) === JSON.stringify(Infinity));</span><br><span class="line"></span><br><span class="line">// true</span><br><span class="line"></span><br><span class="line">let str = &quot;jack&quot;;</span><br><span class="line"></span><br><span class="line">console.log(jsonStringify(str) === JSON.stringify(str));</span><br><span class="line"></span><br><span class="line">// true</span><br><span class="line"></span><br><span class="line">let reg = new RegExp(&quot;\w&quot;);</span><br><span class="line"></span><br><span class="line">console.log(jsonStringify(reg) === JSON.stringify(reg));</span><br><span class="line"></span><br><span class="line">// true</span><br><span class="line"></span><br><span class="line">let date = new Date();</span><br><span class="line"></span><br><span class="line">console.log(jsonStringify(date) === JSON.stringify(date));</span><br><span class="line"></span><br><span class="line">// true</span><br><span class="line"></span><br><span class="line">let sym = Symbol(1);</span><br><span class="line"></span><br><span class="line">console.log(jsonStringify(sym) === JSON.stringify(sym));</span><br><span class="line"></span><br><span class="line">// true</span><br><span class="line"></span><br><span class="line">let array = [1,2,3];</span><br><span class="line"></span><br><span class="line">console.log(jsonStringify(array) === JSON.stringify(array));</span><br><span class="line"></span><br><span class="line">// true</span><br><span class="line"></span><br><span class="line">let obj = &#123;</span><br><span class="line"></span><br><span class="line">    name: &apos;jack&apos;,</span><br><span class="line"></span><br><span class="line">    age: 18,</span><br><span class="line"></span><br><span class="line">    attr: [&apos;coding&apos;, 123],</span><br><span class="line"></span><br><span class="line">    date: new Date(),</span><br><span class="line"></span><br><span class="line">    uni: Symbol(2),</span><br><span class="line"></span><br><span class="line">    sayHi: function() &#123;</span><br><span class="line"></span><br><span class="line">        console.log(&quot;hi&quot;)</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    info: &#123;</span><br><span class="line"></span><br><span class="line">        sister: &apos;lily&apos;,</span><br><span class="line"></span><br><span class="line">        age: 16,</span><br><span class="line"></span><br><span class="line">        intro: &#123;</span><br><span class="line"></span><br><span class="line">            money: undefined,</span><br><span class="line"></span><br><span class="line">            job: null</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(jsonStringify(obj) === JSON.stringify(obj));</span><br><span class="line"></span><br><span class="line">// true</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Eventloop"><a href="#Eventloop" class="headerlink" title="Eventloop"></a>Eventloop</h2><h3 id="浏览器的-Eventloop"><a href="#浏览器的-Eventloop" class="headerlink" title="浏览器的 Eventloop"></a>浏览器的 Eventloop</h3><ul>
<li>JavaScript 引擎</li>
</ul>
<ol>
<li>调用堆栈（call stack）负责跟踪所有要执行的代码。每当一个函数执行完成时，就会从堆栈中弹出（pop）该执行完成函数；如果有代码需要进去执行的话，就进行 push 操作，</li>
<li>事件队列（event queue）负责将新的 function 发送到队列中进行处理。它遵循 queue 的数据结构特性，先进先出，在该顺序下发送所有操作以进行执行。</li>
<li>每当调用事件队列（event queue）中的异步函数时，都会将其发送到浏览器 API。根据从调用堆栈收到的命令，API 开始自己的单线程操作。其中 setTimeout 方法就是一个比较典型的例子，在堆栈中处理 setTimeout 操作时，会将其发送到相应的 API，该 API 一直等到指定的时间将此操作送回进行处理。它将操作发送到哪里去呢？答案是事件队列（event queue）。这样，就有了一个循环系统，用于在 JavaScript 中运行异步操作。</li>
<li>JavaScript 语言本身是单线程的，而浏览器 API 充当单独的线程。事件循环（Eventloop）促进了这一过程，它会不断检查调用堆栈是否为空。如果为空，则从事件队列中添加新的函数进入调用栈（call stack）；如果不为空，则处理当前函数的调用。我们把整个过程串起来就是这样的一个循环执行流程</li>
</ol>
<ul>
<li>macrotasks(宏任务):<br><code>script(整体代码),setTimeout,setInterval,setImmediate,I/O,UI rendering,event listner</code></li>
<li>microtasks(微任务):<br><code>process.nextTick, Promises, Object.observe, MutationObserver</code></li>
<li>Eventloop 处理宏任务和微任务的逻辑</li>
</ul>
<ol>
<li>JavaScript 引擎首先从宏任务队列（macrotask queue）中取出第一个任务；</li>
<li>执行完毕后，再将微任务（microtask queue）中的所有任务取出，按照顺序分别全部执行（这里包括不仅指开始执行时队列里的微任务），如果在这一步过程中产生新的微任务，也需要执行；</li>
<li>然后再从宏任务队列中取下一个，执行完毕后，再次将 microtask queue 中的全部取出，循环往复，直到两个 queue 中的任务都取完。</li>
<li>总结起来就是：一次 Eventloop 循环会处理一个宏任务和所有这次循环中产生的微任务。</li>
</ol>
<ul>
<li>各种浏览器事件同时触发时，肯定有一个先来后到的排队问题。决定这些事件如何排队触发的机制，就是事件循环。这个排队行为以 JavaScript 开发者的角度来看，主要是分成两个队列：</li>
</ul>
<ol>
<li>一个是 JavaScript 外部的队列。外部的队列主要是浏览器协调的各类事件的队列，标准文件中称之为 Task Queue。下文中为了方便理解统一称为外部队列。</li>
<li>另一个是 JavaScript 内部的队列。这部分主要是 JavaScript 内部执行的任务队列，标准中称之为 Microtask Queue。下文中为了方便理解统一称为内部队列。</li>
</ol>
<ul>
<li>值得注意的是，虽然为了好理解我们管这个叫队列 (Queue)，但是本质上是有序集合 (Set)，因为传统的队列都是先进先出（FIFO）的，而这里的队列则不然，排到最前面但是没有满足条件也是不会执行的（比如外部队列里只有一个 setTimeout 的定时任务，但是时间还没有到，没有满足条件也不会把他出列来执行）。<h4 id="外部队列"><a href="#外部队列" class="headerlink" title="外部队列"></a>外部队列</h4></li>
<li>外部队列（Task Queue  关于 Task，常有人称它为 Marcotask (宏任务)，但 HTML 标准中没有这种说法。），顾名思义就是 JavaScript 外部的事件的队列，这里我们可以先列举一下浏览器中这些外部事件源（Task Source），他们主要有：</li>
</ul>
<ol>
<li>DOM 操作 (页面渲染)</li>
<li>用户交互 (鼠标、键盘)</li>
<li>网络请求 (Ajax 等)</li>
<li>History API 操作</li>
<li>定时器 (setTimeout 等)</li>
</ol>
<ul>
<li>HTML 标准中明确指出一个事件循环由一个或多个外部队列，而每一个外部事件源都有一个对应的外部队列。不同事件源的队列可以有不同的优先级（例如在网络事件和用户交互之间，浏览器可以优先处理鼠标行为，从而让用户感觉更加流程）。</li>
<li>scripts 执行也是一个事件，我们只要归类一下就会发现 JavaScript 的执行也是一个浏览器发起的外部事件。<h4 id="内部队列"><a href="#内部队列" class="headerlink" title="内部队列"></a>内部队列</h4></li>
<li>内部队列（Microtask Queue），即 JavaScript 语言内部的事件队列，在 HTML 标准中，并没有明确规定这个队列的事件源，通常认为有以下几种：</li>
</ul>
<ol>
<li>Promise 的成功 (.then) 与失败 (.catch)</li>
<li>MutationObserver</li>
<li>Object.observe (已废弃)<h3 id="Node-js-的-Eventloop"><a href="#Node-js-的-Eventloop" class="headerlink" title="Node.js 的 Eventloop"></a>Node.js 的 Eventloop</h3></li>
</ol>
<ul>
<li>当 Node.js 开始启动时，会初始化一个 Eventloop，处理输入的代码脚本，这些脚本会进行 API 异步调用，process.nextTick() 方法会开始处理事件循环。</li>
<li>整个流程分为六个阶段，当这六个阶段执行完一次之后，才可以算得上执行了一次 Eventloop 的循环过程</li>
</ul>
<ol>
<li>Timers 阶段：这个阶段执行 setTimeout 和 setInterval。</li>
<li>I/O callbacks 阶段：这个阶段主要执行系统级别的回调函数，比如 TCP 连接失败的回调。</li>
<li>idle，prepare 阶段：只是 Node.js 内部闲置、准备，可以忽略。</li>
<li>poll 阶段：poll 阶段是一个重要且复杂的阶段，几乎所有 I/O 相关的回调，都在这个阶段执行（除了setTimeout、setInterval、setImmediate 以及一些因为 exception 意外关闭产生的回调）</li>
<li>check 阶段：执行 setImmediate() 设定的 callbacks。</li>
<li>close callbacks 阶段：执行关闭请求的回调函数，比如 socket.on(‘close’, …)。</li>
</ol>
<ul>
<li>除了把 Eventloop 的宏任务细分到不同阶段外。node 还引入了一个新的任务队列 Process.nextTick()。可以认为，Process.nextTick() 会在上述各个阶段结束时，在进入下一个阶段之前立即执行（优先级甚至超过 microtask 队列）。</li>
<li>Node.js 和浏览器端宏任务队列的另一个很重要的不同点是，浏览器端任务队列每轮事件循环仅出队一个回调函数接着去执行微任务队列；而 Node.js 端只要轮到执行某个宏任务队列，则会执行完队列中所有的当前任务，但是当前轮次新添加到队尾的任务则会等到下一轮次才会执行。</li>
<li>HTML (浏览器端) 与 libuv (服务端) 面对的场景有很大的差异。首先能直观感受到的区别是：</li>
</ul>
<ol>
<li>事件循环的过程没有 HTML 渲染。只剩下了外部队列和内部队列这两个部分。</li>
<li>外部队列的事件源不同。Node.js 端没有了鼠标等外设但是新增了文件等 IO。</li>
<li>内部队列的事件仅剩下 Promise 的 then 和 catch。</li>
</ol>
<ul>
<li>至于内在的差异，有一个很重要的地方是 Node.js （libuv）在最初设计的时候是允许执行多次外部的事件再切换到内部队列的，而浏览器端一次事件循环只允许执行一次外部事件。</li>
<li>setImmediate 的引入是为了解决 setTimeout 的精度问题，由于 setTimeout 指定的延迟时间是毫秒（ms）但实际一次事件循环的时间可能是纳秒级的，所以在一次事件循环的多个外部队列中，找到某一个队列直接执行其中的 callback 可以得到比 setTimeout 更早执行的效果。我们继续以开始的场景构造一个例子，并在 Node.js 10.x 的版本上执行（存在一次事件循环执行多次外部事件）。这里 setTimeout 在 setImmediate 后面执行的原因是因为 ms 精度的问题，想要手动 fix 这个精度可以插入一段 const now = Date.now(); wihle (Date.now() &lt; now + 1) {} 即可看到 setTimeout 在 setImmediate 之前执行了。</li>
<li>我们可以推测出 Node.js 中的事件循环与浏览器类似，也是外部队列与内部队列的循环，而 setImmediate 在另外一个外部队列中。</li>
<li>其中主要有两点需要关注，一是外部列队在每次事件循环只执行了一个，另一个是 Node.js 的固定了多个外部队列的优先级。setImmediate 的外部队列没有执行完的时候，是不会执行 timeout 的外部队列的。</li>
<li>timer（setTimeout）是第一阶段的原因在 libuv 的文档中有描述 —— 为了减少时间相关的系统调用（System Call）。setImmediate 出现在 check 阶段是蹭了 libuv 中 poll 阶段之后的检查过程（这个过程放在 poll 中也很奇怪，放在 poll 之后感觉比较合适）。</li>
<li>idle, prepare 对应的是 libuv 中的两个叫做 idle 和 prepare 的句柄。由于 I/O 的 poll 过程可能阻塞住事件循环，所以这两个句柄主要是用来触发 poll （阻塞）之前需要触发的回调</li>
<li>由于 poll 可能 block 住事件循环，所以应当有一个外部队列专门用于执行 I/O 的 callback ，并且优先级在 poll 以及 prepare to poll 之前。</li>
<li>另外我们知道网络 IO 可能有非常多的请求同时进来，如果该阶段如果无限制的执行这些 callback，可能导致 Node.js 的进程卡死该阶段，其他外部队列的代码都没发执行了。所以当前外部队列在执行一定数量的 callback 之后会截断。由于截断的这个特性，这个专门执行 I/O callbacks 的外部队列也叫 pengding callbacks</li>
</ul>
<h3 id="EventLoop-对渲染的影响"><a href="#EventLoop-对渲染的影响" class="headerlink" title="EventLoop 对渲染的影响"></a>EventLoop 对渲染的影响</h3><ul>
<li>浏览器作为一个复杂的应用是多线程工作的，除了运行 JS 的线程外，还有渲染线程、定时器触发线程、HTTP 请求线程，等等。JS 线程可以读取并且修改 DOM，而渲染线程也需要读取 DOM，这是一个典型的多线程竞争临界资源的问题。所以浏览器就把这两个线程设计成互斥的，即同时只能有一个线程在执行。</li>
<li>requestAnimationFrame，这个 API 保证在下次浏览器渲染之前一定会被调用，实际上我们完全可以把它看成是一个高级版的 setInterval。它们都是在一段时间后执行回调，但是前者的间隔时间是由浏览器自己不断调整的，而后者只能由用户指定。这样的特性也决定了 requestAnimationFrame 更适合用来做针对每一帧来修改的动画效果。</li>
<li>当然 requestAnimationFrame 不是 Eventloop 里的宏任务，或者说它并不在 Eventloop 的生命周期里，只是浏览器又开放的一个在渲染之前发生的新的 hook。另外需要注意的是微任务的认知概念也需要更新，在执行 animation callback 时也有可能产生微任务（比如 promise 的 callback），会放到 animation queue 处理完后再执行。所以微任务并不是像之前说的那样在每一轮 Eventloop 后处理，而是在 JS 的函数调用栈清空后处理。</li>
<li>但是 requestIdlecallback 却是一个更好理解的概念。当宏任务队列中没有任务可以处理时，浏览器可能存在“空闲状态”。这段空闲时间可以被 requestIdlecallback 利用起来执行一些优先级不高、不必立即执行的任务,当然为了防止浏览器一直处于繁忙状态，导致 requestIdlecallback 可能永远无法执行回调，它还提供了一个额外的 timeout 参数，为这个任务设置一个截止时间。浏览器就可以根据这个截止时间规划这个任务的执行。</li>
</ul>
<h3 id="宏任务、微任务"><a href="#宏任务、微任务" class="headerlink" title="宏任务、微任务"></a>宏任务、微任务</h3><ul>
<li>宏任务和微任务的执行顺序基本是，在 EventLoop 中，每一次循环称为一次 tick，主要的任务顺序如下：</li>
</ul>
<ol>
<li>执行栈选择最先进入队列的宏任务，执行其同步代码直至结束；</li>
<li>检查是否有微任务，如果有则执行直到微任务队列为空；</li>
<li>如果是在浏览器端，那么基本要渲染页面了；</li>
<li>开始下一轮的循环（tick），执行宏任务中的一些异步代码，例如 setTimeout 等。</li>
</ol>
<ul>
<li>Call-Stack（调用栈）也就是执行栈，它是一个栈的结构，符合先进后出的机制，每次一个循环，先执行最先入队的宏任务，然后再执行微任务。不管微任务还是宏任务，它们只要按照顺序进入了执行栈，那么执行栈就还是按照先进后出的规则，一步一步执行。因此根据这个原则，最先进行调用栈的宏任务，一般情况下都是最后返回执行的结果。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">async function async1() &#123;</span><br><span class="line"></span><br><span class="line">  console.log(&quot;async1 start&quot;);</span><br><span class="line"></span><br><span class="line">  await async2();</span><br><span class="line"></span><br><span class="line">  console.log(&quot;async1 end&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function async2() &#123;</span><br><span class="line"></span><br><span class="line">  console.log(&quot;async2&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async1();</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  console.log(&quot;timeout&quot;);</span><br><span class="line"></span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">new Promise(function (resolve) &#123;</span><br><span class="line"></span><br><span class="line">  console.log(&quot;promise1&quot;);</span><br><span class="line"></span><br><span class="line">  resolve();</span><br><span class="line"></span><br><span class="line">&#125;).then(function () &#123;</span><br><span class="line"></span><br><span class="line">  console.log(&quot;promise2&quot;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&quot;script end&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">async1 start</span><br><span class="line">async2</span><br><span class="line">promise1</span><br><span class="line">script end</span><br><span class="line">async1 end</span><br><span class="line">promise2</span><br><span class="line">timeout</span><br></pre></td></tr></table></figure>
<h4 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h4><ul>
<li>如果在浏览器的环境下，宏任务主要分为下面这几个大类：</li>
</ul>
<ol>
<li>渲染事件（比如解析 DOM、计算布局、绘制）；</li>
<li>用户交互事件（比如鼠标点击、滚动页面、放大缩小等）；</li>
<li>setTimeout、setInterval 等；</li>
<li>网络请求完成、文件读写完成事件。</li>
</ol>
<ul>
<li>为了让这些任务在主线程上执行，页面进程引入了消息队列和事件循环机制，我们把这些消息队列中的任务称为宏任务。</li>
<li>宏任务基本上满足了日常的开发需求，而对于时间精度有要求的宏任务就不太能满足了，比如渲染事件、各种 I/O、用户交互的事件等，都随时有可能被添加到消息队列中，JS 代码不能准确掌控任务要添加到队列中的位置，控制不了任务在消息队列中的位置，所以很难控制开始执行任务的时间。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function callback2()&#123;</span><br><span class="line"></span><br><span class="line">    console.log(2)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function callback()&#123;</span><br><span class="line"></span><br><span class="line">    console.log(1)</span><br><span class="line"></span><br><span class="line">    setTimeout(callback2,0)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setTimeout(callback,0)</span><br><span class="line">在上面这段代码中，我的目的是想通过 setTimeout 来设置两个回调任务，并让它们按照前后顺序来执行，中间也不要再插入其他的任务。</span><br><span class="line">但是实际情况我们难以控制，比如在你调用 setTimeout 来设置回调任务的间隙，消息队列中就有可能被插入很多系统级的任务。</span><br><span class="line">如果中间被插入的任务执行时间过久的话，那么就会影响到后面任务的执行了。所以说宏任务的时间粒度比较大，执行的间隔是不能精确控制的。</span><br><span class="line">这就不适用于一些高实时性的需求了，比如后面要讲到的监听 DOM 变化。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h4><ul>
<li>微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。</li>
<li>当 JavaScript 执行一段脚本的时候，V8 会为其创建一个全局执行上下文，同时 V8 引擎也会在内部创建一个微任务队列。这个微任务队列就是用来存放微任务的，因为在当前宏任务执行的过程中，有时候会产生多个微任务，这时候就需要使用这个微任务队列来保存这些微任务了。不过这个微任务队列是给 V8 引擎内部使用的，所以你是无法通过 JavaScript 直接访问的。</li>
<li>在现代浏览器里面，产生微任务有两种方式</li>
</ul>
<ol>
<li>使用 MutationObserver 监控某个 DOM 节点，或者为这个节点添加、删除部分子节点，当 DOM 节点发生变化时，就会产生 DOM 变化记录的微任务。</li>
<li>使用 Promise，当调用 Promise.resolve() 或者 Promise.reject() 的时候，也会产生微任务</li>
</ol>
<ul>
<li>如果在执行微任务的过程中，产生了新的微任务，一样会将该微任务添加到微任务队列中，V8 引擎一直循环执行微任务队列中的任务，直到队列清空才算执行结束。也就是说在执行微任务过程中产生的新的微任务并不会推迟到下一个循环中执行，而是在当前的循环中继续执行，这点是需要注意的。</li>
<li>微任务和宏任务是绑定的，每个宏任务在执行时，会创建自己的微任务队列。</li>
<li>微任务的执行时长会影响当前宏任务的时长。比如一个宏任务在执行过程中，产生了 10 个微任务，执行每个微任务的时间是 10ms，那么执行这 10 个微任务的时间就是 100ms，也可以说这 10 个微任务让宏任务的执行时间延长了 100ms。</li>
<li>在一个宏任务中，分别创建一个用于回调的宏任务和微任务，无论什么情况下，微任务都早于宏任务执行。</li>
</ul>
<h4 id="MutationObserver"><a href="#MutationObserver" class="headerlink" title="MutationObserver"></a>MutationObserver</h4><ul>
<li>MutationObserver API 可以用来监视 DOM 的变化，包括属性的变更、节点的增加、内容的改变等。因为上面我们分析过，在两个任务之间，可能会被渲染进程插入其他的事件，从而影响到响应的实时性。这时候，微任务就可以上场了，在每次 DOM 节点发生变化的时候，渲染引擎将变化记录封装成微任务，并将微任务添加进当前的微任务队列中。这样当执行到检查点的时候，V8 引擎就会按照顺序执行微任务了。</li>
<li>MutationObserver 采用了“异步 + 微任务”的策略：</li>
</ul>
<ol>
<li>通过异步操作解决了同步操作的性能问题；</li>
<li>通过微任务解决了实时性的问题。</li>
</ol>
<h4 id="Process-nextTick"><a href="#Process-nextTick" class="headerlink" title="Process.nextTick"></a>Process.nextTick</h4><ul>
<li>Process.nextick 的运行逻辑：</li>
</ul>
<ol>
<li>Process.nextick 会将 callback 添加到“next tick queue”；</li>
<li>“next tick queue”会在当前 JavaScript stack 执行完成后，下一次 event loop 开始执行前按照 FIFO 出队；</li>
<li>如果递归调用 Process.nextick 可能会导致一个无限循环，需要去适时终止递归。</li>
</ol>
<ul>
<li>可能你已经注意到 Process.nextick 其实是微任务，同时也是异步 API 的一部分。但是从技术上来说 Process.nextick 并不是事件循环（eventloop）的一部分，相反地，“next tick queue”将会在当前操作完成之后立即被处理，而不管当前处于事件循环的哪个阶段。</li>
<li>如果任何时刻你在一个给定的阶段调用 Process.nextick，则所有被传入 Process.nextick 的回调将在事件循环继续往下执行前被执行。这可能会导致一些很糟的情形，因为它允许用户递归调用 Process.nextick 来挂起 I/O 进程的进行，这会导致事件循环永远无法到达轮询阶段。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">let bar;</span><br><span class="line"></span><br><span class="line">function someAsyncApiCall(callback) &#123; callback(); &#125;</span><br><span class="line"></span><br><span class="line">someAsyncApiCall(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  console.log(&apos;bar&apos;, bar);   // undefined</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">bar = 1;</span><br><span class="line"></span><br><span class="line">用户定义函数 someAsyncApiCall() 有一个异步签名，但实际上它是同步执行的。</span><br><span class="line">当它被调用时，提供给 someAsyncApiCall() 的回调函数会在执行 someAsyncApiCall() 本身的同一个事件循环阶段被执行，因为 someAsyncApiCall() 实际上并未执行任何异步操作。</span><br><span class="line">结果就是，即使回调函数尝试引用变量 bar，但此时在作用域中并没有改变量。因为程序还没运行到对 bar 赋值的部分。</span><br><span class="line"></span><br><span class="line">将回调放到 Process.nextick 中，程序依然可以执行完毕，且所有的变量、函数等都在执行回调之前被初始化，它还具有不会被事件循环打断的优点。以下是将上面的例子改用 Process.nextick 的代码：</span><br><span class="line"></span><br><span class="line">let bar;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">function someAsyncApiCall(callback) &#123;</span><br><span class="line"></span><br><span class="line">  process.nextTick(callback);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">someAsyncApiCall(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  console.log(&apos;bar&apos;, bar); // 1</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">bar = 1;</span><br><span class="line"></span><br><span class="line">-------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const EventEmitter = require(&apos;events&apos;);</span><br><span class="line"></span><br><span class="line">const util = require(&apos;util&apos;);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">function MyEmitter() &#123;</span><br><span class="line"></span><br><span class="line">EventEmitter.call(this);</span><br><span class="line"></span><br><span class="line">this.emit(&apos;event&apos;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">util.inherits(MyEmitter, EventEmitter);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">const myEmitter = new MyEmitter();</span><br><span class="line"></span><br><span class="line">myEmitter.on(&apos;event&apos;, () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">console.log(&apos;an event occurred!&apos;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">你无法在构造函数中立即触发一个事件，因为此时程序还未运行到将回调赋值给事件的那段代码。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">因此，在构造函数内部，你可以使用 Process.nextick 设置一个回调以在构造函数执行完毕后触发事件，下面的代码满足了我们的预期。</span><br><span class="line"></span><br><span class="line">const EventEmitter = require(&apos;events&apos;);</span><br><span class="line"></span><br><span class="line">const util = require(&apos;util&apos;);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">function MyEmitter() &#123;</span><br><span class="line"></span><br><span class="line">EventEmitter.call(this);</span><br><span class="line"></span><br><span class="line">process.nextTick(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  this.emit(&apos;event&apos;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">util.inherits(MyEmitter, EventEmitter);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">const myEmitter = new MyEmitter();</span><br><span class="line"></span><br><span class="line">  myEmitter.on(&apos;event&apos;, () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  console.log(&apos;an event occurred!&apos;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">通过上面的改造可以看出，使用 Process.nextick 就可以解决问题了，即使 event 事件还没进行绑定，但也可以让代码在前面进行触发，因为根据代码执行顺序，Process.nextick 是在每一次的事件循环最后执行的。</span><br><span class="line">因此这样写，代码也不会报错，同样又保持了代码的逻辑。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="Vue的nextick"><a href="#Vue的nextick" class="headerlink" title="Vue的nextick"></a>Vue的nextick</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"></span><br><span class="line">  &lt;div class=&quot;app&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div ref=&quot;msg&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div v-if=&quot;msg1&quot;&gt;Message got outside $nextTick: &#123;&#123;msg1&#125;&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div v-if=&quot;msg2&quot;&gt;Message got inside $nextTick: &#123;&#123;msg2&#125;&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;button @click=&quot;changeMsg&quot;&gt;</span><br><span class="line"></span><br><span class="line">      Change the Message</span><br><span class="line"></span><br><span class="line">    &lt;/button&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line"></span><br><span class="line">  el: &apos;.app&apos;,</span><br><span class="line"></span><br><span class="line">  data: &#123;</span><br><span class="line"></span><br><span class="line">    msg: &apos;Vue&apos;,</span><br><span class="line"></span><br><span class="line">    msg1: &apos;&apos;,</span><br><span class="line"></span><br><span class="line">    msg2: &apos;&apos;,</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line"></span><br><span class="line">    changeMsg() &#123;</span><br><span class="line"></span><br><span class="line">      this.msg = &quot;Hello world.&quot;</span><br><span class="line"></span><br><span class="line">      this.msg1 = this.$refs.msg.innerHTML</span><br><span class="line"></span><br><span class="line">      this.$nextTick(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">        this.msg2 = this.$refs.msg.innerHTML</span><br><span class="line"></span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">通过按钮点击之后，div 里面的 msg1 和 msg2 的变化情况。你会发现第一次点击按钮调用 changeMsg 方法时，其实 msg2 并没有变化，因为 msg2 的变化是在下一个 tick 才进行执行的。</span><br></pre></td></tr></table></figure>
<h2 id="JS-代码是如何被浏览器引擎编译、执行的？"><a href="#JS-代码是如何被浏览器引擎编译、执行的？" class="headerlink" title="JS 代码是如何被浏览器引擎编译、执行的？"></a>JS 代码是如何被浏览器引擎编译、执行的？</h2><h3 id="V8-引擎"><a href="#V8-引擎" class="headerlink" title="V8 引擎"></a>V8 引擎</h3><ul>
<li>编译型语言和解释型语言</li>
</ul>
<ol>
<li>编译型语言的特点是在代码运行前编译器直接将对应的代码转换成机器码，运行时不需要再重新翻译，直接可以使用编译后的结果。</li>
<li>解释型语言也是需要将代码转换成机器码，但是和编译型的区别在于运行时需要转换。比较显著的特点是，解释型语言的执行速度要慢于编译型语言，因为解释型语言每次执行都需要把源码转换一次才能执行。</li>
</ol>
<ul>
<li>V8是众多浏览器的 JS 引擎中性能表现最好的一个，并且它是 Chrome 的内核，Node.js 也是基于 V8 引擎研发的。</li>
<li>V8引擎执行 JS 代码要经过以下阶段</li>
</ul>
<ol>
<li>Parse 阶段：V8 引擎负责将 JS 代码转换成 AST（抽象语法树）；</li>
<li>Ignition 阶段：解释器将 AST 转换为字节码，解析执行字节码也会为下一个阶段优化编译提供需要的信息；</li>
<li>TurboFan 阶段：编译器利用上个阶段收集的信息，将字节码优化为可以执行的机器码；</li>
<li>Orinoco 阶段：垃圾回收阶段，将程序中不再使用的内存空间进行回收。<h3 id="生成-AST"><a href="#生成-AST" class="headerlink" title="生成 AST"></a>生成 AST</h3></li>
</ol>
<ul>
<li>Eslint 和 Babel 这两个工具都和 AST 脱不了干系。V8 引擎就是通过编译器（Parse）将源代码解析成 AST 的</li>
<li>AST 在实际工作中应用场景也比较多，大致有下面几个：</li>
</ul>
<ol>
<li>JS 反编译，语法解析；</li>
<li>Babel 编译 ES6 语法；</li>
<li>代码高亮；</li>
<li>关键字匹配；</li>
<li>代码压缩。</li>
</ol>
<ul>
<li>生成 AST 分为两个阶段，一是词法分析，二是语法分析</li>
</ul>
<ol>
<li>词法分析：这个阶段会将源代码拆成最小的、不可再分的词法单元，称为 token。比如这行代码 var a =1；通常会被分解成 var 、a、=、2、; 这五个词法单元。另外刚才代码中的空格在 JavaScript 中是直接忽略的。</li>
<li>语法分析：这个过程是将词法单元转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树，这个树被称为抽象语法树。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line">// 第一段代码</span><br><span class="line"></span><br><span class="line">var a = 1;</span><br><span class="line"></span><br><span class="line">// 第二段代码</span><br><span class="line"></span><br><span class="line">function sum (a,b) &#123;</span><br><span class="line"></span><br><span class="line">  return a + b;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第一段代码，编译后的结果：</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  &quot;type&quot;: &quot;Program&quot;,</span><br><span class="line"></span><br><span class="line">  &quot;start&quot;: 0,</span><br><span class="line"></span><br><span class="line">  &quot;end&quot;: 10,</span><br><span class="line"></span><br><span class="line">  &quot;body&quot;: [</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      &quot;type&quot;: &quot;VariableDeclaration&quot;,</span><br><span class="line"></span><br><span class="line">      &quot;start&quot;: 0,</span><br><span class="line"></span><br><span class="line">      &quot;end&quot;: 10,</span><br><span class="line"></span><br><span class="line">      &quot;declarations&quot;: [</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">          &quot;type&quot;: &quot;VariableDeclarator&quot;,</span><br><span class="line"></span><br><span class="line">          &quot;start&quot;: 4,</span><br><span class="line"></span><br><span class="line">          &quot;end&quot;: 9,</span><br><span class="line"></span><br><span class="line">          &quot;id&quot;: &#123;</span><br><span class="line"></span><br><span class="line">            &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line"></span><br><span class="line">            &quot;start&quot;: 4,</span><br><span class="line"></span><br><span class="line">            &quot;end&quot;: 5,</span><br><span class="line"></span><br><span class="line">            &quot;name&quot;: &quot;a&quot;</span><br><span class="line"></span><br><span class="line">          &#125;,</span><br><span class="line"></span><br><span class="line">          &quot;init&quot;: &#123;</span><br><span class="line"></span><br><span class="line">            &quot;type&quot;: &quot;Literal&quot;,</span><br><span class="line"></span><br><span class="line">            &quot;start&quot;: 8,</span><br><span class="line"></span><br><span class="line">            &quot;end&quot;: 9,</span><br><span class="line"></span><br><span class="line">            &quot;value&quot;: 1,</span><br><span class="line"></span><br><span class="line">            &quot;raw&quot;: &quot;1&quot;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      ],</span><br><span class="line"></span><br><span class="line">      &quot;kind&quot;: &quot;var&quot;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  &quot;sourceType&quot;: &quot;module&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">第二段代码，编译出来的结果：</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  &quot;type&quot;: &quot;Program&quot;,</span><br><span class="line"></span><br><span class="line">  &quot;start&quot;: 0,</span><br><span class="line"></span><br><span class="line">  &quot;end&quot;: 38,</span><br><span class="line"></span><br><span class="line">  &quot;body&quot;: [</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      &quot;type&quot;: &quot;FunctionDeclaration&quot;,</span><br><span class="line"></span><br><span class="line">      &quot;start&quot;: 0,</span><br><span class="line"></span><br><span class="line">      &quot;end&quot;: 38,</span><br><span class="line"></span><br><span class="line">      &quot;id&quot;: &#123;</span><br><span class="line"></span><br><span class="line">        &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line"></span><br><span class="line">        &quot;start&quot;: 9,</span><br><span class="line"></span><br><span class="line">        &quot;end&quot;: 12,</span><br><span class="line"></span><br><span class="line">        &quot;name&quot;: &quot;sum&quot;</span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &quot;expression&quot;: false,</span><br><span class="line"></span><br><span class="line">      &quot;generator&quot;: false,</span><br><span class="line"></span><br><span class="line">      &quot;async&quot;: false,</span><br><span class="line"></span><br><span class="line">      &quot;params&quot;: [</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">          &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line"></span><br><span class="line">          &quot;start&quot;: 14,</span><br><span class="line"></span><br><span class="line">          &quot;end&quot;: 15,</span><br><span class="line"></span><br><span class="line">          &quot;name&quot;: &quot;a&quot;</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">          &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line"></span><br><span class="line">          &quot;start&quot;: 16,</span><br><span class="line"></span><br><span class="line">          &quot;end&quot;: 17,</span><br><span class="line"></span><br><span class="line">          &quot;name&quot;: &quot;b&quot;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      ],</span><br><span class="line"></span><br><span class="line">      &quot;body&quot;: &#123;</span><br><span class="line"></span><br><span class="line">        &quot;type&quot;: &quot;BlockStatement&quot;,</span><br><span class="line"></span><br><span class="line">        &quot;start&quot;: 19,</span><br><span class="line"></span><br><span class="line">        &quot;end&quot;: 38,</span><br><span class="line"></span><br><span class="line">        &quot;body&quot;: [</span><br><span class="line"></span><br><span class="line">          &#123;</span><br><span class="line"></span><br><span class="line">            &quot;type&quot;: &quot;ReturnStatement&quot;,</span><br><span class="line"></span><br><span class="line">            &quot;start&quot;: 23,</span><br><span class="line"></span><br><span class="line">            &quot;end&quot;: 36,</span><br><span class="line"></span><br><span class="line">            &quot;argument&quot;: &#123;</span><br><span class="line"></span><br><span class="line">              &quot;type&quot;: &quot;BinaryExpression&quot;,</span><br><span class="line"></span><br><span class="line">              &quot;start&quot;: 30,</span><br><span class="line"></span><br><span class="line">              &quot;end&quot;: 35,</span><br><span class="line"></span><br><span class="line">              &quot;left&quot;: &#123;</span><br><span class="line"></span><br><span class="line">                &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line"></span><br><span class="line">                &quot;start&quot;: 30,</span><br><span class="line"></span><br><span class="line">                &quot;end&quot;: 31,</span><br><span class="line"></span><br><span class="line">                &quot;name&quot;: &quot;a&quot;</span><br><span class="line"></span><br><span class="line">              &#125;,</span><br><span class="line"></span><br><span class="line">              &quot;operator&quot;: &quot;+&quot;,</span><br><span class="line"></span><br><span class="line">              &quot;right&quot;: &#123;</span><br><span class="line"></span><br><span class="line">                &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line"></span><br><span class="line">                &quot;start&quot;: 34,</span><br><span class="line"></span><br><span class="line">                &quot;end&quot;: 35,</span><br><span class="line"></span><br><span class="line">                &quot;name&quot;: &quot;b&quot;</span><br><span class="line"></span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  &quot;sourceType&quot;: &quot;module&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">从上面编译出的结果可以看到，AST 只是源代码语法结构的一种抽象的表示形式，计算机也不会去直接去识别 JS 代码，转换成抽象语法树也只是识别这一过程中的第一步。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>现在浏览器还不支持 ES6 语法，需要将其转换成 ES5 语法，这个过程就要借助 Babel 来实现。将 ES6 源码解析成 AST，再将 ES6 语法的抽象语法树转成 ES5 的抽象语法树，最后利用它来生成 ES5 的源代码。另外 ESlint 的原理也大致相同，检测流程也是将源码转换成抽象语法树，再利用它来检测代码规范。<h3 id="生成字节码"><a href="#生成字节码" class="headerlink" title="生成字节码"></a>生成字节码</h3></li>
<li>之前的 V8 版本不会经过这个过程，最早只是通过 AST 直接转换成机器码，而后面几个版本中才对此进行了改进。如果将 AST 直接转换为机器码还是会有一些问题存在的，例如：</li>
</ul>
<ol>
<li>直接转换会带来内存占用过大的问题，因为将抽象语法树全部生成了机器码，而机器码相比字节码占用的内存多了很多；</li>
<li>某些 JavaScript 使用场景使用解释器更为合适，解析成字节码，有些代码没必要生成机器码，进而尽可能减少了占用内存过大的问题。</li>
</ol>
<ul>
<li>官方在 V8 的 v5.6 版本中还是将抽象语法树转换成字节码这一过程又加上了，重新加入了字节码的处理过程。再然后，V8 重新引进了 Ignition 解释器，将抽象语法树转换成字节码后，内存占用显著下降了，同时也可以使用 JIT 编译器做进一步的优化。</li>
<li>字节码是介于 AST 和机器码之间的一种代码，需要将其转换成机器码后才能执行，字节码可以理解为是机器码的一种抽象。Ignition 解释器除了可以快速生成没有优化的字节码外，还可以执行部分字节码。<h3 id="生成机器码"><a href="#生成机器码" class="headerlink" title="生成机器码"></a>生成机器码</h3></li>
<li>在 Ignition 解释器处理完之后，如果发现一段代码被重复执行多次的情况，生成的字节码以及分析数据会传给 TurboFan 编译器，它会根据分析数据的情况生成优化好的机器码。再执行这段代码之后，只需要直接执行编译后的机器码，这样性能就会更好。</li>
<li>TurboFan 编译器，它是 JIT 优化的编译器，因为 V8 引擎是多线程的，TurboFan 的编译线程和生成字节码不会在同一个线程上，这样可以和 Ignition 解释器相互配合着使用，不受另一方的影响。</li>
<li>由 Ignition 解释器收集的分析数据被 TurboFan 编译器使用，主要是通过一种推测优化的技术，生成已经优化的机器码来执行。</li>
</ul>
<h2 id="JavaScript引擎如何执行JavaScript代码"><a href="#JavaScript引擎如何执行JavaScript代码" class="headerlink" title="JavaScript引擎如何执行JavaScript代码"></a>JavaScript引擎如何执行JavaScript代码</h2><ul>
<li>JavaScript 代码是需要在 JavaScript 引擎中运行的。我们在说到 JavaScript 运行的时候，常常会提到执行环境、词法环境、作用域、执行上下文、闭包等内容。</li>
<li>JavaScript引擎执行JavaScript代码时会进行词法分析、语法分析、语义分析等处理，最终生成抽象语法树，根据抽象语法树生成机器码</li>
<li>在 V8 引擎中 JavaScript 代码的运行过程主要分成三个阶段：</li>
</ul>
<ol>
<li>语法分析阶段：对代码进行语法分析，检查是否有语法错误</li>
<li>编译阶段：会创建执行上下文，包括变量对象的创建、作用域链的建立、this指向的确立等。每进入一个不同的运行环境，V8引擎都会创建一个执行上下文。</li>
<li>执行阶段：将编译阶段的执行上下文压入调用栈，代码执行结束后，将其弹出调用栈</li>
</ol>
<ul>
<li>前面提到的执行环境、词法环境、作用域、执行上下文等内容都是在编译和执行阶段中产生的概念。<h3 id="执行上下文创建"><a href="#执行上下文创建" class="headerlink" title="执行上下文创建"></a>执行上下文创建</h3></li>
<li>全局环境和函数环境的创建过程如下</li>
</ul>
<ol>
<li>第一次载入JavaScript代码时会创建一个全局环境。全局环境位于最外层，直到应用程序结束后（浏览器、网页关闭等）才会被销毁。</li>
<li>每个函数有自己的运行环境，当函数被调用时，会进入该函数的运行环境。当该环境中的代码全部执行完毕后，该环境会被销毁。不同函数运行环境不一样，同一个函数多次被调用会创建不同的函数环境。</li>
</ol>
<ul>
<li>每进入一个不同的运行环境时，JavaScript 都会创建一个新的执行上下文，该过程包括：</li>
</ul>
<ol>
<li>建立作用域链（Scope Chain）；</li>
<li>创建变量对象（Variable Object，简称 VO）；</li>
<li>确定 this 的指向。<h3 id="创建变量对象"><a href="#创建变量对象" class="headerlink" title="创建变量对象"></a>创建变量对象</h3></li>
</ol>
<ul>
<li>每个执行上下文都会有一个关联的变量对象，该对象上会保存这个上下文中定义的所有变量和函数。</li>
<li>而在浏览器中，全局环境的变量对象是window对象，因此所有的全局变量和函数都是作为window对象的属性和方法创建的。相应的，在 Node 中全局环境的变量对象则是global对象。</li>
<li>创建变量对象将会创建arguments对象（仅函数环境下），同时会检查当前上下文的函数声明和变量声明。</li>
</ul>
<ol>
<li>对于变量声明：此时会给变量分配内存，并将其初始化为undefined（该过程只进行定义声明，执行阶段才执行赋值语句）。</li>
<li>对于函数声明：此时会在内存里创建函数对象，并且直接初始化为该函数对象。</li>
</ol>
<ul>
<li>变量声明和函数声明的处理过程，便是我们常说的变量提升和函数提升，其中函数声明提升会优先于变量声明提升。因为变量提升容易带来变量在预期外被覆盖掉的问题，同时还可能导致本应该被销毁的变量没有被销毁等情况。因此 ES6 中引入了let和const关键字，从而使 JavaScript 也拥有了块级作用域。</li>
<li>在 JavaScript 中，词法环境又分为词法环境（Lexical Environment）和变量环境（Variable Environment）两种，其中：</li>
</ul>
<ol>
<li>变量环境用来记录var/function等变量声明；</li>
<li>词法环境是用来记录let/const/class等变量声明。<h3 id="建立作用域链"><a href="#建立作用域链" class="headerlink" title="建立作用域链"></a>建立作用域链</h3></li>
</ol>
<ul>
<li>作用域就是词法环境，而词法环境由两个成员组成。</li>
</ul>
<ol>
<li>环境记录（Environment Record）：用于记录自身词法环境中的变量对象。</li>
<li>外部词法环境引用（Outer Lexical Environment）：记录外层词法环境的引用。</li>
</ol>
<ul>
<li>通过外部词法环境的引用，作用域可以层层拓展，建立起从里到外延伸的一条作用域链。当某个变量无法在自身词法环境记录中找到时，可以根据外部词法环境引用向外层进行寻找，直到最外层的词法环境中外部词法环境引用为null，这便是作用域链的变量查询。</li>
<li><p>通过外部词法环境的引用，作用域可以层层拓展，建立起从里到外延伸的一条作用域链。当某个变量无法在自身词法环境记录中找到时，可以根据外部词法环境引用向外层进行寻找，直到最外层的词法环境中外部词法环境引用为null，这便是作用域链的变量查询。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">function foo(a) &#123;</span><br><span class="line"></span><br><span class="line">  var b = 2;</span><br><span class="line"></span><br><span class="line">  function c() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  var d = function() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foo(1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在执行foo(1)时，首先进入定义期，此时：</span><br><span class="line">参数变量a的值为1</span><br><span class="line">变量b和d初始化为undefined</span><br><span class="line">函数c创建函数并初始化</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">AO = &#123;</span><br><span class="line"></span><br><span class="line">  arguments: &#123;</span><br><span class="line"></span><br><span class="line">    0: 1,</span><br><span class="line"></span><br><span class="line">    length: 1</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  a: 1,</span><br><span class="line"></span><br><span class="line">  b: undefined,</span><br><span class="line"></span><br><span class="line">  c: reference to function c()&#123;&#125;,</span><br><span class="line"></span><br><span class="line">  d: undefined</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">进入执行期之后，会执行赋值语句进行赋值，此时变量b和d会被赋值为 2 和函数表达式：</span><br><span class="line">AO = &#123;</span><br><span class="line"></span><br><span class="line">   arguments: &#123;</span><br><span class="line"></span><br><span class="line">    0: 1,</span><br><span class="line"></span><br><span class="line">    length: 1</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  a: 1,</span><br><span class="line"></span><br><span class="line">  b: 2,</span><br><span class="line"></span><br><span class="line">  c: reference to function c()&#123;&#125;,</span><br><span class="line"></span><br><span class="line">  d: reference to FunctionExpression &quot;d&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>一般来说，当函数执行结束之后，执行期上下文将被销毁（作用域链和活动对象均被销毁）。但有时候我们想要保留其中一些变量对象，不想被销毁，此时就会使用到闭包。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line"></span><br><span class="line">  var a = 1;</span><br><span class="line"></span><br><span class="line">  function bar() &#123;</span><br><span class="line"></span><br><span class="line">    return a;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return bar;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var b = foo();</span><br><span class="line"></span><br><span class="line">console.log(b()); // 1</span><br><span class="line"></span><br><span class="line">在这个例子中，当b()执行时，foo函数上下文包括作用域都已经被销毁了，为什么foo作用域下的a依然可以被访问到呢？</span><br><span class="line"></span><br><span class="line">这是因为bar函数引用了foo函数变量对象中的值，此时即使创建bar函数的foo函数执行上下文被销毁了，但它的变量对象依然会保留在 JavaScript 内存中，bar函数依然可以通过bar函数的作用域链找到它，并进行访问。这便是我们常说的闭包，即使创建它的上下文已经销毁，它仍然被保留在内存中。</span><br></pre></td></tr></table></figure>
</li>
<li><p>闭包使得我们可以从外部读取局部变量，在大多数项目中都会被使用到，常见的用途包括：</p>
</li>
</ul>
<ol>
<li>用于从外部读取其他函数内部变量的函数；</li>
<li>可以使用闭包来模拟私有方法；</li>
<li>让这些变量的值始终保持在内存中。<h3 id="确定-this-的指向"><a href="#确定-this-的指向" class="headerlink" title="确定 this 的指向"></a>确定 this 的指向</h3></li>
</ol>
<ul>
<li>根据 JavaScript 中函数的调用方式不同，this的指向分为以下情况。</li>
</ul>
<ol>
<li>在全局环境中，this指向全局对象（在浏览器中为window）</li>
<li>在函数内部，this的值取决于函数被调用的方式<br>函数作为对象的方法被调用，this指向调用这个方法的对象<br>函数用作构造函数时（使用new关键字），它的this被绑定到正在构造的新对象</li>
<li>在类的构造函数中，this是一个常规对象，类中所有非静态的方法都会被添加到this的原型中</li>
<li>在箭头函数中，this指向它被创建时的环境</li>
<li>使用apply、call、bind等方式调用：根据 API 不同，可切换函数执行的上下文环境，即this绑定的对象</li>
</ol>
<h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h2><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><ul>
<li>如果一定要解释 Promise 到底是什么，简单来说它就是一个容器，里面保存着某个未来才会结束的事件（通常是异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。</li>
<li>回调地狱有两个主要的问题：</li>
</ul>
<ol>
<li>多层嵌套的问题；</li>
<li>每种任务的处理结果存在两种可能性（成功或失败），那么需要在每种任务执行结束后分别处理这两种可能性。</li>
</ol>
<ul>
<li>Promise 的静态方法</li>
</ul>
<ol>
<li><p>all 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">此方法对于汇总多个 promise 的结果很有用，在 ES6 中可以将多个 Promise.all 异步请求并行操作，返回结果一般有下面两种情况。</span><br><span class="line">1.当所有结果成功返回时按照请求顺序返回成功。</span><br><span class="line">2.当其中有一个失败方法时，则进入失败方法</span><br><span class="line"></span><br><span class="line">//1.获取轮播数据列表</span><br><span class="line"></span><br><span class="line">function getBannerList()&#123;</span><br><span class="line"></span><br><span class="line">  return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">      setTimeout(function()&#123;</span><br><span class="line"></span><br><span class="line">        resolve(&apos;轮播数据&apos;)</span><br><span class="line"></span><br><span class="line">      &#125;,300) </span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//2.获取店铺列表</span><br><span class="line"></span><br><span class="line">function getStoreList()&#123;</span><br><span class="line"></span><br><span class="line">  return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line"></span><br><span class="line">      resolve(&apos;店铺数据&apos;)</span><br><span class="line"></span><br><span class="line">    &#125;,500)</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//3.获取分类列表</span><br><span class="line"></span><br><span class="line">function getCategoryList()&#123;</span><br><span class="line"></span><br><span class="line">  return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line"></span><br><span class="line">      resolve(&apos;分类数据&apos;)</span><br><span class="line"></span><br><span class="line">    &#125;,700)</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function initLoad()&#123; </span><br><span class="line"></span><br><span class="line">  Promise.all([getBannerList(),getStoreList(),getCategoryList()])</span><br><span class="line"></span><br><span class="line">  .then(res=&gt;&#123;</span><br><span class="line"></span><br><span class="line">    console.log(res) </span><br><span class="line"></span><br><span class="line">  &#125;).catch(err=&gt;&#123;</span><br><span class="line"></span><br><span class="line">    console.log(err)</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">initLoad()</span><br></pre></td></tr></table></figure>
</li>
<li><p>allSettled 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Promise.allSettled 的语法及参数跟 Promise.all 类似，唯一的不同在于，执行完之后不会失败，也就是说当 Promise.allSettled 全部处理完成后，我们可以拿到每个 Promise 的状态，而不管其是否处理成功。</span><br><span class="line"></span><br><span class="line">const resolved = Promise.resolve(2);</span><br><span class="line"></span><br><span class="line">const rejected = Promise.reject(-1);</span><br><span class="line"></span><br><span class="line">const allSettledPromise = Promise.allSettled([resolved, rejected]);</span><br><span class="line"></span><br><span class="line">allSettledPromise.then(function (results) &#123;</span><br><span class="line"></span><br><span class="line">  console.log(results);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 返回结果：</span><br><span class="line"></span><br><span class="line">// [</span><br><span class="line"></span><br><span class="line">//    &#123; status: &apos;fulfilled&apos;, value: 2 &#125;,</span><br><span class="line"></span><br><span class="line">//    &#123; status: &apos;rejected&apos;, reason: -1 &#125;</span><br><span class="line"></span><br><span class="line">// ]</span><br></pre></td></tr></table></figure>
</li>
<li><p>any 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">any 方法返回一个 Promise，只要参数 Promise 实例有一个变成 fulfilled 状态，最后 any 返回的实例就会变成 fulfilled 状态；如果所有参数 Promise 实例都变成 rejected 状态，包装实例就会变成 rejected 状态。</span><br><span class="line">const resolved = Promise.resolve(2);</span><br><span class="line"></span><br><span class="line">const rejected = Promise.reject(-1);</span><br><span class="line"></span><br><span class="line">const anyPromise = Promise.any([resolved, rejected]);</span><br><span class="line"></span><br><span class="line">anyPromise.then(function (results) &#123;</span><br><span class="line"></span><br><span class="line">  console.log(results);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 返回结果：</span><br><span class="line"></span><br><span class="line">// 2</span><br></pre></td></tr></table></figure>
</li>
<li><p>race 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"> race 方法返回一个 Promise，只要参数的 Promise 之中有一个实例率先改变状态，则 race 方法的返回状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给 race 方法的回调函数。</span><br><span class="line"> //请求某个图片资源</span><br><span class="line"></span><br><span class="line">function requestImg()&#123;</span><br><span class="line"></span><br><span class="line">  var p = new Promise(function(resolve, reject)&#123;</span><br><span class="line"></span><br><span class="line">    var img = new Image();</span><br><span class="line"></span><br><span class="line">    img.onload = function()&#123; resolve(img); &#125;</span><br><span class="line"></span><br><span class="line">    img.src = &apos;http://www.baidu.com/img/flexible/logo/pc/result.png&apos;;</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return p;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//延时函数，用于给请求计时</span><br><span class="line"></span><br><span class="line">function timeout()&#123;</span><br><span class="line"></span><br><span class="line">  var p = new Promise(function(resolve, reject)&#123;</span><br><span class="line"></span><br><span class="line">    setTimeout(function()&#123; reject(&apos;图片请求超时&apos;); &#125;, 5000);</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return p;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise.race([requestImg(), timeout()])</span><br><span class="line"></span><br><span class="line">.then(function(results)&#123;</span><br><span class="line"></span><br><span class="line">  console.log(results);</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">.catch(function(reason)&#123;</span><br><span class="line"></span><br><span class="line">  console.log(reason);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h3><ul>
<li>通俗来讲 Generator 是一个带星号的“函数”（它并不是真正的函数），可以配合 yield 关键字来暂停或者执行函数。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">function* gen() &#123;</span><br><span class="line"></span><br><span class="line">  console.log(&quot;enter&quot;);</span><br><span class="line"></span><br><span class="line">  let a = yield 1;</span><br><span class="line"></span><br><span class="line">  let b = yield (function () &#123;return 2&#125;)();</span><br><span class="line"></span><br><span class="line">  return 3;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var g = gen()           // 阻塞住，不会执行任何语句</span><br><span class="line"></span><br><span class="line">console.log(g.next())</span><br><span class="line"></span><br><span class="line">console.log(g.next())</span><br><span class="line"></span><br><span class="line">console.log(g.next())</span><br><span class="line"></span><br><span class="line">console.log(g.next()) </span><br><span class="line"></span><br><span class="line">// output:</span><br><span class="line"></span><br><span class="line">// &#123; value: 1, done: false &#125;</span><br><span class="line"></span><br><span class="line">// &#123; value: 2, done: false &#125;</span><br><span class="line"></span><br><span class="line">// &#123; value: 3, done: true &#125;</span><br><span class="line"></span><br><span class="line">// &#123; value: undefined, done: true &#125;</span><br><span class="line"></span><br><span class="line">Generator 的执行有这几个关键点</span><br><span class="line">1. 调用 gen() 后，程序会阻塞住，不会执行任何语句。</span><br><span class="line">2. 调用 g.next() 后，程序继续执行，直到遇到 yield 关键词时执行暂停。</span><br><span class="line">3. 一直执行 next 方法，最后返回一个对象，其存在两个属性：value 和 done。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function* gen1() &#123;</span><br><span class="line"></span><br><span class="line">    yield 1;</span><br><span class="line"></span><br><span class="line">    yield* gen2();</span><br><span class="line"></span><br><span class="line">    yield 4;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function* gen2() &#123;</span><br><span class="line"></span><br><span class="line">    yield 2;</span><br><span class="line"></span><br><span class="line">    yield 3;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var g = gen1();</span><br><span class="line"></span><br><span class="line">console.log(g.next())</span><br><span class="line"></span><br><span class="line">console.log(g.next())</span><br><span class="line"></span><br><span class="line">console.log(g.next())</span><br><span class="line"></span><br><span class="line">console.log(g.next())</span><br><span class="line"></span><br><span class="line">// output:</span><br><span class="line"></span><br><span class="line">// &#123; value: 1, done: false &#125;</span><br><span class="line"></span><br><span class="line">// &#123; value: 2, done: false &#125;</span><br><span class="line"></span><br><span class="line">// &#123; value: 3, done: false &#125;</span><br><span class="line"></span><br><span class="line">// &#123; value: 4, done: false &#125;</span><br><span class="line"></span><br><span class="line">// &#123;value: undefined, done: true&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="thunk-函数"><a href="#thunk-函数" class="headerlink" title="thunk 函数"></a>thunk 函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">let isString = (obj) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  return Object.prototype.toString.call(obj) === &apos;[object String]&apos;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let isFunction = (obj) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  return Object.prototype.toString.call(obj) === &apos;[object Function]&apos;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let isArray = (obj) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  return Object.prototype.toString.call(obj) === &apos;[object Array]&apos;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">可以看到，其中出现了非常多重复的数据类型判断逻辑，平常业务开发中类似的重复逻辑的场景也同样会有很多。我们将它们做一下封装，如下所示。</span><br><span class="line">let isType = (type) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  return (obj) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    return Object.prototype.toString.call(obj) === `[object $&#123;type&#125;]`;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let isString = isType(&apos;String&apos;);</span><br><span class="line"></span><br><span class="line">let isArray = isType(&apos;Array&apos;);</span><br><span class="line"></span><br><span class="line">isString(&quot;123&quot;);    // true</span><br><span class="line"></span><br><span class="line">isArray([1,2,3]);   // true</span><br><span class="line">像 isType 这样的函数我们称为 thunk 函数，它的基本思路都是接收一定的参数，会生产出定制化的函数，最后使用定制化的函数去完成想要实现的功能。</span><br></pre></td></tr></table></figure>
<h4 id="Generator-和-thunk-结合"><a href="#Generator-和-thunk-结合" class="headerlink" title="Generator 和 thunk 结合"></a>Generator 和 thunk 结合</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">const readFileThunk = (filename) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  return (callback) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    fs.readFile(filename, callback);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const gen = function* () &#123;</span><br><span class="line"></span><br><span class="line">  const data1 = yield readFileThunk(&apos;1.txt&apos;)</span><br><span class="line"></span><br><span class="line">  console.log(data1.toString())</span><br><span class="line"></span><br><span class="line">  const data2 = yield readFileThunk(&apos;2.txt&apos;)</span><br><span class="line"></span><br><span class="line">  console.log(data2.toString)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let g = gen();</span><br><span class="line"></span><br><span class="line">g.next().value((err, data1) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  g.next(data1).value((err, data2) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    g.next(data2);</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">上面第三段代码执行起来嵌套的情况还算简单，如果任务多起来，就会产生很多层的嵌套，可读性不强，</span><br><span class="line">function run(gen)&#123;</span><br><span class="line"></span><br><span class="line">  const next = (err, data) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    let res = gen.next(data);</span><br><span class="line"></span><br><span class="line">    if(res.done) return;</span><br><span class="line"></span><br><span class="line">    res.value(next);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  next();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(g);</span><br></pre></td></tr></table></figure>
<h4 id="Generator-和-Promise-结合"><a href="#Generator-和-Promise-结合" class="headerlink" title="Generator 和 Promise 结合"></a>Generator 和 Promise 结合</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">// 最后包装成 Promise 对象进行返回</span><br><span class="line"></span><br><span class="line">const readFilePromise = (filename) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    fs.readFile(filename, (err, data) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">      if(err) &#123;</span><br><span class="line"></span><br><span class="line">        reject(err);</span><br><span class="line"></span><br><span class="line">      &#125;else &#123;</span><br><span class="line"></span><br><span class="line">        resolve(data);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  &#125;).then(res =&gt; res);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> let g = gen();</span><br><span class="line"></span><br><span class="line">// 这块和上面 thunk 的方式一样</span><br><span class="line"></span><br><span class="line">const gen = function* () &#123;</span><br><span class="line"></span><br><span class="line">  const data1 = yield readFilePromise(&apos;1.txt&apos;)</span><br><span class="line"></span><br><span class="line">  console.log(data1.toString())</span><br><span class="line"></span><br><span class="line">  const data2 = yield readFilePromise(&apos;2.txt&apos;)</span><br><span class="line"></span><br><span class="line">  console.log(data2.toString)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 这块和上面 thunk 的方式一样</span><br><span class="line"></span><br><span class="line">function run(gen)&#123;</span><br><span class="line"></span><br><span class="line">  const next = (err, data) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    let res = gen.next(data);</span><br><span class="line"></span><br><span class="line">    if(res.done) return;</span><br><span class="line"></span><br><span class="line">    res.value.then(next);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  next();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(g);</span><br></pre></td></tr></table></figure>
<h4 id="co-函数库"><a href="#co-函数库" class="headerlink" title="co 函数库"></a>co 函数库</h4><ul>
<li>为什么 co 函数库可以自动执行 Generator 函数，它的处理原理是什么呢？</li>
</ul>
<ol>
<li>因为 Generator 函数就是一个异步操作的容器，它需要一种自动执行机制，co 函数接受 Generator 函数作为参数，并最后返回一个 Promise 对象。</li>
<li>在返回的 Promise 对象里面，co 先检查参数 gen 是否为 Generator 函数。如果是，就执行该函数；如果不是就返回，并将 Promise 对象的状态改为 resolved。</li>
<li>co 将 Generator 函数的内部指针对象的 next 方法，包装成 onFulfilled 函数。这主要是为了能够捕捉抛出的错误。</li>
<li>关键的是 next 函数，它会反复调用自身。<h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// readFilePromise 依旧返回 Promise 对象</span><br><span class="line"></span><br><span class="line">const readFilePromise = (filename) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    fs.readFile(filename, (err, data) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">      if(err) &#123;</span><br><span class="line"></span><br><span class="line">        reject(err);</span><br><span class="line"></span><br><span class="line">      &#125;else &#123;</span><br><span class="line"></span><br><span class="line">        resolve(data);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  &#125;).then(res =&gt; res);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 这里把 Generator的 * 换成 async，把 yield 换成 await</span><br><span class="line"></span><br><span class="line">const gen = async function() &#123;</span><br><span class="line"></span><br><span class="line">  const data1 = await readFilePromise(&apos;1.txt&apos;)</span><br><span class="line"></span><br><span class="line">  console.log(data1.toString())</span><br><span class="line"></span><br><span class="line">  const data2 = await readFilePromise(&apos;2.txt&apos;)</span><br><span class="line"></span><br><span class="line">  console.log(data2.toString)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>async 函数对 Generator 函数的改进，主要体现在以下三点<br>内置执行器：Generator 函数的执行必须靠执行器，因为不能一次性执行完成，所以之后才有了开源的 co 函数库。但是，async 函数和正常的函数一样执行，也不用 co 函数库，也不用使用 next 方法，而 async 函数自带执行器，会自动执行。<br>适用性更好：co 函数库有条件约束，yield 命令后面只能是 Thunk 函数或 Promise 对象，但是 async 函数的 await 关键词后面，可以不受约束。<br>可读性更好：async 和 await，比起使用 * 号和 yield，语义更清晰明了。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">async function func() &#123;</span><br><span class="line"></span><br><span class="line">  return 100;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(func());</span><br><span class="line"></span><br><span class="line">// Promise &#123;&lt;fulfilled&gt;: 100&#125;</span><br><span class="line">从执行的结果可以看出，async 函数 func 最后返回的结果直接是 Promise 对象，比较方便让开发者继续往后处理。而之前 Generator 并不会自动执行，需要通过 next 方法控制，最后返回的也并不是 Promise 对象，而是需要通过 co 函数库来实现最后返回 Promise 对象。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="EventEmitter"><a href="#EventEmitter" class="headerlink" title="EventEmitter"></a>EventEmitter</h3><ul>
<li>Node.js的events 模块对外提供了一个 EventEmitter 对象，用于对 Node.js 中的事件进行统一管理。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var events = require(&apos;events&apos;);</span><br><span class="line"></span><br><span class="line">var eventEmitter = new events.EventEmitter();</span><br><span class="line"></span><br><span class="line">eventEmitter.on(&apos;say&apos;,function(name)&#123;</span><br><span class="line"></span><br><span class="line">    console.log(&apos;Hello&apos;,name);</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">eventEmitter.emit(&apos;say&apos;,&apos;Jonh&apos;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="addListener-和-removeListener、on-和-off-方法对比"><a href="#addListener-和-removeListener、on-和-off-方法对比" class="headerlink" title="addListener 和 removeListener、on 和 off 方法对比"></a>addListener 和 removeListener、on 和 off 方法对比</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">addListener 方法的作用是为指定事件添加一个监听器，其实和 on 方法实现的功能是一样的，on 其实就是 addListener 方法的一个别名。</span><br><span class="line">二者实现的作用是一样的，同时 removeListener 方法的作用是为移除某个事件的监听器，同样 off 也是 removeListener 的别名。</span><br><span class="line">var events = require(&apos;events&apos;);</span><br><span class="line"></span><br><span class="line">var emitter = new events.EventEmitter();</span><br><span class="line"></span><br><span class="line">function hello1(name)&#123;</span><br><span class="line"></span><br><span class="line">  console.log(&quot;hello 1&quot;,name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function hello2(name)&#123;</span><br><span class="line"></span><br><span class="line">  console.log(&quot;hello 2&quot;,name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">emitter.addListener(&apos;say&apos;,hello1);</span><br><span class="line"></span><br><span class="line">emitter.addListener(&apos;say&apos;,hello2);</span><br><span class="line"></span><br><span class="line">emitter.emit(&apos;say&apos;,&apos;John&apos;);</span><br><span class="line"></span><br><span class="line">//输出hello 1 John </span><br><span class="line"></span><br><span class="line">//输出hello 2 John</span><br><span class="line"></span><br><span class="line">emitter.removeListener(&apos;say&apos;,hello1);</span><br><span class="line"></span><br><span class="line">emitter.emit(&apos;say&apos;,&apos;John&apos;);</span><br><span class="line"></span><br><span class="line">//相应的，监听say事件的hello1事件被移除</span><br><span class="line"></span><br><span class="line">//只输出hello 2 John</span><br></pre></td></tr></table></figure>
<h4 id="removeListener-和-removeAllListeners"><a href="#removeListener-和-removeAllListeners" class="headerlink" title="removeListener 和 removeAllListeners"></a>removeListener 和 removeAllListeners</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var events = require(&apos;events&apos;);</span><br><span class="line"></span><br><span class="line">var emitter = new events.EventEmitter();</span><br><span class="line"></span><br><span class="line">function hello1(name)&#123;</span><br><span class="line"></span><br><span class="line">  console.log(&quot;hello 1&quot;,name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function hello2(name)&#123;</span><br><span class="line"></span><br><span class="line">  console.log(&quot;hello 2&quot;,name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">emitter.addListener(&apos;say&apos;,hello1);</span><br><span class="line"></span><br><span class="line">emitter.addListener(&apos;say&apos;,hello2);</span><br><span class="line"></span><br><span class="line">emitter.removeAllListeners(&apos;say&apos;);</span><br><span class="line"></span><br><span class="line">emitter.emit(&apos;say&apos;,&apos;John&apos;);</span><br><span class="line"></span><br><span class="line">//removeAllListeners 移除了所有关于 say 事件的监听</span><br><span class="line"></span><br><span class="line">//因此没有任何输出</span><br></pre></td></tr></table></figure>
<h4 id="on-和-once-方法区别"><a href="#on-和-once-方法区别" class="headerlink" title="on 和 once 方法区别"></a>on 和 once 方法区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var events = require(&apos;events&apos;);</span><br><span class="line"></span><br><span class="line">var emitter = new events.EventEmitter();</span><br><span class="line"></span><br><span class="line">function hello(name)&#123;</span><br><span class="line"></span><br><span class="line">  console.log(&quot;hello&quot;,name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">emitter.on(&apos;say&apos;,hello);</span><br><span class="line"></span><br><span class="line">emitter.emit(&apos;say&apos;,&apos;John&apos;);</span><br><span class="line"></span><br><span class="line">emitter.emit(&apos;say&apos;,&apos;Lily&apos;);</span><br><span class="line"></span><br><span class="line">emitter.emit(&apos;say&apos;,&apos;Lucy&apos;);</span><br><span class="line"></span><br><span class="line">//会输出 hello John、hello Lily、hello Lucy，之后还要加也可以继续触发</span><br><span class="line"></span><br><span class="line">emitter.once(&apos;see&apos;,hello);</span><br><span class="line"></span><br><span class="line">emitter.emit(&apos;see&apos;,&apos;Tom&apos;);</span><br><span class="line"></span><br><span class="line">//只会输出一次 hello Tom</span><br></pre></td></tr></table></figure>
<h4 id="实现一个-EventEmitter"><a href="#实现一个-EventEmitter" class="headerlink" title="实现一个 EventEmitter"></a>实现一个 EventEmitter</h4><ul>
<li>自己封装一个能在浏览器中跑的EventEmitter，并应用在你的业务代码中还是能带来不少方便的，它可以帮你实现自定义事件的订阅和发布，从而提升业务开发的便利性。</li>
<li>EventEmitter 采用的正是发布-订阅模式。</li>
<li>发布-订阅模式在观察者模式的基础上，在目标和观察者之间增加了一个调度中心。</li>
<li>在 Vue 框架中不同组件之间的通讯里，有一种解决方案叫 EventBus。和 EventEmitter的思路类似，它的基本用途是将 EventBus 作为组件传递数据的桥梁，所有组件共用相同的事件中心，可以向该中心注册发送事件或接收事件，所有组件都可以收到通知，使用起来非常便利，其核心其实就是发布-订阅模式的落地实现。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function EventEmitter() &#123;</span><br><span class="line"></span><br><span class="line">    this.__events = &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventEmitter.VERSION = &apos;1.0.0&apos;;</span><br><span class="line"></span><br><span class="line">从上面的代码中可以看到，我们先初始化了一个内部的__events 的对象，用来存放自定义事件，以及自定义事件的回调函数。</span><br><span class="line"></span><br><span class="line">EventEmitter.prototype.on = function(eventName, listener)&#123;</span><br><span class="line"></span><br><span class="line">	  if (!eventName || !listener) return;</span><br><span class="line"></span><br><span class="line">      // 判断回调的 listener 是否为函数</span><br><span class="line"></span><br><span class="line">	  if (!isValidListener(listener)) &#123;</span><br><span class="line"></span><br><span class="line">	       throw new TypeError(&apos;listener must be a function&apos;);</span><br><span class="line"></span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	   var events = this.__events;</span><br><span class="line"></span><br><span class="line">	   var listeners = events[eventName] = events[eventName] || [];</span><br><span class="line"></span><br><span class="line">	   var listenerIsWrapped = typeof listener === &apos;object&apos;;</span><br><span class="line"></span><br><span class="line">       // 不重复添加事件，判断是否有一样的</span><br><span class="line"></span><br><span class="line">       if (indexOf(listeners, listener) === -1) &#123;</span><br><span class="line"></span><br><span class="line">           listeners.push(listenerIsWrapped ? listener : &#123;</span><br><span class="line"></span><br><span class="line">               listener: listener,</span><br><span class="line"></span><br><span class="line">               once: false</span><br><span class="line"></span><br><span class="line">           &#125;);</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">	   return this;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 判断是否是合法的 listener</span><br><span class="line"></span><br><span class="line"> function isValidListener(listener) &#123;</span><br><span class="line"></span><br><span class="line">     if (typeof listener === &apos;function&apos;) &#123;</span><br><span class="line"></span><br><span class="line">         return true;</span><br><span class="line"></span><br><span class="line">     &#125; else if (listener &amp;&amp; typeof listener === &apos;object&apos;) &#123;</span><br><span class="line"></span><br><span class="line">         return isValidListener(listener.listener);</span><br><span class="line"></span><br><span class="line">     &#125; else &#123;</span><br><span class="line"></span><br><span class="line">         return false;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 顾名思义，判断新增自定义事件是否存在</span><br><span class="line"></span><br><span class="line">function indexOf(array, item) &#123;</span><br><span class="line"></span><br><span class="line">     var result = -1</span><br><span class="line"></span><br><span class="line">     item = typeof item === &apos;object&apos; ? item.listener : item;</span><br><span class="line"></span><br><span class="line">     for (var i = 0, len = array.length; i &lt; len; i++) &#123;</span><br><span class="line"></span><br><span class="line">         if (array[i].listener === item) &#123;</span><br><span class="line"></span><br><span class="line">             result = i;</span><br><span class="line"></span><br><span class="line">             break;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">从上面的代码中可以看出，on 方法的核心思路就是，当调用订阅一个自定义事件的时候，只要该事件通过校验合法之后，就把该自定义事件 push 到 this.__events 这个对象中存储，等需要出发的时候，则直接从通过获取 __events 中对应事件的 listener 回调函数，而后直接执行该回调方法就能实现想要的效果。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EventEmitter.prototype.emit = function(eventName, args) &#123;</span><br><span class="line"></span><br><span class="line">     // 直接通过内部对象获取对应自定义事件的回调函数</span><br><span class="line"></span><br><span class="line">     var listeners = this.__events[eventName];</span><br><span class="line"></span><br><span class="line">     if (!listeners) return;</span><br><span class="line"></span><br><span class="line">     // 需要考虑多个 listener 的情况</span><br><span class="line"></span><br><span class="line">     for (var i = 0; i &lt; listeners.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">         var listener = listeners[i];</span><br><span class="line"></span><br><span class="line">         if (listener) &#123;</span><br><span class="line"></span><br><span class="line">             listener.listener.apply(this, args || []);</span><br><span class="line"></span><br><span class="line">             // 给 listener 中 once 为 true 的进行特殊处理</span><br><span class="line"></span><br><span class="line">             if (listener.once) &#123;</span><br><span class="line"></span><br><span class="line">                 this.off(eventName, listener.listener)</span><br><span class="line"></span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     return this;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EventEmitter.prototype.off = function(eventName, listener) &#123;</span><br><span class="line"></span><br><span class="line">     var listeners = this.__events[eventName];</span><br><span class="line"></span><br><span class="line">     if (!listeners) return;</span><br><span class="line"></span><br><span class="line">     var index;</span><br><span class="line"></span><br><span class="line">     for (var i = 0, len = listeners.length; i &lt; len; i++) &#123;</span><br><span class="line"></span><br><span class="line">	    if (listeners[i] &amp;&amp; listeners[i].listener === listener) &#123;</span><br><span class="line"></span><br><span class="line">           index = i;</span><br><span class="line"></span><br><span class="line">           break;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // off 的关键</span><br><span class="line"></span><br><span class="line">    if (typeof index !== &apos;undefined&apos;) &#123;</span><br><span class="line"></span><br><span class="line">         listeners.splice(index, 1, null)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return this;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">从上面的代码中可以看出 emit 的处理方式，其实就是拿到对应自定义事件进行 apply 执行，在执行过程中对于一开始 once 方法绑定的自定义事件进行特殊的处理，当once 为 true的时候，再触发 off 方法对该自定义事件进行解绑，从而实现自定义事件一次执行的效果。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EventEmitter.prototype.once = function(eventName, listener）&#123;</span><br><span class="line"></span><br><span class="line">    // 直接调用 on 方法，once 参数传入 true，待执行之后进行 once 处理</span><br><span class="line"></span><br><span class="line">     return this.on(eventName, &#123;</span><br><span class="line"></span><br><span class="line">         listener: listener,</span><br><span class="line"></span><br><span class="line">         once: true</span><br><span class="line"></span><br><span class="line">     &#125;)</span><br><span class="line"></span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line">EventEmitter.prototype.allOff = function(eventName) &#123;</span><br><span class="line"></span><br><span class="line">     // 如果该 eventName 存在，则将其对应的 listeners 的数组直接清空</span><br><span class="line"></span><br><span class="line">     if (eventName &amp;&amp; this.__events[eventName]) &#123;</span><br><span class="line"></span><br><span class="line">         this.__events[eventName] = []</span><br><span class="line"></span><br><span class="line">     &#125; else &#123;</span><br><span class="line"></span><br><span class="line">         this.__events = &#123;&#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">从上面的代码中可以看到，once 方法的本质还是调用 on 方法，只不过传入的参数区分和非一次执行的情况。当再次触发 emit 方法的时候，once 绑定的执行一次之后再进行解绑。</span><br><span class="line"></span><br><span class="line">这样，alloff 方法也很好理解了，其实就是对内部的__events 对象进行清空，清空之后如果再次触发自定义事件，也就无法触发回调函数了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------------------------Low逼版，见笑了-----------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function EventEmitter() &#123;</span><br><span class="line">  this.__events = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventEmitter.VERSION = &quot;1.0.0&quot;;</span><br><span class="line"></span><br><span class="line">//绑定事件</span><br><span class="line">EventEmitter.prototype.on = function (eventName, event) &#123;</span><br><span class="line">  let events = (this.__events[eventName] = this.__events[eventName] || []);</span><br><span class="line">  //是否存在该事件</span><br><span class="line">  let isExist = events.find((ev) =&gt; ev.listener === (event.listener || event));</span><br><span class="line">  if (!isExist) &#123;</span><br><span class="line">    events.push(</span><br><span class="line">      //对象或函数</span><br><span class="line">      event.listener</span><br><span class="line">        ? event</span><br><span class="line">        : &#123;</span><br><span class="line">            once: false,</span><br><span class="line">            listener: event,</span><br><span class="line">          &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return this;</span><br><span class="line">&#125;;</span><br><span class="line">//触发事件</span><br><span class="line">EventEmitter.prototype.emit = function (eventName, args) &#123;</span><br><span class="line">  let events = this.__events[eventName] || [];</span><br><span class="line"></span><br><span class="line">  //多个事件</span><br><span class="line">  for (let event of events) &#123;</span><br><span class="line">    event.listener.apply(this, args || []);</span><br><span class="line">    if (event.once) &#123;</span><br><span class="line">      this.off(eventName, event);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//执行一次</span><br><span class="line">EventEmitter.prototype.once = function (eventName, event) &#123;</span><br><span class="line">  return this.on(eventName, &#123;</span><br><span class="line">    once: true,</span><br><span class="line">    listener: event.listener || event,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">//移除事件</span><br><span class="line">EventEmitter.prototype.off = function (eventName, event) &#123;</span><br><span class="line">  let events = this.__events[eventName] || [];</span><br><span class="line">  //事件下标</span><br><span class="line">  let eventIndex = events.findIndex(</span><br><span class="line">    (ev) =&gt; ev.listener === (event.listener || event)</span><br><span class="line">  );</span><br><span class="line">  //存在该事件时</span><br><span class="line">  if (eventIndex !== -1) events.splice(eventIndex, 1);</span><br><span class="line">&#125;;</span><br><span class="line">//移除所有事件</span><br><span class="line">EventEmitter.prototype.allOff = function (eventName) &#123;</span><br><span class="line">  if (this.__events[eventName]) this.__events[eventName] = [];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="实现符合-Promise-A-规范的-Promise"><a href="#实现符合-Promise-A-规范的-Promise" class="headerlink" title="实现符合 Promise/A+ 规范的 Promise"></a>实现符合 Promise/A+ 规范的 Promise</h3><h4 id="Promise-A-规范"><a href="#Promise-A-规范" class="headerlink" title="Promise/A+ 规范"></a>Promise/A+ 规范</h4><ul>
<li>Promise/A+ 规范的基本术语，如下所示</li>
</ul>
<ol>
<li>“promise”：是一个具有 then 方法的对象或者函数，它的行为符合该规范。</li>
<li>“thenable”：是一个定义了 then 方法的对象或者函数。</li>
<li>“value”：可以是任何一个合法的 JavaScript 的值（包括 undefined、thenable 或 promise）。</li>
<li>“exception”：是一个异常，是在 Promise 里面可以用 throw 语句抛出来的值。</li>
<li>“reason”：是一个 Promise 里 reject 之后返回的拒绝原因。</li>
</ol>
<ul>
<li>Promise/A+ 规范中，对 Promise 的内部状态的描述，如下所示</li>
</ul>
<ol>
<li>一个 Promise 有三种状态：pending、fulfilled 和 rejected。</li>
<li>当状态为 pending 状态时，即可以转换为 fulfilled 或者 rejected 其中之一。</li>
<li>当状态为 fulfilled 状态时，就不能转换为其他状态了，必须返回一个不能再改变的值。</li>
<li>当状态为 rejected 状态时，同样也不能转换为其他状态，必须有一个原因的值也不能改变</li>
</ol>
<ul>
<li>一个 Promise 必须拥有一个 then 方法来访问它的值或者拒绝原因。</li>
</ul>
<ol>
<li><code>promise.then(onFulfilled, onRejected)</code> then 方法有两个参数：onFulfilled 和 onRejected 都是可选参数。</li>
<li>如果 onFulfilled 是函数，则当 Promise 执行结束之后必须被调用，最终返回值为 value，其调用次数不可超过一次。</li>
<li>而 onRejected 除了最后返回的是 reason 外，其他方面和 onFulfilled 在规范上的表述基本一样。</li>
</ol>
<ul>
<li>then 方法其实可以被一个 Promise 调用多次，且必须返回一个 Promise 对象。<h4 id="一步步实现-Promise"><a href="#一步步实现-Promise" class="headerlink" title="一步步实现 Promise"></a>一步步实现 Promise</h4><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">Promise 构造函数接受一个 executor 函数，executor 函数执行完同步或者异步操作后，调用它的两个参数 resolve 和 reject。</span><br><span class="line">function Promise(executor) &#123;</span><br><span class="line"></span><br><span class="line">  var self = this</span><br><span class="line"></span><br><span class="line">  self.status = &apos;pending&apos;   // Promise当前的状态</span><br><span class="line"></span><br><span class="line">  self.data = undefined     // Promise的值</span><br><span class="line"></span><br><span class="line">  self.onResolvedCallback = [] // Promise resolve时的回调函数集</span><br><span class="line"></span><br><span class="line">  self.onRejectedCallback = [] // Promise reject时的回调函数集</span><br><span class="line"></span><br><span class="line">  executor(resolve, reject) // 执行executor并传入相应的参数</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">从上面的代码中可以看出，我们先定义了一个 Promise 的初始状态 pending，以及参数执行函数 executor，并且按照规范设计了一个 resolve 回调函数集合数组 onResolvedCallback 以及 一个 reject 回调函数集合数组，那么构造函数的初始化就基本完成了。</span><br><span class="line"></span><br><span class="line">function Promise(executor) &#123;</span><br><span class="line"></span><br><span class="line">  var self = this</span><br><span class="line"></span><br><span class="line">  self.status = &apos;pending&apos;   // Promise当前的状态</span><br><span class="line"></span><br><span class="line">  self.data = undefined    // Promise的值</span><br><span class="line"></span><br><span class="line">  self.onResolvedCallback = [] // Promise resolve时的回调函数集</span><br><span class="line"></span><br><span class="line">  self.onRejectedCallback = [] // Promise reject时的回调函数集</span><br><span class="line"></span><br><span class="line">  function resolve(value) &#123;</span><br><span class="line"></span><br><span class="line">    // TODO</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function reject(reason) &#123;</span><br><span class="line"></span><br><span class="line">    // TODO</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  try &#123; // 考虑到执行过程中有可能出错，所以我们用try/catch块给包起</span><br><span class="line"></span><br><span class="line">    executor(resolve, reject) // 执行executor</span><br><span class="line"></span><br><span class="line">  &#125; catch(e) &#123;</span><br><span class="line"></span><br><span class="line">    reject(e)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">resolve 和 reject 内部应该怎么实现呢？我们根据规范知道这两个方法主要做的事情就是返回对应状态的值 value 或者 reason，并把 Promise 内部的 status 从 pending 变成对应的状态，并且这个状态在改变了之后是不可以逆转的。</span><br><span class="line"></span><br><span class="line">function Promise(executor) &#123;</span><br><span class="line"></span><br><span class="line">  // ...上面的省略</span><br><span class="line"></span><br><span class="line">  function resolve(value) &#123;</span><br><span class="line"></span><br><span class="line">    if (self.status === &apos;pending&apos;) &#123;</span><br><span class="line"></span><br><span class="line">      self.status = &apos;resolved&apos;</span><br><span class="line"></span><br><span class="line">      self.data = value</span><br><span class="line"></span><br><span class="line">      for(var i = 0; i &lt; self.onResolvedCallback.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">        self.onResolvedCallback[i](value)</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  function reject(reason) &#123;</span><br><span class="line"></span><br><span class="line">    if (self.status === &apos;pending&apos;) &#123;</span><br><span class="line"></span><br><span class="line">      self.status = &apos;rejected&apos;</span><br><span class="line"></span><br><span class="line">      self.data = reason</span><br><span class="line"></span><br><span class="line">      for(var i = 0; i &lt; self.onRejectedCallback.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">        self.onRejectedCallback[i](reason)</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 下面的省略</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">上述代码所展示的，基本就是在判断状态为 pending 之后，把状态改为相应的值，并把对应的 value 和 reason 存在内部的 data 属性上面，之后执行相应的回调函数。</span><br><span class="line">逻辑比较简单，无非是由于 onResolveCallback 和 onRejectedCallback 这两个是数组，需要通过循环来执行，</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="实现-then-方法"><a href="#实现-then-方法" class="headerlink" title="实现 then 方法"></a>实现 then 方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">then 方法是 Promise 执行完之后可以拿到 value 或者 reason 的方法，并且还要保持 then 执行之后，返回的依旧是一个 Promise 方法，还要支持多次调用</span><br><span class="line">Promise.prototype.then = function(onResolved, onRejected) &#123;</span><br><span class="line"></span><br><span class="line">  var self = this</span><br><span class="line"></span><br><span class="line">  var promise2</span><br><span class="line"></span><br><span class="line">  // 根据标准，如果then的参数不是function，则需要忽略它</span><br><span class="line"></span><br><span class="line">  onResolved = typeof onResolved === &apos;function&apos; ? onResolved : function(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  onRejected = typeof onRejected === &apos;function&apos; ? onRejected : function(reason) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  if (self.status === &apos;resolved&apos;) &#123;</span><br><span class="line"></span><br><span class="line">    // 如果promise1的状态已经确定并且是resolved，我们调用onResolved，考虑到有可能throw，所以还需要将其包在try/catch块里</span><br><span class="line"></span><br><span class="line">    return promise2 = new Promise(function(resolve, reject) &#123;</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line"></span><br><span class="line">        var x = onResolved(self.data)</span><br><span class="line"></span><br><span class="line">        if (x instanceof Promise) &#123;</span><br><span class="line"></span><br><span class="line">// 如果onResolved的返回值是一个Promise对象，直接取它的结果作为promise2的结果</span><br><span class="line"></span><br><span class="line">          x.then(resolve, reject)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        resolve(x) // 否则，以它的返回值作为promise2的结果</span><br><span class="line"></span><br><span class="line">      &#125; catch (e) &#123;</span><br><span class="line"></span><br><span class="line">        reject(e) // 如果出错，以捕获到的错误作为promise2的结果</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 此处与前一个if块的逻辑几乎相同，区别在于所调用的是onRejected函数</span><br><span class="line"></span><br><span class="line">  if (self.status === &apos;rejected&apos;) &#123;</span><br><span class="line"></span><br><span class="line">    return promise2 = new Promise(function(resolve, reject) &#123;</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line"></span><br><span class="line">        var x = onRejected(self.data)</span><br><span class="line"></span><br><span class="line">        if (x instanceof Promise) &#123;</span><br><span class="line"></span><br><span class="line">          x.then(resolve, reject)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125; catch (e) &#123;</span><br><span class="line"></span><br><span class="line">        reject(e)</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (self.status === &apos;pending&apos;) &#123;</span><br><span class="line"></span><br><span class="line">  // 如果当前的Promise还处于pending状态，我们并不能确定调用onResolved还是onRejected，只能等到Promise的状态确定后，才能确定如何处理</span><br><span class="line"></span><br><span class="line">    return promise2 = new Promise(function(resolve, reject) &#123;</span><br><span class="line"></span><br><span class="line">      self.onResolvedCallback.push(function(value) &#123;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line"></span><br><span class="line">          var x = onResolved(self.data)</span><br><span class="line"></span><br><span class="line">          if (x instanceof Promise) &#123;</span><br><span class="line"></span><br><span class="line">            x.then(resolve, reject)</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line"></span><br><span class="line">          reject(e)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      self.onRejectedCallback.push(function(reason) &#123;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line"></span><br><span class="line">          var x = onRejected(self.data)</span><br><span class="line"></span><br><span class="line">          if (x instanceof Promise) &#123;</span><br><span class="line"></span><br><span class="line">            x.then(resolve, reject)</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line"></span><br><span class="line">          reject(e)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="完整版"><a href="#完整版" class="headerlink" title="完整版"></a>完整版</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">  module.exports = Promise</span><br><span class="line"></span><br><span class="line">&#125; catch (e) &#123;&#125;</span><br><span class="line"></span><br><span class="line">function Promise(executor) &#123;</span><br><span class="line"></span><br><span class="line">  var self = this</span><br><span class="line"></span><br><span class="line">  self.status = &apos;pending&apos;</span><br><span class="line"></span><br><span class="line">  self.onResolvedCallback = []</span><br><span class="line"></span><br><span class="line">  self.onRejectedCallback = []</span><br><span class="line"></span><br><span class="line">  function resolve(value) &#123;</span><br><span class="line"></span><br><span class="line">    if (value instanceof Promise) &#123;</span><br><span class="line"></span><br><span class="line">      return value.then(resolve, reject)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setTimeout(function() &#123; // 异步执行所有的回调函数</span><br><span class="line"></span><br><span class="line">      if (self.status === &apos;pending&apos;) &#123;</span><br><span class="line"></span><br><span class="line">        self.status = &apos;resolved&apos;</span><br><span class="line"></span><br><span class="line">        self.data = value</span><br><span class="line"></span><br><span class="line">        for (var i = 0; i &lt; self.onResolvedCallback.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">          self.onResolvedCallback[i](value)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function reject(reason) &#123;</span><br><span class="line"></span><br><span class="line">    setTimeout(function() &#123; // 异步执行所有的回调函数</span><br><span class="line"></span><br><span class="line">      if (self.status === &apos;pending&apos;) &#123;</span><br><span class="line"></span><br><span class="line">        self.status = &apos;rejected&apos;</span><br><span class="line"></span><br><span class="line">        self.data = reason</span><br><span class="line"></span><br><span class="line">        for (var i = 0; i &lt; self.onRejectedCallback.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">          self.onRejectedCallback[i](reason)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  try &#123;</span><br><span class="line"></span><br><span class="line">    executor(resolve, reject)</span><br><span class="line"></span><br><span class="line">  &#125; catch (reason) &#123;</span><br><span class="line"></span><br><span class="line">    reject(reason)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function resolvePromise(promise2, x, resolve, reject) &#123;</span><br><span class="line"></span><br><span class="line">  var then</span><br><span class="line"></span><br><span class="line">  var thenCalledOrThrow = false</span><br><span class="line"></span><br><span class="line">  if (promise2 === x) &#123;</span><br><span class="line"></span><br><span class="line">    return reject(new TypeError(&apos;Chaining cycle detected for promise!&apos;))</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (x instanceof Promise) &#123;</span><br><span class="line"></span><br><span class="line">    if (x.status === &apos;pending&apos;) &#123; </span><br><span class="line"></span><br><span class="line">      x.then(function(v) &#123;</span><br><span class="line"></span><br><span class="line">        resolvePromise(promise2, v, resolve, reject)</span><br><span class="line"></span><br><span class="line">      &#125;, reject)</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">      x.then(resolve, reject)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if ((x !== null) &amp;&amp; ((typeof x === &apos;object&apos;) || (typeof x === &apos;function&apos;))) &#123;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line"></span><br><span class="line">      then = x.then</span><br><span class="line"></span><br><span class="line">      if (typeof then === &apos;function&apos;) &#123;</span><br><span class="line"></span><br><span class="line">        then.call(x, function rs(y) &#123;</span><br><span class="line"></span><br><span class="line">          if (thenCalledOrThrow) return</span><br><span class="line"></span><br><span class="line">          thenCalledOrThrow = true</span><br><span class="line"></span><br><span class="line">          return resolvePromise(promise2, y, resolve, reject)</span><br><span class="line"></span><br><span class="line">        &#125;, function rj(r) &#123;</span><br><span class="line"></span><br><span class="line">          if (thenCalledOrThrow) return</span><br><span class="line"></span><br><span class="line">          thenCalledOrThrow = true</span><br><span class="line"></span><br><span class="line">          return reject(r)</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">      &#125; else &#123;</span><br><span class="line"></span><br><span class="line">        resolve(x)</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line"></span><br><span class="line">      if (thenCalledOrThrow) return</span><br><span class="line"></span><br><span class="line">      thenCalledOrThrow = true</span><br><span class="line"></span><br><span class="line">      return reject(e)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125; else &#123;</span><br><span class="line"></span><br><span class="line">    resolve(x)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise.prototype.then = function(onResolved, onRejected) &#123;</span><br><span class="line"></span><br><span class="line">  var self = this</span><br><span class="line"></span><br><span class="line">  var promise2</span><br><span class="line"></span><br><span class="line">  onResolved = typeof onResolved === &apos;function&apos; ? onResolved : function(v) &#123;</span><br><span class="line"></span><br><span class="line">    return v</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onRejected = typeof onRejected === &apos;function&apos; ? onRejected : function(r) &#123;</span><br><span class="line"></span><br><span class="line">    throw r</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (self.status === &apos;resolved&apos;) &#123;</span><br><span class="line"></span><br><span class="line">    return promise2 = new Promise(function(resolve, reject) &#123;</span><br><span class="line"></span><br><span class="line">      setTimeout(function() &#123; // 异步执行onResolved</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line"></span><br><span class="line">          var x = onResolved(self.data)</span><br><span class="line"></span><br><span class="line">          resolvePromise(promise2, x, resolve, reject)</span><br><span class="line"></span><br><span class="line">        &#125; catch (reason) &#123;</span><br><span class="line"></span><br><span class="line">          reject(reason)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (self.status === &apos;rejected&apos;) &#123;</span><br><span class="line"></span><br><span class="line">    return promise2 = new Promise(function(resolve, reject) &#123;</span><br><span class="line"></span><br><span class="line">      setTimeout(function() &#123; // 异步执行onRejected</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line"></span><br><span class="line">          var x = onRejected(self.data)</span><br><span class="line"></span><br><span class="line">          resolvePromise(promise2, x, resolve, reject)</span><br><span class="line"></span><br><span class="line">        &#125; catch (reason) &#123;</span><br><span class="line"></span><br><span class="line">          reject(reason)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (self.status === &apos;pending&apos;) &#123;</span><br><span class="line"></span><br><span class="line">    // 这里之所以没有异步执行，是因为这些函数必然会被resolve或reject调用，而resolve或reject函数里的内容已是异步执行，构造函数里的定义</span><br><span class="line"></span><br><span class="line">    return promise2 = new Promise(function(resolve, reject) &#123;</span><br><span class="line"></span><br><span class="line">      self.onResolvedCallback.push(function(value) &#123;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line"></span><br><span class="line">          var x = onResolved(value)</span><br><span class="line"></span><br><span class="line">          resolvePromise(promise2, x, resolve, reject)</span><br><span class="line"></span><br><span class="line">        &#125; catch (r) &#123;</span><br><span class="line"></span><br><span class="line">          reject(r)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      self.onRejectedCallback.push(function(reason) &#123;</span><br><span class="line"></span><br><span class="line">          try &#123;</span><br><span class="line"></span><br><span class="line">            var x = onRejected(reason)</span><br><span class="line"></span><br><span class="line">            resolvePromise(promise2, x, resolve, reject)</span><br><span class="line"></span><br><span class="line">          &#125; catch (r) &#123;</span><br><span class="line"></span><br><span class="line">            reject(r)</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise.prototype.catch = function(onRejected) &#123;</span><br><span class="line"></span><br><span class="line">  return this.then(null, onRejected)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 最后这个是测试用的，后面会说</span><br><span class="line"></span><br><span class="line">Promise.deferred = Promise.defer = function() &#123;</span><br><span class="line"></span><br><span class="line">  var dfd = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  dfd.promise = new Promise(function(resolve, reject) &#123;</span><br><span class="line"></span><br><span class="line">    dfd.resolve = resolve</span><br><span class="line"></span><br><span class="line">    dfd.reject = reject</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  return dfd</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="另一版"><a href="#另一版" class="headerlink" title="另一版"></a>另一版</h5><ul>
<li>微信公众号文章：<a href="https://mp.weixin.qq.com/s/C-U93BmK0U_iw3sqG0g70g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/C-U93BmK0U_iw3sqG0g70g</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line">// MyPromise.js</span><br><span class="line"></span><br><span class="line">// 先定义三个常量表示状态</span><br><span class="line">const PENDING = &apos;pending&apos;;</span><br><span class="line">const FULFILLED = &apos;fulfilled&apos;;</span><br><span class="line">const REJECTED = &apos;rejected&apos;;</span><br><span class="line"></span><br><span class="line">// 新建 MyPromise 类</span><br><span class="line">class MyPromise &#123;</span><br><span class="line">  constructor(executor)&#123;</span><br><span class="line">    // executor 是一个执行器，进入会立即执行</span><br><span class="line">    // 并传入resolve和reject方法</span><br><span class="line">    try &#123;</span><br><span class="line">      executor(this.resolve, this.reject)</span><br><span class="line">    &#125; catch (error) &#123;</span><br><span class="line">      this.reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 储存状态的变量，初始值是 pending</span><br><span class="line">  status = PENDING;</span><br><span class="line">  // 成功之后的值</span><br><span class="line">  value = null;</span><br><span class="line">  // 失败之后的原因</span><br><span class="line">  reason = null;</span><br><span class="line"></span><br><span class="line">  // 存储成功回调函数</span><br><span class="line">  onFulfilledCallbacks = [];</span><br><span class="line">  // 存储失败回调函数</span><br><span class="line">  onRejectedCallbacks = [];</span><br><span class="line"></span><br><span class="line">  // 更改成功后的状态</span><br><span class="line">  resolve = (value) =&gt; &#123;</span><br><span class="line">    // 只有状态是等待，才执行状态修改</span><br><span class="line">    if (this.status === PENDING) &#123;</span><br><span class="line">      // 状态修改为成功</span><br><span class="line">      this.status = FULFILLED;</span><br><span class="line">      // 保存成功之后的值</span><br><span class="line">      this.value = value;</span><br><span class="line">      // resolve里面将所有成功的回调拿出来执行</span><br><span class="line">      while (this.onFulfilledCallbacks.length) &#123;</span><br><span class="line">        // Array.shift() 取出数组第一个元素，然后（）调用，shift不是纯函数，取出后，数组将失去该元素，直到数组为空</span><br><span class="line">        this.onFulfilledCallbacks.shift()(value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 更改失败后的状态</span><br><span class="line">  reject = (reason) =&gt; &#123;</span><br><span class="line">    // 只有状态是等待，才执行状态修改</span><br><span class="line">    if (this.status === PENDING) &#123;</span><br><span class="line">      // 状态成功为失败</span><br><span class="line">      this.status = REJECTED;</span><br><span class="line">      // 保存失败后的原因</span><br><span class="line">      this.reason = reason;</span><br><span class="line">      // resolve里面将所有失败的回调拿出来执行</span><br><span class="line">      while (this.onRejectedCallbacks.length) &#123;</span><br><span class="line">        this.onRejectedCallbacks.shift()(reason)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  then(onFulfilled, onRejected) &#123;</span><br><span class="line">    const realOnFulfilled = typeof onFulfilled === &apos;function&apos; ? onFulfilled : value =&gt; value;</span><br><span class="line">    const realOnRejected = typeof onRejected === &apos;function&apos; ? onRejected : reason =&gt; &#123;throw reason&#125;;</span><br><span class="line"></span><br><span class="line">    // 为了链式调用这里直接创建一个 MyPromise，并在后面 return 出去</span><br><span class="line">    const promise2 = new MyPromise((resolve, reject) =&gt; &#123;</span><br><span class="line">      const fulfilledMicrotask = () =&gt;  &#123;</span><br><span class="line">        // 创建一个微任务等待 promise2 完成初始化</span><br><span class="line">        queueMicrotask(() =&gt; &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">            // 获取成功回调函数的执行结果</span><br><span class="line">            const x = realOnFulfilled(this.value);</span><br><span class="line">            // 传入 resolvePromise 集中处理</span><br><span class="line">            resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">          &#125; catch (error) &#123;</span><br><span class="line">            reject(error)</span><br><span class="line">          &#125; </span><br><span class="line">        &#125;)  </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      const rejectedMicrotask = () =&gt; &#123; </span><br><span class="line">        // 创建一个微任务等待 promise2 完成初始化</span><br><span class="line">        queueMicrotask(() =&gt; &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">            // 调用失败回调，并且把原因返回</span><br><span class="line">            const x = realOnRejected(this.reason);</span><br><span class="line">            // 传入 resolvePromise 集中处理</span><br><span class="line">            resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">          &#125; catch (error) &#123;</span><br><span class="line">            reject(error)</span><br><span class="line">          &#125; </span><br><span class="line">        &#125;) </span><br><span class="line">      &#125;</span><br><span class="line">      // 判断状态</span><br><span class="line">      if (this.status === FULFILLED) &#123;</span><br><span class="line">        fulfilledMicrotask() </span><br><span class="line">      &#125; else if (this.status === REJECTED) &#123; </span><br><span class="line">        rejectedMicrotask()</span><br><span class="line">      &#125; else if (this.status === PENDING) &#123;</span><br><span class="line">        // 等待</span><br><span class="line">        // 因为不知道后面状态的变化情况，所以将成功回调和失败回调存储起来</span><br><span class="line">        // 等到执行成功失败函数的时候再传递</span><br><span class="line">        this.onFulfilledCallbacks.push(fulfilledMicrotask);</span><br><span class="line">        this.onRejectedCallbacks.push(rejectedMicrotask);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;) </span><br><span class="line">    </span><br><span class="line">    return promise2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // resolve 静态方法</span><br><span class="line">  static resolve (parameter) &#123;</span><br><span class="line">    // 如果传入 MyPromise 就直接返回</span><br><span class="line">    if (parameter instanceof MyPromise) &#123;</span><br><span class="line">      return parameter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 转成常规方式</span><br><span class="line">    return new MyPromise(resolve =&gt;  &#123;</span><br><span class="line">      resolve(parameter);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // reject 静态方法</span><br><span class="line">  static reject (reason) &#123;</span><br><span class="line">    return new MyPromise((resolve, reject) =&gt; &#123;</span><br><span class="line">      reject(reason);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function resolvePromise(promise2, x, resolve, reject) &#123;</span><br><span class="line">  // 如果相等了，说明return的是自己，抛出类型错误并返回</span><br><span class="line">  if (promise2 === x) &#123;</span><br><span class="line">    return reject(new TypeError(&apos;Chaining cycle detected for promise #&lt;Promise&gt;&apos;))</span><br><span class="line">  &#125;</span><br><span class="line">  // 判断x是不是 MyPromise 实例对象</span><br><span class="line">  if(x instanceof MyPromise) &#123;</span><br><span class="line">    // 执行 x，调用 then 方法，目的是将其状态变为 fulfilled 或者 rejected</span><br><span class="line">    // x.then(value =&gt; resolve(value), reason =&gt; reject(reason))</span><br><span class="line">    // 简化之后</span><br><span class="line">    x.then(resolve, reject)</span><br><span class="line">  &#125; else&#123;</span><br><span class="line">    // 普通值</span><br><span class="line">    resolve(x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = MyPromise;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上面是公众号文章分享的<br>下面是自己的再次实现，根据自己理解加了一些注释<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line">class APromise &#123;</span><br><span class="line">  //容器状态</span><br><span class="line">  status = &quot;pending&quot;;</span><br><span class="line">  //处理成功时的容器值</span><br><span class="line">  value = &quot;&quot;;</span><br><span class="line">  //处理失败时的原因</span><br><span class="line">  reason = &quot;&quot;;</span><br><span class="line">  //处理成功回调函数     then方法被多次调用时，采用数组进行存储回调函数</span><br><span class="line">  fullFilledCallbacks = [];</span><br><span class="line">  //处理失败回调函数</span><br><span class="line">  rejectedCallBacks = [];</span><br><span class="line">  //处理成功</span><br><span class="line">  resolve = (value) =&gt; &#123;</span><br><span class="line">    if (this.status === &quot;pending&quot;) &#123;</span><br><span class="line">      this.status = &quot;fullFilled&quot;;</span><br><span class="line">      this.value = value;</span><br><span class="line"></span><br><span class="line">      //处理成功回调</span><br><span class="line">      while (this.fullFilledCallbacks.length) &#123;</span><br><span class="line">        this.fullFilledCallbacks.shift()(value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  //处理成败</span><br><span class="line">  reject = (reason) =&gt; &#123;</span><br><span class="line">    if (this.status === &quot;pending&quot;) &#123;</span><br><span class="line">      this.status = &quot;rejected&quot;;</span><br><span class="line">      this.reason = reason;</span><br><span class="line"></span><br><span class="line">      //处理失败回调</span><br><span class="line">      while (this.rejectedCallBacks.length) &#123;</span><br><span class="line">        this.rejectedCallBacks.shift()(reason);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  //处理then方法回调函数返回值</span><br><span class="line">  resolvePromise = (promise, res, resolve, reject) =&gt; &#123;</span><br><span class="line">    //then方法成功回调返回值和then方法返回值一样时</span><br><span class="line">    if (promise === res) &#123;</span><br><span class="line">      //避免循环引用</span><br><span class="line">      reject(new TypeError(&quot;Chaining cycle detected for promise #&lt;Promise&gt;&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //返回值为promise（这里的promise指then方法成功回调时返回的promise）时</span><br><span class="line">    if (res instanceof APromise) &#123;</span><br><span class="line">      //对返回的promise（这里的promise指then方法成功回调时返回的promise）的处理结果进行处理</span><br><span class="line">      //通过resolve/reject对返回的promise（这里的promise指调用then方法时返回的promise）状态进行处理</span><br><span class="line">      res.then(resolve, reject);</span><br><span class="line">    &#125;</span><br><span class="line">    //普通值</span><br><span class="line">    else &#123;</span><br><span class="line">      resolve(res);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  //处理完成   (rejected/pending逻辑参考fullFilled状态)</span><br><span class="line">  then = (onFullFilled, onRejected) =&gt; &#123;</span><br><span class="line">    // 如果不传，就使用默认函数</span><br><span class="line">    onFullFilled =</span><br><span class="line">      typeof onFullFilled === &quot;function&quot; ? onFullFilled : (value) =&gt; value;</span><br><span class="line">    // 如果不传，就使用默认函数</span><br><span class="line">    onRejected =</span><br><span class="line">      typeof onRejected === &quot;function&quot;</span><br><span class="line">        ? onRejected</span><br><span class="line">        : (reason) =&gt; &#123;</span><br><span class="line">            throw reason;</span><br><span class="line">          &#125;;</span><br><span class="line"></span><br><span class="line">    //返回promise用于链式调用</span><br><span class="line">    const promise = new APromise((resolve, reject) =&gt; &#123;</span><br><span class="line">      //成功回调</span><br><span class="line">      if (this.status === &quot;fullFilled&quot;) &#123;</span><br><span class="line">        // 为了拿到上面返回的promise实例对象，需要创建一个微任务等待promise初始化</span><br><span class="line">        //否则，会报ReferenceError: Cannot access &apos;promise&apos; before initialization</span><br><span class="line">        queueMicrotask(() =&gt; &#123;</span><br><span class="line">          //异常捕获</span><br><span class="line">          try &#123;</span><br><span class="line">            const res = onFullFilled(this.value);</span><br><span class="line">            this.resolvePromise(promise, res, resolve, reject);</span><br><span class="line">          &#125; catch (error) &#123;</span><br><span class="line">            reject(error);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      //失败回调</span><br><span class="line">      if (this.status === &quot;rejected&quot;) &#123;</span><br><span class="line">        queueMicrotask(() =&gt; &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">            const res = onRejected(this.reason);</span><br><span class="line">            this.resolvePromise(promise, res, resolve, reject);</span><br><span class="line">          &#125; catch (error) &#123;</span><br><span class="line">            reject(error);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      //处理异步任务</span><br><span class="line">      if (this.status === &quot;pending&quot;) &#123;</span><br><span class="line">        //对成功、失败回调进行存储。异步任务执行成功后再进行处理</span><br><span class="line">        //对成功处理函数存储</span><br><span class="line">        this.fullFilledCallbacks.push(() =&gt; &#123;</span><br><span class="line">          //异常捕获</span><br><span class="line">          try &#123;</span><br><span class="line">            const res = onFullFilled(this.value);</span><br><span class="line">            this.resolvePromise(promise, res, resolve, reject);</span><br><span class="line">          &#125; catch (error) &#123;</span><br><span class="line">            reject(error);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        //对失败处理函数进行存储</span><br><span class="line">        this.rejectedCallBacks.push(() =&gt; &#123;</span><br><span class="line">          queueMicrotask(() =&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">              const res = onRejected(this.reason);</span><br><span class="line">              this.resolvePromise(promise, res, resolve, reject);</span><br><span class="line">            &#125; catch (error) &#123;</span><br><span class="line">              reject(error);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return promise;</span><br><span class="line">  &#125;;</span><br><span class="line">  constructor(executor) &#123;</span><br><span class="line">    //异常捕获</span><br><span class="line">    try &#123;</span><br><span class="line">      //执行器</span><br><span class="line">      executor(this.resolve, this.reject);</span><br><span class="line">    &#125; catch (error) &#123;</span><br><span class="line">      console.log(error);</span><br><span class="line">      this.reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default APromise;</span><br></pre></td></tr></table></figure></p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul>
<li>可以毫不夸张地说，不深入地了解数组，就不足以写好 JavaScript。<h3 id="数组构造器"><a href="#数组构造器" class="headerlink" title="数组构造器"></a>数组构造器</h3></li>
<li>new Array(arg1, arg2,…)，参数长度为 0 或长度大于等于 2 时，传入的参数将按照顺序依次成为新数组的第 0 至第 N 项（参数长度为 0 时，返回空数组）；</li>
<li>new Array(len)，当 len 不是数值时，处理同上，返回一个只包含 len 元素一项的数组；当 len 为数值时，len 最大不能超过 32 位无符号整型，即需要小于 2 的 32 次方（len 最大为 Math.pow(2,32)），否则将抛出 RangeError。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 使用 Array 构造器，可以自定义长度</span><br><span class="line"></span><br><span class="line">var a = Array(6); // [empty × 6]</span><br><span class="line"></span><br><span class="line">// 使用对象字面量</span><br><span class="line"></span><br><span class="line">var b = [];</span><br><span class="line"></span><br><span class="line">b.length = 6; // [empty × 6]</span><br><span class="line"></span><br><span class="line">let arr3=Array(6,8,9)</span><br><span class="line">console.log(arr3);  //[6, 8, 9]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="新增的构造方法"><a href="#新增的构造方法" class="headerlink" title="新增的构造方法"></a>新增的构造方法</h3><h4 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of"></a>Array.of</h4><ul>
<li>它基本上与 Array 构造器功能一致，唯一的区别就在单个数字参数的处理上。</li>
<li>：当参数为两个时，返回的结果是一致的；当参数是一个时，Array.of 会把参数变成数组里的一项，而构造器则会生成长度和第一个参数相同的空数组。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Array.of(8.0); // [8]</span><br><span class="line"></span><br><span class="line">Array(8.0); // [empty × 8]</span><br><span class="line"></span><br><span class="line">Array.of(8.0, 5); // [8, 5]</span><br><span class="line"></span><br><span class="line">Array(8.0, 5); // [8, 5]</span><br><span class="line"></span><br><span class="line">Array.of(&apos;8&apos;); // [&quot;8&quot;]</span><br><span class="line"></span><br><span class="line">Array(&apos;8&apos;); // [&quot;8&quot;]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from"></a>Array.from</h4><ul>
<li>Array.from 的设计初衷是快速便捷地基于其他对象创建新数组，准确来说就是从一个类似数组的可迭代对象中创建一个新的数组实例。其实就是，只要一个对象有迭代器，Array.from 就能把它变成一个数组（注意：是返回新的数组，不改变原对象）。</li>
<li>Array.from 拥有 3 个参数：</li>
</ul>
<ol>
<li>类似数组的对象，必选；</li>
<li>加工函数，新生成的数组会经过该函数的加工再返回；</li>
<li>this 作用域，表示加工函数执行时 this 的值。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;0: &apos;a&apos;, 1: &apos;b&apos;, 2:&apos;c&apos;, length: 3&#125;;</span><br><span class="line"></span><br><span class="line">Array.from(obj, function(value, index)&#123;</span><br><span class="line"></span><br><span class="line">  console.log(value, index, this, arguments.length);</span><br><span class="line"></span><br><span class="line">  return value.repeat(3);   //必须指定返回值，否则返回 undefined</span><br><span class="line"></span><br><span class="line">&#125;, obj);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><p>如果这里不指定 this 的话，加工函数完全可以是一个箭头函数。上述代码可以简写为如下形式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Array.from(obj, (value) =&gt; value.repeat(3));</span><br><span class="line"></span><br><span class="line">//  控制台返回 (3) [&quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot;]</span><br></pre></td></tr></table></figure>
</li>
<li><p>拥有迭代器的对象还包括 String、Set、Map 等，Array.from 统统可以处理，请看下面的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// String</span><br><span class="line"></span><br><span class="line">Array.from(&apos;abc&apos;);         // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line"></span><br><span class="line">// Set</span><br><span class="line"></span><br><span class="line">Array.from(new Set([&apos;abc&apos;, &apos;def&apos;])); // [&quot;abc&quot;, &quot;def&quot;]</span><br><span class="line"></span><br><span class="line">// Map</span><br><span class="line"></span><br><span class="line">Array.from(new Map([[1, &apos;ab&apos;], [2, &apos;de&apos;]])); </span><br><span class="line"></span><br><span class="line">// [[1, &apos;ab&apos;], [2, &apos;de&apos;]]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Array-的判断"><a href="#Array-的判断" class="headerlink" title="Array 的判断"></a>Array 的判断</h3><ul>
<li><p>在 ES5 提供该方法之前，我们至少有如下 5 种方式去判断一个变量是否为数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var a = [];</span><br><span class="line"></span><br><span class="line">// 1.基于instanceof</span><br><span class="line"></span><br><span class="line">a instanceof Array;</span><br><span class="line"></span><br><span class="line">// 2.基于constructor</span><br><span class="line"></span><br><span class="line">a.constructor === Array;</span><br><span class="line"></span><br><span class="line">// 3.基于Object.prototype.isPrototypeOf</span><br><span class="line"></span><br><span class="line">Array.prototype.isPrototypeOf(a);</span><br><span class="line"></span><br><span class="line">// 4.基于getPrototypeOf</span><br><span class="line"></span><br><span class="line">Object.getPrototypeOf(a) === Array.prototype;</span><br><span class="line"></span><br><span class="line">// 5.基于Object.prototype.toString</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.apply(a) === &apos;[object Array]&apos;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ES6 之后新增了一个 Array.isArray 方法，能直接判断数据类型是否为数组，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">如果 isArray 不存在，那么 Array.isArray 的 polyfill 通常可以这样写：</span><br><span class="line">if (!Array.isArray)&#123;</span><br><span class="line"></span><br><span class="line">  Array.isArray = function(arg)&#123;</span><br><span class="line"></span><br><span class="line">    return Object.prototype.toString.call(arg) === &apos;[object Array]&apos;;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="改变自身的方法"><a href="#改变自身的方法" class="headerlink" title="改变自身的方法"></a>改变自身的方法</h3><ul>
<li>基于 ES6，会改变自身值的方法一共有 9 个，分别为 pop、push、reverse、shift、sort、splice、unshift，以及两个 ES6 新增的方法 copyWithin 和 fill。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">// pop方法</span><br><span class="line"></span><br><span class="line">var array = [&quot;cat&quot;, &quot;dog&quot;, &quot;cow&quot;, &quot;chicken&quot;, &quot;mouse&quot;];</span><br><span class="line"></span><br><span class="line">var item = array.pop();</span><br><span class="line"></span><br><span class="line">console.log(array); // [&quot;cat&quot;, &quot;dog&quot;, &quot;cow&quot;, &quot;chicken&quot;]</span><br><span class="line"></span><br><span class="line">console.log(item); // mouse</span><br><span class="line"></span><br><span class="line">// push方法</span><br><span class="line"></span><br><span class="line">var array = [&quot;football&quot;, &quot;basketball&quot;,  &quot;badminton&quot;];</span><br><span class="line"></span><br><span class="line">var i = array.push(&quot;golfball&quot;);</span><br><span class="line"></span><br><span class="line">console.log(array); </span><br><span class="line"></span><br><span class="line">// [&quot;football&quot;, &quot;basketball&quot;, &quot;badminton&quot;, &quot;golfball&quot;]</span><br><span class="line"></span><br><span class="line">console.log(i); // 4</span><br><span class="line"></span><br><span class="line">// reverse方法</span><br><span class="line"></span><br><span class="line">var array = [1,2,3,4,5];</span><br><span class="line"></span><br><span class="line">var array2 = array.reverse();</span><br><span class="line"></span><br><span class="line">console.log(array); // [5,4,3,2,1]</span><br><span class="line"></span><br><span class="line">console.log(array2===array); // true</span><br><span class="line"></span><br><span class="line">// shift方法</span><br><span class="line"></span><br><span class="line">var array = [1,2,3,4,5];</span><br><span class="line"></span><br><span class="line">var item = array.shift();</span><br><span class="line"></span><br><span class="line">console.log(array); // [2,3,4,5]</span><br><span class="line"></span><br><span class="line">console.log(item); // 1</span><br><span class="line"></span><br><span class="line">// unshift方法</span><br><span class="line"></span><br><span class="line">var array = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];</span><br><span class="line"></span><br><span class="line">var length = array.unshift(&quot;yellow&quot;);</span><br><span class="line"></span><br><span class="line">console.log(array); // [&quot;yellow&quot;, &quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]</span><br><span class="line"></span><br><span class="line">console.log(length); // 4</span><br><span class="line"></span><br><span class="line">// sort方法</span><br><span class="line"></span><br><span class="line">var array = [&quot;apple&quot;,&quot;Boy&quot;,&quot;Cat&quot;,&quot;dog&quot;];</span><br><span class="line"></span><br><span class="line">var array2 = array.sort();</span><br><span class="line"></span><br><span class="line">console.log(array); // [&quot;Boy&quot;, &quot;Cat&quot;, &quot;apple&quot;, &quot;dog&quot;]</span><br><span class="line"></span><br><span class="line">console.log(array2 == array); // true</span><br><span class="line"></span><br><span class="line">// splice方法</span><br><span class="line"></span><br><span class="line">var array = [&quot;apple&quot;,&quot;boy&quot;];</span><br><span class="line"></span><br><span class="line">var splices = array.splice(1,1);</span><br><span class="line"></span><br><span class="line">console.log(array); // [&quot;apple&quot;]</span><br><span class="line"></span><br><span class="line">console.log(splices); // [&quot;boy&quot;]</span><br><span class="line"></span><br><span class="line">// copyWithin方法</span><br><span class="line"></span><br><span class="line">var array = [1,2,3,4,5]; </span><br><span class="line"></span><br><span class="line">var array2 = array.copyWithin(0,3);</span><br><span class="line"></span><br><span class="line">console.log(array===array2,array2);  // true [4, 5, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">// fill方法</span><br><span class="line"></span><br><span class="line">var array = [1,2,3,4,5];</span><br><span class="line"></span><br><span class="line">var array2 = array.fill(10,0,3);</span><br><span class="line"></span><br><span class="line">console.log(array===array2,array2); </span><br><span class="line"></span><br><span class="line">// true [10, 10, 10, 4, 5], 可见数组区间[0,3]的元素全部替换为10</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="不改变自身的方法"><a href="#不改变自身的方法" class="headerlink" title="不改变自身的方法"></a>不改变自身的方法</h3><ul>
<li>基于 ES7，不会改变自身的方法也有 9 个，分别为 concat、join、slice、toString、toLocaleString、indexOf、lastIndexOf、未形成标准的 toSource，以及 ES7 新增的方法 includes。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">// concat方法</span><br><span class="line"></span><br><span class="line">var array = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">var array2 = array.concat(4,[5,6],[7,8,9]);</span><br><span class="line"></span><br><span class="line">console.log(array2); // [1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line"></span><br><span class="line">console.log(array); // [1, 2, 3], 可见原数组并未被修改</span><br><span class="line"></span><br><span class="line">// join方法</span><br><span class="line"></span><br><span class="line">var array = [&apos;We&apos;, &apos;are&apos;, &apos;Chinese&apos;];</span><br><span class="line"></span><br><span class="line">console.log(array.join()); // &quot;We,are,Chinese&quot;</span><br><span class="line"></span><br><span class="line">console.log(array.join(&apos;+&apos;)); // &quot;We+are+Chinese&quot;</span><br><span class="line"></span><br><span class="line">// slice方法</span><br><span class="line"></span><br><span class="line">var array = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;,&quot;four&quot;, &quot;five&quot;];</span><br><span class="line"></span><br><span class="line">console.log(array.slice()); // [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;,&quot;four&quot;, &quot;five&quot;]</span><br><span class="line"></span><br><span class="line">console.log(array.slice(2,3)); // [&quot;three&quot;]</span><br><span class="line"></span><br><span class="line">// toString方法</span><br><span class="line"></span><br><span class="line">var array = [&apos;Jan&apos;, &apos;Feb&apos;, &apos;Mar&apos;, &apos;Apr&apos;];</span><br><span class="line"></span><br><span class="line">var str = array.toString();</span><br><span class="line"></span><br><span class="line">console.log(str); // Jan,Feb,Mar,Apr</span><br><span class="line"></span><br><span class="line">// tolocalString方法</span><br><span class="line"></span><br><span class="line">var array= [&#123;name:&apos;zz&apos;&#125;, 123, &quot;abc&quot;, new Date()];</span><br><span class="line"></span><br><span class="line">var str = array.toLocaleString();</span><br><span class="line"></span><br><span class="line">console.log(str); // [object Object],123,abc,2016/1/5 下午1:06:23</span><br><span class="line"></span><br><span class="line">// indexOf方法</span><br><span class="line"></span><br><span class="line">var array = [&apos;abc&apos;, &apos;def&apos;, &apos;ghi&apos;,&apos;123&apos;];</span><br><span class="line"></span><br><span class="line">console.log(array.indexOf(&apos;def&apos;)); // 1</span><br><span class="line"></span><br><span class="line">// includes方法</span><br><span class="line"></span><br><span class="line">var array = [-0, 1, 2];</span><br><span class="line"></span><br><span class="line">console.log(array.includes(+0)); // true</span><br><span class="line"></span><br><span class="line">console.log(array.includes(1)); // true</span><br><span class="line"></span><br><span class="line">var array = [NaN];</span><br><span class="line"></span><br><span class="line">console.log(array.includes(NaN)); // true</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="数组遍历的方法"><a href="#数组遍历的方法" class="headerlink" title="数组遍历的方法"></a>数组遍历的方法</h3><ul>
<li>基于 ES6，不会改变自身的遍历方法一共有 12 个，分别为 forEach、every、some、filter、map、reduce、reduceRight，以及 ES6 新增的方法 entries、find、findIndex、keys、values。</li>
<li><p>其中，要注意有些遍历方法不会返回处理之后的数组，比如 forEach；有些方法会返回处理之后的数组，比如 filter。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line">// forEach方法</span><br><span class="line"></span><br><span class="line">var array = [1, 3, 5];</span><br><span class="line"></span><br><span class="line">var obj = &#123;name:&apos;cc&apos;&#125;;</span><br><span class="line"></span><br><span class="line">var sReturn = array.forEach(function(value, index, array)&#123;</span><br><span class="line"></span><br><span class="line">  array[index] = value;</span><br><span class="line"></span><br><span class="line">  console.log(this.name); // cc被打印了三次, this指向obj</span><br><span class="line"></span><br><span class="line">&#125;,obj);</span><br><span class="line"></span><br><span class="line">console.log(array); // [1, 3, 5]</span><br><span class="line"></span><br><span class="line">console.log(sReturn); // undefined, 可见返回值为undefined</span><br><span class="line"></span><br><span class="line">// every方法</span><br><span class="line"></span><br><span class="line">var o = &#123;0:10, 1:8, 2:25, length:3&#125;;</span><br><span class="line"></span><br><span class="line">var bool = Array.prototype.every.call(o,function(value, index, obj)&#123;</span><br><span class="line"></span><br><span class="line">  return value &gt;= 8;</span><br><span class="line"></span><br><span class="line">&#125;,o);</span><br><span class="line"></span><br><span class="line">console.log(bool); // true</span><br><span class="line"></span><br><span class="line">// some方法</span><br><span class="line"></span><br><span class="line">var array = [18, 9, 10, 35, 80];</span><br><span class="line"></span><br><span class="line">var isExist = array.some(function(value, index, array)&#123;</span><br><span class="line"></span><br><span class="line">  return value &gt; 20;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(isExist); // true </span><br><span class="line"></span><br><span class="line">// map 方法</span><br><span class="line"></span><br><span class="line">var array = [18, 9, 10, 35, 80];</span><br><span class="line"></span><br><span class="line">array.map(item =&gt; item + 1);</span><br><span class="line"></span><br><span class="line">console.log(array);  // [19, 10, 11, 36, 81]</span><br><span class="line"></span><br><span class="line">// filter 方法</span><br><span class="line"></span><br><span class="line">var array = [18, 9, 10, 35, 80];</span><br><span class="line"></span><br><span class="line">var array2 = array.filter(function(value, index, array)&#123;</span><br><span class="line"></span><br><span class="line">  return value &gt; 20;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(array2); // [35, 80]</span><br><span class="line"></span><br><span class="line">// reduce方法</span><br><span class="line"></span><br><span class="line">var array = [1, 2, 3, 4];</span><br><span class="line"></span><br><span class="line">var s = array.reduce(function(previousValue, value, index, array)&#123;</span><br><span class="line"></span><br><span class="line">  return previousValue * value;</span><br><span class="line"></span><br><span class="line">&#125;,1);</span><br><span class="line"></span><br><span class="line">console.log(s); // 24</span><br><span class="line"></span><br><span class="line">// ES6写法更加简洁</span><br><span class="line"></span><br><span class="line">array.reduce((p, v) =&gt; p * v); // 24</span><br><span class="line"></span><br><span class="line">// reduceRight方法 (和reduce的区别就是从后往前累计)</span><br><span class="line"></span><br><span class="line">var array = [1, 2, 3, 4];</span><br><span class="line"></span><br><span class="line">array.reduceRight((p, v) =&gt; p * v); // 24</span><br><span class="line"></span><br><span class="line">// entries方法</span><br><span class="line"></span><br><span class="line">var array = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];</span><br><span class="line"></span><br><span class="line">var iterator = array.entries();</span><br><span class="line"></span><br><span class="line">console.log(iterator.next().value); // [0, &quot;a&quot;]</span><br><span class="line"></span><br><span class="line">console.log(iterator.next().value); // [1, &quot;b&quot;]</span><br><span class="line"></span><br><span class="line">console.log(iterator.next().value); // [2, &quot;c&quot;]</span><br><span class="line"></span><br><span class="line">console.log(iterator.next().value); // undefined, 迭代器处于数组末尾时, 再迭代就会返回undefined</span><br><span class="line"></span><br><span class="line">// find &amp; findIndex方法</span><br><span class="line"></span><br><span class="line">var array = [1, 3, 5, 7, 8, 9, 10];</span><br><span class="line"></span><br><span class="line">function f(value, index, array)&#123;</span><br><span class="line"></span><br><span class="line">  return value%2==0;     // 返回偶数</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function f2(value, index, array)&#123;</span><br><span class="line"></span><br><span class="line">  return value &gt; 20;     // 返回大于20的数</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(array.find(f)); // 8</span><br><span class="line"></span><br><span class="line">console.log(array.find(f2)); // undefined</span><br><span class="line"></span><br><span class="line">console.log(array.findIndex(f)); // 4</span><br><span class="line"></span><br><span class="line">console.log(array.findIndex(f2)); // -1</span><br><span class="line"></span><br><span class="line">// keys方法</span><br><span class="line"></span><br><span class="line">[...Array(10).keys()];     // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line"></span><br><span class="line">[...new Array(10).keys()]; // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line"></span><br><span class="line">// values方法</span><br><span class="line"></span><br><span class="line">var array = [&quot;abc&quot;, &quot;xyz&quot;];</span><br><span class="line"></span><br><span class="line">var iterator = array.values();</span><br><span class="line"></span><br><span class="line">console.log(iterator.next().value);//abc</span><br><span class="line"></span><br><span class="line">console.log(iterator.next().value);//xyz</span><br></pre></td></tr></table></figure>
</li>
<li><p>reduce 的两个参数</p>
</li>
</ul>
<ol>
<li>首先是 callback（一个在数组的每一项中调用的函数，接受四个参数）：<br>previousValue（上一次调用回调函数时的返回值，或者初始值）<br>currentValue（当前正在处理的数组元素）<br>currentIndex（当前正在处理的数组元素下标）<br>array（调用 reduce() 方法的数组）</li>
<li>然后是 initialValue（可选的初始值，作为第一次调用回调函数时传给 previousValue 的值）。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/* 题目：数组 arr = [1,2,3,4] 求数组的和：*/</span><br><span class="line"></span><br><span class="line">// 第一种方法：</span><br><span class="line"></span><br><span class="line">var arr = [1,2,3,4];</span><br><span class="line"></span><br><span class="line">var sum = 0;</span><br><span class="line"></span><br><span class="line">arr.forEach(function(e)&#123;sum += e;&#125;); // sum = 10</span><br><span class="line"></span><br><span class="line">// 第二种方法</span><br><span class="line"></span><br><span class="line">var arr = [1,2,3,4];</span><br><span class="line"></span><br><span class="line">var sum = 0;</span><br><span class="line"></span><br><span class="line">arr.map(function(obj)&#123;sum += obj&#125;);</span><br><span class="line"></span><br><span class="line">// 第三种方法</span><br><span class="line"></span><br><span class="line">var arr = [1,2,3,4];</span><br><span class="line"></span><br><span class="line">arr.reduce(function(pre,cur)&#123;return pre + cur&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a>类数组</h3><ul>
<li>JavaScript 中有哪些情况下的对象是类数组呢？主要有以下几种：</li>
</ul>
<ol>
<li>函数里面的参数对象 arguments；</li>
<li>用 getElementsByTagName/ClassName/Name 获得的 HTMLCollection；</li>
<li>用 querySelector 获得的 NodeList。<h4 id="如何将类数组转换成数组"><a href="#如何将类数组转换成数组" class="headerlink" title="如何将类数组转换成数组"></a>如何将类数组转换成数组</h4></li>
</ol>
<ul>
<li>类数组借用数组方法转数组<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function sum(a, b) &#123;</span><br><span class="line"></span><br><span class="line">  let args = Array.prototype.slice.call(arguments);</span><br><span class="line"></span><br><span class="line"> // let args = [].slice.call(arguments); // 这样写也是一样效果</span><br><span class="line"></span><br><span class="line">  console.log(args.reduce((sum, cur) =&gt; sum + cur));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(1, 2);  // 3</span><br><span class="line"></span><br><span class="line">function sum(a, b) &#123;</span><br><span class="line"></span><br><span class="line">  let args = Array.prototype.concat.apply([], arguments);</span><br><span class="line"></span><br><span class="line">  console.log(args.reduce((sum, cur) =&gt; sum + cur));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sum(1, 2);  // 3</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="ES6-的方法转数组"><a href="#ES6-的方法转数组" class="headerlink" title="ES6 的方法转数组"></a>ES6 的方法转数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function sum(a, b) &#123;</span><br><span class="line"></span><br><span class="line">  let args = Array.from(arguments);</span><br><span class="line"></span><br><span class="line">  console.log(args.reduce((sum, cur) =&gt; sum + cur));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(1, 2);    // 3</span><br><span class="line"></span><br><span class="line">function sum(a, b) &#123;</span><br><span class="line"></span><br><span class="line">  let args = [...arguments];</span><br><span class="line"></span><br><span class="line">  console.log(args.reduce((sum, cur) =&gt; sum + cur));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(1, 2);    // 3</span><br><span class="line"></span><br><span class="line">function sum(...args) &#123;</span><br><span class="line"></span><br><span class="line">  console.log(args.reduce((sum, cur) =&gt; sum + cur));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(1, 2);    // 3</span><br></pre></td></tr></table></figure>
<h3 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h3><ul>
<li><p>普通的递归实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 方法1</span><br><span class="line"></span><br><span class="line">var a = [1, [2, [3, 4, 5]]];</span><br><span class="line"></span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line"></span><br><span class="line">  let result = [];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  for(let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">    if(Array.isArray(arr[i])) &#123;</span><br><span class="line"></span><br><span class="line">      result = result.concat(flatten(arr[i]));</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">      result.push(arr[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">flatten(a);  //  [1, 2, 3, 4，5]</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用 reduce 函数迭代</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 方法2</span><br><span class="line"></span><br><span class="line">var arr = [1, [2, [3, 4]]];</span><br><span class="line"></span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line"></span><br><span class="line">    return arr.reduce(function(prev, next)&#123;</span><br><span class="line"></span><br><span class="line">        return prev.concat(Array.isArray(next) ? flatten(next) : next)</span><br><span class="line"></span><br><span class="line">    &#125;, [])</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(flatten(arr));//  [1, 2, 3, 4，5]</span><br></pre></td></tr></table></figure>
</li>
<li><p>扩展运算符实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 方法3</span><br><span class="line"></span><br><span class="line">var arr = [1, [2, [3, 4]]];</span><br><span class="line"></span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line"></span><br><span class="line">    while (arr.some(item =&gt; Array.isArray(item))) &#123;</span><br><span class="line"></span><br><span class="line">        arr = [].concat(...arr);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return arr;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(flatten(arr)); //  [1, 2, 3, 4，5]</span><br></pre></td></tr></table></figure>
</li>
<li><p>split 和 toString 共同处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 方法4</span><br><span class="line"></span><br><span class="line">var arr = [1, [2, [3, 4]]];</span><br><span class="line"></span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line"></span><br><span class="line">    return arr.toString().split(&apos;,&apos;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(flatten(arr)); //  [1, 2, 3, 4]</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用 ES6 中的 flat,发现对数组的嵌套层数不确定的时候，最好直接使用 Infinity，可以达到扁平化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 方法5</span><br><span class="line"></span><br><span class="line">var arr = [1, [2, [3, 4]]];</span><br><span class="line"></span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line"></span><br><span class="line">  return arr.flat(Infinity);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(flatten(arr)); //  [1, 2, 3, 4，5]</span><br></pre></td></tr></table></figure>
</li>
<li><p>正则和 JSON 方法共同处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 方法 6</span><br><span class="line"></span><br><span class="line">let arr = [1, [2, [3, [4, 5]]], 6];</span><br><span class="line"></span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line"></span><br><span class="line">  let str = JSON.stringify(arr);</span><br><span class="line"></span><br><span class="line">  str = str.replace(/(\[|\])/g, &apos;&apos;);</span><br><span class="line"></span><br><span class="line">  str = &apos;[&apos; + str + &apos;]&apos;;</span><br><span class="line"></span><br><span class="line">  return JSON.parse(str); </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(flatten(arr)); //  [1, 2, 3, 4，5]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="sort-排序方法的实现原理"><a href="#sort-排序方法的实现原理" class="headerlink" title="sort 排序方法的实现原理"></a>sort 排序方法的实现原理</h3><ul>
<li>sort() 方法用原地算法对数组的元素进行排序，并返回数组。默认排序顺序是在将元素转换为字符串，然后比较它们的UTF-16代码单元值序列时构建的</li>
<li>通过研究源码我们先直接看一下结论，如果要排序的元素个数是 n 的时候，那么就会有以下几种情况：</li>
</ul>
<ol>
<li>当 n&lt;=10 时，采用插入排序；对于很小的数据量，应用插入排序是一个非常不错的选择。</li>
<li>当 n&gt;10 时，采用三路快速排序；<br>快速排序的性能瓶颈在于递归的深度，最坏的情况是每次的哨兵都是最小元素或者最大元素，那么进行 partition（一边是小于哨兵的元素，另一边是大于哨兵的元素）时，就会有一边是空的。<br>如果这么排下去，递归的层数就达到了 n , 而每一层的复杂度是 O(n)，因此快排这时候会退化成 O(n^2) 级别。<br>这种情况是要尽力避免的，那么如何来避免？就是让哨兵元素尽可能地处于数组的中间位置，让最大或者最小的情况尽可能少。</li>
<li>10&lt;n &lt;=1000，采用中位数作为哨兵元素；</li>
<li>n&gt;1000，每隔 200~215 个元素挑出一个元素，放到一个新数组中，然后对它排序，找到中间位置的数，以此作为中位数。<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2></li>
</ol>
<ul>
<li>浏览器在加载页面的时候会用到 GUI 渲染线程和 JavaScript 引擎线程（更详细的浏览器加载和渲染机制将在第 7 讲中介绍）。其中，GUI 渲染线程负责渲染浏览器界面 HTML 元素，JavaScript 引擎线程主要负责处理 JavaScript 脚本程序。由于 JavaScript 在执行过程中还可能会改动界面结构和样式，因此它们之间被设计为互斥的关系。也就是说，当 JavaScript 引擎执行时，GUI 线程会被挂起。</li>
<li>如果我们直接在document.body上进行事件委托，可能会带来额外的问题。由于浏览器在进行页面渲染的时候会有合成的步骤，合成的过程会先将页面分成不同的合成层，而用户与浏览器进行交互的时候需要接收事件。此时，浏览器会将页面上具有事件处理程序的区域进行标记，被标记的区域会与主线程进行通信。</li>
<li>如果我们document.body上被绑定了事件，这时候整个页面都会被标记。即使我们的页面不关心某些部分的用户交互，合成器线程也必须与主线程进行通信，并在每次事件发生时进行等待。这种情况，我们可以使用passive: true选项来解决。<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h3></li>
</ul>
<ol>
<li>盒模型会发生margin外边距叠加，叠加后的值会以最大边距为准。</li>
</ol>
<ul>
<li>需要注意的是，并不是所有情况下都会发生外边距叠加，比如行内框、浮动框或绝对定位框之间的外边距不会叠加。</li>
</ul>
<ol start="2">
<li>们可以通过box-sizing属性进行设置盒模型的计算方式，正常的盒模型默认值是content-box。</li>
</ol>
<ul>
<li>使用box-sizing属性可以解决问题 （调整元素的边框时，不影响元素的宽高），我们可以将元素的box-sizing属性设置为border-box<h3 id="内联元素与块状元素"><a href="#内联元素与块状元素" class="headerlink" title="内联元素与块状元素"></a>内联元素与块状元素</h3></li>
<li>除了内联元素和块状元素，我们还可以将元素设置为inline-block，inline-block可以很方便解决一些问题：使元素居中、给inline元素（<a>/<span>）设置宽高、将多个块状元素放在一行等。<h3 id="文档流和元素定位"><a href="#文档流和元素定位" class="headerlink" title="文档流和元素定位"></a>文档流和元素定位</h3></span></a></li>
<li>文档流布局方式可以使用position样式进行调整，包括：static（默认值）、inherit（继承父元素）、relative（相对定位）、absolute（相对非static父元素绝对定位）、fixed（相对浏览器窗口进行绝对定位）,sticky粘性定位。</li>
<li>这是因为除了同级元素以外，z-index值的设置效果还会受到父元素的z-index值的影响。z-index值的设置只决定同一父元素中的同级子元素的堆叠顺序。因此，即使将某个元素z-index设置为9999999，它依然可能因为父元素的z-index值小于其他父元素同级的元素，而导致该元素依然被其他元素遮挡。<h3 id="常见页面布局方式"><a href="#常见页面布局方式" class="headerlink" title="常见页面布局方式"></a>常见页面布局方式</h3></li>
</ul>
<ol>
<li>传统布局</li>
</ol>
<ul>
<li>除了使用position: fixed或者position: absolute时，会使元素脱离文档流，使用float属性同样会导致元素脱离文档流。</li>
</ul>
<ol start="2">
<li>Flex 布局</li>
<li>Grid 布局<h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2></li>
</ol>
<ul>
<li>每个对象都有<strong>proto</strong>属性来标识自己所继承的原型对象，但只有函数才有prototype属性</li>
<li>对于函数来说，每个函数都有一个prototype属性，该属性为该函数的原型对象</li>
<li>一个对象可通过<strong>proto</strong>访问原型对象上的属性和方法，而该原型同样也可通过<strong>proto</strong>访问它的原型对象，这样我们就在实例和原型之间构造了一条原型链</li>
<li>当 JavaScript 试图访问一个对象的属性时，会基于原型链进行查找。查找的过程是这样的：</li>
</ul>
<ol>
<li>首先会优先在该对象上搜寻。如果找不到，还会依次层层向上搜索该对象的原型对象、该对象的原型对象的原型对象等（套娃警告）；</li>
<li>JavaScript 中的所有对象都来自Object，Object.prototype.<strong>proto</strong> === null。null没有原型，并作为这个原型链中的最后一个环节；</li>
<li>JavaScript 会遍历访问对象的整个原型链，如果最终依然找不到，此时会认为该对象的属性值为undefined。</li>
</ol>
<ul>
<li>原型链继承方式中引用类型的属性被所有实例共享，无法做到实例私有</li>
</ul>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2021/03/25/core/">核心进阶</a></p>
        <p><span>文章作者:</span><a href="/" title="访问 DiamondsZz 的个人博客">DiamondsZz</a></p>
        <p><span>发布时间:</span>2021年03月25日</p>
        <p><span>最后更新:</span>2021年04月21日 - 21时20分</p>    
    </div>



<nav id="article-nav">
  
    <a href="/2021/03/25/vue/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          vue进阶
        
      </div>
    </a>
  
  
    <a href="/2021/03/25/browser/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">浏览器工作原理</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>


  
</article>

    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#数据类型"><span class="toc-number">1.</span> <span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据类型检测"><span class="toc-number">2.</span> <span class="toc-text">数据类型检测</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据类型转换"><span class="toc-number">3.</span> <span class="toc-text">数据类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#拷贝"><span class="toc-number">4.</span> <span class="toc-text">拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#浅拷贝"><span class="toc-number">4.1.</span> <span class="toc-text">浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#深拷贝"><span class="toc-number">4.2.</span> <span class="toc-text">深拷贝</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#继承"><span class="toc-number">5.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#垃圾回收"><span class="toc-number">6.</span> <span class="toc-text">垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#内存管理"><span class="toc-number">6.1.</span> <span class="toc-text">内存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#chrome内存回收机制"><span class="toc-number">6.2.</span> <span class="toc-text">chrome内存回收机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#新生代内存回收"><span class="toc-number">6.2.1.</span> <span class="toc-text">新生代内存回收</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#老生代内存回收"><span class="toc-number">6.2.2.</span> <span class="toc-text">老生代内存回收</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存泄漏与优化"><span class="toc-number">6.3.</span> <span class="toc-text">内存泄漏与优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据结构与算法"><span class="toc-number">7.</span> <span class="toc-text">数据结构与算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#时间、空间复杂度"><span class="toc-number">7.1.</span> <span class="toc-text">时间、空间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#增删查"><span class="toc-number">7.2.</span> <span class="toc-text">增删查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线性表"><span class="toc-number">7.3.</span> <span class="toc-text">线性表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#栈"><span class="toc-number">7.4.</span> <span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#顺序栈"><span class="toc-number">7.4.1.</span> <span class="toc-text">顺序栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#链栈"><span class="toc-number">7.4.2.</span> <span class="toc-text">链栈</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#队列"><span class="toc-number">7.5.</span> <span class="toc-text">队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#循环队列"><span class="toc-number">7.5.1.</span> <span class="toc-text">循环队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#链式队列"><span class="toc-number">7.5.2.</span> <span class="toc-text">链式队列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#树"><span class="toc-number">7.6.</span> <span class="toc-text">树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#二叉树"><span class="toc-number">7.6.1.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#二叉查找树（二叉搜索树）"><span class="toc-number">7.6.1.1.</span> <span class="toc-text">二叉查找树（二叉搜索树）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Trie-树，或字典树"><span class="toc-number">7.6.1.2.</span> <span class="toc-text">Trie 树，或字典树</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#哈希表"><span class="toc-number">7.7.</span> <span class="toc-text">哈希表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#递归"><span class="toc-number">7.8.</span> <span class="toc-text">递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分治"><span class="toc-number">7.9.</span> <span class="toc-text">分治</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#排序"><span class="toc-number">7.10.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#冒泡排序"><span class="toc-number">7.10.1.</span> <span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#插入排序"><span class="toc-number">7.10.2.</span> <span class="toc-text">插入排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#归并排序"><span class="toc-number">7.10.3.</span> <span class="toc-text">归并排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#快速排序"><span class="toc-number">7.10.4.</span> <span class="toc-text">快速排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态规划"><span class="toc-number">7.11.</span> <span class="toc-text">动态规划</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new-apply-call-bind"><span class="toc-number">8.</span> <span class="toc-text">new/apply/call/bind</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#new"><span class="toc-number">8.1.</span> <span class="toc-text">new</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#call-apply-bind"><span class="toc-number">8.2.</span> <span class="toc-text">call/apply/bind</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#手写实现"><span class="toc-number">8.3.</span> <span class="toc-text">手写实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#new-1"><span class="toc-number">8.3.1.</span> <span class="toc-text">new</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#call-apply"><span class="toc-number">8.3.2.</span> <span class="toc-text">call/apply</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bind"><span class="toc-number">8.3.3.</span> <span class="toc-text">bind</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#闭包"><span class="toc-number">9.</span> <span class="toc-text">闭包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JSON"><span class="toc-number">10.</span> <span class="toc-text">JSON</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JSON-parse"><span class="toc-number">10.1.</span> <span class="toc-text">JSON.parse</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JSON-stringify"><span class="toc-number">10.2.</span> <span class="toc-text">JSON.stringify</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Eventloop"><span class="toc-number">11.</span> <span class="toc-text">Eventloop</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#浏览器的-Eventloop"><span class="toc-number">11.1.</span> <span class="toc-text">浏览器的 Eventloop</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#外部队列"><span class="toc-number">11.1.1.</span> <span class="toc-text">外部队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#内部队列"><span class="toc-number">11.1.2.</span> <span class="toc-text">内部队列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Node-js-的-Eventloop"><span class="toc-number">11.2.</span> <span class="toc-text">Node.js 的 Eventloop</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EventLoop-对渲染的影响"><span class="toc-number">11.3.</span> <span class="toc-text">EventLoop 对渲染的影响</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#宏任务、微任务"><span class="toc-number">11.4.</span> <span class="toc-text">宏任务、微任务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#宏任务"><span class="toc-number">11.4.1.</span> <span class="toc-text">宏任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#微任务"><span class="toc-number">11.4.2.</span> <span class="toc-text">微任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MutationObserver"><span class="toc-number">11.4.3.</span> <span class="toc-text">MutationObserver</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Process-nextTick"><span class="toc-number">11.4.4.</span> <span class="toc-text">Process.nextTick</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vue的nextick"><span class="toc-number">11.4.5.</span> <span class="toc-text">Vue的nextick</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JS-代码是如何被浏览器引擎编译、执行的？"><span class="toc-number">12.</span> <span class="toc-text">JS 代码是如何被浏览器引擎编译、执行的？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#V8-引擎"><span class="toc-number">12.1.</span> <span class="toc-text">V8 引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#生成-AST"><span class="toc-number">12.2.</span> <span class="toc-text">生成 AST</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#生成字节码"><span class="toc-number">12.3.</span> <span class="toc-text">生成字节码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#生成机器码"><span class="toc-number">12.4.</span> <span class="toc-text">生成机器码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript引擎如何执行JavaScript代码"><span class="toc-number">13.</span> <span class="toc-text">JavaScript引擎如何执行JavaScript代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#执行上下文创建"><span class="toc-number">13.1.</span> <span class="toc-text">执行上下文创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建变量对象"><span class="toc-number">13.2.</span> <span class="toc-text">创建变量对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#建立作用域链"><span class="toc-number">13.3.</span> <span class="toc-text">建立作用域链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#确定-this-的指向"><span class="toc-number">13.4.</span> <span class="toc-text">确定 this 的指向</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#异步编程"><span class="toc-number">14.</span> <span class="toc-text">异步编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise"><span class="toc-number">14.1.</span> <span class="toc-text">Promise</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Generator"><span class="toc-number">14.2.</span> <span class="toc-text">Generator</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#thunk-函数"><span class="toc-number">14.2.1.</span> <span class="toc-text">thunk 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Generator-和-thunk-结合"><span class="toc-number">14.2.2.</span> <span class="toc-text">Generator 和 thunk 结合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Generator-和-Promise-结合"><span class="toc-number">14.2.3.</span> <span class="toc-text">Generator 和 Promise 结合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#co-函数库"><span class="toc-number">14.2.4.</span> <span class="toc-text">co 函数库</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#async-await"><span class="toc-number">14.3.</span> <span class="toc-text">async/await</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EventEmitter"><span class="toc-number">14.4.</span> <span class="toc-text">EventEmitter</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#addListener-和-removeListener、on-和-off-方法对比"><span class="toc-number">14.4.1.</span> <span class="toc-text">addListener 和 removeListener、on 和 off 方法对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#removeListener-和-removeAllListeners"><span class="toc-number">14.4.2.</span> <span class="toc-text">removeListener 和 removeAllListeners</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#on-和-once-方法区别"><span class="toc-number">14.4.3.</span> <span class="toc-text">on 和 once 方法区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现一个-EventEmitter"><span class="toc-number">14.4.4.</span> <span class="toc-text">实现一个 EventEmitter</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现符合-Promise-A-规范的-Promise"><span class="toc-number">14.5.</span> <span class="toc-text">实现符合 Promise/A+ 规范的 Promise</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Promise-A-规范"><span class="toc-number">14.5.1.</span> <span class="toc-text">Promise/A+ 规范</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#一步步实现-Promise"><span class="toc-number">14.5.2.</span> <span class="toc-text">一步步实现 Promise</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#构造函数"><span class="toc-number">14.5.2.1.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#实现-then-方法"><span class="toc-number">14.5.2.2.</span> <span class="toc-text">实现 then 方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#完整版"><span class="toc-number">14.5.2.3.</span> <span class="toc-text">完整版</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#另一版"><span class="toc-number">14.5.2.4.</span> <span class="toc-text">另一版</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数组"><span class="toc-number">15.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#数组构造器"><span class="toc-number">15.1.</span> <span class="toc-text">数组构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#新增的构造方法"><span class="toc-number">15.2.</span> <span class="toc-text">新增的构造方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Array-of"><span class="toc-number">15.2.1.</span> <span class="toc-text">Array.of</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Array-from"><span class="toc-number">15.2.2.</span> <span class="toc-text">Array.from</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Array-的判断"><span class="toc-number">15.3.</span> <span class="toc-text">Array 的判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#改变自身的方法"><span class="toc-number">15.4.</span> <span class="toc-text">改变自身的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不改变自身的方法"><span class="toc-number">15.5.</span> <span class="toc-text">不改变自身的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组遍历的方法"><span class="toc-number">15.6.</span> <span class="toc-text">数组遍历的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类数组"><span class="toc-number">15.7.</span> <span class="toc-text">类数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#如何将类数组转换成数组"><span class="toc-number">15.7.1.</span> <span class="toc-text">如何将类数组转换成数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ES6-的方法转数组"><span class="toc-number">15.7.2.</span> <span class="toc-text">ES6 的方法转数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组扁平化"><span class="toc-number">15.8.</span> <span class="toc-text">数组扁平化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sort-排序方法的实现原理"><span class="toc-number">15.9.</span> <span class="toc-text">sort 排序方法的实现原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTML"><span class="toc-number">16.</span> <span class="toc-text">HTML</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS"><span class="toc-number">17.</span> <span class="toc-text">CSS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#盒模型"><span class="toc-number">17.1.</span> <span class="toc-text">盒模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内联元素与块状元素"><span class="toc-number">17.2.</span> <span class="toc-text">内联元素与块状元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文档流和元素定位"><span class="toc-number">17.3.</span> <span class="toc-text">文档流和元素定位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常见页面布局方式"><span class="toc-number">17.4.</span> <span class="toc-text">常见页面布局方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JS"><span class="toc-number">18.</span> <span class="toc-text">JS</span></a></li></ol>
</div>
<style>
    .left-col .switch-btn {
        display: none;
    }
    .left-col .switch-area {
        display: none;
    }
</style>
<input type="button" id="tocButton" value="隐藏目录" title="点击按钮隐藏或者显示文章目录">

<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>

<script>
    var valueHide = "隐藏目录";
    var valueShow = "显示目录";
    if ($(".left-col").is(":hidden")) {
        $("#tocButton").attr("value", valueShow);
    }
    $("#tocButton").click(function() {
        if ($("#toc").is(":hidden")) {
            $("#tocButton").attr("value", valueHide);
            $("#toc").slideDown(320);
            $(".switch-btn, .switch-area").fadeOut(300);
        }
        else {
            $("#tocButton").attr("value", valueShow);
            $("#toc").slideUp(350);
            $(".switch-btn, .switch-area").fadeIn(500);
        }
    })
    if ($(".toc").length < 1) {
        $("#toc, #tocButton").hide();
        $(".switch-btn, .switch-area").show();
    }
</script>






    



    <div class="scroll" id="post-nav-button">
        
            <a href="/2021/03/25/vue/" title="上一篇: vue进阶">
                <i class="fa fa-angle-left"></i>
            </a>
        
        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>
        
            <a href="/2021/03/25/browser/" title="下一篇: 浏览器工作原理">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>
    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/08/01/test/">前端测试</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/07/18/node/">node学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/01/performance/">performance</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/25/http/">http协议</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/29/algorithm/">算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/25/react/">react进阶</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/25/vue/">vue进阶</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/25/core/">核心进阶</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/25/browser/">浏览器工作原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/08/module_webpack/">模块化/webpack</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/08/yeoman/">脚手架/yeoman/gulp</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/01/10/question_five/">知识点五</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/01/10/question_four/">知识点四</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/01/10/question_one/">知识点一</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/01/10/question_two/">知识点二</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/16/question/">知识点</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/24/question_three/">知识点三</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/02/life/">记录生活</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/30/bug/">遇到的一些坑</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/10/store/">杂货铺</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/03/wfe/">前端笔记（旧）</a></li></ul>
    
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>

    <script>
        $(".post-list").addClass("toc-article");
        // $(".post-list-item a").attr("target","_blank");
        $("#post-nav-button > a:nth-child(2)").click(function() {
            $(".fa-bars, .fa-times").toggle();
            $(".post-list").toggle(300);
            if ($(".toc").length > 0) {
                $("#toc, #tocButton").toggle(200, function() {
                    if ($(".switch-area").is(":visible")) {
                        $("#toc, .switch-btn, .switch-area").toggle();
                        $("#tocButton").attr("value", valueHide);
                        }
                    })
            }
            else {
                $(".switch-btn, .switch-area").fadeToggle(300);
            }
        })
    </script>




    <script>
        
    </script>

</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2021 DiamondsZz
            </div>        
        </div>
    </div>
</footer>

    </div>
    
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>

<script src="/js/main.js"></script>

    <script>
        $(document).ready(function() {
            var backgroundnum = 1;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>






<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" "="">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(
            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


  </div>
</body>
</html>