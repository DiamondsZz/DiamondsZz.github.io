<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  <meta name="baidu-site-verification" content="L6Lm9d5Crl">
  
  
  
  
  <title>学习记录 | DiamondsZz</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="数据类型 基础类型存储在栈内存，被引用或拷贝时，会创建一个完全相等的变量； Undefined Null String Number Boolean Symbol BigInt   引用类型存储在堆内存，存储的是地址，多个引用指向同一个地址，这里会涉及一个“共享”的概念。 ObjectArray Date RegExp Function Math    1234567891011121314151">
<meta name="keywords" content="资源,学习,网站">
<meta property="og:type" content="article">
<meta property="og:title" content="学习记录">
<meta property="og:url" content="https://DiamondsZz.github.io/2021/03/25/note/index.html">
<meta property="og:site_name" content="DiamondsZz">
<meta property="og:description" content="数据类型 基础类型存储在栈内存，被引用或拷贝时，会创建一个完全相等的变量； Undefined Null String Number Boolean Symbol BigInt   引用类型存储在堆内存，存储的是地址，多个引用指向同一个地址，这里会涉及一个“共享”的概念。 ObjectArray Date RegExp Function Math    1234567891011121314151">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2021-03-29T12:57:00.577Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="学习记录">
<meta name="twitter:description" content="数据类型 基础类型存储在栈内存，被引用或拷贝时，会创建一个完全相等的变量； Undefined Null String Number Boolean Symbol BigInt   引用类型存储在堆内存，存储的是地址，多个引用指向同一个地址，这里会涉及一个“共享”的概念。 ObjectArray Date RegExp Function Math    1234567891011121314151">
  
    <link rel="alternative" href="/atom.xml" title="DiamondsZz" type="application/atom+xml">
  
  
  
  <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet">
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: false,
          isPost: true,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>

        <a href="/" class="profilepic">
            
            <img lazy-src="/img/iu.jpeg" class="js-avatar">
            
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">DiamondsZz</a></h1>
        </hgroup>
        
        <p class="header-subtitle">DiamondsZz</p>
        
        
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        
        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                        </ul>
                    </nav>
                </section>
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/css/" style="font-size: 15px;">css</a> <a href="/tags/js/" style="font-size: 20px;">js</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/学习/" style="font-size: 15px;">学习</a> <a href="/tags/生活，心情/" style="font-size: 10px;">生活，心情</a> <a href="/tags/网站/" style="font-size: 15px;">网站</a> <a href="/tags/资源/" style="font-size: 15px;">资源</a>
                    </div>
                </section>
                
                
                
                
                <section class="switch-part switch-part3">
                
                    <div id="js-aboutme">矮穷矬!</div>
                </section>
                
            </div>
        </div>
    </header>
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">DiamondsZz</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/img/iu.jpeg" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">DiamondsZz</a></h1>
            </hgroup>
            
            <p class="header-subtitle">DiamondsZz</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                </div>
            </nav>
        </header>
    </div>
</nav>
      <div class="body-wrap"><article id="post-note" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2021/03/25/note/" class="article-date">
      <time datetime="2021-03-24T16:00:00.000Z" itemprop="datePublished">2021-03-25</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      学习记录
    </h1>
  


      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/学习/">学习</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/学习/">学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网站/">网站</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/资源/">资源</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ol>
<li>基础类型存储在栈内存，被引用或拷贝时，会创建一个完全相等的变量；<blockquote>
<p><code>Undefined</code> <code>Null</code> <code>String</code> <code>Number</code> <code>Boolean</code> <code>Symbol</code> <code>BigInt</code></p>
</blockquote>
</li>
<li>引用类型存储在堆内存，存储的是地址，多个引用指向同一个地址，这里会涉及一个“共享”的概念。<blockquote>
<p><code>Object</code><br><code>Array</code> <code>Date</code> <code>RegExp</code> <code>Function</code> <code>Math</code></p>
</blockquote>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">let a = &#123;</span><br><span class="line">  name: &quot;Julia&quot;,</span><br><span class="line"></span><br><span class="line">  age: 20,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function change(o) &#123;</span><br><span class="line">  o.age = 24;</span><br><span class="line">  //关键   变量o改变内存指向 跟a已经没有关系</span><br><span class="line">  o = &#123;</span><br><span class="line">    name: &quot;Kath&quot;,</span><br><span class="line">    age: 30,</span><br><span class="line">  &#125;;</span><br><span class="line">  return o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let b = change(a);</span><br><span class="line"></span><br><span class="line">console.log(b.age); // 第一个console   30</span><br><span class="line"></span><br><span class="line">console.log(a.age); // 第二个console   24</span><br></pre></td></tr></table></figure>
<h2 id="数据类型检测"><a href="#数据类型检测" class="headerlink" title="数据类型检测"></a>数据类型检测</h2><ol>
<li>typeof<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">typeof 1 // &apos;number&apos;</span><br><span class="line"></span><br><span class="line">typeof &apos;1&apos; // &apos;string&apos;</span><br><span class="line"></span><br><span class="line">typeof undefined // &apos;undefined&apos;</span><br><span class="line"></span><br><span class="line">typeof true // &apos;boolean&apos;</span><br><span class="line"></span><br><span class="line">typeof Symbol() // &apos;symbol&apos;</span><br><span class="line"></span><br><span class="line">typeof null // &apos;object&apos;       !!!!!!!!!!!!!!!!</span><br><span class="line"></span><br><span class="line">typeof [] // &apos;object&apos;</span><br><span class="line"></span><br><span class="line">typeof &#123;&#125; // &apos;object&apos;</span><br><span class="line"></span><br><span class="line">typeof console // &apos;object&apos;</span><br><span class="line"></span><br><span class="line">typeof console.log // &apos;function&apos;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>虽然 typeof null 会输出 object，但这只是 JS 存在的一个悠久 Bug，不代表 null 就是引用数据类型，并且 null 本身也不是对象。因此，null 在 typeof 之后返回的是有问题的结果，不能作为判断 null 的方法。如果你需要在 if 语句中判断是否为 null，直接通过 ‘===null’来判断就好。</li>
<li>引用数据类型 Object，用 typeof 来判断的话，除了 function 会判断为 OK 以外，其余都是 ‘object’，是无法判断出来的。</li>
</ul>
<ol start="2">
<li>instanceof<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">let Car = function() &#123;&#125;</span><br><span class="line"></span><br><span class="line">let benz = new Car()</span><br><span class="line"></span><br><span class="line">benz instanceof Car // true</span><br><span class="line"></span><br><span class="line">let car = new String(&apos;Mercedes Benz&apos;)</span><br><span class="line"></span><br><span class="line">car instanceof String // true</span><br><span class="line"></span><br><span class="line">let str = &apos;Covid-19&apos;</span><br><span class="line"></span><br><span class="line">str instanceof String // false</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------------------------------</span><br><span class="line"></span><br><span class="line">function myInstanceof(left, right) &#123;</span><br><span class="line"></span><br><span class="line">  // 这里先用typeof来判断基础数据类型，如果是，直接返回false</span><br><span class="line"></span><br><span class="line">  if(typeof left !== &apos;object&apos; || left === null) return false;</span><br><span class="line"></span><br><span class="line">  // getPrototypeOf是Object对象自带的API，能够拿到参数的原型对象</span><br><span class="line"></span><br><span class="line">  let proto = Object.getPrototypeOf(left);</span><br><span class="line"></span><br><span class="line">  while(true) &#123;                  //循环往下寻找，直到找到相同的原型对象</span><br><span class="line"></span><br><span class="line">    if(proto === null) return false;</span><br><span class="line"></span><br><span class="line">    if(proto === right.prototype) return true;//找到相同原型对象，返回true</span><br><span class="line"></span><br><span class="line">    proto = Object.getPrototypeof(proto);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 验证一下自己实现的myInstanceof是否OK</span><br><span class="line"></span><br><span class="line">console.log(myInstanceof(new Number(123), Number));    // true</span><br><span class="line"></span><br><span class="line">console.log(myInstanceof(123, Number));                // false</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>instanceof 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型；</li>
<li>而 typeof 也存在弊端，它虽然可以判断基础数据类型（null 除外），但是引用数据类型中，除了 function 类型以外，其他的也无法判断。</li>
</ul>
<ol start="3">
<li>Object.prototype.toString<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString(&#123;&#125;)       // &quot;[object Object]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(&#123;&#125;)  // 同上结果，加上call也ok</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(1)    // &quot;[object Number]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(&apos;1&apos;)  // &quot;[object String]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(true)  // &quot;[object Boolean]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(function()&#123;&#125;)  // &quot;[object Function]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(null)   //&quot;[object Null]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(undefined) //&quot;[object Undefined]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(/123/g)    //&quot;[object RegExp]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(new Date()) //&quot;[object Date]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call([])       //&quot;[object Array]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(document)  //&quot;[object HTMLDocument]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(window)   //&quot;[object Window]&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function getType(obj)&#123;</span><br><span class="line">  let type  = typeof obj;</span><br><span class="line">  if (type !== &quot;object&quot;) &#123;    // 先进行typeof判断，如果是基础数据类型，直接返回</span><br><span class="line">    return type;</span><br><span class="line">  &#125;</span><br><span class="line">  // 对于typeof返回结果是object的，再进行如下的判断，正则返回结果</span><br><span class="line">  return Object.prototype.toString.call(obj).replace(/^\[object (\S+)\]$/, &apos;$1&apos;);  // 注意正则中间有个空格</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><ol>
<li>强制类型转换 Number()、parseInt()、parseFloat()、toString()、String()、Boolean()<blockquote>
<p>Number() 方法的强制转换规则<br>如果是布尔值，true 和 false 分别被转换为 1 和 0；<br>如果是数字，返回自身；<br>如果是 null，返回 0；<br>如果是 undefined，返回 NaN；<br>如果是字符串，遵循以下规则：如果字符串中只包含数字（或者是 0X / 0x 开头的十六进制数字字符串，允许包含正负号），则将其转换为十进制；如果字符串中包含有效的浮点格式，将其转换为浮点数值；如果是空字符串，将其转换为 0；如果不是以上格式的字符串，均返回 NaN；<br>如果是 Symbol，抛出错误；<br>如果是对象，并且部署了 [Symbol.toPrimitive] ，那么调用此方法，否则调用对象的 valueOf() 方法，然后依据前面的规则转换返回的值；如果转换的结果是 NaN ，则调用对象的 toString() 方法，再次依照前面的顺序转换返回对应的值</p>
</blockquote>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Number(true);        // 1</span><br><span class="line"></span><br><span class="line">Number(false);       // 0</span><br><span class="line"></span><br><span class="line">Number(&apos;0111&apos;);      //111</span><br><span class="line"></span><br><span class="line">Number(null);        //0</span><br><span class="line"></span><br><span class="line">Number(&apos;&apos;);          //0</span><br><span class="line"></span><br><span class="line">Number(&apos;1a&apos;);        //NaN</span><br><span class="line"></span><br><span class="line">Number(-0X11);       //-17</span><br><span class="line"></span><br><span class="line">Number(&apos;0X11&apos;)       //17</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Boolean() 方法的强制转换规则<br>除了 undefined、 null、 false、 ‘’、 0（包括 +0，-0）、 NaN 转换出来是 false，其他都是 true。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Boolean(0)          //false</span><br><span class="line"></span><br><span class="line">Boolean(null)       //false</span><br><span class="line"></span><br><span class="line">Boolean(undefined)  //false</span><br><span class="line"></span><br><span class="line">Boolean(NaN)        //false</span><br><span class="line"></span><br><span class="line">Boolean(1)          //true</span><br><span class="line"></span><br><span class="line">Boolean(13)         //true</span><br><span class="line"></span><br><span class="line">Boolean(&apos;12&apos;)       //true</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>‘==’ 的隐式类型转换规则</li>
</ol>
<ul>
<li>如果类型相同，无须进行类型转换；</li>
<li>如果其中一个操作值是 null 或者 undefined，那么另一个操作符必须为 null 或者 undefined，才会返回 true，否则都返回 false；</li>
<li>如果其中一个是 Symbol 类型，那么返回 false；</li>
<li>两个操作值如果为 string 和 number 类型，那么就会将字符串转换为 number；</li>
<li>如果一个操作值是 boolean，那么转换成 number；</li>
<li>如果一个操作值为 object 且另一方为 string、number 或者 symbol，就会把 object 转为原始类型再进行判断（调用 object 的 valueOf/toString 方法进行转换）。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">null == undefined       // true  规则2</span><br><span class="line"></span><br><span class="line">null == 0               // false 规则2</span><br><span class="line"></span><br><span class="line">&apos;&apos; == null              // false 规则2</span><br><span class="line"></span><br><span class="line">&apos;&apos; == 0                 // true  规则4 字符串转隐式转换成Number之后再对比</span><br><span class="line"></span><br><span class="line">&apos;123&apos; == 123            // true  规则4 字符串转隐式转换成Number之后再对比</span><br><span class="line"></span><br><span class="line">0 == false              // true  e规则 布尔型隐式转换成Number之后再对比</span><br><span class="line"></span><br><span class="line">1 == true               // true  e规则 布尔型隐式转换成Number之后再对比</span><br><span class="line"></span><br><span class="line">var a = &#123;</span><br><span class="line"></span><br><span class="line">  value: 0,</span><br><span class="line"></span><br><span class="line">  valueOf: function() &#123;</span><br><span class="line"></span><br><span class="line">    this.value++;</span><br><span class="line"></span><br><span class="line">    return this.value;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 注意这里a又可以等于1、2、3</span><br><span class="line"></span><br><span class="line">console.log(a == 1 &amp;&amp; a == 2 &amp;&amp; a ==3);  //true f规则 Object隐式转换</span><br><span class="line"></span><br><span class="line">// 注：但是执行过3遍之后，再重新执行a==3或之前的数字就是false，因为value已经加上去了，这里需要注意一下</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="3">
<li>‘+’ 的隐式类型转换规则</li>
</ol>
<ul>
<li>如果其中有一个是字符串，另外一个是 undefined、null 或布尔型，则调用 toString() 方法进行字符串拼接；如果是纯对象、数组、正则等，则默认调用对象的转换方法会存在优先级，然后再进行拼接。</li>
<li>如果其中有一个是数字，另外一个是 undefined、null、布尔型或数字，则会将其转换成数字进行加法运算，对象的情况还是参考上一条规则。</li>
<li>如果其中一个是字符串、一个是数字，则按照字符串规则进行拼接</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1 + 2        // 3  常规情况</span><br><span class="line"></span><br><span class="line">&apos;1&apos; + &apos;2&apos;    // &apos;12&apos; 常规情况</span><br><span class="line"></span><br><span class="line">// 下面看一下特殊情况</span><br><span class="line"></span><br><span class="line">&apos;1&apos; + undefined   // &quot;1undefined&quot; 规则1，undefined转换字符串</span><br><span class="line"></span><br><span class="line">&apos;1&apos; + null        // &quot;1null&quot; 规则1，null转换字符串</span><br><span class="line"></span><br><span class="line">&apos;1&apos; + true        // &quot;1true&quot; 规则1，true转换字符串</span><br><span class="line"></span><br><span class="line">&apos;1&apos; + 1n          // &apos;11&apos; 比较特殊字符串和BigInt相加，BigInt转换为字符串</span><br><span class="line"></span><br><span class="line">1 + undefined     // NaN  规则2，undefined转换数字相加NaN</span><br><span class="line"></span><br><span class="line">1 + null          // 1    规则2，null转换为0</span><br><span class="line"></span><br><span class="line">1 + true          // 2    规则2，true转换为1，二者相加为2</span><br><span class="line"></span><br><span class="line">1 + 1n            // 错误  不能把BigInt和Number类型直接混合相加</span><br><span class="line"></span><br><span class="line">&apos;1&apos; + 3           // &apos;13&apos; 规则3，字符串拼接</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>Object 的转换规则</li>
</ol>
<ul>
<li>如果部署了 Symbol.toPrimitive 方法，优先调用再返回；</li>
<li>调用 valueOf()，如果转换为基础类型，则返回；</li>
<li>调用 toString()，如果转换为基础类型，则返回；</li>
<li>如果都没有返回基础类型，会报错。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line"></span><br><span class="line">  value: 1,</span><br><span class="line"></span><br><span class="line">  valueOf() &#123;</span><br><span class="line"></span><br><span class="line">    return 2;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line"></span><br><span class="line">    return &apos;3&apos;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  [Symbol.toPrimitive]() &#123;</span><br><span class="line"></span><br><span class="line">    return 4</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(obj + 1); // 输出5</span><br><span class="line"></span><br><span class="line">// 因为有Symbol.toPrimitive，就优先执行这个；如果Symbol.toPrimitive这段代码删掉，则执行valueOf打印结果为3；如果valueOf也去掉，则调用toString返回&apos;31&apos;(字符串拼接)</span><br><span class="line"></span><br><span class="line">// 再看两个特殊的case：</span><br><span class="line"></span><br><span class="line">10 + &#123;&#125;</span><br><span class="line"></span><br><span class="line">// &quot;10[object Object]&quot;，注意：&#123;&#125;会默认调用valueOf是&#123;&#125;，不是基础类型继续转换，调用toString，返回结果&quot;[object Object]&quot;，于是和10进行&apos;+&apos;运算，按照字符串拼接规则来，参考&apos;+&apos;的规则C</span><br><span class="line"></span><br><span class="line">[1,2,undefined,4,5] + 10</span><br><span class="line"></span><br><span class="line">// &quot;1,2,,4,510&quot;，注意[1,2,undefined,4,5]会默认先调用valueOf结果还是这个数组，不是基础数据类型继续转换，也还是调用toString，返回&quot;1,2,,4,5&quot;，然后再和10进行运算，还是按照字符串拼接规则，参考&apos;+&apos;的第3条规则</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h2><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><ol>
<li>Object.assign<br><em>注意点</em></li>
</ol>
<ul>
<li>它不会拷贝对象的继承属性；</li>
<li>它不会拷贝对象的不可枚举的属性；</li>
<li>可以拷贝 Symbol 类型的属性。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">let obj1 = &#123; a:&#123; b:1 &#125;, sym:Symbol(1)&#125;; </span><br><span class="line"></span><br><span class="line">Object.defineProperty(obj1, &apos;innumerable&apos; ,&#123;</span><br><span class="line"></span><br><span class="line">    value:&apos;不可枚举属性&apos;,</span><br><span class="line"></span><br><span class="line">    enumerable:false</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">let obj2 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Object.assign(obj2,obj1)</span><br><span class="line"></span><br><span class="line">obj1.a.b = 2;</span><br><span class="line"></span><br><span class="line">console.log(&apos;obj1&apos;,obj1);</span><br><span class="line"></span><br><span class="line">console.log(&apos;obj2&apos;,obj2);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="2">
<li>扩展运算符<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/* 对象的拷贝 */</span><br><span class="line"></span><br><span class="line">let obj = &#123;a:1,b:&#123;c:1&#125;&#125;</span><br><span class="line"></span><br><span class="line">let obj2 = &#123;...obj&#125;</span><br><span class="line"></span><br><span class="line">obj.a = 2</span><br><span class="line"></span><br><span class="line">console.log(obj)  //&#123;a:2,b:&#123;c:1&#125;&#125; console.log(obj2); //&#123;a:1,b:&#123;c:1&#125;&#125;</span><br><span class="line"></span><br><span class="line">obj.b.c = 2</span><br><span class="line"></span><br><span class="line">console.log(obj)  //&#123;a:2,b:&#123;c:2&#125;&#125; console.log(obj2); //&#123;a:1,b:&#123;c:2&#125;&#125;</span><br><span class="line"></span><br><span class="line">/* 数组的拷贝 */</span><br><span class="line"></span><br><span class="line">let arr = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">let newArr = [...arr]; //跟arr.slice()是一样的效果</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>扩展运算符 和 object.assign 有同样的缺陷，也就是实现的浅拷贝的功能差不多，但是如果属性都是基本类型的值，使用扩展运算符进行浅拷贝会更加方便。</li>
</ul>
<ol start="3">
<li>concat 拷贝数组<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">let newArr = arr.concat();</span><br><span class="line"></span><br><span class="line">newArr[1] = 100;</span><br><span class="line"></span><br><span class="line">console.log(arr);  // [ 1, 2, 3 ]</span><br><span class="line"></span><br><span class="line">console.log(newArr); // [ 1, 100, 3 ]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>concat 只能用于数组的浅拷贝，使用场景比较局限。</li>
</ul>
<ol start="4">
<li>slice 拷贝数组</li>
</ol>
<ul>
<li>slice 方法也比较有局限性，因为它仅仅针对数组类型。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, 2, &#123;val: 4&#125;];</span><br><span class="line"></span><br><span class="line">let newArr = arr.slice();</span><br><span class="line"></span><br><span class="line">newArr[2].val = 1000;</span><br><span class="line"></span><br><span class="line">console.log(arr);  //[ 1, 2, &#123; val: 1000 &#125; ]</span><br></pre></td></tr></table></figure>
<ul>
<li>浅拷贝只能拷贝一层对象。如果存在对象的嵌套，那么浅拷贝将无能为力。因此深拷贝就是为了解决这个问题而生的，它能解决多层对象嵌套问题，彻底实现拷贝。</li>
</ul>
<ol start="5">
<li>浅拷贝</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">const shallowClone = (target) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  if (typeof target === &apos;object&apos; &amp;&amp; target !== null) &#123;</span><br><span class="line"></span><br><span class="line">    const cloneTarget = Array.isArray(target) ? []: &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    for (let prop in target) &#123;</span><br><span class="line"></span><br><span class="line">      //是否是自有属性</span><br><span class="line">      if (target.hasOwnProperty(prop)) &#123;</span><br><span class="line"></span><br><span class="line">          cloneTarget[prop] = target[prop];</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return cloneTarget;</span><br><span class="line"></span><br><span class="line">  &#125; else &#123;</span><br><span class="line"></span><br><span class="line">    return target;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><ol>
<li>JSON.stringify()<br><em>弊端</em></li>
</ol>
<ul>
<li>拷贝的对象的值中如果有函数、undefined、symbol 这几种类型，经过 JSON.stringify 序列化之后的字符串中这个键值对会消失；</li>
<li>拷贝 Date 引用类型会变成字符串；</li>
<li>无法拷贝不可枚举的属性；</li>
<li>无法拷贝对象的原型链；</li>
<li>拷贝 RegExp 引用类型会变成空对象；</li>
<li>对象中含有 NaN、Infinity 以及 -Infinity，JSON 序列化的结果会变成 null；</li>
<li>无法拷贝对象的循环应用，即对象成环 (obj[key] = obj)。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">function Obj() &#123; </span><br><span class="line"></span><br><span class="line">  this.func = function () &#123; alert(1) &#125;; </span><br><span class="line"></span><br><span class="line">  this.obj = &#123;a:1&#125;;</span><br><span class="line"></span><br><span class="line">  this.arr = [1,2,3];</span><br><span class="line"></span><br><span class="line">  this.und = undefined; </span><br><span class="line"></span><br><span class="line">  this.reg = /123/; </span><br><span class="line"></span><br><span class="line">  this.date = new Date(0); </span><br><span class="line"></span><br><span class="line">  this.NaN = NaN;</span><br><span class="line"></span><br><span class="line">  this.infinity = Infinity;</span><br><span class="line"></span><br><span class="line">  this.sym = Symbol(1);</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">let obj1 = new Obj();</span><br><span class="line"></span><br><span class="line">Object.defineProperty(obj1,&apos;innumerable&apos;,&#123; </span><br><span class="line"></span><br><span class="line">  enumerable:false,</span><br><span class="line"></span><br><span class="line">  value:&apos;innumerable&apos;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&apos;obj1&apos;,obj1);</span><br><span class="line"></span><br><span class="line">let str = JSON.stringify(obj1);</span><br><span class="line"></span><br><span class="line">let obj2 = JSON.parse(str);</span><br><span class="line"></span><br><span class="line">console.log(&apos;obj2&apos;,obj2);</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 JSON.stringify 方法实现深拷贝对象，虽然到目前为止还有很多无法实现的功能，但是这种方法足以满足日常的开发需求，并且是最简单和快捷的。</li>
</ul>
<ol start="2">
<li>手写递归实现<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">let obj1 = &#123;</span><br><span class="line"></span><br><span class="line">  a:&#123;</span><br><span class="line"></span><br><span class="line">    b:1</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function deepClone(obj) &#123; </span><br><span class="line"></span><br><span class="line">  let cloneObj = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  for(let key in obj) &#123;                 //遍历</span><br><span class="line"></span><br><span class="line">    if(typeof obj[key] ===&apos;object&apos;) &#123; </span><br><span class="line"></span><br><span class="line">      cloneObj[key] = deepClone(obj[key])  //是对象就再次调用该函数递归</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">      cloneObj[key] = obj[key]  //基本类型的话直接复制值</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return cloneObj</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let obj2 = deepClone(obj1);</span><br><span class="line"></span><br><span class="line">obj1.a.b = 2;</span><br><span class="line"></span><br><span class="line">console.log(obj2);   //  &#123;a:&#123;b:1&#125;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><em>弊端</em></p>
<ul>
<li>这个深拷贝函数并不能复制不可枚举的属性以及 Symbol 类型；</li>
<li>这种方法只是针对普通的引用类型的值做递归复制，而对于 Array、Date、RegExp、Error、Function 这样的引用类型并不能正确地拷贝；</li>
<li>对象的属性里面成环，即循环引用没有解决。</li>
</ul>
<ol start="3">
<li>改进后递归实现<br><em>注意点</em></li>
</ol>
<ul>
<li>针对能够遍历对象的不可枚举属性以及 Symbol 类型，我们可以使用 Reflect.ownKeys 方法；</li>
<li>当参数为 Date、RegExp 类型，则直接生成一个新的实例返回；</li>
<li>利用 Object 的 getOwnPropertyDescriptors 方法可以获得对象的所有属性，以及对应的特性，顺便结合 Object 的 create 方法创建一个新对象，并继承传入原对象的原型链；</li>
<li>利用 WeakMap 类型作为 Hash 表，因为 WeakMap 是弱引用类型，可以有效防止内存泄漏（你可以关注一下 Map 和 weakMap 的关键区别，这里要用 weakMap），作为检测循环引用很有帮助，如果存在循环，则引用直接返回 WeakMap 存储的值。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">const isComplexDataType = obj =&gt; (typeof obj === &apos;object&apos; || typeof obj === &apos;function&apos;) &amp;&amp; (obj !== null)</span><br><span class="line"></span><br><span class="line">const deepClone = function (obj, hash = new WeakMap()) &#123;</span><br><span class="line"></span><br><span class="line">  if (obj.constructor === Date) </span><br><span class="line"></span><br><span class="line">  return new Date(obj)       // 日期对象直接返回一个新的日期对象</span><br><span class="line"></span><br><span class="line">  if (obj.constructor === RegExp)</span><br><span class="line"></span><br><span class="line">  return new RegExp(obj)     //正则对象直接返回一个新的正则对象</span><br><span class="line"></span><br><span class="line">  //如果循环引用了就用 weakMap 来解决</span><br><span class="line"></span><br><span class="line">  if (hash.has(obj)) return hash.get(obj)</span><br><span class="line"></span><br><span class="line">  let allDesc = Object.getOwnPropertyDescriptors(obj)</span><br><span class="line"></span><br><span class="line">  //遍历传入参数所有键的特性</span><br><span class="line"></span><br><span class="line">  let cloneObj = Object.create(Object.getPrototypeOf(obj), allDesc)</span><br><span class="line"></span><br><span class="line">  //继承原型链</span><br><span class="line"></span><br><span class="line">  hash.set(obj, cloneObj)</span><br><span class="line"></span><br><span class="line">  for (let key of Reflect.ownKeys(obj)) &#123; </span><br><span class="line"></span><br><span class="line">    cloneObj[key] = (isComplexDataType(obj[key]) &amp;&amp; typeof obj[key] !== &apos;function&apos;) ? deepClone(obj[key], hash) : obj[key]</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return cloneObj</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 下面是验证代码</span><br><span class="line"></span><br><span class="line">let obj = &#123;</span><br><span class="line"></span><br><span class="line">  num: 0,</span><br><span class="line"></span><br><span class="line">  str: &apos;&apos;,</span><br><span class="line"></span><br><span class="line">  boolean: true,</span><br><span class="line"></span><br><span class="line">  unf: undefined,</span><br><span class="line"></span><br><span class="line">  nul: null,</span><br><span class="line"></span><br><span class="line">  obj: &#123; name: &apos;我是一个对象&apos;, id: 1 &#125;,</span><br><span class="line"></span><br><span class="line">  arr: [0, 1, 2],</span><br><span class="line"></span><br><span class="line">  func: function () &#123; console.log(&apos;我是一个函数&apos;) &#125;,</span><br><span class="line"></span><br><span class="line">  date: new Date(0),</span><br><span class="line"></span><br><span class="line">  reg: new RegExp(&apos;/我是一个正则/ig&apos;),</span><br><span class="line"></span><br><span class="line">  [Symbol(&apos;1&apos;)]: 1,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.defineProperty(obj, &apos;innumerable&apos;, &#123;</span><br><span class="line"></span><br><span class="line">  enumerable: false, value: &apos;不可枚举属性&apos; &#125;</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">obj = Object.create(obj, Object.getOwnPropertyDescriptors(obj))</span><br><span class="line"></span><br><span class="line">obj.loop = obj    // 设置loop成循环引用的属性</span><br><span class="line"></span><br><span class="line">let cloneObj = deepClone(obj)</span><br><span class="line"></span><br><span class="line">cloneObj.arr.push(4)</span><br><span class="line"></span><br><span class="line">console.log(&apos;obj&apos;, obj)</span><br><span class="line"></span><br><span class="line">console.log(&apos;cloneObj&apos;, cloneObj)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ol>
<li>原型链继承<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function Parent1() &#123;</span><br><span class="line"></span><br><span class="line">  this.name = &apos;parent1&apos;;</span><br><span class="line"></span><br><span class="line">  this.play = [1, 2, 3]</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child1() &#123;</span><br><span class="line"></span><br><span class="line">  this.type = &apos;child2&apos;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child1.prototype = new Parent1();</span><br><span class="line">let c1=new Child1()</span><br><span class="line">let c2=new Child1()</span><br><span class="line">console.log(c1.__proto__===c2.__proto__); //true</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>两个实例使用的是同一个原型对象。它们的内存空间是共享的，当一个发生变化的时候，另外一个也随之进行了变化，这就是使用原型链继承方式的一个缺点。</p>
<ol start="2">
<li>构造函数继承（借助 call）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">function Parent1()&#123;</span><br><span class="line"></span><br><span class="line">  this.name = &apos;parent1&apos;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Parent1.prototype.getName = function () &#123;</span><br><span class="line"></span><br><span class="line">  return this.name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function Child1()&#123;</span><br><span class="line"></span><br><span class="line">  Parent1.call(this);</span><br><span class="line"></span><br><span class="line">  this.type = &apos;child1&apos;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let child = new Child1();</span><br><span class="line"></span><br><span class="line">console.log(child);  // 没问题</span><br><span class="line"></span><br><span class="line">console.log(child.getName());  // 会报错</span><br></pre></td></tr></table></figure>
<p>构造函数实现继承的优缺点，它使父类的引用属性不会被共享，优化了第一种继承方式的弊端；<br>但是随之而来的缺点也比较明显——只能继承父类的实例属性和方法，不能继承原型属性或者方法。</p>
<ol start="3">
<li><p>组合继承（前两种组合）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">function Parent3 () &#123;</span><br><span class="line"></span><br><span class="line">  this.name = &apos;parent3&apos;;</span><br><span class="line"></span><br><span class="line">  this.play = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Parent3.prototype.getName = function () &#123;</span><br><span class="line"></span><br><span class="line">  return this.name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child3() &#123;</span><br><span class="line"></span><br><span class="line">  // 第二次调用 Parent3()</span><br><span class="line"></span><br><span class="line">  Parent3.call(this);</span><br><span class="line"></span><br><span class="line">  this.type = &apos;child3&apos;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 第一次调用 Parent3()</span><br><span class="line"></span><br><span class="line">Child3.prototype = new Parent3();</span><br><span class="line"></span><br><span class="line">// 手动挂上构造器，指向自己的构造函数</span><br><span class="line"></span><br><span class="line">Child3.prototype.constructor = Child3;</span><br><span class="line"></span><br><span class="line">var s3 = new Child3();</span><br><span class="line"></span><br><span class="line">var s4 = new Child3();</span><br><span class="line"></span><br><span class="line">s3.play.push(4);</span><br><span class="line"></span><br><span class="line">console.log(s3.play, s4.play);  // 不互相影响</span><br><span class="line"></span><br><span class="line">console.log(s3.getName()); // 正常输出&apos;parent3&apos;</span><br><span class="line"></span><br><span class="line">console.log(s4.getName()); // 正常输出&apos;parent3&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>原型式继承</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">let parent4 = &#123;</span><br><span class="line"></span><br><span class="line">  name: &quot;parent4&quot;,</span><br><span class="line"></span><br><span class="line">  friends: [&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;],</span><br><span class="line"></span><br><span class="line">  getName: function() &#123;</span><br><span class="line"></span><br><span class="line">    return this.name;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let person4 = Object.create(parent4);</span><br><span class="line"></span><br><span class="line">person4.name = &quot;tom&quot;;</span><br><span class="line"></span><br><span class="line">person4.friends.push(&quot;jerry&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let person5 = Object.create(parent4);</span><br><span class="line"></span><br><span class="line">person5.friends.push(&quot;lucy&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">console.log(person4.name);</span><br><span class="line"></span><br><span class="line">console.log(person4.name === person4.getName());</span><br><span class="line"></span><br><span class="line">console.log(person5.name);</span><br><span class="line"></span><br><span class="line">console.log(person4.friends);</span><br><span class="line"></span><br><span class="line">console.log(person5.friends);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>最后两个输出结果是一样的，关于引用数据类型“共享”的问题，其实 Object.create 方法是可以为一些对象实现浅拷贝的。<br>关于这种继承方式的缺点也很明显，多个实例的引用类型属性指向相同的内存，存在篡改的可能。</p>
<ol start="5">
<li>寄生式继承</li>
</ol>
<ul>
<li><p>使用原型式继承可以获得一份目标对象的浅拷贝，然后利用这个浅拷贝的能力再进行增强，添加一些方法，这样的继承方式就叫作寄生式继承。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"> let parent5 = &#123;</span><br><span class="line"></span><br><span class="line">  name: &quot;parent5&quot;,</span><br><span class="line"></span><br><span class="line">  friends: [&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;],</span><br><span class="line"></span><br><span class="line">  getName: function() &#123;</span><br><span class="line"></span><br><span class="line">    return this.name;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function clone(original) &#123;</span><br><span class="line"></span><br><span class="line">  let clone = Object.create(original);</span><br><span class="line"></span><br><span class="line">  clone.getFriends = function() &#123;</span><br><span class="line"></span><br><span class="line">    return this.friends;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return clone;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let person5 = clone(parent5);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">console.log(person5.getName());</span><br><span class="line"></span><br><span class="line">console.log(person5.getFriends());</span><br></pre></td></tr></table></figure>
</li>
<li><p>虽然其优缺点和原型式继承一样，但是对于普通对象的继承方式来说，寄生式继承相比于原型式继承，还是在父类基础上添加了更多的方法。</p>
</li>
</ul>
<ol start="6">
<li>寄生组合式继承</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">function clone (parent, child) &#123;</span><br><span class="line"></span><br><span class="line">  // 这里改用 Object.create 就可以减少组合继承中多进行一次构造的过程</span><br><span class="line"></span><br><span class="line">  child.prototype = Object.create(parent.prototype);</span><br><span class="line"></span><br><span class="line">  child.prototype.constructor = child;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function Parent6() &#123;</span><br><span class="line"></span><br><span class="line">  this.name = &apos;parent6&apos;;</span><br><span class="line"></span><br><span class="line">  this.play = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> Parent6.prototype.getName = function () &#123;</span><br><span class="line"></span><br><span class="line">  return this.name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child6() &#123;</span><br><span class="line"></span><br><span class="line">  Parent6.call(this);</span><br><span class="line"></span><br><span class="line">  this.friends = &apos;child5&apos;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">clone(Parent6, Child6);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Child6.prototype.getFriends = function () &#123;</span><br><span class="line"></span><br><span class="line">  return this.friends;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let person6 = new Child6();</span><br><span class="line"></span><br><span class="line">console.log(person6);</span><br><span class="line"></span><br><span class="line">console.log(person6.getName());</span><br><span class="line"></span><br><span class="line">console.log(person6.getFriends());</span><br></pre></td></tr></table></figure>
<ul>
<li>这种寄生组合式继承方式，基本可以解决前几种继承方式的缺点，较好地实现了继承想要的结果，同时也减少了构造次数，减少了性能的开销</li>
</ul>
<ol start="7">
<li>ES6 的 extends 关键字实现逻辑<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line"></span><br><span class="line">  constructor(name) &#123;</span><br><span class="line"></span><br><span class="line">    this.name = name</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 原型方法</span><br><span class="line"></span><br><span class="line">  // 即 Person.prototype.getName = function() &#123; &#125;</span><br><span class="line"></span><br><span class="line">  // 下面可以简写为 getName() &#123;...&#125;</span><br><span class="line"></span><br><span class="line">  getName = function () &#123;</span><br><span class="line"></span><br><span class="line">    console.log(&apos;Person:&apos;, this.name)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Gamer extends Person &#123;</span><br><span class="line"></span><br><span class="line">  constructor(name, age) &#123;</span><br><span class="line"></span><br><span class="line">    // 子类中存在构造函数，则需要在使用“this”之前首先调用 super()。</span><br><span class="line"></span><br><span class="line">    super(name)</span><br><span class="line"></span><br><span class="line">    this.age = age</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const asuna = new Gamer(&apos;Asuna&apos;, 20)</span><br><span class="line"></span><br><span class="line">asuna.getName() // 成功访问到父类的方法</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>利用 babel 这个编译工具，将 ES6 的代码编译成 ES5</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">function _possibleConstructorReturn (self, call) &#123; </span><br><span class="line"></span><br><span class="line">		// ...</span><br><span class="line"></span><br><span class="line">		return call &amp;&amp; (typeof call === &apos;object&apos; || typeof call === &apos;function&apos;) ? call : self; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _inherits (subClass, superClass) &#123; </span><br><span class="line"></span><br><span class="line">    // 这里可以看到</span><br><span class="line"></span><br><span class="line">	subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, &#123; </span><br><span class="line"></span><br><span class="line">		constructor: &#123; </span><br><span class="line"></span><br><span class="line">			value: subClass, </span><br><span class="line"></span><br><span class="line">			enumerable: false, </span><br><span class="line"></span><br><span class="line">			writable: true, </span><br><span class="line"></span><br><span class="line">			configurable: true </span><br><span class="line"></span><br><span class="line">		&#125; </span><br><span class="line"></span><br><span class="line">	&#125;); </span><br><span class="line"></span><br><span class="line">	if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var Parent = function Parent () &#123;</span><br><span class="line"></span><br><span class="line">	// 验证是否是 Parent 构造出来的 this</span><br><span class="line"></span><br><span class="line">	_classCallCheck(this, Parent);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var Child = (function (_Parent) &#123;</span><br><span class="line"></span><br><span class="line">	_inherits(Child, _Parent);</span><br><span class="line"></span><br><span class="line">	function Child () &#123;</span><br><span class="line"></span><br><span class="line">		_classCallCheck(this, Child);</span><br><span class="line"></span><br><span class="line">		return _possibleConstructorReturn(this, (Child.__proto__ || Object.getPrototypeOf(Child)).apply(this, arguments));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	return Child;</span><br><span class="line"></span><br><span class="line">&#125;(Parent));</span><br></pre></td></tr></table></figure>
<p>从上面编译完成的源码中可以看到，它采用的也是寄生组合继承方式，因此也证明了这种方式是较优的解决继承的方式。</p>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><ul>
<li>不管是什么样的计算机程序语言，运行在对应的代码引擎上，对应的使用内存过程大致逻辑是一样的，可以分为这三个步骤：</li>
</ul>
<ol>
<li>分配你所需要的系统内存空间；</li>
<li>使用分配到的内存进行读或者写等操作；</li>
<li>不需要使用内存时，将其空间释放或者归还。</li>
</ol>
<ul>
<li><p>在 JavaScript 中，当我们创建变量（对象，字符串等）的时候，系统会自动给对象分配对应的内存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var a = 123; // 给数值变量分配栈内存</span><br><span class="line"></span><br><span class="line">var etf = &quot;ARK&quot;; // 给字符串分配栈内存</span><br><span class="line"></span><br><span class="line">// 给对象及其包含的值分配堆内存</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line"></span><br><span class="line">  name: &apos;tom&apos;,</span><br><span class="line"></span><br><span class="line">  age: 13</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">// 给数组及其包含的值分配内存（就像对象一样）</span><br><span class="line"></span><br><span class="line">var a = [1, null, &quot;PSAC&quot;]; </span><br><span class="line"></span><br><span class="line">// 给函数（可调用的对象）分配内存</span><br><span class="line"></span><br><span class="line">function sum(a, b)&#123;</span><br><span class="line"></span><br><span class="line">  return a + b;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>栈内存中的基本类型，可以通过操作系统直接处理；<br>而堆内存中的引用类型，正是由于可以经常变化，大小不固定，因此需要 JavaScript 的引擎通过垃圾回收机制来处理。</p>
<h3 id="chrome内存回收机制"><a href="#chrome内存回收机制" class="headerlink" title="chrome内存回收机制"></a>chrome内存回收机制</h3></li>
<li>在 Chrome 浏览器中，JavaScript 的 V8 引擎被限制了内存的使用，根据不同的操作系统（操作系统有 64 位和 32 位的）内存大小会不同，大的可以到 1.4G 的空间，小的只能到 0.7G 的空间。</li>
<li>为什么要去限制内存使用呢？<br>大致是两个原因：V8 最开始是为浏览器而设计的引擎，早些年由于 Web 应用都比较简单，其实并未考虑占据过多的内存空间；<br>另外又由于被 V8 的垃圾回收机制所限制，比如清理大量的内存时会耗费很多时间，这样会引起 JavaScript 执行的线程被挂起，会影响当前执行的页面应用的性能。<h4 id="新生代内存回收"><a href="#新生代内存回收" class="headerlink" title="新生代内存回收"></a>新生代内存回收</h4></li>
<li>新生代的内存回收的空间，在 64 位操作系统下分配为 32MB，正是因为新生代中的变量存活时间短，不太容易产生太大的内存压力，因此不够大也是可以理解的。</li>
<li>系统会将分配给新生代的内存空间分为两部分：正在使用的内存空间[1]，闲置的内存空间[2]<br>当浏览器开始进行内存的垃圾回收时，JavaScript 的 V8 引擎会将[1]的对象检查一遍。如果引擎检测是存活对象，那么会复制到[2]去；如果不是存活的对象，则直接进行系统回收。当所有[1]的对象没有了的时候，等再有新生代的对象产生时，[1][2]对调，这样来循环处理。</li>
<li><code>算法 Scavenge</code>，它主要就是解决内存碎片<h4 id="老生代内存回收"><a href="#老生代内存回收" class="headerlink" title="老生代内存回收"></a>老生代内存回收</h4></li>
<li>新生代中的变量如果经过回收之后依然一直存在，那么就会被放入到老生代内存中。</li>
<li>只要是已经经历过一次 Scavenge 算法回收的，就可以晋升为老生代内存的对象</li>
<li>对于内存空间比较大的，就不适合用 Scavenge 算法了。</li>
<li>老生代内存中的垃圾回收,采用了 <code>Mark-Sweep（标记清除）</code> 和 <code>Mark-Compact（标记整理）</code>的策略</li>
</ul>
<ol>
<li>标记清除（Mark-Sweep）<br>分为两个阶段：标记阶段和清除阶段。<br>首先它会遍历堆上的所有的对象，分别对它们打上标记；然后在代码执行过程结束之后，对使用过的变量取消标记。<br>那么没取消标记的就是没有使用过的变量，因此在清除阶段，就会把还有标记的进行整体清除，从而释放内存空间。</li>
</ol>
<p>通过标记清除之后，还是会出现内存碎片的问题。标记整理策略（Mark-Compact）用来解决内存碎片的问题。</p>
<ol start="2">
<li>标记整理（Mark-Compact）<br>标记整理添加了活动对象整理阶段，处理过程中会将所有的活动对象往一端靠拢，整体移动完成后，直接清理掉边界外的内存。<br>Scavenge 算法比较适合内存较小的情况处理；而对于老生代内存较大、变量较多的时候，还是需要采用“标记-清除”结合“标记-整理”这样的方式处理内存问题，并尽量避免内存碎片的产生。<h3 id="内存泄漏与优化"><a href="#内存泄漏与优化" class="headerlink" title="内存泄漏与优化"></a>内存泄漏与优化</h3></li>
</ol>
<ul>
<li>内存泄漏的场景：</li>
</ul>
<ol>
<li>过多的缓存未释放；</li>
<li>闭包太多未释放；</li>
<li>定时器或者回调太多未释放；</li>
<li>太多无效的 DOM 未释放；</li>
<li>全局变量太多未被发现。</li>
</ol>
<h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><h3 id="时间、空间复杂度"><a href="#时间、空间复杂度" class="headerlink" title="时间、空间复杂度"></a>时间、空间复杂度</h3><p>通常，复杂度的计算方法遵循以下几个原则：</p>
<ol>
<li>首先，复杂度与具体的常系数无关，例如 O(n) 和 O(2n) 表示的是同样的复杂度。<br>我们详细分析下，O(2n) 等于 O(n+n)，也等于 O(n) + O(n)。<br>也就是说，一段 O(n) 复杂度的代码只是先后执行两遍 O(n)，其复杂度是一致的。</li>
<li>其次，多项式级的复杂度相加的时候，选择高者作为结果，例如 O(n²)+O(n) 和 O(n²) 表示的是同样的复杂度。<br>具体分析一下就是，O(n²)+O(n) = O(n²+n)。随着 n 越来越大，二阶多项式的变化率是要比一阶多项式更大的。<br>因此，只需要通过更大变化率的二阶多项式来表征复杂度就可以了。</li>
<li>值得一提的是，O(1) 也是表示一个特殊复杂度，含义为某个任务通过有限可数的资源即可完成。<br>此处有限可数的具体意义是，与输入数据量 n 无关。</li>
<li>一个顺序结构的代码，时间复杂度是 O(1)。</li>
<li>二分查找，或者更通用地说是采用分而治之的二分策略，时间复杂度都是 O(logn)。这个我们会在后续课程讲到。</li>
<li>一个简单的 for 循环，时间复杂度是 O(n)。</li>
<li>两个顺序执行的 for 循环，时间复杂度是 O(n)+O(n)=O(2n)，其实也是 O(n)。</li>
<li>两个嵌套的 for 循环，时间复杂度是 O(n²)。</li>
<li>程序优化的最核心的思路，简单梳理如下：<br>第一步，暴力解法。在没有任何时间、空间约束下，完成代码任务的开发。<br>第二步，无效操作处理。将代码中的无效计算、无效存储剔除，降低时间或空间复杂度。<br>第三步，时空转换。设计合理数据结构，完成时间复杂度向空间复杂度的转移。<h3 id="增删查"><a href="#增删查" class="headerlink" title="增删查"></a>增删查</h3></li>
<li>链表和数组一样，都是 O(n) 空间复杂度的复杂数据结构。但其区别之一就是，数组有 index 的索引，而链表没有。<br>① 有了 index 的索引，所以我们就可以直接进行查找操作来，这里的时间复杂度为 O(1)。<br>② 链表因为没有索引，只能“一个接一个”地按照位置条件查找，在这种情况下时间复杂度就是 O (n)。</li>
<li>数据处理的基本操作只有 3 个，分别是增、删、查。其中，增和删又可以细分为在数据结构中间的增和删，以及在数据结构最后的增和删。<br>区别就在于原数据的位置是否发生改变。查找又可以细分为按照位置条件的查找和按照数据数值特征的查找。<br>几乎所有的数据处理，都是这些基本操作的组合和叠加。<h3 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h3></li>
</ol>
<ul>
<li>最常用的是链式表达，通常也叫作线性链表或者链表。</li>
</ul>
<ol>
<li>虽然链表在新增和删除数据上有优势，但仔细思考就会发现，这个优势并不实用。这主要是因为，在新增数据时，通常会伴随一个查找的动作。例如，在第五个结点后，新增一个新的数据结点，那么执行的操作就包含两个步骤：<br>①第一步，查找第五个结点；<br>②第二步，再新增一个数据结点。整体的复杂度就是 O(n) + O(1)，也就是O(n)。</li>
<li>线性表真正的价值在于，它对数据的存储方式是按照顺序的存储。<br>如果数据的元素个数不确定，且需要经常进行数据的新增和删除时，那么链表会比较合适。<br>如果数据元素大小确定，删除插入的操作并不多，那么数组可能更适合些。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">例 1，链表的翻转。给定一个链表，输出翻转后的链表。例如，输入1 -&gt;2 -&gt; 3 -&gt; 4 -&gt;5，输出 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1。</span><br><span class="line">我们来仔细看一下这个问题的难点在哪里，这里有两种情况：</span><br><span class="line">如果是数组的翻转，这会非常容易。原因在于，数组在连续的空间进行存储，可以直接求解出数组的长度。而且，数组可以通过索引值去查找元素，然后对相应的数据进行交换操作而完成翻转。</span><br><span class="line">但对于某个单向链表，它的指针结构造成了它的数据通路有去无回，一旦修改了某个指针，后面的数据就会造成失联的状态。为了解决这个问题，我们需要构造三个指针 prev、curr 和 next，对当前结点、以及它之前和之后的结点进行缓存，再完成翻转动作。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">例 2，给定一个奇数个元素的链表，查找出这个链表中间位置的结点的数值。</span><br><span class="line">这个问题也是利用了链表的长度无法直接获取的不足做文章，解决办法如下：</span><br><span class="line">一个暴力的办法是，先通过一次遍历去计算链表的长度，这样我们就知道了链表中间位置是第几个。接着再通过一次遍历去查找这个位置的数值。</span><br><span class="line">除此之外，还有一个巧妙的办法，就是利用快慢指针进行处理。其中快指针每次循环向后跳转两次，而慢指针每次向后跳转一次。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">例 3，判断链表是否有环。</span><br><span class="line">假设链表有环，这个环里面就像是一个跑步赛道的操场一样。经过多次循环之后，快指针和慢指针都会进入到这个赛道中，就好像两个跑步选手在比赛。</span><br><span class="line">快指针每次走两格，而慢指针每次走一格，相对而言，快指针每次循环会多走一步。</span><br><span class="line">这就意味着：如果链表存在环，快指针和慢指针一定会在环内相遇，即 fast == slow 的情况一定会发生。</span><br><span class="line">反之，则最终会完成循环，二者从未相遇。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><h4 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h4><ol>
<li>栈的顺序存储可以借助数组来实现。一般来说，会把数组的首元素存在栈底，最后一个元素放在栈顶。<br>然后定义一个 top 指针来指示栈顶元素在数组中的位置。假设栈中只有一个数据元素，则 top = 0。<br>一般以 top 是否为 -1 来判定是否为空栈。<br>当定义了栈的最大容量为 StackSize 时，则栈顶 top 必须小于 StackSize。</li>
<li>对于查找操作，栈没有额外的改变，跟线性表一样，它也需要遍历整个栈来完成基于某些条件的数值查找。</li>
<li>删除数据元素，即出栈操作，只需要 top - 1 就可以了。<h4 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h4></li>
<li>关于链式栈，就是用链表的方式对栈的表示。</li>
<li>在链式栈中进行删除操作时，只能在栈顶进行操作。因此，将栈顶的 top 指针指向栈顶元素的 next 指针即可完成删除。</li>
<li>对于链式栈来说，新增删除数据元素没有任何循环操作，其时间复杂度均为 O(1)。</li>
</ol>
<ul>
<li>不管是顺序栈还是链栈，数据的新增、删除、查找与线性表的操作原理极为相似，时间复杂度完全一样，都依赖当前位置的指针来进行数据对象的操作。区别仅仅在于新增和删除的对象，只能是栈顶的数据结点。</li>
</ul>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2021/03/25/note/">学习记录</a></p>
        <p><span>文章作者:</span><a href="/" title="访问 DiamondsZz 的个人博客">DiamondsZz</a></p>
        <p><span>发布时间:</span>2021年03月25日</p>
        <p><span>最后更新:</span>2021年03月29日 - 20时57分</p>    
    </div>



<nav id="article-nav">
  
    <a href="/2021/03/29/algorithm/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          算法
        
      </div>
    </a>
  
  
    <a href="/2021/03/08/record/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">记录</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>


  
</article>

    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#数据类型"><span class="toc-number">1.</span> <span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据类型检测"><span class="toc-number">2.</span> <span class="toc-text">数据类型检测</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据类型转换"><span class="toc-number">3.</span> <span class="toc-text">数据类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#拷贝"><span class="toc-number">4.</span> <span class="toc-text">拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#浅拷贝"><span class="toc-number">4.1.</span> <span class="toc-text">浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#深拷贝"><span class="toc-number">4.2.</span> <span class="toc-text">深拷贝</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#继承"><span class="toc-number">5.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#垃圾回收"><span class="toc-number">6.</span> <span class="toc-text">垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#内存管理"><span class="toc-number">6.1.</span> <span class="toc-text">内存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#chrome内存回收机制"><span class="toc-number">6.2.</span> <span class="toc-text">chrome内存回收机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#新生代内存回收"><span class="toc-number">6.2.1.</span> <span class="toc-text">新生代内存回收</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#老生代内存回收"><span class="toc-number">6.2.2.</span> <span class="toc-text">老生代内存回收</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存泄漏与优化"><span class="toc-number">6.3.</span> <span class="toc-text">内存泄漏与优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据结构与算法"><span class="toc-number">7.</span> <span class="toc-text">数据结构与算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#时间、空间复杂度"><span class="toc-number">7.1.</span> <span class="toc-text">时间、空间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#增删查"><span class="toc-number">7.2.</span> <span class="toc-text">增删查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线性表"><span class="toc-number">7.3.</span> <span class="toc-text">线性表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#栈"><span class="toc-number">7.4.</span> <span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#顺序栈"><span class="toc-number">7.4.1.</span> <span class="toc-text">顺序栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#链栈"><span class="toc-number">7.4.2.</span> <span class="toc-text">链栈</span></a></li></ol></li></ol></li></ol>
</div>
<style>
    .left-col .switch-btn {
        display: none;
    }
    .left-col .switch-area {
        display: none;
    }
</style>
<input type="button" id="tocButton" value="隐藏目录" title="点击按钮隐藏或者显示文章目录">

<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>

<script>
    var valueHide = "隐藏目录";
    var valueShow = "显示目录";
    if ($(".left-col").is(":hidden")) {
        $("#tocButton").attr("value", valueShow);
    }
    $("#tocButton").click(function() {
        if ($("#toc").is(":hidden")) {
            $("#tocButton").attr("value", valueHide);
            $("#toc").slideDown(320);
            $(".switch-btn, .switch-area").fadeOut(300);
        }
        else {
            $("#tocButton").attr("value", valueShow);
            $("#toc").slideUp(350);
            $(".switch-btn, .switch-area").fadeIn(500);
        }
    })
    if ($(".toc").length < 1) {
        $("#toc, #tocButton").hide();
        $(".switch-btn, .switch-area").show();
    }
</script>






    



    <div class="scroll" id="post-nav-button">
        
            <a href="/2021/03/29/algorithm/" title="上一篇: 算法">
                <i class="fa fa-angle-left"></i>
            </a>
        
        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>
        
            <a href="/2021/03/08/record/" title="下一篇: 记录">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>
    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/03/29/algorithm/">算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/25/note/">学习记录</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/08/record/">记录</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/01/10/project/">前端工程</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/01/10/study/">前端学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/01/10/ts/">typescript</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/01/10/webpack/">前端构建</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/16/log/">前端记录</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/24/vue/">vue</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/02/life/">记录生活</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/30/bug/">遇到的一些坑</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/17/es6/">es6</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/14/js/">js</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/10/store/">杂货铺</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/03/wfe/">前端笔记</a></li></ul>
    
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>

    <script>
        $(".post-list").addClass("toc-article");
        // $(".post-list-item a").attr("target","_blank");
        $("#post-nav-button > a:nth-child(2)").click(function() {
            $(".fa-bars, .fa-times").toggle();
            $(".post-list").toggle(300);
            if ($(".toc").length > 0) {
                $("#toc, #tocButton").toggle(200, function() {
                    if ($(".switch-area").is(":visible")) {
                        $("#toc, .switch-btn, .switch-area").toggle();
                        $("#tocButton").attr("value", valueHide);
                        }
                    })
            }
            else {
                $(".switch-btn, .switch-area").fadeToggle(300);
            }
        })
    </script>




    <script>
        
    </script>

</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2021 DiamondsZz
            </div>        
        </div>
    </div>
</footer>

    </div>
    
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>

<script src="/js/main.js"></script>

    <script>
        $(document).ready(function() {
            var backgroundnum = 1;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>






<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" "="">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(
            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


  </div>
</body>
</html>