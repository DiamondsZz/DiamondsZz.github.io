<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  <meta name="baidu-site-verification" content="L6Lm9d5Crl">
  
  
  
  
  <title>学习记录 | DiamondsZz</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="数据类型 基础类型存储在栈内存，被引用或拷贝时，会创建一个完全相等的变量； Undefined Null String Number Boolean Symbol BigInt   引用类型存储在堆内存，存储的是地址，多个引用指向同一个地址，这里会涉及一个“共享”的概念。 ObjectArray Date RegExp Function Math    1234567891011121314151">
<meta name="keywords" content="资源,学习,网站">
<meta property="og:type" content="article">
<meta property="og:title" content="学习记录">
<meta property="og:url" content="https://DiamondsZz.github.io/2021/03/25/note/index.html">
<meta property="og:site_name" content="DiamondsZz">
<meta property="og:description" content="数据类型 基础类型存储在栈内存，被引用或拷贝时，会创建一个完全相等的变量； Undefined Null String Number Boolean Symbol BigInt   引用类型存储在堆内存，存储的是地址，多个引用指向同一个地址，这里会涉及一个“共享”的概念。 ObjectArray Date RegExp Function Math    1234567891011121314151">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2021-04-05T05:57:40.929Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="学习记录">
<meta name="twitter:description" content="数据类型 基础类型存储在栈内存，被引用或拷贝时，会创建一个完全相等的变量； Undefined Null String Number Boolean Symbol BigInt   引用类型存储在堆内存，存储的是地址，多个引用指向同一个地址，这里会涉及一个“共享”的概念。 ObjectArray Date RegExp Function Math    1234567891011121314151">
  
    <link rel="alternative" href="/atom.xml" title="DiamondsZz" type="application/atom+xml">
  
  
  
  <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet">
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: false,
          isPost: true,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>

        <a href="/" class="profilepic">
            
            <img lazy-src="/img/iu.jpeg" class="js-avatar">
            
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">DiamondsZz</a></h1>
        </hgroup>
        
        <p class="header-subtitle">DiamondsZz</p>
        
        
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        
        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                        </ul>
                    </nav>
                </section>
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/css/" style="font-size: 15px;">css</a> <a href="/tags/js/" style="font-size: 20px;">js</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/学习/" style="font-size: 15px;">学习</a> <a href="/tags/生活，心情/" style="font-size: 10px;">生活，心情</a> <a href="/tags/网站/" style="font-size: 15px;">网站</a> <a href="/tags/资源/" style="font-size: 15px;">资源</a>
                    </div>
                </section>
                
                
                
                
                <section class="switch-part switch-part3">
                
                    <div id="js-aboutme">矮穷矬!</div>
                </section>
                
            </div>
        </div>
    </header>
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">DiamondsZz</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/img/iu.jpeg" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">DiamondsZz</a></h1>
            </hgroup>
            
            <p class="header-subtitle">DiamondsZz</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                </div>
            </nav>
        </header>
    </div>
</nav>
      <div class="body-wrap"><article id="post-note" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2021/03/25/note/" class="article-date">
      <time datetime="2021-03-24T16:00:00.000Z" itemprop="datePublished">2021-03-25</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      学习记录
    </h1>
  


      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/学习/">学习</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/学习/">学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网站/">网站</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/资源/">资源</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ol>
<li>基础类型存储在栈内存，被引用或拷贝时，会创建一个完全相等的变量；<blockquote>
<p><code>Undefined</code> <code>Null</code> <code>String</code> <code>Number</code> <code>Boolean</code> <code>Symbol</code> <code>BigInt</code></p>
</blockquote>
</li>
<li>引用类型存储在堆内存，存储的是地址，多个引用指向同一个地址，这里会涉及一个“共享”的概念。<blockquote>
<p><code>Object</code><br><code>Array</code> <code>Date</code> <code>RegExp</code> <code>Function</code> <code>Math</code></p>
</blockquote>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">let a = &#123;</span><br><span class="line">  name: &quot;Julia&quot;,</span><br><span class="line"></span><br><span class="line">  age: 20,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function change(o) &#123;</span><br><span class="line">  o.age = 24;</span><br><span class="line">  //关键   变量o改变内存指向 跟a已经没有关系</span><br><span class="line">  o = &#123;</span><br><span class="line">    name: &quot;Kath&quot;,</span><br><span class="line">    age: 30,</span><br><span class="line">  &#125;;</span><br><span class="line">  return o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let b = change(a);</span><br><span class="line"></span><br><span class="line">console.log(b.age); // 第一个console   30</span><br><span class="line"></span><br><span class="line">console.log(a.age); // 第二个console   24</span><br></pre></td></tr></table></figure>
<h2 id="数据类型检测"><a href="#数据类型检测" class="headerlink" title="数据类型检测"></a>数据类型检测</h2><ol>
<li>typeof<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">typeof 1 // &apos;number&apos;</span><br><span class="line"></span><br><span class="line">typeof &apos;1&apos; // &apos;string&apos;</span><br><span class="line"></span><br><span class="line">typeof undefined // &apos;undefined&apos;</span><br><span class="line"></span><br><span class="line">typeof true // &apos;boolean&apos;</span><br><span class="line"></span><br><span class="line">typeof Symbol() // &apos;symbol&apos;</span><br><span class="line"></span><br><span class="line">typeof null // &apos;object&apos;       !!!!!!!!!!!!!!!!</span><br><span class="line"></span><br><span class="line">typeof [] // &apos;object&apos;</span><br><span class="line"></span><br><span class="line">typeof &#123;&#125; // &apos;object&apos;</span><br><span class="line"></span><br><span class="line">typeof console // &apos;object&apos;</span><br><span class="line"></span><br><span class="line">typeof console.log // &apos;function&apos;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>虽然 typeof null 会输出 object，但这只是 JS 存在的一个悠久 Bug，不代表 null 就是引用数据类型，并且 null 本身也不是对象。因此，null 在 typeof 之后返回的是有问题的结果，不能作为判断 null 的方法。如果你需要在 if 语句中判断是否为 null，直接通过 ‘===null’来判断就好。</li>
<li>引用数据类型 Object，用 typeof 来判断的话，除了 function 会判断为 OK 以外，其余都是 ‘object’，是无法判断出来的。</li>
</ul>
<ol start="2">
<li>instanceof<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">let Car = function() &#123;&#125;</span><br><span class="line"></span><br><span class="line">let benz = new Car()</span><br><span class="line"></span><br><span class="line">benz instanceof Car // true</span><br><span class="line"></span><br><span class="line">let car = new String(&apos;Mercedes Benz&apos;)</span><br><span class="line"></span><br><span class="line">car instanceof String // true</span><br><span class="line"></span><br><span class="line">let str = &apos;Covid-19&apos;</span><br><span class="line"></span><br><span class="line">str instanceof String // false</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------------------------------</span><br><span class="line"></span><br><span class="line">function myInstanceof(left, right) &#123;</span><br><span class="line"></span><br><span class="line">  // 这里先用typeof来判断基础数据类型，如果是，直接返回false</span><br><span class="line"></span><br><span class="line">  if(typeof left !== &apos;object&apos; || left === null) return false;</span><br><span class="line"></span><br><span class="line">  // getPrototypeOf是Object对象自带的API，能够拿到参数的原型对象</span><br><span class="line"></span><br><span class="line">  let proto = Object.getPrototypeOf(left);</span><br><span class="line"></span><br><span class="line">  while(true) &#123;                  //循环往下寻找，直到找到相同的原型对象</span><br><span class="line"></span><br><span class="line">    if(proto === null) return false;</span><br><span class="line"></span><br><span class="line">    if(proto === right.prototype) return true;//找到相同原型对象，返回true</span><br><span class="line"></span><br><span class="line">    proto = Object.getPrototypeof(proto);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 验证一下自己实现的myInstanceof是否OK</span><br><span class="line"></span><br><span class="line">console.log(myInstanceof(new Number(123), Number));    // true</span><br><span class="line"></span><br><span class="line">console.log(myInstanceof(123, Number));                // false</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>instanceof 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型；</li>
<li>而 typeof 也存在弊端，它虽然可以判断基础数据类型（null 除外），但是引用数据类型中，除了 function 类型以外，其他的也无法判断。</li>
</ul>
<ol start="3">
<li>Object.prototype.toString<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString(&#123;&#125;)       // &quot;[object Object]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(&#123;&#125;)  // 同上结果，加上call也ok</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(1)    // &quot;[object Number]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(&apos;1&apos;)  // &quot;[object String]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(true)  // &quot;[object Boolean]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(function()&#123;&#125;)  // &quot;[object Function]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(null)   //&quot;[object Null]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(undefined) //&quot;[object Undefined]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(/123/g)    //&quot;[object RegExp]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(new Date()) //&quot;[object Date]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call([])       //&quot;[object Array]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(document)  //&quot;[object HTMLDocument]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(window)   //&quot;[object Window]&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function getType(obj)&#123;</span><br><span class="line">  let type  = typeof obj;</span><br><span class="line">  if (type !== &quot;object&quot;) &#123;    // 先进行typeof判断，如果是基础数据类型，直接返回</span><br><span class="line">    return type;</span><br><span class="line">  &#125;</span><br><span class="line">  // 对于typeof返回结果是object的，再进行如下的判断，正则返回结果</span><br><span class="line">  return Object.prototype.toString.call(obj).replace(/^\[object (\S+)\]$/, &apos;$1&apos;);  // 注意正则中间有个空格</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><ol>
<li>强制类型转换 Number()、parseInt()、parseFloat()、toString()、String()、Boolean()<blockquote>
<p>Number() 方法的强制转换规则<br>如果是布尔值，true 和 false 分别被转换为 1 和 0；<br>如果是数字，返回自身；<br>如果是 null，返回 0；<br>如果是 undefined，返回 NaN；<br>如果是字符串，遵循以下规则：如果字符串中只包含数字（或者是 0X / 0x 开头的十六进制数字字符串，允许包含正负号），则将其转换为十进制；如果字符串中包含有效的浮点格式，将其转换为浮点数值；如果是空字符串，将其转换为 0；如果不是以上格式的字符串，均返回 NaN；<br>如果是 Symbol，抛出错误；<br>如果是对象，并且部署了 [Symbol.toPrimitive] ，那么调用此方法，否则调用对象的 valueOf() 方法，然后依据前面的规则转换返回的值；如果转换的结果是 NaN ，则调用对象的 toString() 方法，再次依照前面的顺序转换返回对应的值</p>
</blockquote>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Number(true);        // 1</span><br><span class="line"></span><br><span class="line">Number(false);       // 0</span><br><span class="line"></span><br><span class="line">Number(&apos;0111&apos;);      //111</span><br><span class="line"></span><br><span class="line">Number(null);        //0</span><br><span class="line"></span><br><span class="line">Number(&apos;&apos;);          //0</span><br><span class="line"></span><br><span class="line">Number(&apos;1a&apos;);        //NaN</span><br><span class="line"></span><br><span class="line">Number(-0X11);       //-17</span><br><span class="line"></span><br><span class="line">Number(&apos;0X11&apos;)       //17</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Boolean() 方法的强制转换规则<br>除了 undefined、 null、 false、 ‘’、 0（包括 +0，-0）、 NaN 转换出来是 false，其他都是 true。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Boolean(0)          //false</span><br><span class="line"></span><br><span class="line">Boolean(null)       //false</span><br><span class="line"></span><br><span class="line">Boolean(undefined)  //false</span><br><span class="line"></span><br><span class="line">Boolean(NaN)        //false</span><br><span class="line"></span><br><span class="line">Boolean(1)          //true</span><br><span class="line"></span><br><span class="line">Boolean(13)         //true</span><br><span class="line"></span><br><span class="line">Boolean(&apos;12&apos;)       //true</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>‘==’ 的隐式类型转换规则</li>
</ol>
<ul>
<li>如果类型相同，无须进行类型转换；</li>
<li>如果其中一个操作值是 null 或者 undefined，那么另一个操作符必须为 null 或者 undefined，才会返回 true，否则都返回 false；</li>
<li>如果其中一个是 Symbol 类型，那么返回 false；</li>
<li>两个操作值如果为 string 和 number 类型，那么就会将字符串转换为 number；</li>
<li>如果一个操作值是 boolean，那么转换成 number；</li>
<li>如果一个操作值为 object 且另一方为 string、number 或者 symbol，就会把 object 转为原始类型再进行判断（调用 object 的 valueOf/toString 方法进行转换）。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">null == undefined       // true  规则2</span><br><span class="line"></span><br><span class="line">null == 0               // false 规则2</span><br><span class="line"></span><br><span class="line">&apos;&apos; == null              // false 规则2</span><br><span class="line"></span><br><span class="line">&apos;&apos; == 0                 // true  规则4 字符串转隐式转换成Number之后再对比</span><br><span class="line"></span><br><span class="line">&apos;123&apos; == 123            // true  规则4 字符串转隐式转换成Number之后再对比</span><br><span class="line"></span><br><span class="line">0 == false              // true  e规则 布尔型隐式转换成Number之后再对比</span><br><span class="line"></span><br><span class="line">1 == true               // true  e规则 布尔型隐式转换成Number之后再对比</span><br><span class="line"></span><br><span class="line">var a = &#123;</span><br><span class="line"></span><br><span class="line">  value: 0,</span><br><span class="line"></span><br><span class="line">  valueOf: function() &#123;</span><br><span class="line"></span><br><span class="line">    this.value++;</span><br><span class="line"></span><br><span class="line">    return this.value;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 注意这里a又可以等于1、2、3</span><br><span class="line"></span><br><span class="line">console.log(a == 1 &amp;&amp; a == 2 &amp;&amp; a ==3);  //true f规则 Object隐式转换</span><br><span class="line"></span><br><span class="line">// 注：但是执行过3遍之后，再重新执行a==3或之前的数字就是false，因为value已经加上去了，这里需要注意一下</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="3">
<li>‘+’ 的隐式类型转换规则</li>
</ol>
<ul>
<li>如果其中有一个是字符串，另外一个是 undefined、null 或布尔型，则调用 toString() 方法进行字符串拼接；如果是纯对象、数组、正则等，则默认调用对象的转换方法会存在优先级，然后再进行拼接。</li>
<li>如果其中有一个是数字，另外一个是 undefined、null、布尔型或数字，则会将其转换成数字进行加法运算，对象的情况还是参考上一条规则。</li>
<li>如果其中一个是字符串、一个是数字，则按照字符串规则进行拼接</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1 + 2        // 3  常规情况</span><br><span class="line"></span><br><span class="line">&apos;1&apos; + &apos;2&apos;    // &apos;12&apos; 常规情况</span><br><span class="line"></span><br><span class="line">// 下面看一下特殊情况</span><br><span class="line"></span><br><span class="line">&apos;1&apos; + undefined   // &quot;1undefined&quot; 规则1，undefined转换字符串</span><br><span class="line"></span><br><span class="line">&apos;1&apos; + null        // &quot;1null&quot; 规则1，null转换字符串</span><br><span class="line"></span><br><span class="line">&apos;1&apos; + true        // &quot;1true&quot; 规则1，true转换字符串</span><br><span class="line"></span><br><span class="line">&apos;1&apos; + 1n          // &apos;11&apos; 比较特殊字符串和BigInt相加，BigInt转换为字符串</span><br><span class="line"></span><br><span class="line">1 + undefined     // NaN  规则2，undefined转换数字相加NaN</span><br><span class="line"></span><br><span class="line">1 + null          // 1    规则2，null转换为0</span><br><span class="line"></span><br><span class="line">1 + true          // 2    规则2，true转换为1，二者相加为2</span><br><span class="line"></span><br><span class="line">1 + 1n            // 错误  不能把BigInt和Number类型直接混合相加</span><br><span class="line"></span><br><span class="line">&apos;1&apos; + 3           // &apos;13&apos; 规则3，字符串拼接</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>Object 的转换规则</li>
</ol>
<ul>
<li>如果部署了 Symbol.toPrimitive 方法，优先调用再返回；</li>
<li>调用 valueOf()，如果转换为基础类型，则返回；</li>
<li>调用 toString()，如果转换为基础类型，则返回；</li>
<li>如果都没有返回基础类型，会报错。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line"></span><br><span class="line">  value: 1,</span><br><span class="line"></span><br><span class="line">  valueOf() &#123;</span><br><span class="line"></span><br><span class="line">    return 2;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line"></span><br><span class="line">    return &apos;3&apos;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  [Symbol.toPrimitive]() &#123;</span><br><span class="line"></span><br><span class="line">    return 4</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(obj + 1); // 输出5</span><br><span class="line"></span><br><span class="line">// 因为有Symbol.toPrimitive，就优先执行这个；如果Symbol.toPrimitive这段代码删掉，则执行valueOf打印结果为3；如果valueOf也去掉，则调用toString返回&apos;31&apos;(字符串拼接)</span><br><span class="line"></span><br><span class="line">// 再看两个特殊的case：</span><br><span class="line"></span><br><span class="line">10 + &#123;&#125;</span><br><span class="line"></span><br><span class="line">// &quot;10[object Object]&quot;，注意：&#123;&#125;会默认调用valueOf是&#123;&#125;，不是基础类型继续转换，调用toString，返回结果&quot;[object Object]&quot;，于是和10进行&apos;+&apos;运算，按照字符串拼接规则来，参考&apos;+&apos;的规则C</span><br><span class="line"></span><br><span class="line">[1,2,undefined,4,5] + 10</span><br><span class="line"></span><br><span class="line">// &quot;1,2,,4,510&quot;，注意[1,2,undefined,4,5]会默认先调用valueOf结果还是这个数组，不是基础数据类型继续转换，也还是调用toString，返回&quot;1,2,,4,5&quot;，然后再和10进行运算，还是按照字符串拼接规则，参考&apos;+&apos;的第3条规则</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h2><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><ol>
<li>Object.assign<br><em>注意点</em></li>
</ol>
<ul>
<li>它不会拷贝对象的继承属性；</li>
<li>它不会拷贝对象的不可枚举的属性；</li>
<li>可以拷贝 Symbol 类型的属性。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">let obj1 = &#123; a:&#123; b:1 &#125;, sym:Symbol(1)&#125;; </span><br><span class="line"></span><br><span class="line">Object.defineProperty(obj1, &apos;innumerable&apos; ,&#123;</span><br><span class="line"></span><br><span class="line">    value:&apos;不可枚举属性&apos;,</span><br><span class="line"></span><br><span class="line">    enumerable:false</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">let obj2 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Object.assign(obj2,obj1)</span><br><span class="line"></span><br><span class="line">obj1.a.b = 2;</span><br><span class="line"></span><br><span class="line">console.log(&apos;obj1&apos;,obj1);</span><br><span class="line"></span><br><span class="line">console.log(&apos;obj2&apos;,obj2);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="2">
<li>扩展运算符<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/* 对象的拷贝 */</span><br><span class="line"></span><br><span class="line">let obj = &#123;a:1,b:&#123;c:1&#125;&#125;</span><br><span class="line"></span><br><span class="line">let obj2 = &#123;...obj&#125;</span><br><span class="line"></span><br><span class="line">obj.a = 2</span><br><span class="line"></span><br><span class="line">console.log(obj)  //&#123;a:2,b:&#123;c:1&#125;&#125; console.log(obj2); //&#123;a:1,b:&#123;c:1&#125;&#125;</span><br><span class="line"></span><br><span class="line">obj.b.c = 2</span><br><span class="line"></span><br><span class="line">console.log(obj)  //&#123;a:2,b:&#123;c:2&#125;&#125; console.log(obj2); //&#123;a:1,b:&#123;c:2&#125;&#125;</span><br><span class="line"></span><br><span class="line">/* 数组的拷贝 */</span><br><span class="line"></span><br><span class="line">let arr = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">let newArr = [...arr]; //跟arr.slice()是一样的效果</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>扩展运算符 和 object.assign 有同样的缺陷，也就是实现的浅拷贝的功能差不多，但是如果属性都是基本类型的值，使用扩展运算符进行浅拷贝会更加方便。</li>
</ul>
<ol start="3">
<li>concat 拷贝数组<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">let newArr = arr.concat();</span><br><span class="line"></span><br><span class="line">newArr[1] = 100;</span><br><span class="line"></span><br><span class="line">console.log(arr);  // [ 1, 2, 3 ]</span><br><span class="line"></span><br><span class="line">console.log(newArr); // [ 1, 100, 3 ]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>concat 只能用于数组的浅拷贝，使用场景比较局限。</li>
</ul>
<ol start="4">
<li>slice 拷贝数组</li>
</ol>
<ul>
<li>slice 方法也比较有局限性，因为它仅仅针对数组类型。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, 2, &#123;val: 4&#125;];</span><br><span class="line"></span><br><span class="line">let newArr = arr.slice();</span><br><span class="line"></span><br><span class="line">newArr[2].val = 1000;</span><br><span class="line"></span><br><span class="line">console.log(arr);  //[ 1, 2, &#123; val: 1000 &#125; ]</span><br></pre></td></tr></table></figure>
<ul>
<li>浅拷贝只能拷贝一层对象。如果存在对象的嵌套，那么浅拷贝将无能为力。因此深拷贝就是为了解决这个问题而生的，它能解决多层对象嵌套问题，彻底实现拷贝。</li>
</ul>
<ol start="5">
<li>浅拷贝</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">const shallowClone = (target) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  if (typeof target === &apos;object&apos; &amp;&amp; target !== null) &#123;</span><br><span class="line"></span><br><span class="line">    const cloneTarget = Array.isArray(target) ? []: &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    for (let prop in target) &#123;</span><br><span class="line"></span><br><span class="line">      //是否是自有属性</span><br><span class="line">      if (target.hasOwnProperty(prop)) &#123;</span><br><span class="line"></span><br><span class="line">          cloneTarget[prop] = target[prop];</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return cloneTarget;</span><br><span class="line"></span><br><span class="line">  &#125; else &#123;</span><br><span class="line"></span><br><span class="line">    return target;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><ol>
<li>JSON.stringify()<br><em>弊端</em></li>
</ol>
<ul>
<li>拷贝的对象的值中如果有函数、undefined、symbol 这几种类型，经过 JSON.stringify 序列化之后的字符串中这个键值对会消失；</li>
<li>拷贝 Date 引用类型会变成字符串；</li>
<li>无法拷贝不可枚举的属性；</li>
<li>无法拷贝对象的原型链；</li>
<li>拷贝 RegExp 引用类型会变成空对象；</li>
<li>对象中含有 NaN、Infinity 以及 -Infinity，JSON 序列化的结果会变成 null；</li>
<li>无法拷贝对象的循环应用，即对象成环 (obj[key] = obj)。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">function Obj() &#123; </span><br><span class="line"></span><br><span class="line">  this.func = function () &#123; alert(1) &#125;; </span><br><span class="line"></span><br><span class="line">  this.obj = &#123;a:1&#125;;</span><br><span class="line"></span><br><span class="line">  this.arr = [1,2,3];</span><br><span class="line"></span><br><span class="line">  this.und = undefined; </span><br><span class="line"></span><br><span class="line">  this.reg = /123/; </span><br><span class="line"></span><br><span class="line">  this.date = new Date(0); </span><br><span class="line"></span><br><span class="line">  this.NaN = NaN;</span><br><span class="line"></span><br><span class="line">  this.infinity = Infinity;</span><br><span class="line"></span><br><span class="line">  this.sym = Symbol(1);</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">let obj1 = new Obj();</span><br><span class="line"></span><br><span class="line">Object.defineProperty(obj1,&apos;innumerable&apos;,&#123; </span><br><span class="line"></span><br><span class="line">  enumerable:false,</span><br><span class="line"></span><br><span class="line">  value:&apos;innumerable&apos;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&apos;obj1&apos;,obj1);</span><br><span class="line"></span><br><span class="line">let str = JSON.stringify(obj1);</span><br><span class="line"></span><br><span class="line">let obj2 = JSON.parse(str);</span><br><span class="line"></span><br><span class="line">console.log(&apos;obj2&apos;,obj2);</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 JSON.stringify 方法实现深拷贝对象，虽然到目前为止还有很多无法实现的功能，但是这种方法足以满足日常的开发需求，并且是最简单和快捷的。</li>
</ul>
<ol start="2">
<li>手写递归实现<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">let obj1 = &#123;</span><br><span class="line"></span><br><span class="line">  a:&#123;</span><br><span class="line"></span><br><span class="line">    b:1</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function deepClone(obj) &#123; </span><br><span class="line"></span><br><span class="line">  let cloneObj = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  for(let key in obj) &#123;                 //遍历</span><br><span class="line"></span><br><span class="line">    if(typeof obj[key] ===&apos;object&apos;) &#123; </span><br><span class="line"></span><br><span class="line">      cloneObj[key] = deepClone(obj[key])  //是对象就再次调用该函数递归</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">      cloneObj[key] = obj[key]  //基本类型的话直接复制值</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return cloneObj</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let obj2 = deepClone(obj1);</span><br><span class="line"></span><br><span class="line">obj1.a.b = 2;</span><br><span class="line"></span><br><span class="line">console.log(obj2);   //  &#123;a:&#123;b:1&#125;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><em>弊端</em></p>
<ul>
<li>这个深拷贝函数并不能复制不可枚举的属性以及 Symbol 类型；</li>
<li>这种方法只是针对普通的引用类型的值做递归复制，而对于 Array、Date、RegExp、Error、Function 这样的引用类型并不能正确地拷贝；</li>
<li>对象的属性里面成环，即循环引用没有解决。</li>
</ul>
<ol start="3">
<li>改进后递归实现<br><em>注意点</em></li>
</ol>
<ul>
<li>针对能够遍历对象的不可枚举属性以及 Symbol 类型，我们可以使用 Reflect.ownKeys 方法；</li>
<li>当参数为 Date、RegExp 类型，则直接生成一个新的实例返回；</li>
<li>利用 Object 的 getOwnPropertyDescriptors 方法可以获得对象的所有属性，以及对应的特性，顺便结合 Object 的 create 方法创建一个新对象，并继承传入原对象的原型链；</li>
<li>利用 WeakMap 类型作为 Hash 表，因为 WeakMap 是弱引用类型，可以有效防止内存泄漏（你可以关注一下 Map 和 weakMap 的关键区别，这里要用 weakMap），作为检测循环引用很有帮助，如果存在循环，则引用直接返回 WeakMap 存储的值。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">const isComplexDataType = obj =&gt; (typeof obj === &apos;object&apos; || typeof obj === &apos;function&apos;) &amp;&amp; (obj !== null)</span><br><span class="line"></span><br><span class="line">const deepClone = function (obj, hash = new WeakMap()) &#123;</span><br><span class="line"></span><br><span class="line">  if (obj.constructor === Date) </span><br><span class="line"></span><br><span class="line">  return new Date(obj)       // 日期对象直接返回一个新的日期对象</span><br><span class="line"></span><br><span class="line">  if (obj.constructor === RegExp)</span><br><span class="line"></span><br><span class="line">  return new RegExp(obj)     //正则对象直接返回一个新的正则对象</span><br><span class="line"></span><br><span class="line">  //如果循环引用了就用 weakMap 来解决</span><br><span class="line"></span><br><span class="line">  if (hash.has(obj)) return hash.get(obj)</span><br><span class="line"></span><br><span class="line">  let allDesc = Object.getOwnPropertyDescriptors(obj)</span><br><span class="line"></span><br><span class="line">  //遍历传入参数所有键的特性</span><br><span class="line"></span><br><span class="line">  let cloneObj = Object.create(Object.getPrototypeOf(obj), allDesc)</span><br><span class="line"></span><br><span class="line">  //继承原型链</span><br><span class="line"></span><br><span class="line">  hash.set(obj, cloneObj)</span><br><span class="line"></span><br><span class="line">  for (let key of Reflect.ownKeys(obj)) &#123; </span><br><span class="line"></span><br><span class="line">    cloneObj[key] = (isComplexDataType(obj[key]) &amp;&amp; typeof obj[key] !== &apos;function&apos;) ? deepClone(obj[key], hash) : obj[key]</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return cloneObj</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 下面是验证代码</span><br><span class="line"></span><br><span class="line">let obj = &#123;</span><br><span class="line"></span><br><span class="line">  num: 0,</span><br><span class="line"></span><br><span class="line">  str: &apos;&apos;,</span><br><span class="line"></span><br><span class="line">  boolean: true,</span><br><span class="line"></span><br><span class="line">  unf: undefined,</span><br><span class="line"></span><br><span class="line">  nul: null,</span><br><span class="line"></span><br><span class="line">  obj: &#123; name: &apos;我是一个对象&apos;, id: 1 &#125;,</span><br><span class="line"></span><br><span class="line">  arr: [0, 1, 2],</span><br><span class="line"></span><br><span class="line">  func: function () &#123; console.log(&apos;我是一个函数&apos;) &#125;,</span><br><span class="line"></span><br><span class="line">  date: new Date(0),</span><br><span class="line"></span><br><span class="line">  reg: new RegExp(&apos;/我是一个正则/ig&apos;),</span><br><span class="line"></span><br><span class="line">  [Symbol(&apos;1&apos;)]: 1,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.defineProperty(obj, &apos;innumerable&apos;, &#123;</span><br><span class="line"></span><br><span class="line">  enumerable: false, value: &apos;不可枚举属性&apos; &#125;</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">obj = Object.create(obj, Object.getOwnPropertyDescriptors(obj))</span><br><span class="line"></span><br><span class="line">obj.loop = obj    // 设置loop成循环引用的属性</span><br><span class="line"></span><br><span class="line">let cloneObj = deepClone(obj)</span><br><span class="line"></span><br><span class="line">cloneObj.arr.push(4)</span><br><span class="line"></span><br><span class="line">console.log(&apos;obj&apos;, obj)</span><br><span class="line"></span><br><span class="line">console.log(&apos;cloneObj&apos;, cloneObj)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ol>
<li>原型链继承<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function Parent1() &#123;</span><br><span class="line"></span><br><span class="line">  this.name = &apos;parent1&apos;;</span><br><span class="line"></span><br><span class="line">  this.play = [1, 2, 3]</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child1() &#123;</span><br><span class="line"></span><br><span class="line">  this.type = &apos;child2&apos;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child1.prototype = new Parent1();</span><br><span class="line">let c1=new Child1()</span><br><span class="line">let c2=new Child1()</span><br><span class="line">console.log(c1.__proto__===c2.__proto__); //true</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>两个实例使用的是同一个原型对象。它们的内存空间是共享的，当一个发生变化的时候，另外一个也随之进行了变化，这就是使用原型链继承方式的一个缺点。</p>
<ol start="2">
<li>构造函数继承（借助 call）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">function Parent1()&#123;</span><br><span class="line"></span><br><span class="line">  this.name = &apos;parent1&apos;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Parent1.prototype.getName = function () &#123;</span><br><span class="line"></span><br><span class="line">  return this.name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function Child1()&#123;</span><br><span class="line"></span><br><span class="line">  Parent1.call(this);</span><br><span class="line"></span><br><span class="line">  this.type = &apos;child1&apos;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let child = new Child1();</span><br><span class="line"></span><br><span class="line">console.log(child);  // 没问题</span><br><span class="line"></span><br><span class="line">console.log(child.getName());  // 会报错</span><br></pre></td></tr></table></figure>
<p>构造函数实现继承的优缺点，它使父类的引用属性不会被共享，优化了第一种继承方式的弊端；<br>但是随之而来的缺点也比较明显——只能继承父类的实例属性和方法，不能继承原型属性或者方法。</p>
<ol start="3">
<li><p>组合继承（前两种组合）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">function Parent3 () &#123;</span><br><span class="line"></span><br><span class="line">  this.name = &apos;parent3&apos;;</span><br><span class="line"></span><br><span class="line">  this.play = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Parent3.prototype.getName = function () &#123;</span><br><span class="line"></span><br><span class="line">  return this.name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child3() &#123;</span><br><span class="line"></span><br><span class="line">  // 第二次调用 Parent3()</span><br><span class="line"></span><br><span class="line">  Parent3.call(this);</span><br><span class="line"></span><br><span class="line">  this.type = &apos;child3&apos;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 第一次调用 Parent3()</span><br><span class="line"></span><br><span class="line">Child3.prototype = new Parent3();</span><br><span class="line"></span><br><span class="line">// 手动挂上构造器，指向自己的构造函数</span><br><span class="line"></span><br><span class="line">Child3.prototype.constructor = Child3;</span><br><span class="line"></span><br><span class="line">var s3 = new Child3();</span><br><span class="line"></span><br><span class="line">var s4 = new Child3();</span><br><span class="line"></span><br><span class="line">s3.play.push(4);</span><br><span class="line"></span><br><span class="line">console.log(s3.play, s4.play);  // 不互相影响</span><br><span class="line"></span><br><span class="line">console.log(s3.getName()); // 正常输出&apos;parent3&apos;</span><br><span class="line"></span><br><span class="line">console.log(s4.getName()); // 正常输出&apos;parent3&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>原型式继承</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">let parent4 = &#123;</span><br><span class="line"></span><br><span class="line">  name: &quot;parent4&quot;,</span><br><span class="line"></span><br><span class="line">  friends: [&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;],</span><br><span class="line"></span><br><span class="line">  getName: function() &#123;</span><br><span class="line"></span><br><span class="line">    return this.name;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let person4 = Object.create(parent4);</span><br><span class="line"></span><br><span class="line">person4.name = &quot;tom&quot;;</span><br><span class="line"></span><br><span class="line">person4.friends.push(&quot;jerry&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let person5 = Object.create(parent4);</span><br><span class="line"></span><br><span class="line">person5.friends.push(&quot;lucy&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">console.log(person4.name);</span><br><span class="line"></span><br><span class="line">console.log(person4.name === person4.getName());</span><br><span class="line"></span><br><span class="line">console.log(person5.name);</span><br><span class="line"></span><br><span class="line">console.log(person4.friends);</span><br><span class="line"></span><br><span class="line">console.log(person5.friends);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>最后两个输出结果是一样的，关于引用数据类型“共享”的问题，其实 Object.create 方法是可以为一些对象实现浅拷贝的。<br>关于这种继承方式的缺点也很明显，多个实例的引用类型属性指向相同的内存，存在篡改的可能。</p>
<ol start="5">
<li>寄生式继承</li>
</ol>
<ul>
<li><p>使用原型式继承可以获得一份目标对象的浅拷贝，然后利用这个浅拷贝的能力再进行增强，添加一些方法，这样的继承方式就叫作寄生式继承。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"> let parent5 = &#123;</span><br><span class="line"></span><br><span class="line">  name: &quot;parent5&quot;,</span><br><span class="line"></span><br><span class="line">  friends: [&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;],</span><br><span class="line"></span><br><span class="line">  getName: function() &#123;</span><br><span class="line"></span><br><span class="line">    return this.name;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function clone(original) &#123;</span><br><span class="line"></span><br><span class="line">  let clone = Object.create(original);</span><br><span class="line"></span><br><span class="line">  clone.getFriends = function() &#123;</span><br><span class="line"></span><br><span class="line">    return this.friends;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return clone;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let person5 = clone(parent5);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">console.log(person5.getName());</span><br><span class="line"></span><br><span class="line">console.log(person5.getFriends());</span><br></pre></td></tr></table></figure>
</li>
<li><p>虽然其优缺点和原型式继承一样，但是对于普通对象的继承方式来说，寄生式继承相比于原型式继承，还是在父类基础上添加了更多的方法。</p>
</li>
</ul>
<ol start="6">
<li>寄生组合式继承</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">function clone (parent, child) &#123;</span><br><span class="line"></span><br><span class="line">  // 这里改用 Object.create 就可以减少组合继承中多进行一次构造的过程</span><br><span class="line"></span><br><span class="line">  child.prototype = Object.create(parent.prototype);</span><br><span class="line"></span><br><span class="line">  child.prototype.constructor = child;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function Parent6() &#123;</span><br><span class="line"></span><br><span class="line">  this.name = &apos;parent6&apos;;</span><br><span class="line"></span><br><span class="line">  this.play = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> Parent6.prototype.getName = function () &#123;</span><br><span class="line"></span><br><span class="line">  return this.name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child6() &#123;</span><br><span class="line"></span><br><span class="line">  Parent6.call(this);</span><br><span class="line"></span><br><span class="line">  this.friends = &apos;child5&apos;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">clone(Parent6, Child6);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Child6.prototype.getFriends = function () &#123;</span><br><span class="line"></span><br><span class="line">  return this.friends;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let person6 = new Child6();</span><br><span class="line"></span><br><span class="line">console.log(person6);</span><br><span class="line"></span><br><span class="line">console.log(person6.getName());</span><br><span class="line"></span><br><span class="line">console.log(person6.getFriends());</span><br></pre></td></tr></table></figure>
<ul>
<li>这种寄生组合式继承方式，基本可以解决前几种继承方式的缺点，较好地实现了继承想要的结果，同时也减少了构造次数，减少了性能的开销</li>
</ul>
<ol start="7">
<li>ES6 的 extends 关键字实现逻辑<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line"></span><br><span class="line">  constructor(name) &#123;</span><br><span class="line"></span><br><span class="line">    this.name = name</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 原型方法</span><br><span class="line"></span><br><span class="line">  // 即 Person.prototype.getName = function() &#123; &#125;</span><br><span class="line"></span><br><span class="line">  // 下面可以简写为 getName() &#123;...&#125;</span><br><span class="line"></span><br><span class="line">  getName = function () &#123;</span><br><span class="line"></span><br><span class="line">    console.log(&apos;Person:&apos;, this.name)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Gamer extends Person &#123;</span><br><span class="line"></span><br><span class="line">  constructor(name, age) &#123;</span><br><span class="line"></span><br><span class="line">    // 子类中存在构造函数，则需要在使用“this”之前首先调用 super()。</span><br><span class="line"></span><br><span class="line">    super(name)</span><br><span class="line"></span><br><span class="line">    this.age = age</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const asuna = new Gamer(&apos;Asuna&apos;, 20)</span><br><span class="line"></span><br><span class="line">asuna.getName() // 成功访问到父类的方法</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>利用 babel 这个编译工具，将 ES6 的代码编译成 ES5</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">function _possibleConstructorReturn (self, call) &#123; </span><br><span class="line"></span><br><span class="line">		// ...</span><br><span class="line"></span><br><span class="line">		return call &amp;&amp; (typeof call === &apos;object&apos; || typeof call === &apos;function&apos;) ? call : self; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _inherits (subClass, superClass) &#123; </span><br><span class="line"></span><br><span class="line">    // 这里可以看到</span><br><span class="line"></span><br><span class="line">	subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, &#123; </span><br><span class="line"></span><br><span class="line">		constructor: &#123; </span><br><span class="line"></span><br><span class="line">			value: subClass, </span><br><span class="line"></span><br><span class="line">			enumerable: false, </span><br><span class="line"></span><br><span class="line">			writable: true, </span><br><span class="line"></span><br><span class="line">			configurable: true </span><br><span class="line"></span><br><span class="line">		&#125; </span><br><span class="line"></span><br><span class="line">	&#125;); </span><br><span class="line"></span><br><span class="line">	if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var Parent = function Parent () &#123;</span><br><span class="line"></span><br><span class="line">	// 验证是否是 Parent 构造出来的 this</span><br><span class="line"></span><br><span class="line">	_classCallCheck(this, Parent);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var Child = (function (_Parent) &#123;</span><br><span class="line"></span><br><span class="line">	_inherits(Child, _Parent);</span><br><span class="line"></span><br><span class="line">	function Child () &#123;</span><br><span class="line"></span><br><span class="line">		_classCallCheck(this, Child);</span><br><span class="line"></span><br><span class="line">		return _possibleConstructorReturn(this, (Child.__proto__ || Object.getPrototypeOf(Child)).apply(this, arguments));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	return Child;</span><br><span class="line"></span><br><span class="line">&#125;(Parent));</span><br></pre></td></tr></table></figure>
<p>从上面编译完成的源码中可以看到，它采用的也是寄生组合继承方式，因此也证明了这种方式是较优的解决继承的方式。</p>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><ul>
<li>不管是什么样的计算机程序语言，运行在对应的代码引擎上，对应的使用内存过程大致逻辑是一样的，可以分为这三个步骤：</li>
</ul>
<ol>
<li>分配你所需要的系统内存空间；</li>
<li>使用分配到的内存进行读或者写等操作；</li>
<li>不需要使用内存时，将其空间释放或者归还。</li>
</ol>
<ul>
<li><p>在 JavaScript 中，当我们创建变量（对象，字符串等）的时候，系统会自动给对象分配对应的内存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var a = 123; // 给数值变量分配栈内存</span><br><span class="line"></span><br><span class="line">var etf = &quot;ARK&quot;; // 给字符串分配栈内存</span><br><span class="line"></span><br><span class="line">// 给对象及其包含的值分配堆内存</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line"></span><br><span class="line">  name: &apos;tom&apos;,</span><br><span class="line"></span><br><span class="line">  age: 13</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">// 给数组及其包含的值分配内存（就像对象一样）</span><br><span class="line"></span><br><span class="line">var a = [1, null, &quot;PSAC&quot;]; </span><br><span class="line"></span><br><span class="line">// 给函数（可调用的对象）分配内存</span><br><span class="line"></span><br><span class="line">function sum(a, b)&#123;</span><br><span class="line"></span><br><span class="line">  return a + b;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>栈内存中的基本类型，可以通过操作系统直接处理；<br>而堆内存中的引用类型，正是由于可以经常变化，大小不固定，因此需要 JavaScript 的引擎通过垃圾回收机制来处理。</p>
<h3 id="chrome内存回收机制"><a href="#chrome内存回收机制" class="headerlink" title="chrome内存回收机制"></a>chrome内存回收机制</h3></li>
<li>在 Chrome 浏览器中，JavaScript 的 V8 引擎被限制了内存的使用，根据不同的操作系统（操作系统有 64 位和 32 位的）内存大小会不同，大的可以到 1.4G 的空间，小的只能到 0.7G 的空间。</li>
<li>为什么要去限制内存使用呢？<br>大致是两个原因：V8 最开始是为浏览器而设计的引擎，早些年由于 Web 应用都比较简单，其实并未考虑占据过多的内存空间；<br>另外又由于被 V8 的垃圾回收机制所限制，比如清理大量的内存时会耗费很多时间，这样会引起 JavaScript 执行的线程被挂起，会影响当前执行的页面应用的性能。<h4 id="新生代内存回收"><a href="#新生代内存回收" class="headerlink" title="新生代内存回收"></a>新生代内存回收</h4></li>
<li>新生代的内存回收的空间，在 64 位操作系统下分配为 32MB，正是因为新生代中的变量存活时间短，不太容易产生太大的内存压力，因此不够大也是可以理解的。</li>
<li>系统会将分配给新生代的内存空间分为两部分：正在使用的内存空间[1]，闲置的内存空间[2]<br>当浏览器开始进行内存的垃圾回收时，JavaScript 的 V8 引擎会将[1]的对象检查一遍。如果引擎检测是存活对象，那么会复制到[2]去；如果不是存活的对象，则直接进行系统回收。当所有[1]的对象没有了的时候，等再有新生代的对象产生时，[1][2]对调，这样来循环处理。</li>
<li><code>算法 Scavenge</code>，它主要就是解决内存碎片<h4 id="老生代内存回收"><a href="#老生代内存回收" class="headerlink" title="老生代内存回收"></a>老生代内存回收</h4></li>
<li>新生代中的变量如果经过回收之后依然一直存在，那么就会被放入到老生代内存中。</li>
<li>只要是已经经历过一次 Scavenge 算法回收的，就可以晋升为老生代内存的对象</li>
<li>对于内存空间比较大的，就不适合用 Scavenge 算法了。</li>
<li>老生代内存中的垃圾回收,采用了 <code>Mark-Sweep（标记清除）</code> 和 <code>Mark-Compact（标记整理）</code>的策略</li>
</ul>
<ol>
<li>标记清除（Mark-Sweep）<br>分为两个阶段：标记阶段和清除阶段。<br>首先它会遍历堆上的所有的对象，分别对它们打上标记；然后在代码执行过程结束之后，对使用过的变量取消标记。<br>那么没取消标记的就是没有使用过的变量，因此在清除阶段，就会把还有标记的进行整体清除，从而释放内存空间。</li>
</ol>
<p>通过标记清除之后，还是会出现内存碎片的问题。标记整理策略（Mark-Compact）用来解决内存碎片的问题。</p>
<ol start="2">
<li>标记整理（Mark-Compact）<br>标记整理添加了活动对象整理阶段，处理过程中会将所有的活动对象往一端靠拢，整体移动完成后，直接清理掉边界外的内存。<br>Scavenge 算法比较适合内存较小的情况处理；而对于老生代内存较大、变量较多的时候，还是需要采用“标记-清除”结合“标记-整理”这样的方式处理内存问题，并尽量避免内存碎片的产生。<h3 id="内存泄漏与优化"><a href="#内存泄漏与优化" class="headerlink" title="内存泄漏与优化"></a>内存泄漏与优化</h3></li>
</ol>
<ul>
<li>内存泄漏的场景：</li>
</ul>
<ol>
<li>过多的缓存未释放；</li>
<li>闭包太多未释放；</li>
<li>定时器或者回调太多未释放；</li>
<li>太多无效的 DOM 未释放；</li>
<li>全局变量太多未被发现。</li>
</ol>
<h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><h3 id="时间、空间复杂度"><a href="#时间、空间复杂度" class="headerlink" title="时间、空间复杂度"></a>时间、空间复杂度</h3><p>通常，复杂度的计算方法遵循以下几个原则：</p>
<ol>
<li>首先，复杂度与具体的常系数无关，例如 O(n) 和 O(2n) 表示的是同样的复杂度。<br>我们详细分析下，O(2n) 等于 O(n+n)，也等于 O(n) + O(n)。<br>也就是说，一段 O(n) 复杂度的代码只是先后执行两遍 O(n)，其复杂度是一致的。</li>
<li>其次，多项式级的复杂度相加的时候，选择高者作为结果，例如 O(n²)+O(n) 和 O(n²) 表示的是同样的复杂度。<br>具体分析一下就是，O(n²)+O(n) = O(n²+n)。随着 n 越来越大，二阶多项式的变化率是要比一阶多项式更大的。<br>因此，只需要通过更大变化率的二阶多项式来表征复杂度就可以了。</li>
<li>值得一提的是，O(1) 也是表示一个特殊复杂度，含义为某个任务通过有限可数的资源即可完成。<br>此处有限可数的具体意义是，与输入数据量 n 无关。</li>
<li>一个顺序结构的代码，时间复杂度是 O(1)。</li>
<li>二分查找，或者更通用地说是采用分而治之的二分策略，时间复杂度都是 O(logn)。这个我们会在后续课程讲到。</li>
<li>一个简单的 for 循环，时间复杂度是 O(n)。</li>
<li>两个顺序执行的 for 循环，时间复杂度是 O(n)+O(n)=O(2n)，其实也是 O(n)。</li>
<li>两个嵌套的 for 循环，时间复杂度是 O(n²)。</li>
<li>程序优化的最核心的思路，简单梳理如下：<br>第一步，暴力解法。在没有任何时间、空间约束下，完成代码任务的开发。<br>第二步，无效操作处理。将代码中的无效计算、无效存储剔除，降低时间或空间复杂度。<br>第三步，时空转换。设计合理数据结构，完成时间复杂度向空间复杂度的转移。<h3 id="增删查"><a href="#增删查" class="headerlink" title="增删查"></a>增删查</h3></li>
<li>链表和数组一样，都是 O(n) 空间复杂度的复杂数据结构。但其区别之一就是，数组有 index 的索引，而链表没有。<br>① 有了 index 的索引，所以我们就可以直接进行查找操作来，这里的时间复杂度为 O(1)。<br>② 链表因为没有索引，只能“一个接一个”地按照位置条件查找，在这种情况下时间复杂度就是 O (n)。</li>
<li>数据处理的基本操作只有 3 个，分别是增、删、查。其中，增和删又可以细分为在数据结构中间的增和删，以及在数据结构最后的增和删。<br>区别就在于原数据的位置是否发生改变。查找又可以细分为按照位置条件的查找和按照数据数值特征的查找。<br>几乎所有的数据处理，都是这些基本操作的组合和叠加。<h3 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h3></li>
</ol>
<ul>
<li>最常用的是链式表达，通常也叫作线性链表或者链表。</li>
</ul>
<ol>
<li>虽然链表在新增和删除数据上有优势，但仔细思考就会发现，这个优势并不实用。这主要是因为，在新增数据时，通常会伴随一个查找的动作。例如，在第五个结点后，新增一个新的数据结点，那么执行的操作就包含两个步骤：<br>①第一步，查找第五个结点；<br>②第二步，再新增一个数据结点。整体的复杂度就是 O(n) + O(1)，也就是O(n)。</li>
<li>线性表真正的价值在于，它对数据的存储方式是按照顺序的存储。<br>如果数据的元素个数不确定，且需要经常进行数据的新增和删除时，那么链表会比较合适。<br>如果数据元素大小确定，删除插入的操作并不多，那么数组可能更适合些。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">例 1，链表的翻转。给定一个链表，输出翻转后的链表。例如，输入1 -&gt;2 -&gt; 3 -&gt; 4 -&gt;5，输出 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1。</span><br><span class="line">我们来仔细看一下这个问题的难点在哪里，这里有两种情况：</span><br><span class="line">如果是数组的翻转，这会非常容易。原因在于，数组在连续的空间进行存储，可以直接求解出数组的长度。而且，数组可以通过索引值去查找元素，然后对相应的数据进行交换操作而完成翻转。</span><br><span class="line">但对于某个单向链表，它的指针结构造成了它的数据通路有去无回，一旦修改了某个指针，后面的数据就会造成失联的状态。为了解决这个问题，我们需要构造三个指针 prev、curr 和 next，对当前结点、以及它之前和之后的结点进行缓存，再完成翻转动作。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">例 2，给定一个奇数个元素的链表，查找出这个链表中间位置的结点的数值。</span><br><span class="line">这个问题也是利用了链表的长度无法直接获取的不足做文章，解决办法如下：</span><br><span class="line">一个暴力的办法是，先通过一次遍历去计算链表的长度，这样我们就知道了链表中间位置是第几个。接着再通过一次遍历去查找这个位置的数值。</span><br><span class="line">除此之外，还有一个巧妙的办法，就是利用快慢指针进行处理。其中快指针每次循环向后跳转两次，而慢指针每次向后跳转一次。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">例 3，判断链表是否有环。</span><br><span class="line">假设链表有环，这个环里面就像是一个跑步赛道的操场一样。经过多次循环之后，快指针和慢指针都会进入到这个赛道中，就好像两个跑步选手在比赛。</span><br><span class="line">快指针每次走两格，而慢指针每次走一格，相对而言，快指针每次循环会多走一步。</span><br><span class="line">这就意味着：如果链表存在环，快指针和慢指针一定会在环内相遇，即 fast == slow 的情况一定会发生。</span><br><span class="line">反之，则最终会完成循环，二者从未相遇。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><h4 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h4><ol>
<li>栈的顺序存储可以借助数组来实现。一般来说，会把数组的首元素存在栈底，最后一个元素放在栈顶。<br>然后定义一个 top 指针来指示栈顶元素在数组中的位置。假设栈中只有一个数据元素，则 top = 0。<br>一般以 top 是否为 -1 来判定是否为空栈。<br>当定义了栈的最大容量为 StackSize 时，则栈顶 top 必须小于 StackSize。</li>
<li>对于查找操作，栈没有额外的改变，跟线性表一样，它也需要遍历整个栈来完成基于某些条件的数值查找。</li>
<li>删除数据元素，即出栈操作，只需要 top - 1 就可以了。<h4 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h4></li>
<li>关于链式栈，就是用链表的方式对栈的表示。</li>
<li>在链式栈中进行删除操作时，只能在栈顶进行操作。因此，将栈顶的 top 指针指向栈顶元素的 next 指针即可完成删除。</li>
<li>对于链式栈来说，新增删除数据元素没有任何循环操作，其时间复杂度均为 O(1)。</li>
</ol>
<ul>
<li>不管是顺序栈还是链栈，数据的新增、删除、查找与线性表的操作原理极为相似，时间复杂度完全一样，都依赖当前位置的指针来进行数据对象的操作。区别仅仅在于新增和删除的对象，只能是栈顶的数据结点。<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3>队列也存在这两种存储方式，即顺序队列和链式队列：</li>
</ul>
<ol>
<li>顺序队列，依赖数组来实现，其中的数据在内存中也是顺序存储。</li>
<li>而链式队列，则依赖链表来实现，其中的数据依赖每个结点的指针互联，在内存中并不是顺序存储。链式队列，实际上就是只能尾进头出的线性表的单链表。</li>
<li>队列从队头（front）删除元素，从队尾（rear）插入元素。</li>
<li>队列新增数据的操作，就是利用 rear 指针在队尾新增一个数据元素。这个过程不会影响其他数据，时间复杂度为 O(1)</li>
<li>队列删除数据的操作与栈不同。队列元素出口在队列头部，即下标为 0 的位置。当利用 front 指针删除一个数据时，队列中剩余的元素都需要向前移动一个位置，以保证队列头部下标为 0 的位置不为空，此时时间复杂度就变成 O(n) <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">采用顺序存储的队列时，我们可以通过移动指针的方式来删除数据，这样就不需要移动剩余的数据了。</span><br><span class="line">但是，这样的操作，也可能会产生数组越界的问题。</span><br><span class="line">两个简单粗暴的解决方法就是：</span><br><span class="line">1. 不惜消耗 O(n) 的时间复杂度去移动数据；</span><br><span class="line">2. 或者开辟足够大的内存空间确保数组不会越界。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h4><ol>
<li>循环队列进行新增数据元素操作时，首先判断队列是否为满。<br>如果不满，则可以将新元素赋值给队尾，然后让 rear 指针向后移动一个位置。<br>如果已经排到队列最后的位置，则 rea r指针重新指向头部。</li>
<li>循环队列进行删除操作时，即出队列操作，需要判断队列是否为空，然后将队头元素赋值给返回值，front 指针向后移一个位置。<br>如果已经排到队列最后的位置，就把 front 指针重新指向到头部。<br>这个过程就好像钟表的指针转到了表盘的尾部 12 点的位置后，又重新回到了表盘头部 1 点钟的位置。<br>这样就能在不开辟大量存储空间的前提下，不采用 O(n) 的操作，也能通过移动数据来完成频繁的新增和删除数据。</li>
<li>此时，又会产生新的问题，即当队列为空时，有 front 指针和 rear 指针相等。<br>而现在的队列是满的，同样有 front 指针和 rear 指针相等。<br>那么怎样判断队列到底是空还是满呢？常用的方法是，设置一个标志变量 flag 来区别队列是空还是满。<h4 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h4></li>
<li>链式队列就是一个单链表，同时增加了 front 指针和 rear 指针。<br>链式队列和单链表一样，通常会增加一个头结点，并另 front 指针指向头结点。<br>头结点不存储数据，只是用来辅助标识。</li>
<li>特别值得一提的是，如果这个链表除去头结点外只剩一个元素，那么删除仅剩的一个元素后，rear 指针就变成野指针了。<br>这时候，需要让 rear 指针指向头结点。也许你前面会对头结点存在的意义产生怀疑，似乎没有它也不影响增删的操作。</li>
<li>那么为何队列还特被强调要有头结点呢？<br>这主要是为了防止删除最后一个有效数据结点后， front 指针和 rear 指针变成野指针，导致队列没有意义了。<br>有了头结点后，哪怕队列为空，头结点依然存在，能让 front 指针和 rear 指针依然有意义。</li>
</ol>
<ul>
<li>空间性能方面，循环队列必须有一个固定的长度，因此存在存储元素数量和空间的浪费问题，而链式队列不存在这种问题，所以在空间上，链式队列更为灵活一些。</li>
<li>通常情况下，在可以确定队列长度最大值时，建议使用循环队列。无法确定队列长度时，应考虑使用链式队列。队列具有先进先出的特点，很像现实中人们排队买票的场景。在面对数据处理顺序非常敏感的问题时，队列一定是个不错的技术选型。<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3></li>
<li>树是由结点和边组成的，不存在环的一种数据结构。</li>
<li>没有父结点，则可以称为根结点</li>
<li>没有子结点，则称为叶子结点</li>
<li>树中结点的最大层次数，就是这棵树的树深（称为深度，也称为高度）</li>
<li>树数据的查找操作和链表一样，都需要遍历每一个数据去判断，所以时间复杂度是 O(n)。</li>
<li>对于查找操作，如果是普通二叉树，则查找的时间复杂度和遍历一样，都是 O(n)。如果是二叉查找树，则可以在 O(logn) 的时间复杂度内完成查找动作。<h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4></li>
<li>在二叉树中，每个结点最多有两个分支，即每个结点最多有两个子结点，分别称作左子结点和右子结点。</li>
<li>满二叉树，定义为除了叶子结点外，所有结点都有 2 个子结点。</li>
<li>完全二叉树，定义为除了最后一层以外，其他层的结点个数都达到最大，并且最后一层的叶子结点都靠左排列。之所以称为完全二叉树，是从存储空间利用效率的视角来看的。对于一棵完全二叉树而言，仅仅浪费了下标为 0 的存储位置。而如果是一棵非完全二叉树，则会浪费大量的存储空间。</li>
<li>存储二叉树有两种办法，一种是基于指针的链式存储法，另一种是基于数组的顺序存储法。</li>
<li>根据基于数组的顺序存储法，我们可以发现如果结点 X 的下标为 i，那么 X 的左子结点总是存放在 2 <em> i 的位置，X 的右子结点总是存放在 2 </em> i + 1 的位置。<h5 id="二叉查找树（二叉搜索树）"><a href="#二叉查找树（二叉搜索树）" class="headerlink" title="二叉查找树（二叉搜索树）"></a>二叉查找树（二叉搜索树）</h5></li>
<li>在二叉查找树中的任意一个结点，其左子树中的每个结点的值，都要小于这个结点的值。</li>
<li>在二叉查找树中的任意一个结点，其右子树中每个结点的值，都要大于这个结点的值。</li>
<li>在二叉查找树中，会尽可能规避两个结点数值相等的情况。</li>
<li>对二叉查找树进行中序遍历，就可以输出一个从小到大的有序数据队列。</li>
<li>在利用二叉查找树执行查找操作时，我们可以进行以下判断：</li>
</ul>
<ol>
<li>首先判断根结点是否等于要查找的数据，如果是就返回。</li>
<li>如果根结点大于要查找的数据，就在左子树中递归执行查找动作，直到叶子结点。</li>
<li>如果根结点小于要查找的数据，就在右子树中递归执行查找动作，直到叶子结点。</li>
<li>这样的“二分查找”所消耗的时间复杂度就可以降低为 O(logn)。</li>
</ol>
<ul>
<li>二叉查找树插入数据的时间复杂度是 O(logn)。但这并不意味着它比普通二叉树要复杂。原因在于这里的时间复杂度更多是消耗在了遍历数据去找到查找位置上，真正执行插入动作的时间复杂度仍然是 O(1)。</li>
<li>二叉查找树的删除操作会比较复杂，这是因为删除完某个结点后的树，仍然要满足二叉查找树的性质。</li>
</ul>
<ol>
<li>情况一，如果要删除的结点是某个叶子结点，则直接删除，将其父结点指针指向 null 即可。</li>
<li>情况二，如果要删除的结点只有一个子结点，只需要将其父结点指向的子结点的指针换成其子结点的指针即可。</li>
<li>情况三，如果要删除的结点有两个子结点，则有两种可行的操作方式。①找到这个结点的左子树中最大的结点，替换要删除的结点。②找到这个结点的右子树中最小的结点，替换要删除的结点。<h5 id="Trie-树，或字典树"><a href="#Trie-树，或字典树" class="headerlink" title="Trie 树，或字典树"></a>Trie 树，或字典树</h5></li>
</ol>
<ul>
<li>根结点不包含字符</li>
<li>除根结点外每一个结点都只包含一个字符；</li>
<li>从根结点到某一叶子结点，路径上经过的字符连接起来，即为集合中的某个字符串。<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3></li>
<li>哈希表的设计采用了函数映射的思想，将记录的存储位置与记录的关键字关联起来。这样的设计方式，能够快速定位到想要查找的记录，而且不需要与表中存在的记录的关键字比较后再来进行查找。</li>
<li>如果有一种方法，可以实现“地址 = f (关键字)”的映射关系，那么就可以快速完成基于数据的数值的查找了。这就是哈希表的核心思想</li>
<li>Hash 函数设计的好坏会直接影响到对哈希表的操作效率。</li>
<li>哈希冲突，是需要在设计哈希函数时进行规避的</li>
<li>常用的设计哈希函数的方法：</li>
</ul>
<ol>
<li>直接定制法<br>哈希函数为关键字到地址的线性函数。如，H (key) = a*key + b。 这里，a 和 b 是设置好的常数。</li>
<li>数字分析法<br>假设关键字集合中的每个关键字 key 都是由 s 位数字组成（k1,k2,…,Ks），并从中提取分布均匀的若干位组成哈希地址。上面张一、张二、张三、张四的手机号信息存储，就是使用的这种方法。</li>
<li>平方取中法<br>如果关键字的每一位都有某些数字重复出现，并且频率很高，我们就可以先求关键字的平方值，通过平方扩大差异，然后取中间几位作为最终存储地址。</li>
<li>折叠法<br>如果关键字的位数很多，可以将关键字分割为几个等长的部分，取它们的叠加和的值（舍去进位）作为哈希地址。</li>
<li>除留余数法<br>预先设置一个数 p，然后对关键字进行取余运算。即地址为 key mod p。</li>
</ol>
<ul>
<li>解决哈希冲突</li>
</ul>
<ol>
<li>开放定址法<br>即当一个关键字和另一个关键字发生冲突时，使用某种探测技术在哈希表中形成一个探测序列，然后沿着这个探测序列依次查找下去。当碰到一个空的单元时，则插入其中。<br>常用的探测方法是线性探测法。<br>比如有一组关键字 {12，13，25，23}，采用的哈希函数为 key mod 11。<br>当插入 12，13，25 时可以直接插入，地址分别为 1、2、3。而当插入 23 时，哈希地址为 23 mod 11 = 1。然而，地址 1 已经被占用，因此沿着地址 1 依次往下探测，直到探测到地址 4，发现为空，则将 23 插入其中。</li>
<li>链地址法<br>将哈希地址相同的记录存储在一张线性链表中。</li>
</ol>
<ul>
<li>哈希表相对于其他数据结构有很多的优势。它可以提供非常快速的插入-删除-查找操作，无论多少数据，插入和删除值需要接近常量的时间。在查找方面，哈希表的速度比树还要快，基本可以瞬间查找到想要的元素。</li>
<li>哈希表也有一些不足。哈希表中的数据是没有顺序概念的，所以不能以一种固定的方式（比如从小到大）来遍历其中的元素。在数据处理顺序敏感的问题时，选择哈希表并不是个好的处理方法。同时，哈希表中的 key 是不允许重复的，在重复性非常高的数据中，哈希表也不是个好的选择。<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3></li>
<li>递归的核心思想是把规模大的问题转化为规模小的相似的子问题来解决。</li>
<li>当一个问题同时满足以下 2 个条件时，就可以使用递归的方法求解：</li>
</ul>
<ol>
<li>可以拆解为除了数据规模以外，求解思路完全相同的子问题；</li>
<li>存在终止条件。<h3 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h3></li>
</ol>
<ul>
<li>分治法的核心思想就是“分而治之”。</li>
<li>利用分而治之的思想，就可以把一个大规模、高难度的问题，分解为若干个小规模、低难度的小问题。随后，开发者将面对多个简单的问题，并很快地找到答案各个击破。在把这些简单问题解决好之后，我们通过把这些小问题的答案合并，就得到了原问题的答案。</li>
<li>二分查找，则是利用分治法去解决查找问题。通常二分查找需要一个前提，那就是输入的数列是有序的。</li>
<li>二分查找的时间复杂度是 O(logn)，这也是分治法普遍具备的特性。当你面对某个代码题，而且约束了时间复杂度是 O(logn) 或者是 O(nlogn) 时，可以想一下分治法是否可行。</li>
<li>二分查找的循环次数并不确定。一般是达到某个条件就跳出循环。因此，编码的时候，多数会采用 while 循环加 break 跳出的代码结构。</li>
<li>二分查找处理的原问题必须是有序的。因此，当你在一个有序数据环境中处理问题时，可以考虑分治法。相反，如果原问题中的数据并不是有序的，则使用分治法的可能性就会很低了。<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3></li>
<li>衡量一个排序算法的优劣，我们主要会从以下 3 个角度进行分析：</li>
</ul>
<ol>
<li>时间复杂度，具体包括，最好时间复杂度、最坏时间复杂度以及平均时间复杂度。</li>
<li>空间复杂度，如果空间复杂度为 1，也叫作原地排序。</li>
<li>稳定性，排序的稳定性是指相等的数据对象，在排序之后，顺序是否能保证不变。</li>
<li>排序最暴力的方法，时间复杂度是 O(n*n)。这恰如冒泡排序和插入排序。</li>
<li>当我们利用算法思维去解决问题时，就会想到尝试分治法。此时，利用归并排序就能让时间复杂度降低到 O(nlogn)。然而，归并排序需要额外开辟临时空间。一方面是为了保证稳定性，另一方面则是在归并时，由于在数组中插入元素导致了数据挪移的问题。</li>
<li>为了规避因此而带来的时间损耗，此时我们采用快速排序。通过交换操作，可以解决插入元素导致的数据挪移问题，而且降低了不必要的空间开销。但是由于其动态二分的交换数据，导致了由此得出的排序结果并不稳定。</li>
<li>如果对数据规模比较小的数据进行排序，可以选择时间复杂度为 O(n<em>n) 的排序算法。因为当数据规模小的时候，时间复杂度 O(nlogn) 和 O(n</em>n) 的区别很小，它们之间仅仅相差几十毫秒，因此对实际的性能影响并不大。</li>
<li>但对数据规模比较大的数据进行排序，就需要选择时间复杂度为 O(nlogn) 的排序算法了。归并排序的空间复杂度为 O(n)，也就意味着当排序 100M 的数据，就需要 200M 的空间，所以对空间资源消耗会很多。快速排序在平均时间复杂度为 O(nlogn)，但是如果分区点选择不好的话，最坏的时间复杂度也有可能逼近 O(n*n)。而且快速排序不具备稳定性，这也需要看你所面对的问题是否有稳定性的需求。<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4></li>
</ol>
<ul>
<li>冒泡排序最好时间复杂度是 O(n)，也就是当输入数组刚好是顺序的时候，只需要挨个比较一遍就行了，不需要做交换操作，所以时间复杂度为 O(n)。</li>
<li>冒泡排序最坏时间复杂度会比较惨，是 O(n<em>n)。也就是说当数组刚好是完全逆序的时候，每轮排序都需要挨个比较 n 次，并且重复 n 次，所以时间复杂度为 O(n</em>n)。</li>
<li>很显然，当输入数组杂乱无章时，它的平均时间复杂度也是 O(n*n)。</li>
<li>冒泡排序不需要额外的空间，所以空间复杂度是 O(1)。冒泡排序过程中，当元素相同时不做交换，所以冒泡排序是稳定的排序算法。<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4></li>
<li>选取未排序的元素，插入到已排序区间的合适位置，直到未排序区间为空。插入排序顾名思义，就是从左到右维护一个已经排好序的序列。直到所有的待排数据全都完成插入的动作。</li>
<li>插入排序最好时间复杂度是 O(n)，即当数组刚好是完全顺序时，每次只用比较一次就能找到正确的位置。这个过程重复 n 次，就可以清空未排序区间。</li>
<li>插入排序最坏时间复杂度则需要 O(n<em>n)。即当数组刚好是完全逆序时，每次都要比较 n 次才能找到正确位置。这个过程重复 n 次，就可以清空未排序区间，所以最坏时间复杂度为 O(n</em>n)。</li>
<li>插入排序的平均时间复杂度是 O(n<em>n)。这是因为往数组中插入一个元素的平均时间复杂度为 O(n)，而插入排序可以理解为重复 n 次的数组插入操作，所以平均时间复杂度为 O(n</em>n)。</li>
<li>插入排序不需要开辟额外的空间，所以空间复杂度是 O(1)。<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4></li>
<li>归并排序法的原理是分治法。</li>
<li>对于归并排序，它采用了二分的迭代方式，复杂度是 logn。</li>
<li>每次的迭代，需要对两个有序数组进行合并，这样的动作在 O(n) 的时间复杂度下就可以完成。因此，归并排序的复杂度就是二者的乘积 O(nlogn)。同时，它的执行频次与输入序列无关，因此，归并排序最好、最坏、平均时间复杂度都是 O(nlogn)。</li>
<li>空间复杂度方面，由于每次合并的操作都需要开辟基于数组的临时内存空间，所以空间复杂度为 O(n)。归并排序合并的时候，相同元素的前后顺序不变，所以归并是稳定的排序算法。<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4></li>
<li>快速排序法的原理也是分治法。</li>
<li>的每轮迭代，会选取数组中任意一个数据作为分区点，将小于它的元素放在它的左侧，大于它的放在它的右侧。再利用分治思想，继续分别对左右两侧进行同样的操作，直至每个区间缩小为 1，则完成排序。</li>
<li>在快排的最好时间的复杂度下，如果每次选取分区点时，都能选中中位数，把数组等分成两个，那么此时的时间复杂度和归并一样，都是 O(n*logn)。</li>
<li>而在最坏的时间复杂度下，也就是如果每次分区都选中了最小值或最大值，得到不均等的两组。那么就需要 n 次的分区操作，每次分区平均扫描 n / 2 个元素，此时时间复杂度就退化为 O(n*n) 了。</li>
<li>快速排序法在大部分情况下，统计上是很难选到极端情况的。因此它平均的时间复杂度是 O(n*logn)。</li>
<li>快速排序法的空间方面，使用了交换法，因此空间复杂度为 O(1)。</li>
<li>很显然，快速排序的分区过程涉及交换操作，所以快排是不稳定的排序算法。<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3></li>
<li>从数学的视角来看，动态规划是一种运筹学方法，是在多轮决策过程中的最优方法。</li>
<li>从分治法的视角来看，每个子问题必须相互独立。但在多轮决策中，这个假设显然不成立。这也是动态规划方法产生的原因之一。</li>
<li>动态规划有一个重要概念叫作状态。</li>
<li>一般而言，具有如下几个特征的问题，可以采用动态规划求解：</li>
</ul>
<ol>
<li>最优子结构。它的含义是，原问题的最优解所包括的子问题的解也是最优的。例如，某个策略使得 A 到 G 是最优的。假设它途径了 Fi，那么它从 A 到 Fi 也一定是最优的。</li>
<li>无后效性。某阶段的决策，无法影响先前的状态。可以理解为今天的动作改变不了历史。</li>
<li>有重叠子问题。也就是，子问题之间不独立。这个性质是动态规划区别于分治法的条件。如果原问题不满足这个特征，也是可以用动态规划求解的，无非就是杀鸡用了宰牛刀。<h2 id="new-apply-call-bind"><a href="#new-apply-call-bind" class="headerlink" title="new/apply/call/bind"></a>new/apply/call/bind</h2><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3></li>
</ol>
<ul>
<li>new 关键词的主要作用就是执行一个构造函数、返回一个实例对象，在 new 的过程中，根据构造函数的情况，来确定是否可以接受参数的传递。</li>
<li>new 在这个生成实例的过程中,大致分为以下几个步骤:</li>
</ul>
<ol>
<li>创建一个新对象；</li>
<li>将构造函数的作用域赋给新对象（this 指向新对象）；</li>
<li>执行构造函数中的代码（为这个新对象添加属性）；</li>
<li>返回新对象。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//如果不用 new 这个关键词，会发生什么样的变化呢？</span><br><span class="line">function Person()&#123;</span><br><span class="line"></span><br><span class="line">  this.name = &apos;Jack&apos;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p = Person();</span><br><span class="line"></span><br><span class="line">console.log(p) // undefined</span><br><span class="line"></span><br><span class="line">console.log(name) // Jack</span><br><span class="line"></span><br><span class="line">console.log(p.name) // &apos;name&apos; of undefined</span><br><span class="line"></span><br><span class="line">//当构造函数中有 return 一个对象的操作，结果又会是什么样子呢？</span><br><span class="line">function Person()&#123;</span><br><span class="line"></span><br><span class="line">   this.name = &apos;Jack&apos;; </span><br><span class="line"></span><br><span class="line">   return &#123;age: 18&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p = new Person(); </span><br><span class="line"></span><br><span class="line">console.log(p)  // &#123;age: 18&#125;</span><br><span class="line"></span><br><span class="line">console.log(p.name) // undefined</span><br><span class="line"></span><br><span class="line">console.log(p.age) // 18</span><br></pre></td></tr></table></figure>
<ul>
<li><p>构造函数必须是返回一个对象，如果返回的不是对象，那么还是会按照 new 的实现步骤，返回新生成的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line"></span><br><span class="line">   this.name = &apos;Jack&apos;; </span><br><span class="line"></span><br><span class="line">   return &apos;tom&apos;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p = new Person(); </span><br><span class="line"></span><br><span class="line">console.log(p)  // &#123;name: &apos;Jack&apos;&#125;</span><br><span class="line"></span><br><span class="line">console.log(p.name) // Jack</span><br></pre></td></tr></table></figure>
</li>
<li><p>new 关键词执行之后总是会返回一个对象，要么是实例对象，要么是 return 语句指定的对象。</p>
<h3 id="call-apply-bind"><a href="#call-apply-bind" class="headerlink" title="call/apply/bind"></a>call/apply/bind</h3></li>
<li><p>call、apply 和 bind 是挂在 Function 对象上的三个方法，调用这三个方法的必须是一个函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func.call(thisArg, param1, param2, ...)</span><br><span class="line"></span><br><span class="line">func.apply(thisArg, [param1,param2,...])</span><br><span class="line"></span><br><span class="line">func.bind(thisArg, param1, param2, ...)</span><br></pre></td></tr></table></figure>
</li>
<li><p>bind 虽然改变了 func 的 this 指向，但不是马上执行，而这两个（call、apply）是在改变了函数的 this 指向之后立马执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">let a = &#123;</span><br><span class="line"></span><br><span class="line">  name: &apos;jack&apos;,</span><br><span class="line"></span><br><span class="line">  getName: function(msg) &#123;</span><br><span class="line"></span><br><span class="line">    return msg + this.name;</span><br><span class="line"></span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let b = &#123;</span><br><span class="line"></span><br><span class="line">  name: &apos;lily&apos;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(a.getName(&apos;hello~&apos;));  // hello~jack</span><br><span class="line"></span><br><span class="line">console.log(a.getName.call(b, &apos;hi~&apos;));  // hi~lily</span><br><span class="line"></span><br><span class="line">console.log(a.getName.apply(b, [&apos;hi~&apos;]))  // hi~lily</span><br><span class="line"></span><br><span class="line">let name = a.getName.bind(b, &apos;hello~&apos;);</span><br><span class="line"></span><br><span class="line">console.log(name());  // hello~lily</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="手写实现"><a href="#手写实现" class="headerlink" title="手写实现"></a>手写实现</h3><h4 id="new-1"><a href="#new-1" class="headerlink" title="new"></a>new</h4><ul>
<li>new 被调用后大致做了哪几件事情。</li>
</ul>
<ol>
<li>让实例可以访问到私有属性；</li>
<li>让实例可以访问构造函数原型（constructor.prototype）所在原型链上的属性；</li>
<li>构造函数返回的最后结果是引用数据类型。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function _new(ctor, ...args) &#123;</span><br><span class="line"></span><br><span class="line">    if(typeof ctor !== &apos;function&apos;) &#123;</span><br><span class="line"></span><br><span class="line">      throw &apos;ctor must be a function&apos;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let obj = new Object();</span><br><span class="line"></span><br><span class="line">    obj.__proto__ = Object.create(ctor.prototype);</span><br><span class="line"></span><br><span class="line">    //关键  this指向</span><br><span class="line">    let res = ctor.apply(obj,  [...args]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    let isObject = typeof res === &apos;object&apos; &amp;&amp; res !== null;</span><br><span class="line"></span><br><span class="line">    let isFunction = typeof res === &apos;function&apos;;</span><br><span class="line"></span><br><span class="line">    return isObject || isFunction ? res : obj;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="call-apply"><a href="#call-apply" class="headerlink" title="call/apply"></a>call/apply</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.call = function (context, ...args) &#123;</span><br><span class="line"></span><br><span class="line">  var context = context || window;</span><br><span class="line">  //当前this指向Function.prototype上面的方法</span><br><span class="line">  context.fn = this;</span><br><span class="line"></span><br><span class="line">  var result = eval(&apos;context.fn(...args)&apos;);</span><br><span class="line"></span><br><span class="line">  delete context.fn</span><br><span class="line"></span><br><span class="line">  return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Function.prototype.apply = function (context, args) &#123;</span><br><span class="line"></span><br><span class="line">  let context = context || window;</span><br><span class="line">  //当前this指向Function.prototype上面的方法</span><br><span class="line">  context.fn = this;</span><br><span class="line"></span><br><span class="line">  let result = eval(&apos;context.fn(...args)&apos;);</span><br><span class="line"></span><br><span class="line">  delete context.fn</span><br><span class="line"></span><br><span class="line">  return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind = function (context, ...args) &#123;</span><br><span class="line"></span><br><span class="line">    if (typeof this !== &quot;function&quot;) &#123;</span><br><span class="line"></span><br><span class="line">      throw new Error(&quot;this must be a function&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var self = this;</span><br><span class="line"></span><br><span class="line">    var fbound = function () &#123;</span><br><span class="line"></span><br><span class="line">        self.apply(this instanceof fbound ? this : context, args.concat(Array.prototype.slice.call(arguments)));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(this.prototype) &#123;</span><br><span class="line"></span><br><span class="line">      fbound.prototype = Object.create(this.prototype);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return fbound;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//new (Math.max.bind(this))();</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>方法特征</th>
<th>call</th>
<th>apply</th>
<th>bind</th>
</tr>
</thead>
<tbody>
<tr>
<td>方法参数</td>
<td>多个</td>
<td>单个数组</td>
<td>多个</td>
</tr>
<tr>
<td>方法功能</td>
<td>函数调用改变this</td>
<td>函数调用改变this</td>
<td>函数调用改变this</td>
</tr>
<tr>
<td>返回结果</td>
<td>直接执行</td>
<td>直接执行</td>
<td>返回待执行函数</td>
</tr>
<tr>
<td>底层实现</td>
<td>通过eval</td>
<td>通过eval</td>
<td>间接调用apply</td>
</tr>
</tbody>
</table>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2021/03/25/note/">学习记录</a></p>
        <p><span>文章作者:</span><a href="/" title="访问 DiamondsZz 的个人博客">DiamondsZz</a></p>
        <p><span>发布时间:</span>2021年03月25日</p>
        <p><span>最后更新:</span>2021年04月05日 - 13时57分</p>    
    </div>



<nav id="article-nav">
  
    <a href="/2021/03/29/algorithm/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          算法
        
      </div>
    </a>
  
  
    <a href="/2021/03/08/record/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">记录</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>


  
</article>

    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#数据类型"><span class="toc-number">1.</span> <span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据类型检测"><span class="toc-number">2.</span> <span class="toc-text">数据类型检测</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据类型转换"><span class="toc-number">3.</span> <span class="toc-text">数据类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#拷贝"><span class="toc-number">4.</span> <span class="toc-text">拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#浅拷贝"><span class="toc-number">4.1.</span> <span class="toc-text">浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#深拷贝"><span class="toc-number">4.2.</span> <span class="toc-text">深拷贝</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#继承"><span class="toc-number">5.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#垃圾回收"><span class="toc-number">6.</span> <span class="toc-text">垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#内存管理"><span class="toc-number">6.1.</span> <span class="toc-text">内存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#chrome内存回收机制"><span class="toc-number">6.2.</span> <span class="toc-text">chrome内存回收机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#新生代内存回收"><span class="toc-number">6.2.1.</span> <span class="toc-text">新生代内存回收</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#老生代内存回收"><span class="toc-number">6.2.2.</span> <span class="toc-text">老生代内存回收</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存泄漏与优化"><span class="toc-number">6.3.</span> <span class="toc-text">内存泄漏与优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据结构与算法"><span class="toc-number">7.</span> <span class="toc-text">数据结构与算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#时间、空间复杂度"><span class="toc-number">7.1.</span> <span class="toc-text">时间、空间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#增删查"><span class="toc-number">7.2.</span> <span class="toc-text">增删查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线性表"><span class="toc-number">7.3.</span> <span class="toc-text">线性表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#栈"><span class="toc-number">7.4.</span> <span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#顺序栈"><span class="toc-number">7.4.1.</span> <span class="toc-text">顺序栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#链栈"><span class="toc-number">7.4.2.</span> <span class="toc-text">链栈</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#队列"><span class="toc-number">7.5.</span> <span class="toc-text">队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#循环队列"><span class="toc-number">7.5.1.</span> <span class="toc-text">循环队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#链式队列"><span class="toc-number">7.5.2.</span> <span class="toc-text">链式队列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#树"><span class="toc-number">7.6.</span> <span class="toc-text">树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#二叉树"><span class="toc-number">7.6.1.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#二叉查找树（二叉搜索树）"><span class="toc-number">7.6.1.1.</span> <span class="toc-text">二叉查找树（二叉搜索树）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Trie-树，或字典树"><span class="toc-number">7.6.1.2.</span> <span class="toc-text">Trie 树，或字典树</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#哈希表"><span class="toc-number">7.7.</span> <span class="toc-text">哈希表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#递归"><span class="toc-number">7.8.</span> <span class="toc-text">递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分治"><span class="toc-number">7.9.</span> <span class="toc-text">分治</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#排序"><span class="toc-number">7.10.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#冒泡排序"><span class="toc-number">7.10.1.</span> <span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#插入排序"><span class="toc-number">7.10.2.</span> <span class="toc-text">插入排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#归并排序"><span class="toc-number">7.10.3.</span> <span class="toc-text">归并排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#快速排序"><span class="toc-number">7.10.4.</span> <span class="toc-text">快速排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态规划"><span class="toc-number">7.11.</span> <span class="toc-text">动态规划</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new-apply-call-bind"><span class="toc-number">8.</span> <span class="toc-text">new/apply/call/bind</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#new"><span class="toc-number">8.1.</span> <span class="toc-text">new</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#call-apply-bind"><span class="toc-number">8.2.</span> <span class="toc-text">call/apply/bind</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#手写实现"><span class="toc-number">8.3.</span> <span class="toc-text">手写实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#new-1"><span class="toc-number">8.3.1.</span> <span class="toc-text">new</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#call-apply"><span class="toc-number">8.3.2.</span> <span class="toc-text">call/apply</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bind"><span class="toc-number">8.3.3.</span> <span class="toc-text">bind</span></a></li></ol></li></ol></li></ol>
</div>
<style>
    .left-col .switch-btn {
        display: none;
    }
    .left-col .switch-area {
        display: none;
    }
</style>
<input type="button" id="tocButton" value="隐藏目录" title="点击按钮隐藏或者显示文章目录">

<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>

<script>
    var valueHide = "隐藏目录";
    var valueShow = "显示目录";
    if ($(".left-col").is(":hidden")) {
        $("#tocButton").attr("value", valueShow);
    }
    $("#tocButton").click(function() {
        if ($("#toc").is(":hidden")) {
            $("#tocButton").attr("value", valueHide);
            $("#toc").slideDown(320);
            $(".switch-btn, .switch-area").fadeOut(300);
        }
        else {
            $("#tocButton").attr("value", valueShow);
            $("#toc").slideUp(350);
            $(".switch-btn, .switch-area").fadeIn(500);
        }
    })
    if ($(".toc").length < 1) {
        $("#toc, #tocButton").hide();
        $(".switch-btn, .switch-area").show();
    }
</script>






    



    <div class="scroll" id="post-nav-button">
        
            <a href="/2021/03/29/algorithm/" title="上一篇: 算法">
                <i class="fa fa-angle-left"></i>
            </a>
        
        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>
        
            <a href="/2021/03/08/record/" title="下一篇: 记录">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>
    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/03/29/algorithm/">算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/25/note/">学习记录</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/08/record/">记录</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/01/10/project/">前端工程</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/01/10/study/">前端学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/01/10/ts/">typescript</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/01/10/webpack/">前端构建</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/16/log/">前端记录</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/24/vue/">vue</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/02/life/">记录生活</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/30/bug/">遇到的一些坑</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/17/es6/">es6</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/14/js/">js</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/10/store/">杂货铺</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/03/wfe/">前端笔记</a></li></ul>
    
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>

    <script>
        $(".post-list").addClass("toc-article");
        // $(".post-list-item a").attr("target","_blank");
        $("#post-nav-button > a:nth-child(2)").click(function() {
            $(".fa-bars, .fa-times").toggle();
            $(".post-list").toggle(300);
            if ($(".toc").length > 0) {
                $("#toc, #tocButton").toggle(200, function() {
                    if ($(".switch-area").is(":visible")) {
                        $("#toc, .switch-btn, .switch-area").toggle();
                        $("#tocButton").attr("value", valueHide);
                        }
                    })
            }
            else {
                $(".switch-btn, .switch-area").fadeToggle(300);
            }
        })
    </script>




    <script>
        
    </script>

</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2021 DiamondsZz
            </div>        
        </div>
    </div>
</footer>

    </div>
    
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>

<script src="/js/main.js"></script>

    <script>
        $(document).ready(function() {
            var backgroundnum = 1;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>






<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" "="">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(
            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


  </div>
</body>
</html>