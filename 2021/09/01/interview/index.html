<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  <meta name="baidu-site-verification" content="L6Lm9d5Crl">
  
  
  
  
  <title>起个名字真难 | DiamondsZz</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="前端基础http/https123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979">
<meta name="keywords" content="学习,资源,网站">
<meta property="og:type" content="article">
<meta property="og:title" content="起个名字真难">
<meta property="og:url" content="https://DiamondsZz.github.io/2021/09/01/interview/index.html">
<meta property="og:site_name" content="DiamondsZz">
<meta property="og:description" content="前端基础http/https123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2022-10-09T14:36:41.033Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="起个名字真难">
<meta name="twitter:description" content="前端基础http/https123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979">
  
    <link rel="alternative" href="/atom.xml" title="DiamondsZz" type="application/atom+xml">
  
  
  
  <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet">
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: false,
          isPost: true,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        
<script src="https://www.unpkg.com/jquery@3.6.0/dist/jquery.js"></script>

        <a href="/" class="profilepic">
            
            <img lazy-src="/img/iu.jpeg" class="js-avatar">
            
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">DiamondsZz</a></h1>
        </hgroup>
        
        <p class="header-subtitle">DiamondsZz</p>
        
        
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        
        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                        </ul>
                    </nav>
                </section>
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/css/" style="font-size: 12.5px;">css</a> <a href="/tags/js/" style="font-size: 15px;">js</a> <a href="/tags/学习/" style="font-size: 20px;">学习</a> <a href="/tags/生活，心情/" style="font-size: 10px;">生活，心情</a> <a href="/tags/网站/" style="font-size: 17.5px;">网站</a> <a href="/tags/资源/" style="font-size: 17.5px;">资源</a>
                    </div>
                </section>
                
                
                
                
                <section class="switch-part switch-part3">
                
                    <div id="js-aboutme">矮穷矬!</div>
                </section>
                
            </div>
        </div>
    </header>
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">DiamondsZz</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/img/iu.jpeg" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">DiamondsZz</a></h1>
            </hgroup>
            
            <p class="header-subtitle">DiamondsZz</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                </div>
            </nav>
        </header>
    </div>
</nav>
      <div class="body-wrap"><article id="post-interview" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2021/09/01/interview/" class="article-date">
      <time datetime="2021-08-31T16:00:00.000Z" itemprop="datePublished">2021-09-01</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      起个名字真难
    </h1>
  


      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/学习/">学习</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/学习/">学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网站/">网站</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/资源/">资源</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="前端基础"><a href="#前端基础" class="headerlink" title="前端基础"></a>前端基础</h2><h3 id="http-https"><a href="#http-https" class="headerlink" title="http/https"></a>http/https</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line">1.http: 超文本传输协议，是一个客户端和服务器端请求和应答的标准</span><br><span class="line">可靠传输。这个特点显而易见，因为 HTTP 协议是基于 TCP/IP 的，而 TCP 本身是一个“可靠”的传输协议，所以 HTTP 自然也就继承了这个特性，能够在请求方和应答方之间“可靠”地传输数据。</span><br><span class="line">应用层协议。HTTP 几乎可以传递一切东西，满足各种需求，称得上是一个“万能”的协议。</span><br><span class="line">我们可以再对比一下 UDP 协议，不过它是无连接也无状态的，顺序发包乱序收包，数据包发出去后就不管了，收到后也不会顺序整理。而 HTTP 是有连接无状态，顺序发包顺序收包，按照收发的顺序管理报文。</span><br><span class="line"></span><br><span class="line">2.https: 是以安全为目标的 HTTP 通道，简单讲是 HTTP 的安全版，即 HTTP 下加入 SSL层</span><br><span class="line">SSL/TLS，它是一个负责加密通信的安全协议，建立在 TCP/IP 之上，所以也是个可靠的传输协议</span><br><span class="line">SSL 的全称是“Secure Socket Layer”，由网景公司发明，当发展到 3.0 时被标准化，改名为 TLS，即“Transport Layer Security”，</span><br><span class="line">但由于历史的原因还是有很多人称之为 SSL/TLS，或者直接简称为 SSL。</span><br><span class="line"></span><br><span class="line">TLS 协议的组成</span><br><span class="line">TLS 包含几个子协议，你也可以理解为它是由几个不同职责的模块组成，比较常用的有记录协议、警报协议、握手协议、变更密码规范协议等。</span><br><span class="line">记录协议（Record Protocol）规定了 TLS 收发数据的基本单位,所有的其他子协议都需要通过记录协议发出。</span><br><span class="line">警报协议（Alert Protocol）的职责是向对方发出警报信息，有点像是 HTTP 协议里的状态码。</span><br><span class="line">握手协议（Handshake Protocol）是 TLS 里最复杂的子协议，浏览器和服务器会在握手过程中协商 TLS 版本号、随机数、密码套件等信息，然后交换证书和密钥参数，最终双方协商得到会话密钥，用于后续的混合加密系统。</span><br><span class="line">变更密码规范协议（Change Cipher Spec Protocol），它非常简单，就是一个“通知”，告诉对方，后续的数据都将使用加密保护。那么反过来，在它之前，数据都是明文的。</span><br><span class="line"></span><br><span class="line">ECDHE 握手过程</span><br><span class="line">在 TCP 建立连接之后，浏览器会首先发一个“Client Hello”消息，也就是跟服务器“打招呼”。里面有客户端的版本号、支持的密码套件，还有一个随机数（Client Random），用于后续生成会话密钥。这个的意思就是：“我这边有这些这些信息，你看看哪些是能用的，关键的随机数可得留着。”</span><br><span class="line">作为“礼尚往来”，服务器收到“Client Hello”后，会返回一个“Server Hello”消息。把版本号对一下，也给出一个随机数（Server Random），然后从客户端的列表里选一个作为本次通信使用的密码套件，在这里它选择了“TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384”。这个的意思就是：“版本号对上了，可以加密，你的密码套件挺多，我选一个最合适的吧，用椭圆曲线加 RSA、AES、SHA384。我也给你一个随机数，你也得留着。”</span><br><span class="line">然后，服务器为了证明自己的身份，就把证书也发给了客户端（Server Certificate）。</span><br><span class="line">接下来是一个关键的操作，因为服务器选择了 ECDHE 算法，所以它会在证书后发送“Server Key Exchange”消息，里面是椭圆曲线的公钥（Server Params），用来实现密钥交换算法，再加上自己的私钥签名认证。这相当于说：“刚才我选的密码套件有点复杂，所以再给你个算法的参数，和刚才的随机数一样有用，别丢了。为了防止别人冒充，我又盖了个章。”</span><br><span class="line">这样第一个消息往返就结束了（两个 TCP 包），结果是客户端和服务器通过明文共享了三个信息：Client Random、Server Random 和 Server Params。</span><br><span class="line">客户端这时也拿到了服务器的证书，那这个证书是不是真实有效的呢？开始走证书链逐级验证，确认证书的真实性，再用证书公钥验证签名，就确认了服务器的身份：“刚才跟我打招呼的不是骗子，可以接着往下走。”</span><br><span class="line">然后，客户端按照密码套件的要求，也生成一个椭圆曲线的公钥（Client Params），用“Client Key Exchange”消息发给服务器。</span><br><span class="line">现在客户端和服务器手里都拿到了密钥交换算法的两个参数（Client Params、Server Params），就用 ECDHE 算法一阵算，算出了一个新的东西，叫“Pre-Master”，其实也是一个随机数。</span><br><span class="line">现在客户端和服务器手里有了三个随机数：Client Random、Server Random 和 Pre-Master。用这三个作为原始材料，就可以生成用于加密会话的主密钥，叫“Master Secret”。而黑客因为拿不到“Pre-Master”，所以也就得不到主密钥。</span><br><span class="line">为什么非得这么麻烦，非要三个随机数呢？这就必须说 TLS 的设计者考虑得非常周到了，他们不信任客户端或服务器伪随机数的可靠性，为了保证真正的“完全随机”“不可预测”，把三个不可靠的随机数混合起来，那么“随机”的程度就非常高了，足够让黑客难以猜测。</span><br><span class="line">主密钥有 48 字节，但它也不是最终用于通信的会话密钥，还会再用 PRF 扩展出更多的密钥，比如客户端发送用的会话密钥（client_write_key）、服务器发送用的会话密钥（server_write_key）等等，避免只用一个密钥带来的安全隐患。</span><br><span class="line">有了主密钥和派生的会话密钥，握手就快结束了。客户端发一个“Change Cipher Spec”，然后再发一个“Finished”消息，把之前所有发送的数据做个摘要，再加密一下，让服务器做个验证。意思就是告诉服务器：“后面都改用对称算法加密通信了啊，用的就是打招呼时说的 AES，加密对不对还得你测一下。”</span><br><span class="line">服务器也是同样的操作，发“Change Cipher Spec”和“Finished”消息，双方都验证加密解密 OK，握手正式结束，后面就收发被加密的 HTTP 请求和响应了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RSA 握手过程</span><br><span class="line">RSA 握手过程大体的流程没有变，只是“Pre-Master”不再需要用算法生成，而是客户端直接生成随机数，然后用服务器的公钥加密，通过“Client Key Exchange”消息发给服务器。服务器再用私钥解密，这样双方也实现了共享三个随机数，就可以生成主密钥。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3.HTTP/1.0增加了 HEAD、POST 等新方法；</span><br><span class="line">增加了响应状态码，标记可能的错误原因；</span><br><span class="line">引入了协议版本号概念；</span><br><span class="line">引入了 HTTP Header（头部）的概念，让 HTTP 处理请求和响应更加灵活；</span><br><span class="line">传输的数据不再仅限于文本。</span><br><span class="line"></span><br><span class="line">4.HTTP/1.1 主要的变更点有：</span><br><span class="line">增加了 PUT、DELETE 等新的方法；</span><br><span class="line">增加了缓存管理和控制；</span><br><span class="line">明确了连接管理，允许持久连接；</span><br><span class="line">允许响应数据分块（chunked），利于传输大文件；</span><br><span class="line"></span><br><span class="line">TTP/1.1 中的连接都会默认启用长连接。不需要用什么特殊的头字段指定，只要向服务器发送了第一次请求，后续的请求都会重复利用第一次打开的 TCP 连接，也就是长连接，在这个连接上收发数据。</span><br><span class="line">请求头里明确地要求使用长连接机制，使用的字段是 Connection，值是“keep-alive”。</span><br><span class="line">TCP 连接长时间不关闭，服务器必须在内存里保存它的状态，这就占用了服务器的资源。如果有大量的空闲长连接只连不发，就会很快耗尽服务器的资源，导致服务器无法为真正有需要的用户提供服务。</span><br><span class="line">服务器端通常不会主动关闭连接，但也可以使用一些策略。拿 Nginx 来举例，它有两种方式：</span><br><span class="line">使用“keepalive_timeout”指令，设置长连接的超时时间，如果在一段时间内连接上没有任何数据收发就主动断开连接，避免空闲连接占用系统资源。</span><br><span class="line">使用“keepalive_requests”指令，设置长连接上可发送的最大请求次数。比如设置成 1000，那么当 Nginx 在这个连接上处理了 1000 个请求后，也会主动断开连接。</span><br><span class="line">另外，客户端和服务器都可以在报文里附加通用头字段“Keep-Alive: timeout=value”，限定长连接的超时时间。但这个字段的约束力并不强，通信的双方可能并不会遵守，所以不太常见。</span><br><span class="line"></span><br><span class="line">队头阻塞</span><br><span class="line">因为 HTTP 规定报文必须是“一发一收”，这就形成了一个先进先出的“串行”队列。队列里的请求没有轻重缓急的优先级，只有入队的先后顺序，排在最前面的请求被最优先处理。</span><br><span class="line">如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本。</span><br><span class="line"></span><br><span class="line">性能优化 </span><br><span class="line">“域名分片”（domain sharding）技术，还是用数量来解决质量的思路。HTTP 协议和浏览器不是限制并发连接数量吗？好，那我就多开几个域名，比如 shard1.diamonds.com、shard2.diamonds.com，而这些域名都指向同一台服务器 www.diamonds.com，这样实际长连接的数量就又上去了，真是“美滋滋”。不过实在是有点“上有政策，下有对策”的味道。</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">5.HTTP/2在高度兼容 HTTP/1.1 的同时在性能改善方面做了很大努力，主要的特点有：</span><br><span class="line">二进制协议，不再是纯文本；</span><br><span class="line">可发起多个请求，废弃了 1.1 里的管道；</span><br><span class="line">使用专用算法压缩头部，减少数据传输量；</span><br><span class="line">允许服务器主动向客户端推送数据；</span><br><span class="line">增强了安全性，“事实上”要求加密通信。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">头部压缩</span><br><span class="line">HTTP/1 里可以用头字段“Content-Encoding”指定 Body 的编码方式，比如用 gzip 压缩来节约带宽，但报文的另一个组成部分——Header 却被无视了，没有针对它的优化手段。</span><br><span class="line">由于报文 Header 一般会携带“User Agent”“Cookie”“Accept”“Server”等许多固定的头字段，多达几百字节甚至上千字节，但 Body 却经常只有几十字节（比如 GET 请求、204/301/304 响应），成了不折不扣的“大头儿子”。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">二进制格式</span><br><span class="line">它把 TCP 协议的部分特性挪到了应用层，把原来的“Header+Body”的消息“打散”为数个小片的二进制“帧”（Frame），用“HEADERS”帧存放头数据、“DATA”帧存放实体数据。</span><br><span class="line"></span><br><span class="line">虚拟的“流”</span><br><span class="line">HTTP/2 为此定义了一个“流”（Stream）的概念，它是二进制帧的双向传输序列，同一个消息往返的帧会分配一个唯一的流 ID。你可以把它想象成是一个虚拟的“数据流”，在里面流动的是一串有先后顺序的数据帧，这些数据帧按照次序组装起来就是 HTTP/1 里的请求报文和响应报文。</span><br><span class="line">因为“流”是虚拟的，实际上并不存在，所以 HTTP/2 就可以在一个 TCP 连接上用“流”同时发送多个“碎片化”的消息，这就是常说的“多路复用”（ Multiplexing）——多个往返通信都复用一个连接来处理。</span><br><span class="line">HTTP/2 还在一定程度上改变了传统的“请求 - 应答”工作模式，服务器不再是完全被动地响应请求，也可以新建“流”主动向客户端发送消息。比如，在浏览器刚请求 HTML 的时候就提前把可能会用到的 JS、CSS 文件发给客户端，减少等待的延迟，这被称为“服务器推送”（Server Push，也叫 Cache Push）。</span><br><span class="line">为了区分“加密”和“明文”这两个不同的版本，HTTP/2 协议定义了两个字符串标识符：“h2”表示加密的 HTTP/2，“h2c”表示明文的 HTTP/2，多出的那个字母“c”的意思是“clear text”。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">6.HTTP/3 HTTP over QUIC</span><br><span class="line">HTTP/2 虽然使用“帧”“流”“多路复用”，没有了“队头阻塞”，但这些手段都是在应用层里，而在下层，也就是 TCP 协议里，还是会发生“队头阻塞”。</span><br><span class="line">TCP 为了保证可靠传输，有个特别的“丢包重传”机制，丢失的包必须要等待重新传输确认，其他的包即使已经收到了，也只能放在缓冲区里，上层的应用拿不出来，只能“干着急”。</span><br><span class="line"></span><br><span class="line">客户端用 TCP 发送了三个包，但服务器所在的操作系统只收到了后两个包，第一个包丢了。那么内核里的 TCP 协议栈就只能把已经收到的包暂存起来，“停下”等着客户端重传那个丢失的包，这样就又出现了“队头阻塞”。</span><br><span class="line">由于这种“队头阻塞”是 TCP 协议固有的，所以 HTTP/2 即使设计出再多的“花样”也无法解决。</span><br><span class="line"></span><br><span class="line">HTTP/3 有一个关键的改变，那就是它把下层的 TCP“抽掉”了，换成了 UDP。因为 UDP 是无序的，包之间没有依赖关系，所以就从根本上解决了“队头阻塞”。</span><br><span class="line">UDP 是一个简单、不可靠的传输协议，只是对 IP 协议的一层很薄的包装，和 TCP 相比，它实际应用的较少。不过正是因为它简单，不需要建连和断连，通信成本低，也就非常灵活、高效，“可塑性”很强。</span><br><span class="line">所以，QUIC 就选定了 UDP，在它之上把 TCP 的那一套连接管理、拥塞窗口、流量控制等“搬”了过来，“去其糟粕，取其精华”，打造出了一个全新的可靠传输协议，可以认为是“新时代的 TCP”。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">QUIC 的特点</span><br><span class="line">QUIC 基于 UDP，而 UDP 是“无连接”的，根本就不需要“握手”和“挥手”，所以天生就要比 TCP 快。</span><br><span class="line">就像 TCP 在 IP 的基础上实现了可靠传输一样，QUIC 也基于 UDP 实现了可靠传输，保证数据一定能够抵达目的地。它还引入了类似 HTTP/2 的“流”和“多路复用”，单个“流”是有序的，可能会因为丢包而阻塞，但其他“流”不会受到影响。</span><br><span class="line">但 QUIC 并不是建立在 TLS 之上，而是内部“包含”了 TLS。它使用自己的帧“接管”了 TLS 里的“记录”，握手消息、警报消息都不使用 TLS 记录，直接封装成 QUIC 的帧发送，省掉了一次开销。</span><br><span class="line"></span><br><span class="line">HTTP/3 没有指定默认端口号，需要用 HTTP/2 的扩展帧“Alt-Svc”来发现。</span><br><span class="line">QUIC 内含了 TLS1.3，只能加密通信，支持 0-RTT 快速建连；</span><br><span class="line">QUIC 是一个新的传输层协议，建立在 UDP 之上，实现了可靠传输；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">7.正向代理：靠近客户端，代表客户端向服务器发送请求</span><br><span class="line">反向代理：靠近服务器端，代表服务器响应客户端的请求；</span><br><span class="line">CDN，实际上就是一种代理，它代替源站服务器响应客户端的请求，通常扮演着透明代理和反向代理的角色。</span><br><span class="line"></span><br><span class="line">8.1××：提示信息，表示目前是协议处理的中间状态，还需要后续的操作；</span><br><span class="line">2××：成功，报文已经收到并被正确处理；</span><br><span class="line">“204 No Content”是另一个很常见的成功状态码，它的含义与“200 OK”基本相同，但响应头后没有 body 数据。</span><br><span class="line">“206 Partial Content”是 HTTP 分块下载或断点续传的基础，在客户端发送“范围请求”、要求获取资源的部分数据时出现，它与 200 一样，也是服务器成功处理了请求，但 body 里的数据不是资源的全部，而是其中的一部分。状态码 206 通常还会伴随着头字段“Content-Range”，表示响应报文里 body 数据的具体范围，供客户端确认，</span><br><span class="line">例如“Content-Range: bytes 0-99/2000”，意思是此次获取的是总计 2000 个字节的前 100 个字节。</span><br><span class="line">3××：重定向，资源位置发生变动，需要客户端重新发送请求；</span><br><span class="line">“301 Moved Permanently”俗称“永久重定向”，含义是此次请求的资源已经不存在了，需要改用新的 URI 再次访问。</span><br><span class="line">比如，你的网站升级到了 HTTPS，原来的 HTTP 不打算用了，这就是“永久”的，所以要配置 301 跳转，把所有的 HTTP 流量都切换到 HTTPS。</span><br><span class="line">“302 Found”，曾经的描述短语是“Moved Temporarily”，俗称“临时重定向”，意思是请求的资源还在，但需要暂时用另一个 URI 来访问。301 和 302 都会在响应头里使用字段 Location 指明后续要跳转的 URI，最终的效果很相似，浏览器都会重定向到新的 URI。两者的根本区别在于语义，一个是“永久”，一个是“临时”，所以在场景、用法上差距很大。</span><br><span class="line">比如，今天夜里网站后台要系统维护，服务暂时不可用，这就属于“临时”的，可以配置成 302 跳转，把流量临时切换到一个静态通知页面，浏览器看到这个 302 就知道这只是暂时的情况，不会做缓存优化，第二天还会访问原来的地址。</span><br><span class="line">“304 Not Modified” 是一个比较有意思的状态码，它用于 If-Modified-Since 等条件请求，表示资源未修改，用于缓存控制。它不具有通常的跳转含义，但可以理解成“重定向已到缓存的文件”（即“缓存重定向”）。</span><br><span class="line">4××：客户端错误，请求报文有误，服务器无法处理；</span><br><span class="line">400 Bad Request”是一个通用的错误码，只是一个笼统的错误，客户端看到 400 只会是“一头雾水”“不知所措”。</span><br><span class="line">所以，在开发 Web 应用时应当尽量避免给客户端返回 400，而是要用其他更有明确含义的状态码。</span><br><span class="line">413 Request Entity Too Large：请求报文里的 body 太大；</span><br><span class="line">414 Request-URI Too Long：请求行里的 URI 太大；</span><br><span class="line">5××：服务器错误，服务器在处理请求时内部发生了错误</span><br><span class="line">“500 Internal Server Error”与 400 类似，也是一个通用的错误码，服务器究竟发生了什么错误我们是不知道的。不过对于服务器来说这应该算是好事，通常不应该把服务器内部的详细信息，例如出错的函数调用栈告诉外界。虽然不利于调试，但能够防止黑客的窥探或者分析。</span><br><span class="line">“502 Bad Gateway”通常是服务器作为网关或者代理时返回的错误码，表示服务器自身工作正常，访问后端服务器时发生了错误，但具体的错误原因也是不知道的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">9.MIME 是一个很大的标准规范，但 HTTP 只“顺手牵羊”取了其中的一部分，用来标记 body 的数据类型，这就是我们平常总能听到的“MIME type”。</span><br><span class="line">text：即文本格式的可读数据，我们最熟悉的应该就是 text/html 了，表示超文本文档，此外还有纯文本 text/plain、样式表 text/css 等。</span><br><span class="line">image：即图像文件，有 image/gif、image/jpeg、image/png 等。</span><br><span class="line">audio/video：音频和视频数据，例如 audio/mpeg、video/mp4 等。</span><br><span class="line">application：数据格式不固定，可能是文本也可能是二进制，必须由上层应用程序来解释。常见的有 application/json，application/javascript、application/pdf 等，另外，如果实在是不知道数据是什么类型，像刚才说的“黑盒”，就会是 application/octet-stream，即不透明的二进制数据。</span><br><span class="line"></span><br><span class="line">10.为了节约带宽，有时候还会压缩数据，Encoding type”，告诉数据是用的什么编码格式</span><br><span class="line">常用的只有下面三种：</span><br><span class="line">gzip：GNU zip 压缩格式，也是互联网上最流行的压缩格式；</span><br><span class="line">deflate：zlib（deflate）压缩格式，流行程度仅次于 gzip；</span><br><span class="line">br：一种专门为 HTTP 优化的新压缩算法（Brotli）。</span><br><span class="line"></span><br><span class="line">11.范围请求不是 Web 服务器必备的功能，可以实现也可以不实现，所以服务器必须在响应头里使用字段“Accept-Ranges: bytes”明确告知客户端：“我是支持范围请求的”。</span><br><span class="line">请求头 Range 是 HTTP 范围请求的专用字段，格式是“bytes=x-y”，其中的 x 和 y 是以字节为单位的数据范围。要注意 x、y 表示的是“偏移量”，范围必须从 0 计数，例如前 10 个字节表示为“0-9”，第二个 10 字节表示为“10-19”，而“0-10”实际上是前 11 个字节。</span><br><span class="line">服务器收到 Range 字段后，需要做四件事。</span><br><span class="line">第一，它必须检查范围是否合法，比如文件只有 100 个字节，但请求“200-300”，这就是范围越界了。服务器就会返回状态码 416，意思是“你的范围请求有误，我无法处理，请再检查一下”。</span><br><span class="line">第二，如果范围正确，服务器就可以根据 Range 头计算偏移量，读取文件的片段了，返回状态码“206 Partial Content”，和 200 的意思差不多，但表示 body 只是原数据的一部分。</span><br><span class="line">第三，服务器要添加一个响应头字段 Content-Range，告诉片段的实际偏移量和资源的总大小，格式是“bytes x-y/length”，与 Range 头区别在没有“=”，范围后多了总长度。例如，对于“0-10”的范围请求，值就是“bytes 0-10/100”。</span><br><span class="line">不仅看视频的拖拽进度需要范围请求，常用的下载工具里的多段下载、断点续传也是基于它实现的，要点是：</span><br><span class="line">先发个 HEAD，看服务器是否支持范围请求，同时获取文件的大小；</span><br><span class="line">开 N 个线程，每个线程使用 Range 字段划分出各自负责下载的片段，发请求传输数据；</span><br><span class="line">下载意外中断也不怕，不必重头再来一遍，只要根据上次的下载记录，用 Range 请求剩下的那一部分就可以了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">12.Cookie 的安全性</span><br><span class="line">属性“HttpOnly”会告诉浏览器，此 Cookie 只能通过浏览器 HTTP 协议传输，禁止其他方式访问，浏览器的 JS 引擎就会禁用 document.cookie 等一切相关的 API，脚本攻击也就无从谈起了。</span><br><span class="line">另一个属性“SameSite”可以防范“跨站请求伪造”（XSRF）攻击，设置成“SameSite=Strict”可以严格限定 Cookie 不能随着跳转链接跨站发送，而“SameSite=Lax”则略宽松一点，允许 GET/HEAD 等安全方法，但禁止 POST 跨站发送。</span><br><span class="line">还有一个属性叫“Secure”，表示这个 Cookie 仅能用 HTTPS 协议加密传输，明文的 HTTP 协议会禁止发送。但 Cookie 本身不是加密的，浏览器里还是以明文的形式存在。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">13.客户端的缓存控制</span><br><span class="line">当你点“刷新”按钮的时候，协商缓存</span><br><span class="line">Ctrl+F5 的“强制刷新”又是什么样的呢？请求头里面没有if-modified-since/if-none-match字段</span><br><span class="line"></span><br><span class="line">14.加密</span><br><span class="line">对称加密</span><br><span class="line">加密和解密时使用的密钥都是同一个，是“对称”的。只要保证了密钥的安全，那整个通信过程就可以说具有了机密性。</span><br><span class="line"></span><br><span class="line">非对称加密</span><br><span class="line">它有两个密钥，一个叫“公钥”（public key），一个叫“私钥”（private key）。两个密钥是不同的，“不对称”，公钥可以公开给任何人使用，而私钥必须严格保密。</span><br><span class="line">公钥和私钥有个特别的“单向”性，虽然都可以用来加密解密，但公钥加密后只能用私钥解密，反过来，私钥加密后也只能用公钥解密。</span><br><span class="line"></span><br><span class="line">混合加密</span><br><span class="line">在通信刚开始的时候使用非对称算法，比如 RSA、ECDHE，首先解决密钥交换的问题。</span><br><span class="line">然后用随机数产生对称算法使用的“会话密钥”（session key），再用公钥加密。</span><br></pre></td></tr></table></figure>
<h3 id="从输入URL到页面展示，这中间发生了什么？"><a href="#从输入URL到页面展示，这中间发生了什么？" class="headerlink" title="从输入URL到页面展示，这中间发生了什么？"></a>从输入URL到页面展示，这中间发生了什么？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1.URL 请求过程</span><br><span class="line">浏览器进程会通过进程间通信（IPC）把 URL 请求发送至网络进程，网络进程接收到 URL 请求后，会在这里发起真正的 URL 请求流程。</span><br><span class="line">网络进程会查找本地缓存是否缓存了该资源。如果有缓存资源，那么直接返回资源给浏览器进程；如果在缓存中没有查找到资源，那么直接进入网络请求流程。</span><br><span class="line">请求前的第一步是要进行 DNS 解析，以获取请求域名的服务器 IP 地址。如果请求协议是 HTTPS，那么还需要建立 TLS 连接。</span><br><span class="line">接下来就是利用 IP 地址和服务器建立 TCP 连接。连接建立之后，浏览器端会构建请求行、请求头等信息，并把和该域名相关的 Cookie 等数据附加到请求头中，然后向服务器发送构建的请求信息。</span><br><span class="line">服务器接收到请求信息后，会根据请求信息生成响应数据（包括响应行、响应头和响应体等信息），并发给网络进程。等网络进程接收了响应行和响应头之后，就开始解析响应头的内容了。</span><br><span class="line">在接收到服务器返回的响应头后，网络进程开始解析响应头，如果发现返回的状态码是 301 或者 302，那么说明服务器需要浏览器重定向到其他 URL。这时网络进程会从响应头的 Location 字段里面读取重定向的地址，然后再发起新的 HTTP 或者 HTTPS 请求，一切又重头开始了。</span><br><span class="line">在导航过程中，如果服务器响应行的状态码包含了 301、302 一类的跳转信息，浏览器会跳转到新的地址继续导航；如果响应行是 200，那么表示浏览器可以继续处理该请求。</span><br><span class="line">Content-Type 是 HTTP 头中一个非常重要的字段， 它告诉浏览器服务器返回的响应体数据是什么类型，然后浏览器会根据 Content-Type 的值来决定如何显示响应体的内容。</span><br><span class="line">Content-Type 的值是 application/octet-stream，显示数据是字节流类型的，通常情况下，浏览器会按照下载类型来处理该请求。</span><br><span class="line">如果 Content-Type 字段的值被浏览器判断为下载类型，那么该请求会被提交给浏览器的下载管理器，同时该 URL 请求的导航流程就此结束。但如果是 HTML，那么浏览器则会继续进行导航流程。由于 Chrome 的页面渲染是运行在渲染进程中的，所以接下来就需要准备渲染进程了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.渲染进程</span><br><span class="line">默认情况下，Chrome 会为每个页面分配一个渲染进程，也就是说，每打开一个新页面就会配套创建一个新的渲染进程。但是，也有一些例外，在某些情况下，浏览器会让多个页面直接运行在同一个渲染进程中。</span><br><span class="line">那什么情况下多个页面会同时运行在一个渲染进程中呢？</span><br><span class="line">https://time.diamonds.org</span><br><span class="line">https://www.diamonds.org</span><br><span class="line">https://www.diamonds.org:8080</span><br><span class="line">它们都是属于同一站点，因为它们的协议都是 HTTPS，而且根域名也都是 diamonds.org。</span><br><span class="line">Chrome 的默认策略是，每个标签对应一个渲染进程。但如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程。官方把这个默认策略叫 process-per-site-instance。</span><br><span class="line">总结来说，打开一个新页面采用的渲染进程策略就是：</span><br><span class="line">通常情况下，打开新的页面都会使用单独的渲染进程；如果从 A 页面打开 B 页面，且 A 和 B 都属于同一站点的话，那么 B 页面复用 A 页面的渲染进程；</span><br><span class="line">如果是其他情况，浏览器进程则会为 B 创建一个新的渲染进程。</span><br><span class="line">渲染进程准备好之后，还不能立即进入文档解析状态，因为此时的文档数据还在网络进程中，并没有提交给渲染进程，所以下一步就进入了提交文档阶段。</span><br><span class="line"></span><br><span class="line">所谓提交文档，就是指浏览器进程将网络进程接收到的 HTML 数据提交给渲染进程，具体流程是这样的：</span><br><span class="line">首先当浏览器进程接收到网络进程的响应头数据之后，便向渲染进程发起“提交文档”的消息；</span><br><span class="line">渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”；</span><br><span class="line">等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程；</span><br><span class="line">浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。</span><br><span class="line">这也就解释了为什么在浏览器的地址栏里面输入了一个地址后，之前的页面没有立马消失，而是要加载一会儿才会更新页面。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3.渲染流程</span><br><span class="line">按照渲染的时间顺序，流水线可分为如下几个子阶段：构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成。</span><br><span class="line"></span><br><span class="line">构建 DOM 树</span><br><span class="line">为什么要构建 DOM 树呢？这是因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM 树。</span><br><span class="line"></span><br><span class="line">样式计算（Recalculate Style）</span><br><span class="line">样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式，这个阶段大体可分为三步来完成。</span><br><span class="line">把 CSS 转换为浏览器能够理解的结构</span><br><span class="line">和 HTML 文件一样，浏览器也是无法直接理解这些纯文本的 CSS 样式，所以当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets。</span><br><span class="line">body &#123; font-size: 2em &#125;  =&gt; body &#123; font-size: 32px &#125;</span><br><span class="line">p &#123;color:blue;&#125;  =&gt; p &#123;rgba(0,0,255)&#125;</span><br><span class="line">span  &#123;display: none&#125;</span><br><span class="line">div &#123;font-weight: bold&#125;  =&gt; div &#123;font-weight: 700)&#125;</span><br><span class="line">div  p &#123;color:green;&#125; =&gt; div &#123;rgba(0,128,0)&#125;</span><br><span class="line">div &#123;color:red; &#125;  =&gt; div &#123;rgba(255,0,0)&#125;</span><br><span class="line">可以看到上面的 CSS 文本中有很多属性值，如 2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。</span><br><span class="line">首先是 CSS 继承。CSS 继承就是每个 DOM 节点都包含有父节点的样式。</span><br><span class="line">样式计算过程中的第二个规则是样式层叠。层叠是 CSS 的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法。它在 CSS 处于核心地位，CSS 的全称“层叠样式表”正是强调了这一点。</span><br><span class="line">总之，样式计算阶段的目的是为了计算出 DOM 节点中每个元素的具体样式，在计算过程中需要遵守 CSS 的继承和层叠两个规则。这个阶段最终输出的内容是每个 DOM 节点的样式，并被保存在 ComputedStyle 的结构内。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">布局阶段</span><br><span class="line">有 DOM 树和 DOM 树中元素的样式，但这还不足以显示页面，因为我们还不知道 DOM 元素的几何位置信息。那么接下来就需要计算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做布局。</span><br><span class="line">Chrome 在布局阶段需要完成两个任务：创建布局树和布局计算。</span><br><span class="line">创建布局树</span><br><span class="line">DOM 树还含有很多不可见的元素，比如 head 标签，还有使用了 display:none 属性的元素。所以在显示之前，我们还要额外地构建一棵只包含可见元素布局树。</span><br><span class="line">DOM 树中所有不可见的节点都没有包含到布局树中。</span><br><span class="line">布局计算</span><br><span class="line">在执行布局操作的时候，会把布局运算的结果重新写回布局树中，所以布局树既是输入内容也是输出内容，这是布局阶段一个不合理的地方，因为在布局阶段并没有清晰地将输入内容和输出内容区分开来。</span><br><span class="line">针对这个问题，Chrome 团队正在重构布局代码，下一代布局系统叫 LayoutNG，试图更清晰地分离输入和输出，从而让新设计的布局算法更加简单。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">分层</span><br><span class="line">浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。</span><br><span class="line">通常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层</span><br><span class="line">拥有层叠上下文属性的元素会被提升为单独的一层。页面是个二维平面，但是层叠上下文能够让 HTML 元素具有三维概念，这些 HTML 元素按照自身属性的优先级分布在垂直于这个二维平面的 z 轴上。</span><br><span class="line">明确定位属性的元素、定义透明属性的元素、使用 CSS 滤镜的元素等，都拥有层叠上下文属性。</span><br><span class="line">需要剪裁（clip）的地方也会被创建为图层。</span><br><span class="line"></span><br><span class="line">图层绘制</span><br><span class="line">在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制</span><br><span class="line"></span><br><span class="line">栅格化（raster）操作</span><br><span class="line">绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。</span><br><span class="line">当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程</span><br><span class="line">通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做视口（viewport）。</span><br><span class="line">在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。基于这个原因，合成线程会将图层划分为图块（tile）。</span><br><span class="line">合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的</span><br><span class="line">通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。GPU 操作是运行在 GPU 进程中，如果栅格化操作使用了 GPU，那么最终生成位图的操作是在 GPU 中完成的，这就涉及到了跨进程操作</span><br><span class="line">渲染进程把生成图块的指令发送给 GPU，然后在 GPU 中执行生成图块的位图，并保存在 GPU 的内存中</span><br><span class="line"></span><br><span class="line">合成和显示</span><br><span class="line">一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。</span><br><span class="line">浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">渲染总结</span><br><span class="line">一个完整的渲染流程大致可总结为如下：</span><br><span class="line">渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。</span><br><span class="line">渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。</span><br><span class="line">创建布局树，并计算元素的布局信息。</span><br><span class="line">对布局树进行分层，并生成分层树。</span><br><span class="line">为每个图层生成绘制列表，并将其提交到合成线程。</span><br><span class="line">合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。</span><br><span class="line">合成线程发送绘制图块命令 DrawQuad 给浏览器进程。</span><br><span class="line">浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">相关概念</span><br><span class="line">更新了元素的几何属性（重排）</span><br><span class="line">如果你通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。</span><br><span class="line">无疑，重排需要更新完整的渲染流水线，所以开销也是最大的。</span><br><span class="line">更新元素的绘制属性（重绘）</span><br><span class="line">如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。</span><br><span class="line">相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。</span><br><span class="line">直接合成阶段</span><br><span class="line">使用 CSS 的 transform 来实现动画效果，可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。</span><br><span class="line">这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，</span><br><span class="line">所以相对于重绘和重排，合成能大大提升绘制效率。</span><br></pre></td></tr></table></figure>
<h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line">// 常见宏任务：setTimeout()/setInterval()/setImmediate()/点击和键盘事件/...</span><br><span class="line">// 常见微任务：promise.then()/promise.catch()/new MutationObserver()/process.nextTick()</span><br><span class="line"></span><br><span class="line">// ------------------</span><br><span class="line">// node环境</span><br><span class="line">// timers:执行setTimeout与setInterval回调</span><br><span class="line">// pending callbacks:执行系统操作的回调，例如tcp、udp</span><br><span class="line">// idle,prepare:只在系统内部调用</span><br><span class="line">// poll:执行与I/O相关的回调,轮询等待新的链接和请求等事件。V8 引擎将 JS 代码解析并传入 Libuv 引擎后首先进入此阶段。如果此阶段任务队列已经执行完了，则进入 check 阶段执行 setImmediate 回调（如果有 setImmediate），或等待新的任务进来（如果没有 setImmediate）。在等待新的任务时，如果有 timers 计时到期，则会直接进入 timers 阶段。此阶段可能会阻塞等待。</span><br><span class="line">// check:执行setImmediate中的回调</span><br><span class="line">// close callbacks:执行close事件的回调</span><br><span class="line">// ----------------------------------</span><br><span class="line"></span><br><span class="line">// Nodejs完整事件环</span><br><span class="line">// 执行同步代码，将不同任务添加至相应的队列</span><br><span class="line">// 所有同步代码执行完成后会去执行满足条件的微任务</span><br><span class="line">// 所有微任务代码执行完会执行timer队列中满足得宏任务</span><br><span class="line">// timers中所有宏任务执行完成后就会依次切换队列（在完成队列切换之前会先清空微任务代码）</span><br><span class="line"></span><br><span class="line">// ------------------------------------------</span><br><span class="line"></span><br><span class="line">// 浏览器、node环境</span><br><span class="line">// 任务队列数不同</span><br><span class="line">// 微任务执行时机不同：二者都会在同步代码执行完毕后执行微任务、浏览器平台下每当一个宏任务执行完毕后就会清空微任务、node环境下在事件队列切换时会去清空微任务队列(新版node（NodeJS 11 ）与浏览器保持一致)</span><br><span class="line">// 微任务优先级：浏览器环境微任务存放于事件队列，先进先出、node环境中process.nextTick先于promise.then执行</span><br><span class="line"></span><br><span class="line">// -------------------------------------</span><br><span class="line"></span><br><span class="line">// setTimeout(()=&gt;&#123;&#125;,0)  不稳定，会产生延时     // timers</span><br><span class="line">// setImmediate(()=&gt;&#123;&#125;)                         // check</span><br><span class="line"></span><br><span class="line">// fs.readFile(&apos;./test.js&apos;,()=&gt;&#123;     // poll</span><br><span class="line">// setTimeout(()=&gt;&#123;&#125;,0)</span><br><span class="line">// setImmediate(()=&gt;&#123;&#125;)</span><br><span class="line">// &#125;)</span><br><span class="line"></span><br><span class="line">// -------------------------------</span><br><span class="line"></span><br><span class="line">// setTimeout(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">//     console.log(&apos;timeout&apos;);</span><br><span class="line"></span><br><span class="line">// &#125;, 0);</span><br><span class="line"></span><br><span class="line">// Promise.resolve().then(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">//     console.error(&apos;promise&apos;)</span><br><span class="line"></span><br><span class="line">// &#125;)</span><br><span class="line"></span><br><span class="line">// process.nextTick(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">//     console.error(&apos;nextTick&apos;)</span><br><span class="line"></span><br><span class="line">// &#125;)</span><br><span class="line"></span><br><span class="line">// // 输出：nextTick、promise、timeout</span><br><span class="line"></span><br><span class="line">// ----------------------</span><br><span class="line">// setTimeout(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">//   console.log(&apos;timeout&apos;);</span><br><span class="line"></span><br><span class="line">// &#125;, 0);</span><br><span class="line"></span><br><span class="line">// setImmediate(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">//   console.log(&apos;setImmediate&apos;);</span><br><span class="line"></span><br><span class="line">// &#125;);</span><br><span class="line"></span><br><span class="line">// // 输出：timeout、 setImmediate</span><br><span class="line"></span><br><span class="line">// 分析上面代码，第一轮循环后，分别将 setTimeout  和 setImmediate 加入了各自阶段的任务队列。</span><br><span class="line">// 第二轮循环首先进入timers 阶段，执行定时器队列回调，然后 pending callbacks和poll 阶段没有任务，</span><br><span class="line">// 因此进入check 阶段执行 setImmediate 回调。所以最后输出为“timeout”、“setImmediate”。</span><br><span class="line">// 当然这里还有种理论上的极端情况，就是第一轮循环结束后耗时很短，导致 setTimeout 的计时还没结束，此时第二轮循环则会先执行 setImmediate 回调。</span><br><span class="line"></span><br><span class="line">// ----------------------------------</span><br><span class="line">// const fs = require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">// fs.readFile(__filename, (data) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">//     console.log(&apos;readFile&apos;);</span><br><span class="line"></span><br><span class="line">//     setTimeout(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">//         console.log(&apos;timeout&apos;);</span><br><span class="line"></span><br><span class="line">//     &#125;, 0);</span><br><span class="line"></span><br><span class="line">//     setImmediate(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">//         console.log(&apos;setImmediate&apos;);</span><br><span class="line"></span><br><span class="line">//     &#125;);</span><br><span class="line"></span><br><span class="line">// &#125;);</span><br><span class="line"></span><br><span class="line">// // 输出：readFile、setImmediate、timeout</span><br><span class="line"></span><br><span class="line">// 如上面代码所示：</span><br><span class="line"></span><br><span class="line">// 第一轮循环没有需要执行的异步任务队列；</span><br><span class="line"></span><br><span class="line">// 第二轮循环 timers 等阶段都没有任务，只有 poll 阶段有 I/O 回调任务，即输出“readFile”；</span><br><span class="line"></span><br><span class="line">// 参考前面事件阶段的说明，接下来，poll 阶段会检测如果有 setImmediate 的任务队列则进入 check 阶段，否则再进行判断，如果有定时器任务回调，则回到 timers 阶段，所以应该进入 check 阶段执行 setImmediate，输出“setImmediate”；</span><br><span class="line"></span><br><span class="line">// 然后进入最后的 close callbacks 阶段，本次循环结束；</span><br><span class="line"></span><br><span class="line">// 最后进行第三轮循环，进入 timers 阶段，输出“timeout”。</span><br><span class="line"></span><br><span class="line">// 所以最终输出“setImmediate”在“timeout”之前。可见这两者的执行顺序与当前执行的阶段有关系。</span><br><span class="line"></span><br><span class="line">//浏览器事件循环</span><br><span class="line">//--------------------</span><br><span class="line">// JavaScript 引擎首先从宏任务队列（macrotask queue）中取出第一个任务；</span><br><span class="line">// 执行完毕后，再将微任务（microtask queue）中的所有任务取出，按照顺序分别全部执行（这里包括不仅指开始执行时队列里的微任务），如果在这一步过程中产生新的微任务，也需要执行；</span><br><span class="line">// 然后再从宏任务队列中取下一个，执行完毕后，再次将 microtask queue 中的全部取出，循环往复，直到两个 queue 中的任务都取完。</span><br><span class="line">// 总结起来就是：一次 Eventloop 循环会处理一个宏任务和所有这次循环中产生的微任务。</span><br><span class="line"></span><br><span class="line">// 各种浏览器事件同时触发时，肯定有一个先来后到的排队问题。决定这些事件如何排队触发的机制，就是事件循环。这个排队行为以 JavaScript 开发者的角度来看，主要是分成两个队列：</span><br><span class="line">// 一个是 JavaScript 外部的队列。外部的队列主要是浏览器协调的各类事件的队列，标准文件中称之为 Task Queue。下文中为了方便理解统一称为外部队列。</span><br><span class="line">// 另一个是 JavaScript 内部的队列。这部分主要是 JavaScript 内部执行的任务队列，标准中称之为 Microtask Queue。下文中为了方便理解统一称为内部队列。</span><br><span class="line">// 值得注意的是，虽然为了好理解我们管这个叫队列 (Queue)，但是本质上是有序集合 (Set)，因为传统的队列都是先进先出（FIFO）的，而这里的队列则不然，排到最前面但是没有满足条件也是不会执行的（比如外部队列里只有一个 setTimeout 的定时任务，但是时间还没有到，没有满足条件也不会把他出列来执行）。</span><br><span class="line"></span><br><span class="line">//外部队列</span><br><span class="line">// 外部队列（Task Queue 关于 Task，常有人称它为 Marcotask (宏任务)，但 HTML 标准中没有这种说法。），顾名思义就是 JavaScript 外部的事件的队列，这里我们可以先列举一下浏览器中这些外部事件源（Task Source），他们主要有：</span><br><span class="line">// DOM 操作 (页面渲染)</span><br><span class="line">// 用户交互 (鼠标、键盘)</span><br><span class="line">// 网络请求 (Ajax 等)</span><br><span class="line">// History API 操作</span><br><span class="line">// 定时器 (setTimeout 等)</span><br><span class="line">// HTML 标准中明确指出一个事件循环由一个或多个外部队列，而每一个外部事件源都有一个对应的外部队列。不同事件源的队列可以有不同的优先级（例如在网络事件和用户交互之间，浏览器可以优先处理鼠标行为，从而让用户感觉更加流程）。</span><br><span class="line">// scripts 执行也是一个事件，我们只要归类一下就会发现 JavaScript 的执行也是一个浏览器发起的外部事件。</span><br><span class="line"></span><br><span class="line">//内部队列</span><br><span class="line"></span><br><span class="line">// 内部队列（Microtask Queue），即 JavaScript 语言内部的事件队列，在 HTML 标准中，并没有明确规定这个队列的事件源，通常认为有以下几种：</span><br><span class="line">// Promise 的成功 (.then) 与失败 (.catch)</span><br><span class="line">// MutationObserver</span><br><span class="line">// Object.observe (已废弃)</span><br><span class="line"></span><br><span class="line">//node事件循环</span><br><span class="line">// 除了把 Eventloop 的宏任务细分到不同阶段外。node 还引入了一个新的任务队列 Process.nextTick()。</span><br><span class="line">// 可以认为，Process.nextTick() 会在上述各个阶段结束时，在进入下一个阶段之前立即执行（优先级甚至超过 microtask 队列）。</span><br><span class="line"></span><br><span class="line">//EventLoop 对渲染的影响</span><br><span class="line">// 浏览器作为一个复杂的应用是多线程工作的，除了运行 JS 的线程外，还有渲染线程、定时器触发线程、HTTP 请求线程，等等。JS 线程可以读取并且修改 DOM，而渲染线程也需要读取 DOM，这是一个典型的多线程竞争临界资源的问题。所以浏览器就把这两个线程设计成互斥的，即同时只能有一个线程在执行。</span><br><span class="line">//requestAnimationFrame 不是 Eventloop 里的宏任务，或者说它并不在 Eventloop 的生命周期里，只是浏览器又开放的一个在渲染之前发生的新的 hook。</span><br><span class="line">//当宏任务队列中没有任务可以处理时，浏览器可能存在“空闲状态”。这段空闲时间可以被 requestIdlecallback 利用起来执行一些优先级不高、不必立即执行的任务,当然为了防止浏览器一直处于繁忙状态，导致 requestIdlecallback 可能永远无法执行回调，它还提供了一个额外的 timeout 参数，为这个任务设置一个截止时间。浏览器就可以根据这个截止时间规划这个任务的执行。</span><br><span class="line"></span><br><span class="line">//async function async1() &#123;</span><br><span class="line">//  console.log(&quot;async1 start&quot;);</span><br><span class="line"></span><br><span class="line">//  await async2();</span><br><span class="line">  //await 后面方法的返回值决定了await下面代码的执行顺序</span><br><span class="line">//  console.log(&quot;async1 end&quot;);</span><br><span class="line">//&#125;</span><br><span class="line">//async function async2() &#123;</span><br><span class="line">  //1.async2()返回非promise时，await下面的代码在本次事件循环微任务执行之前执行</span><br><span class="line">  // setTimeout(() =&gt; &#123;</span><br><span class="line">  //   console.log(&quot;async2&quot;);</span><br><span class="line">  // &#125;);</span><br><span class="line">  //2.async2()返回非promise时，如果存在微任务，await下面的代码在本次事件循环微任务执行之前该微任务之后执行</span><br><span class="line">  // new Promise(function (resolve) &#123;</span><br><span class="line">  //   resolve();</span><br><span class="line">  // &#125;).then(function () &#123;</span><br><span class="line">  //   console.log(&quot;async2&quot;);</span><br><span class="line">  // &#125;);</span><br><span class="line">  //3.async2()返回promise时，是异步操作,await下面的代码在本次事件循环之后执行</span><br><span class="line">  // return new Promise(function (resolve) &#123;</span><br><span class="line">  //   resolve();</span><br><span class="line">  // &#125;).then(function () &#123;</span><br><span class="line">  //   console.log(&quot;async2&quot;);</span><br><span class="line">  // &#125;);</span><br><span class="line">  //4.同步代码直接执行</span><br><span class="line">  //console.log(&quot;async2&quot;);</span><br><span class="line">//&#125;</span><br></pre></td></tr></table></figure>
<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//  在 V8 中会把堆分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象。</span><br><span class="line">//  新生区通常只支持 1～8M 的容量，而老生区支持的容量就大很多了。对于这两块区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。</span><br><span class="line">//  副垃圾回收器，主要负责新生代的垃圾回收。主垃圾回收器，主要负责老生代的垃圾回收。</span><br><span class="line"></span><br><span class="line">// 副垃圾回收器</span><br><span class="line">// 副垃圾回收器主要负责新生区的垃圾回收。而通常情况下，大多数小的对象都会被分配到新生区，所以说这个区域虽然不大，但是垃圾回收还是比较频繁的。</span><br><span class="line">// 新生代中用 Scavenge 算法来处理。所谓 Scavenge 算法，是把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域</span><br><span class="line">// 新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。</span><br><span class="line">// 在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。</span><br><span class="line">// 完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时这种角色翻转的操作还能让新生代中的这两块区域无限重复使用下去。</span><br><span class="line">// 由于新生代中采用的 Scavenge 算法，所以每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域。但复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以为了执行效率，一般新生区的空间会被设置得比较小。</span><br><span class="line">// 也正是因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JavaScript 引擎采用了对象晋升策略，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。</span><br><span class="line"></span><br><span class="line">// 主垃圾回收器</span><br><span class="line">// 主垃圾回收器主要负责老生区中的垃圾回收。除了新生区中晋升的对象，一些大的对象会直接被分配到老生区。因此老生区中的对象有两个特点，一个是对象占用空间大，另一个是对象存活时间长。</span><br><span class="line">// 由于老生区的对象比较大，若要在老生区中使用 Scavenge 算法进行垃圾回收，复制这些大的对象将会花费比较多的时间，从而导致回收执行效率不高，同时还会浪费一半的空间。因而，主垃圾回收器是采用标记 - 清除（Mark-Sweep）的算法进行垃圾回收的。</span><br><span class="line">// 首先是标记过程阶段。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。</span><br><span class="line">// 接下来就是垃圾的清除过程。它和副垃圾回收器的垃圾清除过程完全不同</span><br><span class="line">// 对一块内存多次执行标记 - 清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存，于是又产生了另外一种算法——标记 - 整理（Mark-Compact），这个标记过程仍然与标记 - 清除算法里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</span><br><span class="line"></span><br><span class="line">//全停顿;</span><br><span class="line">// 由于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做全停顿（Stop-The-World）。</span><br><span class="line">// 比如堆中的数据有 1.5GB，V8 实现一次完整的垃圾回收需要 1 秒以上的时间，这也是由于垃圾回收而引起 JavaScript 线程暂停执行的时间，若是这样的时间花销，那么应用的性能和响应能力都会直线下降。</span><br><span class="line">// 在 V8 新生代的垃圾回收中，因其空间较小，且存活对象较少，所以全停顿的影响不大</span><br><span class="line">// 老生代就不一样了。如果在执行垃圾回收的过程中，占用主线程时间过久，主线程是不能做其他事情的。比如页面正在执行一个 JavaScript 动画，因为垃圾回收器在工作，就会导致这个动画在这 200 毫秒内无法执行的，这将会造成页面的卡顿现象。</span><br><span class="line">// 为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为增量标记（Incremental Marking）算法</span><br><span class="line">// 使用增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的 JavaScript 任务中间执行，这样当执行上述动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了。</span><br><span class="line"></span><br><span class="line">// 内存泄漏的场景：</span><br><span class="line">// 过多的缓存未释放；</span><br><span class="line">// 闭包太多未释放；</span><br><span class="line">// 定时器或者回调太多未释放；</span><br><span class="line">// 太多无效的 DOM 未释放；</span><br><span class="line">// 全局变量太多未被发现。</span><br></pre></td></tr></table></figure>
<h3 id="前端异常"><a href="#前端异常" class="headerlink" title="前端异常"></a>前端异常</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">//try...catch  语法错误，异步错误都无法捕获</span><br><span class="line">//window.onerror  语法错误无法捕获，异步错误可以捕获   只有返回值为true时，异常才不会向上抛出。最好先于js脚本执行，否则有些异常无法捕获。</span><br><span class="line">//window.addEventListener(&apos;error&apos;) 可以处理资源加载异常  需要在捕获阶段执行。  最好先于资源执行，否则异常可能无法捕获。</span><br><span class="line">//window.addEventListener(&apos;unhandledrejection&apos;) 全局捕获promise的异常</span><br><span class="line">//Promise Catch  promise异常最好通过catch方法进行捕获</span><br><span class="line">//iframe 异常 window.frames[0].onerror</span><br><span class="line">//Script error 一般情况，如果出现 Script error 这样的错误，基本上可以确定是跨域问题。这时候，是不会有其他太多辅助信息的，但是解决思路无非如下：跨源资源共享机制( CORS )：我们为 script 标签添加 crossOrigin 属性。</span><br><span class="line">//崩溃和卡顿  可以使用 Service Worker 来实现网页崩溃的监控：</span><br><span class="line">//VUE errorHandler</span><br><span class="line">//React 异常捕获  在React，可以使用ErrorBoundary组件包括业务组件的方式进行异常捕获，配合React 16.0+新出的componentDidCatch API，可以实现统一的异常捕获和日志上报。</span><br><span class="line"></span><br><span class="line">//数据上报</span><br><span class="line">// 如果数据上报接口与业务系统使用同一域名，浏览器对请求并发量有限制，所以存在网络资源竞争的可能性。</span><br><span class="line">// 浏览器通常在页面卸载时会忽略异步ajax请求，如果需要必须进行数据请求，一般在unload或者beforeunload事件中创建同步ajax请求，以此延迟页面卸载。从用户侧角度，就是页面跳转变慢。</span><br><span class="line">// Beacon 接口用来调度向 Web 服务器发送的异步非阻塞请求。</span><br><span class="line">// Beacon 请求使用 HTTP POST方法，并且不需要有响应。</span><br><span class="line">// Beacon 请求能确保在页面触发 unload 之前完成初始化。 通俗的讲就是，Beacon可将数据异步发送至服务端，且能够保证在页面卸载完成前发送请求（解决ajax页面卸载会终止请求的问题）。</span><br><span class="line"></span><br><span class="line">// Beacon 接口满足了分析和诊断代码的需要，这些代码通常会尝试在卸载文档之前将数据发送到 web服务器。发送数据的任何过早时机都可能导致错失收集数据的机会。但是，确保在卸载文档期间发送数据是开发人员难以做到的。</span><br><span class="line">// 用户代理通常会忽略卸载文档处理程序中的异步 XMLHttpRequests 请求。若要解决此问题，为了分析和诊断代码，通常会在 unload 事件或 beforeunload 事件中创建同步 XMLHttpRequest 请求以提交数据。同步 XMLHttpRequest 请求强制浏览器延迟卸载文档，并使下一个页面跳转看起来较慢。下一页面没有任何办法来避免这种页面加载性能不佳的感觉。</span><br><span class="line">// 其他技术也可以用来确保提交数据。其中一种技术是通过创建 Image 元素并在卸载文档处理程序中设置其 src 属性来延迟卸载以提交数据。由于大多数用户代理会延迟文档卸载，以完成挂起的图片加载，因此可以在卸载过程中提交数据。另一种方法是在卸载处理程序中创建一个无操作循环，花费数秒以延迟卸载并将数据提交到服务器。</span><br><span class="line">// 但是上述技术不仅代表了较差的编码模式，其中一些还是不可靠的，会导致下一个导航的页面加载性能较差的感觉。信标 API 提供了解决这些问题的标准方法。</span><br><span class="line"></span><br><span class="line">// navigator.sendBeacon(url, data);</span><br><span class="line">// 其中 data 参数是可选的，它的类型可以为 ArrayBufferView, Blob, DOMString 或者 FormData。如果浏览器成功地将 beacon 请求加入到待发送的队列里，这个方法将会返回 true ，否则将会返回 false</span><br><span class="line"></span><br><span class="line">// 使用Beacon时需要后台需要使用post方法接收参数，考虑到跨域问题，后台还需要改造接口配置CORS。同时请求头必须满足CORS-safelisted request-header，其中content-type的类型必须为application/x-www-form-urlencoded, multipart/form-data, 或者text/plain。</span><br><span class="line"></span><br><span class="line">// type ContentType = &apos;application/x-www-form-urlencoded&apos; | &apos;multipart/form-data&apos; | &apos;text/plain&apos;;</span><br><span class="line"></span><br><span class="line">// const serilizeParams = (params: object) =&gt; &#123;</span><br><span class="line">//     return window.btoa(JSON.stringify(params))</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">// function sendBeacon(url: string, params: object) &#123;</span><br><span class="line">//   const formData = new FormData()</span><br><span class="line">//   formData.append(&apos;params&apos;, serilizeParams(params))</span><br><span class="line">//   navigator.sendBeacon(url, formData)</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">// sendBeacon的兼容性问题是不可避免的，不过可以充分利用大部分浏览器会在页面卸载前完成图片的加载的特性，通过在页面添加img的方式上报数据。</span><br><span class="line"></span><br><span class="line">// function sendImage(url: string, params: object) &#123;</span><br><span class="line">//   const img = new Image()</span><br><span class="line"></span><br><span class="line">//   img.style.display = &apos;none&apos;</span><br><span class="line"></span><br><span class="line">//   const removeImage = function() &#123;</span><br><span class="line">//     img.parentNode.removeChild(img)</span><br><span class="line">//   &#125;</span><br><span class="line"></span><br><span class="line">//   img.onload = removeImage</span><br><span class="line">//   img.onerror = removeImage</span><br><span class="line"></span><br><span class="line">//   img.src = `$&#123;url&#125;?params=$&#123;serilizeParams(params)&#125;`</span><br><span class="line"></span><br><span class="line">//   document.body.appendChild(img)</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">// 由于img图片为get请求方式，不同服务器针对uri的长度有限制，长度超过限制时会出现HTTP 414错误，所以还要注意上报频率，减少一次性上传的属性过多。</span><br></pre></td></tr></table></figure>
<h3 id="js编译执行"><a href="#js编译执行" class="headerlink" title="js编译执行"></a>js编译执行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><span class="line">//  V8引擎执行 JS 代码要经过以下阶段</span><br><span class="line">//  Parse 阶段：V8 引擎负责将 JS 代码转换成 AST（抽象语法树）；</span><br><span class="line">//  Ignition 阶段：解释器将 AST 转换为字节码，解析执行字节码也会为下一个阶段优化编译提供需要的信息；</span><br><span class="line">//  TurboFan 阶段：编译器利用上个阶段收集的信息，将字节码优化为可以执行的机器码；</span><br><span class="line">//  Orinoco 阶段：垃圾回收阶段，将程序中不再使用的内存空间进行回收。</span><br><span class="line"></span><br><span class="line">// 生成 AST</span><br><span class="line">// 生成 AST 分为两个阶段，一是词法分析，二是语法分析</span><br><span class="line">// 词法分析：这个阶段会将源代码拆成最小的、不可再分的词法单元，称为 token。比如这行代码 var a =1；通常会被分解成 var 、a、=、2、; 这五个词法单元。另外刚才代码中的空格在 JavaScript 中是直接忽略的。</span><br><span class="line">// 语法分析：这个过程是将词法单元转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树，这个树被称为抽象语法树。</span><br><span class="line">// 现在浏览器还不支持 ES6 语法，需要将其转换成 ES5 语法，这个过程就要借助 Babel 来实现。将 ES6 源码解析成 AST，再将 ES6 语法的抽象语法树转成 ES5 的抽象语法树，最后利用它来生成 ES5 的源代码。另外 ESlint 的原理也大致相同，检测流程也是将源码转换成抽象语法树，再利用它来检测代码规范。</span><br><span class="line"></span><br><span class="line">// 生成字节码</span><br><span class="line">// 之前的 V8 版本不会经过这个过程，最早只是通过 AST 直接转换成机器码，而后面几个版本中才对此进行了改进。如果将 AST 直接转换为机器码还是会有一些问题存在的，例如：</span><br><span class="line">// 直接转换会带来内存占用过大的问题，因为将抽象语法树全部生成了机器码，而机器码相比字节码占用的内存多了很多；</span><br><span class="line">// 某些 JavaScript 使用场景使用解释器更为合适，解析成字节码，有些代码没必要生成机器码，进而尽可能减少了占用内存过大的问题。</span><br><span class="line">// 官方在 V8 的 v5.6 版本中还是将抽象语法树转换成字节码这一过程又加上了，重新加入了字节码的处理过程。再然后，V8 重新引进了 Ignition 解释器，将抽象语法树转换成字节码后，内存占用显著下降了，同时也可以使用 JIT 编译器做进一步的优化。</span><br><span class="line">// 字节码是介于 AST 和机器码之间的一种代码，需要将其转换成机器码后才能执行，字节码可以理解为是机器码的一种抽象。Ignition 解释器除了可以快速生成没有优化的字节码外，还可以执行部分字节码。</span><br><span class="line"></span><br><span class="line">// 生成机器码</span><br><span class="line">// 在 Ignition 解释器处理完之后，如果发现一段代码被重复执行多次的情况，生成的字节码以及分析数据会传给 TurboFan 编译器，它会根据分析数据的情况生成优化好的机器码。再执行这段代码之后，只需要直接执行编译后的机器码，这样性能就会更好。</span><br><span class="line">// TurboFan 编译器，它是 JIT 优化的编译器，因为 V8 引擎是多线程的，TurboFan 的编译线程和生成字节码不会在同一个线程上，这样可以和 Ignition 解释器相互配合着使用，不受另一方的影响。</span><br><span class="line">// 由 Ignition 解释器收集的分析数据被 TurboFan 编译器使用，主要是通过一种推测优化的技术，生成已经优化的机器码来执行。</span><br><span class="line"></span><br><span class="line">// JavaScript 代码是需要在 JavaScript 引擎中运行的。我们在说到 JavaScript 运行的时候，常常会提到执行环境、词法环境、作用域、执行上下文、闭包等内容。</span><br><span class="line">// JavaScript引擎执行JavaScript代码时会进行词法分析、语法分析、语义分析等处理，最终生成抽象语法树，根据抽象语法树生成机器码</span><br><span class="line">// 在 V8 引擎中 JavaScript 代码的运行过程主要分成三个阶段：</span><br><span class="line">// 语法分析阶段：对代码进行语法分析，检查是否有语法错误</span><br><span class="line">// 编译阶段：会创建执行上下文，包括变量对象的创建、作用域链的建立、this指向的确立等。每进入一个不同的运行环境，V8引擎都会创建一个执行上下文。</span><br><span class="line">// 执行阶段：将编译阶段的执行上下文压入调用栈，代码执行结束后，将其弹出调用栈</span><br><span class="line">// 前面提到的执行环境、词法环境、作用域、执行上下文等内容都是在编译和执行阶段中产生的概念。</span><br><span class="line"></span><br><span class="line">// 执行上下文创建</span><br><span class="line">// 全局环境和函数环境的创建过程如下</span><br><span class="line">// 第一次载入JavaScript代码时会创建一个全局环境。全局环境位于最外层，直到应用程序结束后（浏览器、网页关闭等）才会被销毁。</span><br><span class="line">// 每个函数有自己的运行环境，当函数被调用时，会进入该函数的运行环境。当该环境中的代码全部执行完毕后，该环境会被销毁。不同函数运行环境不一样，同一个函数多次被调用会创建不同的函数环境。</span><br><span class="line">// 每进入一个不同的运行环境时，JavaScript 都会创建一个新的执行上下文，该过程包括：</span><br><span class="line">// 建立作用域链（Scope Chain）；</span><br><span class="line">// 创建变量对象（Variable Object，简称 VO）；</span><br><span class="line">// 确定 this 的指向。</span><br><span class="line"></span><br><span class="line">// 创建变量对象</span><br><span class="line">// 每个执行上下文都会有一个关联的变量对象，该对象上会保存这个上下文中定义的所有变量和函数。</span><br><span class="line">// 而在浏览器中，全局环境的变量对象是window对象，因此所有的全局变量和函数都是作为window对象的属性和方法创建的。相应的，在 Node 中全局环境的变量对象则是global对象。</span><br><span class="line">// 创建变量对象将会创建arguments对象（仅函数环境下），同时会检查当前上下文的函数声明和变量声明。</span><br><span class="line">// 对于变量声明：此时会给变量分配内存，并将其初始化为undefined（该过程只进行定义声明，执行阶段才执行赋值语句）。</span><br><span class="line">// 对于函数声明：此时会在内存里创建函数对象，并且直接初始化为该函数对象。</span><br><span class="line">// 变量声明和函数声明的处理过程，便是我们常说的变量提升和函数提升，其中函数声明提升会优先于变量声明提升。因为变量提升容易带来变量在预期外被覆盖掉的问题，同时还可能导致本应该被销毁的变量没有被销毁等情况。因此 ES6 中引入了let和const关键字，从而使 JavaScript 也拥有了块级作用域。</span><br><span class="line">// 在 JavaScript 中，词法环境又分为词法环境（Lexical Environment）和变量环境（Variable Environment）两种，其中：</span><br><span class="line">// 变量环境用来记录var/function等变量声明；</span><br><span class="line">// 词法环境是用来记录let/const/class等变量声明。</span><br><span class="line"></span><br><span class="line">// 建立作用域链</span><br><span class="line">// 作用域就是词法环境，而词法环境由两个成员组成。</span><br><span class="line">// 环境记录（Environment Record）：用于记录自身词法环境中的变量对象。</span><br><span class="line">// 外部词法环境引用（Outer Lexical Environment）：记录外层词法环境的引用。</span><br><span class="line">// 通过外部词法环境的引用，作用域可以层层拓展，建立起从里到外延伸的一条作用域链。当某个变量无法在自身词法环境记录中找到时，可以根据外部词法环境引用向外层进行寻找，直到最外层的词法环境中外部词法环境引用为null，这便是作用域链的变量查询。</span><br><span class="line">// 通过外部词法环境的引用，作用域可以层层拓展，建立起从里到外延伸的一条作用域链。当某个变量无法在自身词法环境记录中找到时，可以根据外部词法环境引用向外层进行寻找，直到最外层的词法环境中外部词法环境引用为null，这便是作用域链的变量查询。</span><br><span class="line"></span><br><span class="line">// function foo(a) &#123;</span><br><span class="line"></span><br><span class="line">//   var b = 2;</span><br><span class="line"></span><br><span class="line">//   function c() &#123;&#125;</span><br><span class="line"></span><br><span class="line">//   var d = function() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">// foo(1);</span><br><span class="line"></span><br><span class="line">// 在执行foo(1)时，首先进入定义期，此时：</span><br><span class="line">// 参数变量a的值为1</span><br><span class="line">// 变量b和d初始化为undefined</span><br><span class="line">// 函数c创建函数并初始化</span><br><span class="line"></span><br><span class="line">// AO = &#123;</span><br><span class="line"></span><br><span class="line">//   arguments: &#123;</span><br><span class="line"></span><br><span class="line">//     0: 1,</span><br><span class="line"></span><br><span class="line">//     length: 1</span><br><span class="line"></span><br><span class="line">//   &#125;,</span><br><span class="line"></span><br><span class="line">//   a: 1,</span><br><span class="line"></span><br><span class="line">//   b: undefined,</span><br><span class="line"></span><br><span class="line">//   c: reference to function c()&#123;&#125;,</span><br><span class="line"></span><br><span class="line">//   d: undefined</span><br><span class="line"></span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">// 进入执行期之后，会执行赋值语句进行赋值，此时变量b和d会被赋值为 2 和函数表达式：</span><br><span class="line">// AO = &#123;</span><br><span class="line"></span><br><span class="line">//    arguments: &#123;</span><br><span class="line"></span><br><span class="line">//     0: 1,</span><br><span class="line"></span><br><span class="line">//     length: 1</span><br><span class="line"></span><br><span class="line">//   &#125;,</span><br><span class="line"></span><br><span class="line">//   a: 1,</span><br><span class="line"></span><br><span class="line">//   b: 2,</span><br><span class="line"></span><br><span class="line">//   c: reference to function c()&#123;&#125;,</span><br><span class="line"></span><br><span class="line">//   d: reference to FunctionExpression &quot;d&quot;</span><br><span class="line"></span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">// 一般来说，当函数执行结束之后，执行期上下文将被销毁（作用域链和活动对象均被销毁）。但有时候我们想要保留其中一些变量对象，不想被销毁，此时就会使用到闭包。</span><br><span class="line"></span><br><span class="line">// function foo() &#123;</span><br><span class="line"></span><br><span class="line">//   var a = 1;</span><br><span class="line"></span><br><span class="line">//   function bar() &#123;</span><br><span class="line"></span><br><span class="line">//     return a;</span><br><span class="line"></span><br><span class="line">//   &#125;</span><br><span class="line"></span><br><span class="line">//   return bar;</span><br><span class="line"></span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">// var b = foo();</span><br><span class="line"></span><br><span class="line">// console.log(b()); // 1</span><br><span class="line"></span><br><span class="line">// 在这个例子中，当b()执行时，foo函数上下文包括作用域都已经被销毁了，为什么foo作用域下的a依然可以被访问到呢？</span><br><span class="line"></span><br><span class="line">// 这是因为bar函数引用了foo函数变量对象中的值，此时即使创建bar函数的foo函数执行上下文被销毁了，但它的变量对象依然会保留在 JavaScript 内存中，bar函数依然可以通过bar函数的作用域链找到它，并进行访问。这便是我们常说的闭包，即使创建它的上下文已经销毁，它仍然被保留在内存中。</span><br><span class="line"></span><br><span class="line">// 闭包使得我们可以从外部读取局部变量，在大多数项目中都会被使用到，常见的用途包括：</span><br><span class="line"></span><br><span class="line">// 用于从外部读取其他函数内部变量的函数；</span><br><span class="line">// 可以使用闭包来模拟私有方法；</span><br><span class="line">// 让这些变量的值始终保持在内存中。</span><br><span class="line"></span><br><span class="line">// 确定 this 的指向</span><br><span class="line">// 根据 JavaScript 中函数的调用方式不同，this的指向分为以下情况。</span><br><span class="line">// 在全局环境中，this指向全局对象（在浏览器中为window）</span><br><span class="line">// 在函数内部，this的值取决于函数被调用的方式</span><br><span class="line">// 函数作为对象的方法被调用，this指向调用这个方法的对象</span><br><span class="line">// 函数用作构造函数时（使用new关键字），它的this被绑定到正在构造的新对象</span><br><span class="line">// 在类的构造函数中，this是一个常规对象，类中所有非静态的方法都会被添加到this的原型中</span><br><span class="line">// 在箭头函数中，this指向它被创建时的环境</span><br><span class="line">// 使用apply、call、bind等方式调用：根据 API 不同，可切换函数执行的上下文环境，即this绑定的对象</span><br><span class="line"></span><br><span class="line">// 当一段代码被执行时，JavaScript 引擎先会对其进行编译，并创建执行上下文。</span><br><span class="line">// 当 JavaScript 执行全局代码的时候，会编译全局代码并创建全局执行上下文，而且在整个页面的生存周期内，全局执行上下文只有一份。</span><br><span class="line">// 当调用一个函数的时候，函数体内的代码会被编译，并创建函数执行上下文，一般情况下，函数执行结束之后，创建的函数执行上下文会被销毁。</span><br><span class="line">// 当使用 eval 函数的时候，eval 的代码也会被编译，并创建执行上下文。</span><br><span class="line">// 用栈就是用来管理函数调用关系的一种数据结构。</span><br><span class="line"></span><br><span class="line">// 每调用一个函数，JavaScript 引擎会为其创建执行上下文，并把该执行上下文压入调用栈，然后 JavaScript 引擎开始执行函数代码。</span><br><span class="line">// 如果在一个函数 A 中调用了另外一个函数 B，那么 JavaScript 引擎会为 B 函数创建执行上下文，并将 B 函数的执行上下文压入栈顶。</span><br><span class="line">// 当前函数执行完毕后，JavaScript 引擎会将该函数的执行上下文弹出栈。</span><br><span class="line">// 当分配的调用栈空间被占满时，会引发“堆栈溢出”问题。</span><br><span class="line"></span><br><span class="line">// function foo()&#123;</span><br><span class="line">//   var a = 1</span><br><span class="line">//   let b = 2</span><br><span class="line">//   &#123;</span><br><span class="line">//     let b = 3</span><br><span class="line">//     var c = 4</span><br><span class="line">//     let d = 5</span><br><span class="line">//     console.log(a)</span><br><span class="line">//     console.log(b)</span><br><span class="line">//   &#125;</span><br><span class="line">//   console.log(b)</span><br><span class="line">//   console.log(c)</span><br><span class="line">//   console.log(d)</span><br><span class="line">// &#125;</span><br><span class="line">// foo()</span><br><span class="line"></span><br><span class="line">// 第一步是编译并创建执行上下文</span><br><span class="line">// 函数内部通过 var 声明的变量，在编译阶段全都被存放到变量环境里面了。</span><br><span class="line">// 通过 let 声明的变量，在编译阶段会被存放到词法环境（Lexical Environment）中。</span><br><span class="line">// 在函数的作用域块内部，通过 let 声明的变量并没有被存放到词法环境中。</span><br><span class="line"></span><br><span class="line">// 第二步继续执行代码，当执行到代码块里面时，变量环境中 a 的值已经被设置成了 1，词法环境中 b 的值已经被设置成了 2</span><br><span class="line">// 当进入函数的作用域块时，作用域块中通过 let 声明的变量，会被存放在词法环境的一个单独的区域中，这个区域中的变量并不影响作用域块外面的变量，比如在作用域外面声明了变量 b，在该作用域块内部也声明了变量 b，当执行到作用域内部时，它们都是独立的存在。</span><br><span class="line">// 其实，在词法环境内部，维护了一个小型栈结构，栈底是函数最外层的变量，进入一个作用域块后，就会把该作用域块内部的变量压到栈顶；当作用域执行完成之后，该作用域的信息就会从栈顶弹出，这就是词法环境的结构。</span><br><span class="line">// 需要注意下，我这里所讲的变量是指通过 let 或者 const 声明的变量。</span><br><span class="line"></span><br><span class="line">// 再接下来，当执行到作用域块中的console.log(a)这行代码时，就需要在词法环境和变量环境中查找变量 a 的值了，</span><br><span class="line">// 具体查找方式是：沿着词法环境的栈顶向下查询，如果在词法环境中的某个块中查找到了，就直接返回给 JavaScript 引擎，</span><br><span class="line">// 如果没有查找到，那么继续在变量环境中查找。</span><br><span class="line"></span><br><span class="line">// var myObj = &#123;</span><br><span class="line">//   name : &quot;diamonds&quot;,</span><br><span class="line">//   showThis: function()&#123;</span><br><span class="line">//     console.log(this)</span><br><span class="line">//     function bar()&#123;console.log(this)&#125;</span><br><span class="line">//     bar()</span><br><span class="line">//   &#125;</span><br><span class="line">// &#125;</span><br><span class="line">// myObj.showThis()</span><br><span class="line"></span><br><span class="line">// 执行这段代码后，你会发现函数 bar 中的 this 指向的是全局 window 对象，而函数 showThis 中的 this 指向的是 myObj 对象。</span><br><span class="line"></span><br><span class="line">// var myObj = &#123;</span><br><span class="line">//   name : &quot;diamond&quot;,</span><br><span class="line">//   showThis: function()&#123;</span><br><span class="line">//     console.log(this)</span><br><span class="line">//     var bar = ()=&gt;&#123;</span><br><span class="line">//       this.name = &quot;diamonds&quot;</span><br><span class="line">//       console.log(this)</span><br><span class="line">//     &#125;</span><br><span class="line">//     bar()</span><br><span class="line">//   &#125;</span><br><span class="line">// &#125;</span><br><span class="line">// myObj.showThis()</span><br><span class="line">// console.log(myObj.name)</span><br><span class="line">// console.log(window.name)</span><br><span class="line"></span><br><span class="line">// ES6 中的箭头函数并不会创建其自身的执行上下文，所以箭头函数中的 this 取决于它的外部函数。</span><br><span class="line">// 因为箭头函数没有自己的执行上下文，所以箭头函数的 this 就是它外层函数的 this。</span><br></pre></td></tr></table></figure>
<h3 id="渲染相关"><a href="#渲染相关" class="headerlink" title="渲染相关"></a>渲染相关</h3><h4 id="DOM-树如何生成"><a href="#DOM-树如何生成" class="headerlink" title="DOM 树如何生成"></a>DOM 树如何生成</h4><ul>
<li>在渲染引擎内部，有一个叫 HTML 解析器（HTMLParser）的模块，它的职责就是负责将 HTML 字节流转换为 DOM 结构。</li>
<li>HTML 解析器并不是等整个文档加载完成之后再解析的，而是网络进程加载了多少数据，HTML 解析器便解析多少数据。</li>
<li>网络进程接收到响应头之后，会根据响应头中的 content-type 字段来判断文件的类型，比如 content-type 的值是“text/html”，那么浏览器就会判断这是一个 HTML 类型的文件，然后为该请求选择或者创建一个渲染进程。渲染进程准备好之后，网络进程和渲染进程之间会建立一个共享数据的管道，网络进程接收到数据后就往这个管道里面放，而渲染进程则从管道的另外一端不断地读取数据，并同时将读取的数据“喂”给 HTML 解析器。你可以把这个管道想象成一个“水管”，网络进程接收到的字节流像水一样倒进这个“水管”，而“水管”的另外一端是渲染进程的 HTML 解析器，它会动态接收字节流，并将其解析为 DOM。</li>
</ul>
<h4 id="JavaScript-是如何影响-DOM-生成的"><a href="#JavaScript-是如何影响-DOM-生成的" class="headerlink" title="JavaScript 是如何影响 DOM 生成的"></a>JavaScript 是如何影响 DOM 生成的</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;1&lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">    let div1 = document.getElementsByTagName(&apos;div&apos;)[0]</span><br><span class="line">    div1.innerText = &apos;time.geekbang&apos;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">    &lt;div&gt;test&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在两段 div 中间插入了一段 JavaScript 脚本，这段脚本的解析过程就有点不一样了。&lt;script&gt;标签之前，所有的解析流程还是和之前介绍的一样，但是解析到&lt;script&gt;标签时，渲染引擎判断这是一段脚本，此时 HTML 解析器就会暂停 DOM 的解析，因为接下来的 JavaScript 可能要修改当前已经生成的 DOM 结构。</span><br><span class="line"></span><br><span class="line">这时候 HTML 解析器暂停工作，JavaScript 引擎介入，并执行 script 标签中的这段脚本，因为这段 JavaScript 脚本修改了 DOM 中第一个 div 中的内容，所以执行这段脚本之后，div 节点内容已经修改为 time.geekbang 了。脚本执行完成之后，HTML 解析器恢复解析过程，继续解析后续的内容，直至生成最终的 DOM。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//foo.js</span><br><span class="line">let div1 = document.getElementsByTagName(&apos;div&apos;)[0]</span><br><span class="line">div1.innerText = &apos;time.geekbang&apos;</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;1&lt;/div&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot; src=&apos;foo.js&apos;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;div&gt;test&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">这段代码的功能还是和前面那段代码是一样的，不过这里把内嵌 JavaScript 脚本修改成了通过 JavaScript 文件加载。其整个执行流程还是一样的，执行到 JavaScript 标签时，暂停整个 DOM 的解析，执行 JavaScript 代码，不过这里执行 JavaScript 时，需要先下载这段 JavaScript 代码。</span><br><span class="line"></span><br><span class="line">这里需要重点关注下载环境，因为 JavaScript 文件的下载过程会阻塞 DOM 解析，而通常下载又是非常耗时的，会受到网络环境、JavaScript 文件大小等因素的影响。</span><br><span class="line"></span><br><span class="line">不过 Chrome 浏览器做了很多优化，其中一个主要的优化是预解析操作。当渲染引擎收到字节流之后，会开启一个预解析线程，用来分析 HTML 文件中包含的 JavaScript、CSS 等相关文件，解析到相关文件之后，预解析线程会提前下载这些文件。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">再回到 DOM 解析上，我们知道引入 JavaScript 线程会阻塞 DOM，不过也有一些相关的策略来规避，比如使用 CDN 来加速 JavaScript 文件的加载，压缩 JavaScript 文件的体积。另外，如果 JavaScript 文件中没有操作 DOM 相关代码，就可以将该 JavaScript 脚本设置为异步加载，通过 async 或 defer 来标记代码，使用方式如下所示：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script async type=&quot;text/javascript&quot; src=&apos;foo.js&apos;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script defer type=&quot;text/javascript&quot; src=&apos;foo.js&apos;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">async 和 defer 虽然都是异步的，不过还有一些差异，使用 async 标志的脚本文件一旦加载完成，会立即执行；</span><br><span class="line">而使用了 defer 标记的脚本文件，需要在 DOMContentLoaded 事件之前执行。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">现在我们知道了 JavaScript 是如何阻塞 DOM 解析的了，那接下来我们再来结合文中代码看看另外一种情况：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//theme.css</span><br><span class="line">div &#123;color:blue&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;style src=&apos;theme.css&apos;&gt;&lt;/style&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;1&lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">            let div1 = document.getElementsByTagName(&apos;div&apos;)[0]</span><br><span class="line">            div1.innerText = &apos;time.geekbang&apos; //需要DOM</span><br><span class="line">            div1.style.color = &apos;red&apos;  //需要CSSOM</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">    &lt;div&gt;test&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">该示例中，JavaScript 代码出现了 div1.style.color = ‘red&apos; 的语句，它是用来操纵 CSSOM 的，所以在执行 JavaScript 之前，需要先解析 JavaScript 语句之上所有的 CSS 样式。所以如果代码里引用了外部的 CSS 文件，那么在执行 JavaScript 之前，还需要等待外部的 CSS 文件下载完成，并解析生成 CSSOM 对象之后，才能执行 JavaScript 脚本。</span><br><span class="line"></span><br><span class="line">而 JavaScript 引擎在解析 JavaScript 之前，是不知道 JavaScript 是否操纵了 CSSOM 的，所以渲染引擎在遇到 JavaScript 脚本时，不管该脚本是否操纵了 CSSOM，都会执行 CSS 文件下载，解析操作，再执行 JavaScript 脚本。</span><br><span class="line"></span><br><span class="line">所以说 JavaScript 脚本是依赖样式表的，这又多了一个阻塞过程。JavaScript 会阻塞 DOM 生成，而样式文件又会阻塞 JavaScript 的执行。</span><br></pre></td></tr></table></figure>
<h4 id="CSS-如何影响首次加载时的白屏时间"><a href="#CSS-如何影响首次加载时的白屏时间" class="headerlink" title="CSS 如何影响首次加载时的白屏时间"></a>CSS 如何影响首次加载时的白屏时间</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//theme.css</span><br><span class="line">div&#123;</span><br><span class="line">    color : coral;</span><br><span class="line">    background-color:black</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;link href=&quot;theme.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;geekbang com&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">首先是发起主页面的请求，这个发起请求方可能是渲染进程，也有可能是浏览器进程，发起的请求被送到网络进程中去执行。</span><br><span class="line">网络进程接收到返回的 HTML 数据之后，将其发送给渲染进程，渲染进程会解析 HTML 数据并构建 DOM。</span><br><span class="line">这里你需要特别注意下，请求 HTML 数据和构建 DOM 中间有一段空闲时间，这个空闲时间有可能成为页面渲染的瓶颈。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">当渲染进程接收 HTML 文件字节流时，会先开启一个预解析线程，如果遇到 JavaScript 文件或者 CSS 文件，那么预解析线程会提前下载这些数据。对于上面的代码，预解析线程会解析出来一个外部的 theme.css 文件，并发起 theme.css 的下载。</span><br><span class="line">这里也有一个空闲时间需要你注意一下，就是在 DOM 构建结束之后、theme.css 文件还未下载完成的这段时间内，渲染流水线无事可做，因为下一步是合成布局树，而合成布局树需要 CSSOM 和 DOM，所以这里需要等待 CSS 加载结束并解析成 CSSOM</span><br></pre></td></tr></table></figure>
<h4 id="影响页面展示的因素以及优化策略"><a href="#影响页面展示的因素以及优化策略" class="headerlink" title="影响页面展示的因素以及优化策略"></a>影响页面展示的因素以及优化策略</h4><p>为什么要花这么多文字来分析渲染流水线呢？主要原因就是渲染流水线影响到了首次页面展示的速度，而首次页面展示的速度又直接影响到了用户体验<br>从发起 URL 请求开始，到首次显示页面的内容，在视觉上经历的三个阶段。<br>第一个阶段，等请求发出去之后，到提交数据阶段，这时页面展示出来的还是之前页面的内容。<br>第二个阶段，提交数据之后渲染进程会创建一个空白页面，我们通常把这段时间称为解析白屏，并等待 CSS 文件和 JavaScript 文件的加载完成，生成 CSSOM 和 DOM，然后合成布局树，最后还要经过一系列的步骤准备首次渲染。<br>第三个阶段，等首次渲染完成之后，就开始进入完整页面的生成阶段了，然后页面会一点点被绘制出来。<br>影响第一个阶段的因素主要是网络或者是服务器处理这块儿,<br>第二个阶段，这个阶段的主要问题是白屏时间，通常情况下的瓶颈主要体现在下载 CSS 文件、下载 JavaScript 文件和执行 JavaScript。所以要想缩短白屏时长，可以有以下策略：<br>通过内联 JavaScript、内联 CSS 来移除这两种类型的文件下载，这样获取到 HTML 文件之后就可以直接开始渲染流程了。<br>并不是所有的场合都适合内联，那么还可以尽量减少文件大小，比如通过 webpack 等工具移除一些不必要的注释，并压缩 JavaScript 文件。<br>还可以将一些不需要在解析 HTML 阶段使用的 JavaScript 标记上 async 或者 defer。<br>对于大的 CSS 文件，可以通过媒体查询属性，将其拆分为多个不同用途的 CSS 文件，这样只有在特定的场景下才会加载特定的 CSS 文件。</p>
<h4 id="为什么-CSS-动画比-JavaScript-高效？"><a href="#为什么-CSS-动画比-JavaScript-高效？" class="headerlink" title="为什么 CSS 动画比 JavaScript 高效？"></a>为什么 CSS 动画比 JavaScript 高效？</h4><p>大多数设备屏幕的更新频率是60 次 / 秒，这也就意味着正常情况下要实现流畅的动画效果，渲染引擎需要每秒更新 60 张图片到显卡的后缓冲区。<br>我们把渲染流水线生成的每一副图片称为一帧，把渲染流水线每秒更新了多少帧称为帧率，比如滚动过程中 1 秒更新了 60 帧，那么帧率就是 60Hz（或者 60FPS）<br>由于用户很容易观察到那些丢失的帧，如果在一次动画过程中，渲染引擎生成某些帧的时间过久，那么用户就会感受到卡顿，这会给用户造成非常不好的印象。<br>要解决卡顿问题，就要解决每帧生成时间过久的问题，为此 Chrome 对浏览器渲染方式做了大量的工作，其中最卓有成效的策略就是引入了分层和合成机制。</p>
<p>重排、重绘和合成这三种方式的渲染路径是不同的，通常渲染路径越长，生成图像花费的时间就越多。<br>比如重排，它需要重新根据 CSSOM 和 DOM 来计算布局树，这样生成一幅图片时，会让整个渲染流水线的每个阶段都执行一遍，如果布局复杂的话，就很难保证渲染的效率了。<br>而重绘因为没有了重新布局的阶段，操作效率稍微高点，但是依然需要重新计算绘制信息，并触发绘制操作之后的一系列操作。<br>相较于重排和重绘，合成操作的路径就显得非常短了，并不需要触发布局和绘制两个阶段，如果采用了 GPU，那么合成的效率会非常高。<br>所以，关于渲染引擎生成一帧图像的几种方式，按照效率我们推荐合成方式优先，若实在不能满足需求，那么就再退后一步使用重绘或者重排的方式。<br>Chrome 中的合成技术，可以用三个词来概括总结：分层、分块和合成。</p>
<p>在 Chrome 的渲染流水线中，分层体现在生成布局树之后，渲染引擎会根据布局树的特点将其转换为层树（Layer Tree），层树是渲染流水线后续流程的基础结构。<br>层树中的每个节点都对应着一个图层，下一步的绘制阶段就依赖于层树中的节点。<br>绘制阶段其实并不是真正地绘出图片，而是将绘制指令组合成一个列表，比如一个图层要设置的背景为黑色，并且还要在中间画一个圆形，那么绘制过程会生成|Paint BackGroundColor:Black | Paint Circle|这样的绘制指令列表，绘制过程就完成了。<br>有了绘制列表之后，就需要进入光栅化阶段了，光栅化就是按照绘制列表中的指令生成图片。每一个图层都对应一张图片，合成线程有了这些图片之后，会将这些图片合成为“一张”图片，并最终将生成的图片发送到后缓冲区。这就是一个大致的分层、合成流程。<br>合成操作是在合成线程上完成的，这也就意味着在执行合成操作时，是不会影响到主线程执行的。这就是为什么经常主线程卡住了，但是 CSS 动画依然能执行的原因。</p>
<p>如果说分层是从宏观上提升了渲染效率，那么分块则是从微观层面提升了渲染效率。<br>通常情况下，页面的内容都要比屏幕大得多，显示一个页面时，如果等待所有的图层都生成完毕，再进行合成的话，会产生一些不必要的开销，也会让合成图片的时间变得更久。<br>因此，合成线程会将每个图层分割为大小固定的图块，然后优先绘制靠近视口的图块，这样就可以大大加速页面的显示速度。不过有时候， 即使只绘制那些优先级最高的图块，也要耗费不少的时间，因为涉及到一个很关键的因素——纹理上传，这是因为从计算机内存上传到 GPU 内存的操作会比较慢。<br>为了解决这个问题，Chrome 又采取了一个策略：在首次合成图块的时候使用一个低分辨率的图片。比如可以是正常分辨率的一半，分辨率减少一半，纹理就减少了四分之三。在首次显示页面内容的时候，将这个低分辨率的图片显示出来，然后合成器继续绘制正常比例的网页内容，当正常比例的网页内容绘制完成后，再替换掉当前显示的低分辨率内容。这种方式尽管会让用户在开始时看到的是低分辨率的内容，但是也比用户在开始时什么都看不到要好。</p>
<h4 id="如何利用分层技术优化代码"><a href="#如何利用分层技术优化代码" class="headerlink" title="如何利用分层技术优化代码"></a>如何利用分层技术优化代码</h4><p>CSS 属性 will-change 为 web 开发者提供了一种告知浏览器该元素会有哪些变化的方法，这样浏览器可以在元素属性真正发生变化之前提前做好对应的优化准备工作。 这种优化可以将一部分复杂的计算工作提前准备好，使页面的反应更为快速灵敏。</p>
<p>所以，如果涉及到一些可以使用合成线程来处理 CSS 特效或者动画的情况，就尽量使用 will-change 来提前告诉渲染引擎，让它为该元素准备独立的层。但是凡事都有两面性，每当渲染引擎为一个元素准备一个独立层的时候，它占用的内存也会大大增加，因为从层树开始，后续每个阶段都会多一个层结构，这些都需要额外的内存，所以你需要恰当地使用 will-change。</p>
<h4 id="如何系统地优化页面？"><a href="#如何系统地优化页面？" class="headerlink" title="如何系统地优化页面？"></a>如何系统地优化页面？</h4><p>图片、音频、视频等文件就不会阻塞页面的首次渲染；而 JavaScript、首次请求的 HTML 资源文件、CSS 文件是会阻塞首次渲染的，因为在构建 DOM 的过程中需要 HTML 和 JavaScript 文件，在构造渲染树的过程中需要用到 CSS 文件。<br>我们把这些能阻塞网页首次渲染的资源称为关键资源。基于关键资源，我们可以继续细化出来三个影响页面首次渲染的核心因素。<br>第一个是关键资源个数。关键资源个数越多，首次页面的加载时间就会越长。比如上图中的关键资源个数就是 3 个，1 个 HTML 文件、1 个 JavaScript 和 1 个 CSS 文件。<br>第二个是关键资源大小。通常情况下，所有关键资源的内容越小，其整个资源的下载时间也就越短，那么阻塞渲染的时间也就越短。上图中关键资源的大小分别是 6KB、8KB 和 9KB，那么整个关键资源大小就是 23KB。<br>第三个是请求关键资源需要多少个 RTT（Round Trip Time）。那什么是 RTT 呢？<br>当使用 TCP 协议传输一个文件时，比如这个文件大小是 0.1M，由于 TCP 的特性，这个数据并不是一次传输到服务端的，而是需要拆分成一个个数据包来回多次进行传输的。<br>RTT 就是这里的往返时延。它是网络中一个重要的性能指标，表示从发送端发送数据开始，到发送端收到来自接收端的确认，总共经历的时延。<br>通常 1 个 HTTP 的数据包在 14KB 左右，所以 1 个 0.1M 的页面就需要拆分成 8 个包来传输了，也就是说需要 8 个 RTT。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">首先是请求 HTML 资源，大小是 6KB，小于 14KB，所以 1 个 RTT 就可以解决了。</span><br><span class="line">至于 JavaScript 和 CSS 文件，这里需要注意一点，由于渲染引擎有一个预解析的线程，在接收到 HTML 数据之后，预解析线程会快速扫描 HTML 数据中的关键资源，一旦扫描到了，会立马发起请求，你可以认为 JavaScript 和 CSS 是同时发起请求的，所以它们的请求是重叠的，那么计算它们的 RTT 时，只需要计算体积最大的那个数据就可以了。这里最大的是 CSS 文件（9KB），所以我们就按照 9KB 来计算，同样由于 9KB 小于 14KB，所以 JavaScript 和 CSS 资源也就可以算成 1 个 RTT。也就是说，关键资源请求共花费了 2 个 RTT。</span><br></pre></td></tr></table></figure>
<p>如果在计算样式阶段发现有布局信息的修改，那么就会触发重排操作，然后触发后续渲染流水线的一系列操作，这个代价是非常大的。<br>同样如果在计算样式阶段没有发现有布局信息的修改，只是修改了颜色一类的信息，那么就不会涉及到布局相关的调整，所以可以跳过布局阶段，直接进入绘制阶段，这个过程叫重绘。不过重绘阶段的代价也是不小的。<br>还有另外一种情况，通过 CSS 实现一些变形、渐变、动画等特效，这是由 CSS 触发的，并且是在合成线程上执行的，这个过程称为合成。因为它不会触发重排或者重绘，而且合成操作本身的速度就非常快，所以执行合成是效率最高的方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;mian_div&quot;&gt;</span><br><span class="line">        &lt;li id=&quot;time_li&quot;&gt;time&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;geekbang&lt;/li&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;p id=&quot;demo&quot;&gt;强制布局demo&lt;/p&gt;</span><br><span class="line">    &lt;button onclick=&quot;foo()&quot;&gt;添加新元素&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        function foo() &#123;</span><br><span class="line">            let main_div = document.getElementById(&quot;mian_div&quot;)</span><br><span class="line">            let new_node = document.createElement(&quot;li&quot;)</span><br><span class="line">            let textnode = document.createTextNode(&quot;time.geekbang&quot;)</span><br><span class="line">            new_node.appendChild(textnode);</span><br><span class="line">            document.getElementById(&quot;mian_div&quot;).appendChild(new_node);</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">执行 JavaScript 添加元素是在一个任务中执行的，重新计算样式布局是在另外一个任务中执行，这就是正常情况下的布局操作。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">    let main_div = document.getElementById(&quot;mian_div&quot;)</span><br><span class="line">    let new_node = document.createElement(&quot;li&quot;)</span><br><span class="line">    let textnode = document.createTextNode(&quot;time.geekbang&quot;)</span><br><span class="line">    new_node.appendChild(textnode);</span><br><span class="line">    document.getElementById(&quot;mian_div&quot;).appendChild(new_node);</span><br><span class="line">    //由于要获取到offsetHeight，</span><br><span class="line">    //但是此时的offsetHeight还是老的数据，</span><br><span class="line">    //所以需要立即执行布局操作</span><br><span class="line">    console.log(main_div.offsetHeight)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">将新的元素添加到 DOM 之后，我们又调用了main_div.offsetHeight来获取新 main_div 的高度信息。</span><br><span class="line">如果要获取到 main_div 的高度，就需要重新布局，所以这里在获取到 main_div 的高度之前，JavaScript 还需要强制让渲染引擎默认执行一次布局操作。</span><br><span class="line">我们把这个操作称为强制同步布局。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">    let time_li = document.getElementById(&quot;time_li&quot;)</span><br><span class="line">    for (let i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">        let main_div = document.getElementById(&quot;mian_div&quot;)</span><br><span class="line">        let new_node = document.createElement(&quot;li&quot;)</span><br><span class="line">        let textnode = document.createTextNode(&quot;time.geekbang&quot;)</span><br><span class="line">        new_node.appendChild(textnode);</span><br><span class="line">        new_node.offsetHeight = time_li.offsetHeight;</span><br><span class="line">        document.getElementById(&quot;mian_div&quot;).appendChild(new_node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在 foo 函数内部重复执行计算样式和布局，这会大大影响当前函数的执行效率。这种情况的避免方式和强制同步布局一样，都是尽量不要在修改 DOM 结构时再去查询一些相关值。</span><br></pre></td></tr></table></figure>
<h3 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h3><p>强制缓存优先于协商缓存进行，若强制缓存(Expires 和 Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified/If-Modified-Since 和 Etag/If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回 200，重新返回资源和缓存标识，再存入浏览器缓存中；生效则返回 304，继续使用缓存。<br>当你点”刷新”按钮的时候，协商缓存<br>Ctrl+F5 的”强制刷新”又是什么样的呢？请求头里面没有 if-modified-since/if-none-match 字段</p>
<h4 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h4><ul>
<li><p>不会向服务器发送请求，直接从缓存中读取资源，在 chrome 控制台的 network 选项中可以看到该请求返回200 的状态码，并且 size 显示 from disk cache 或 from memory cache。强缓存判断是否缓存的依据来自于是否超出某个时间或者某个时间段，而不关心服务器端文件是否已经更新，这可能会导致加载文件不是服务器端最新的内容</p>
</li>
<li><p>Expires：response header 里的过期时间，浏览器再次加载资源时，如果在这个过期时间内，则命中强缓存。它的值为一个绝对时间的 GMT 格式的时间字符串， 比如 <code>Expires:Thu,21 Jan 2018 23:39:02 GMT</code></p>
</li>
<li><p>max-age：当 Cache-Control:max-age=300 时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5 分钟内再次加载资源，就会命中强缓存。</p>
</li>
<li><p>no-cache：客户端缓存内容，是否使用缓存则需要经过协商缓存来验证决定。用 Etag 或者 Last-Modified 字段来控制缓存。</p>
</li>
<li>no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存</li>
</ul>
<h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><ul>
<li><p>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：协商缓存生效，返回304 和 Not Modified 协商缓存失效，返回200 和请求结果</p>
</li>
<li><p>Last-Modified 和 If-Modified-Since 浏览器在第一次访问资源时，服务器返回资源的同时，在 response header 中添加 Last-Modified 的 header，值是这个资源在服务器上的最后修改时间，浏览器接收后缓存文件和 header；</p>
</li>
<li>ETag 和 If-None-Match Etag 是上一次加载资源时，服务器返回的 response header，是对该资源的一种唯一标识，只要资源有变化，Etag 就会重新生成。</li>
<li>首先在精确度上，Etag 要优于 Last-Modified。Last-Modified 的时间单位是秒，如果某个文件在 1 秒内改变了多次，那么他们的 Last-Modified 其实并没有体现出来修改，但是 Etag 每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的 Last-Modified 也有可能不一致。<br>第二在性能上，Etag 要逊于 Last-Modified，毕竟 Last-Modified 只需要记录时间，而 Etag 需要服务器通过算法来计算出一个 hash 值。<br>第三在优先级上，服务器校验优先考虑 Etag  </li>
</ul>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">基础类型存储在栈内存，被引用或拷贝时，会创建一个完全相等的变量；</span><br><span class="line">Undefined Null String Number Boolean Symbol BigInt</span><br><span class="line"></span><br><span class="line">引用类型存储在堆内存，存储的是地址，多个引用指向同一个地址，这里会涉及一个“共享”的概念。</span><br><span class="line">Object</span><br><span class="line">Array Date RegExp Function Math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let a = &#123;</span><br><span class="line">  name: &quot;Julia&quot;,</span><br><span class="line"></span><br><span class="line">  age: 20,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function change(o) &#123;</span><br><span class="line">  o.age = 24;</span><br><span class="line">  //关键   变量o改变内存指向 跟a已经没有关系</span><br><span class="line">  o = &#123;</span><br><span class="line">    name: &quot;Kath&quot;,</span><br><span class="line">    age: 30,</span><br><span class="line">  &#125;;</span><br><span class="line">  return o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let b = change(a);</span><br><span class="line"></span><br><span class="line">console.log(b.age); // 第一个console   30</span><br><span class="line"></span><br><span class="line">console.log(a.age); // 第二个console   24</span><br></pre></td></tr></table></figure>
<h4 id="数据类型检测"><a href="#数据类型检测" class="headerlink" title="数据类型检测"></a>数据类型检测</h4><h5 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">typeof 1 // &apos;number&apos;</span><br><span class="line"></span><br><span class="line">typeof &apos;1&apos; // &apos;string&apos;</span><br><span class="line"></span><br><span class="line">typeof undefined // &apos;undefined&apos;</span><br><span class="line"></span><br><span class="line">typeof true // &apos;boolean&apos;</span><br><span class="line"></span><br><span class="line">typeof Symbol() // &apos;symbol&apos;</span><br><span class="line"></span><br><span class="line">typeof null // &apos;object&apos;       !!!!!!!!!!!!!!!!</span><br><span class="line"></span><br><span class="line">typeof [] // &apos;object&apos;</span><br><span class="line"></span><br><span class="line">typeof &#123;&#125; // &apos;object&apos;</span><br><span class="line"></span><br><span class="line">typeof console // &apos;object&apos;</span><br><span class="line"></span><br><span class="line">typeof console.log // &apos;function&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">虽然 typeof null 会输出 object，但这只是 JS 存在的一个悠久 Bug，不代表 null 就是引用数据类型，并且 null 本身也不是对象。因此，null 在 typeof 之后返回的是有问题的结果，不能作为判断 null 的方法。如果你需要在 if 语句中判断是否为 null，直接通过 ‘===null’来判断就好。</span><br><span class="line"></span><br><span class="line">引用数据类型 Object，用 typeof 来判断的话，除了 function 会判断为 OK 以外，其余都是 ‘object’，是无法判断出来的。</span><br></pre></td></tr></table></figure>
<h5 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">let Car = function() &#123;&#125;</span><br><span class="line"></span><br><span class="line">let benz = new Car()</span><br><span class="line"></span><br><span class="line">benz instanceof Car // true</span><br><span class="line"></span><br><span class="line">let car = new String(&apos;Mercedes Benz&apos;)</span><br><span class="line"></span><br><span class="line">car instanceof String // true</span><br><span class="line"></span><br><span class="line">let str = &apos;Covid-19&apos;</span><br><span class="line"></span><br><span class="line">str instanceof String // false</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------------------------------</span><br><span class="line"></span><br><span class="line">function myInstanceof(left, right) &#123;</span><br><span class="line"></span><br><span class="line">  // 这里先用typeof来判断基础数据类型，如果是，直接返回false</span><br><span class="line"></span><br><span class="line">  if(typeof left !== &apos;object&apos; || left === null) return false;</span><br><span class="line"></span><br><span class="line">  // getPrototypeOf是Object对象自带的API，能够拿到参数的原型对象</span><br><span class="line"></span><br><span class="line">  let proto = Object.getPrototypeOf(left);</span><br><span class="line"></span><br><span class="line">  while(true) &#123;                  //循环往下寻找，直到找到相同的原型对象</span><br><span class="line"></span><br><span class="line">    if(proto === null) return false;</span><br><span class="line"></span><br><span class="line">    if(proto === right.prototype) return true;//找到相同原型对象，返回true</span><br><span class="line"></span><br><span class="line">    proto = Object.getPrototypeof(proto);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 验证一下自己实现的myInstanceof是否OK</span><br><span class="line"></span><br><span class="line">console.log(myInstanceof(new Number(123), Number));    // true</span><br><span class="line"></span><br><span class="line">console.log(myInstanceof(123, Number));                // false</span><br><span class="line"></span><br><span class="line">instanceof 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型；</span><br><span class="line">而 typeof 也存在弊端，它虽然可以判断基础数据类型（null 除外），但是引用数据类型中，除了 function 类型以外，其他的也无法判断。</span><br></pre></td></tr></table></figure>
<h5 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString"></a>Object.prototype.toString</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString(&#123;&#125;)       // &quot;[object Object]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(&#123;&#125;)  // 同上结果，加上call也ok</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(1)    // &quot;[object Number]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(&apos;1&apos;)  // &quot;[object String]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(true)  // &quot;[object Boolean]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(function()&#123;&#125;)  // &quot;[object Function]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(null)   //&quot;[object Null]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(undefined) //&quot;[object Undefined]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(/123/g)    //&quot;[object RegExp]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(new Date()) //&quot;[object Date]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call([])       //&quot;[object Array]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(document)  //&quot;[object HTMLDocument]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(window)   //&quot;[object Window]&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function getType(obj)&#123;</span><br><span class="line">  let type  = typeof obj;</span><br><span class="line">  if (type !== &quot;object&quot;) &#123;    // 先进行typeof判断，如果是基础数据类型，直接返回</span><br><span class="line">    return type;</span><br><span class="line">  &#125;</span><br><span class="line">  // 对于typeof返回结果是object的，再进行如下的判断，正则返回结果</span><br><span class="line">  return Object.prototype.toString.call(obj).replace(/^\[object (\S+)\]$/, &apos;$1&apos;);  // 注意正则中间有个空格</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">强制类型转换 Number()、parseInt()、parseFloat()、toString()、String()、Boolean()</span><br><span class="line"></span><br><span class="line">Number() 方法的强制转换规则</span><br><span class="line">如果是布尔值，true 和 false 分别被转换为 1 和 0；</span><br><span class="line">如果是数字，返回自身；</span><br><span class="line">如果是 null，返回 0；</span><br><span class="line">如果是 undefined，返回 NaN；</span><br><span class="line">如果是字符串，遵循以下规则：如果字符串中只包含数字（或者是 0X / 0x 开头的十六进制数字字符串，允许包含正负号），则将其转换为十进制；如果字符串中包含有效的浮点格式，将其转换为浮点数值；如果是空字符串，将其转换为 0；如果不是以上格式的字符串，均返回 NaN；</span><br><span class="line">如果是 Symbol，抛出错误；</span><br><span class="line">如果是对象，并且部署了 [Symbol.toPrimitive] ，那么调用此方法，否则调用对象的 valueOf() 方法，然后依据前面的规则转换返回的值；如果转换的结果是 NaN ，则调用对象的 toString() 方法，再次依照前面的顺序转换返回对应的值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Number(true);        // 1</span><br><span class="line"></span><br><span class="line">Number(false);       // 0</span><br><span class="line"></span><br><span class="line">Number(&apos;0111&apos;);      //111</span><br><span class="line"></span><br><span class="line">Number(null);        //0</span><br><span class="line"></span><br><span class="line">Number(&apos;&apos;);          //0</span><br><span class="line"></span><br><span class="line">Number(&apos;1a&apos;);        //NaN</span><br><span class="line"></span><br><span class="line">Number(-0X11);       //-17</span><br><span class="line"></span><br><span class="line">Number(&apos;0X11&apos;)       //17</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Boolean() 方法的强制转换规则</span><br><span class="line">除了 undefined、 null、 false、 &apos;&apos;、 0（包括 +0，-0）、 NaN 转换出来是 false，其他都是 true。</span><br><span class="line"></span><br><span class="line">Boolean(0)          //false</span><br><span class="line"></span><br><span class="line">Boolean(null)       //false</span><br><span class="line"></span><br><span class="line">Boolean(undefined)  //false</span><br><span class="line"></span><br><span class="line">Boolean(NaN)        //false</span><br><span class="line"></span><br><span class="line">Boolean(1)          //true</span><br><span class="line"></span><br><span class="line">Boolean(13)         //true</span><br><span class="line"></span><br><span class="line">Boolean(&apos;12&apos;)       //true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------------------------------------------------</span><br><span class="line"></span><br><span class="line">&quot;==&quot; 的隐式类型转换规则</span><br><span class="line">如果类型相同，无须进行类型转换；</span><br><span class="line">如果其中一个操作值是 null 或者 undefined，那么另一个操作符必须为 null 或者 undefined，才会返回 true，否则都返回 false；</span><br><span class="line">如果其中一个是 Symbol 类型，那么返回 false；</span><br><span class="line">两个操作值如果为 string 和 number 类型，那么就会将字符串转换为 number；</span><br><span class="line">如果一个操作值是 boolean，那么转换成 number；</span><br><span class="line">如果一个操作值为 object 且另一方为 string、number 或者 symbol，就会把 object 转为原始类型再进行判断（调用 object 的 valueOf/toString 方法进行转换）。</span><br><span class="line"></span><br><span class="line">null == undefined       // true  规则2</span><br><span class="line"></span><br><span class="line">null == 0               // false 规则2</span><br><span class="line"></span><br><span class="line">&apos;&apos; == null              // false 规则2</span><br><span class="line"></span><br><span class="line">&apos;&apos; == 0                 // true  规则4 字符串转隐式转换成Number之后再对比</span><br><span class="line"></span><br><span class="line">&apos;123&apos; == 123            // true  规则4 字符串转隐式转换成Number之后再对比</span><br><span class="line"></span><br><span class="line">0 == false              // true  规则5 布尔型隐式转换成Number之后再对比</span><br><span class="line"></span><br><span class="line">1 == true               // true  规则5 布尔型隐式转换成Number之后再对比</span><br><span class="line"></span><br><span class="line">var a = &#123;</span><br><span class="line"></span><br><span class="line">  value: 0,</span><br><span class="line"></span><br><span class="line">  valueOf: function() &#123;</span><br><span class="line"></span><br><span class="line">    this.value++;</span><br><span class="line"></span><br><span class="line">    return this.value;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 注意这里a又可以等于1、2、3</span><br><span class="line"></span><br><span class="line">console.log(a == 1 &amp;&amp; a == 2 &amp;&amp; a ==3);  //true f规则 Object隐式转换</span><br><span class="line"></span><br><span class="line">// 注：但是执行过3遍之后，再重新执行a==3或之前的数字就是false，因为value已经加上去了，这里需要注意一下</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------------------------------------</span><br><span class="line"></span><br><span class="line">&apos;+’ 的隐式类型转换规则</span><br><span class="line">如果其中有一个是字符串，另外一个是 undefined、null 或布尔型，则调用 toString() 方法进行字符串拼接；如果是纯对象、数组、正则等，则默认调用对象的转换方法会存在优先级，然后再进行拼接。</span><br><span class="line">如果其中有一个是数字，另外一个是 undefined、null、布尔型或数字，则会将其转换成数字进行加法运算，对象的情况还是参考上一条规则。</span><br><span class="line">如果其中一个是字符串、一个是数字，则按照字符串规则进行拼接</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-------------------------------------------------------</span><br><span class="line">Object 的转换规则</span><br><span class="line">如果部署了 Symbol.toPrimitive 方法，优先调用再返回；</span><br><span class="line">调用 valueOf()，如果转换为基础类型，则返回；</span><br><span class="line">调用 toString()，如果转换为基础类型，则返回；</span><br><span class="line">如果都没有返回基础类型，会报错。</span><br></pre></td></tr></table></figure>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><h4 id="http-proxy-middleware"><a href="#http-proxy-middleware" class="headerlink" title="http-proxy-middleware"></a>http-proxy-middleware</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// javascript</span><br><span class="line"></span><br><span class="line">const express = require(&apos;express&apos;);</span><br><span class="line">const &#123; createProxyMiddleware &#125; = require(&apos;http-proxy-middleware&apos;);</span><br><span class="line"></span><br><span class="line">const app = express();</span><br><span class="line"></span><br><span class="line">app.use(&apos;/api&apos;, createProxyMiddleware(&#123; target: &apos;http://www.example.org&apos;, changeOrigin: true &#125;));</span><br><span class="line">app.listen(3000);</span><br><span class="line"></span><br><span class="line">// http://localhost:3000/api/foo/bar -&gt; http://www.example.org/api/foo/bar</span><br></pre></td></tr></table></figure>
<ul>
<li>箭头函数有几个使用注意点。<br>（1）箭头函数没有自己的 this 对象。对于普通函数来说，内部的 this 指向函数运行时所在的对象，但是这一点对箭头函数不立。它没有自己的 this 对象，内部的 this 就是定义时上层作用域中的 this。也就是说，箭头函数内部的 this 指向是固定的，相比之下，普通函数的 this 指向是可变的。<br>（2）不可以当作构造函数，也就是说，不可以对箭头函数使用 new 命令，否则会抛出一个错误。<br>（3）不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。<br>（4）不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。</li>
<li>AMD 是”Asynchronous Module Definition”的缩写，意思就是”异步模块定义”。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。require.js 实现了 AMD 规范。浏览器端的模块，不能采用”同步加载”（synchronous），只能采用”异步加载”（asynchronous）。这就是 AMD 规范诞生的背景。<br>CommonJS node.js 的模块系统，就是参照 CommonJS 规范实现的。在 CommonJS 中，有一个全局性方法 require()，用于加载模块。<br>RequireJS 的做法是并行加载所有依赖的模块, 并完成解析后, 再开始执行其他代码。<br>而 SeaJS 一样是并行加载所有依赖的模块, 但不会立即执行模块, 等到真正需要(require)的时候才开始解析。</li>
<li>WebP 新一代图片格式，有损压缩，压缩体积小，在压缩方面比当前 JPEG 格式更优越。谷歌表示，webp 这种格式的主要优势在于高效率。他们发现，“在质量相同的情况下，WebP 格式图像的体积要比 JPEG 格式图像小 40%。美中不足的是，WebP 格式图像的编码时间“比 JPEG 格式图像长8 倍”。<br>png 是一种采用无损压缩算法的位图格式，其设计目的是试图替代 GIF 和 TIFF 文件格式，压缩比高，生成文件体积小。<br>JPEG 有损压缩</li>
<li>设置元素浮动后，该元素的 display 值为 block(window.getComputedStyle(‘对应 dom 元素’))</li>
<li>块格式化上下文(<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context</a>)<br>块格式化上下文（Block Formatting Context，BFC） 是 Web 页面的可视 CSS 渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。<br>块格式化上下文对浮动定位（参见 float）与清除浮动（参见 clear）都很重要。浮动定位和清除浮动时只会应用于同一个 BFC 内的元素。浮动不会影响其它 BFC 中元素的布局，而清除浮动只能清除同一 BFC 中在它前面的元素的浮动。外边距折叠（Margin collapsing）也只会发生在属于同一 BFC 的块级元素之间。<br>下列方式会创建块格式化上下文：<br>根元素（<code>&lt;html&gt;</code>）<br>浮动元素（元素的 float 不是 none）<br>绝对定位元素（元素的 position 为 absolute 或 fixed）<br>行内块元素（元素的 display 为 inline-block）<br>表格单元格（元素的 display 为 table-cell，HTML 表格单元格默认为该值）<br>表格标题（元素的 display 为 table-caption，HTML 表格标题默认为该值）<br>匿名表格单元格元素（元素的 display 为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是 HTML table、row、tbody、thead、tfoot 的默认属性）或 inline-table）<br>overflow 计算值(Computed)不为 visible 的块元素<br>display 值为 flow-root 的元素<br>contain 值为 layout、content 或 paint 的元素<br>弹性元素（display 为 flex 或 inline-flex 元素的直接子元素）<br>网格元素（display 为 grid 或 inline-grid 元素的直接子元素）<br>多列容器（元素的 column-count 或 column-width (en-US) 不为 auto，包括 column-count 为 1）</li>
<li>清除浮动</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.clear:after</span><br><span class="line">&#123;</span><br><span class="line">    content:&apos;&apos;;</span><br><span class="line">    display:table;</span><br><span class="line">    clear:both;</span><br><span class="line">&#125;</span><br><span class="line">.clear</span><br><span class="line">&#123;</span><br><span class="line">    *zoom:1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Cache Manifest</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line"># 2012-02-21 v1.0.0</span><br><span class="line">/theme.css</span><br><span class="line">/logo.gif</span><br><span class="line">/main.js</span><br><span class="line"></span><br><span class="line">NETWORK:</span><br><span class="line">login.php</span><br><span class="line"></span><br><span class="line">FALLBACK:</span><br><span class="line">/html/ /offline.html</span><br></pre></td></tr></table></figure>
<ul>
<li>web worker 是运行在后台的 JavaScript，不会影响页面的性能。<br>当在 HTML 页面中执行脚本时，页面的状态是不可响应的，直到脚本已完成。<br>web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;计数： &lt;output id=&quot;result&quot;&gt;&lt;/output&gt;&lt;/p&gt;</span><br><span class="line">&lt;button onclick=&quot;startWorker()&quot;&gt;开始工作&lt;/button&gt;</span><br><span class="line">&lt;button onclick=&quot;stopWorker()&quot;&gt;停止工作&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; Internet Explorer 9 及更早 IE 版本浏览器不支持 Web Workers.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">var w;</span><br><span class="line"></span><br><span class="line">function startWorker() &#123;</span><br><span class="line">    if(typeof(Worker) !== &quot;undefined&quot;) &#123;</span><br><span class="line">        if(typeof(w) == &quot;undefined&quot;) &#123;</span><br><span class="line">            w = new Worker(&quot;demo_workers.js&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        w.onmessage = function(event) &#123;</span><br><span class="line">            document.getElementById(&quot;result&quot;).innerHTML = event.data;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        document.getElementById(&quot;result&quot;).innerHTML = &quot;抱歉，你的浏览器不支持 Web Workers...&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function stopWorker()</span><br><span class="line">&#123;</span><br><span class="line">    w.terminate();</span><br><span class="line">    w = undefined;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">demo_workers.js</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var i=0;</span><br><span class="line"></span><br><span class="line">function timedCount()</span><br><span class="line">&#123;</span><br><span class="line">    i=i+1;</span><br><span class="line">    postMessage(i);</span><br><span class="line">    setTimeout(&quot;timedCount()&quot;,500);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timedCount();</span><br></pre></td></tr></table></figure>
<ul>
<li>Web App Manifest Web 应用程序清单在一个 JSON 文本文件中提供有关应用程序的信息（如名称，作者，图标和描述）。manifest 的目的是将 Web 应用程序安装到设备的主屏幕，为用户提供更快的访问和更丰富的体验。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;manifest&quot; href=&quot;/manifest.json&quot;&gt;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;HackerWeb&quot;,</span><br><span class="line">  &quot;short_name&quot;: &quot;HackerWeb&quot;,</span><br><span class="line">  &quot;start_url&quot;: &quot;.&quot;,</span><br><span class="line">  &quot;display&quot;: &quot;standalone&quot;,</span><br><span class="line">  &quot;background_color&quot;: &quot;#fff&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;A simply readable Hacker News app.&quot;,</span><br><span class="line">  &quot;icons&quot;: [&#123;</span><br><span class="line">    &quot;src&quot;: &quot;images/touch/homescreen48.png&quot;,</span><br><span class="line">    &quot;sizes&quot;: &quot;48x48&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;image/png&quot;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    &quot;src&quot;: &quot;images/touch/homescreen72.png&quot;,</span><br><span class="line">    &quot;sizes&quot;: &quot;72x72&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;image/png&quot;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    &quot;src&quot;: &quot;images/touch/homescreen96.png&quot;,</span><br><span class="line">    &quot;sizes&quot;: &quot;96x96&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;image/png&quot;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    &quot;src&quot;: &quot;images/touch/homescreen144.png&quot;,</span><br><span class="line">    &quot;sizes&quot;: &quot;144x144&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;image/png&quot;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    &quot;src&quot;: &quot;images/touch/homescreen168.png&quot;,</span><br><span class="line">    &quot;sizes&quot;: &quot;168x168&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;image/png&quot;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    &quot;src&quot;: &quot;images/touch/homescreen192.png&quot;,</span><br><span class="line">    &quot;sizes&quot;: &quot;192x192&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;image/png&quot;</span><br><span class="line">  &#125;],</span><br><span class="line">  &quot;related_applications&quot;: [&#123;</span><br><span class="line">    &quot;platform&quot;: &quot;web&quot;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    &quot;platform&quot;: &quot;play&quot;,</span><br><span class="line">    &quot;url&quot;: &quot;https://play.google.com/store/apps/details?id=cheeaun.hackerweb&quot;</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>offsetWidth :内容宽度+padding+border<br>offsetHeight :内容高度+padding+border<br>clientWidth :内容宽度+padding<br>clientHeight :内容高度度+padding<br>scrollWidth,<br>scrollHeight :能够滚动的内容高度+padding <code>1340=44*30（滚动内容高度）+20（padding-top）</code><br>offsetTop : 距离具有定位属性的父盒子的距离,父盒子没有定位属性则一直向上找直到 body(不带 border 值)<br>offsetLeft<br>clientTop:border-top 的值<br>clientLeft:border-left<br>scrollTop:滚动条滚动距离(需要 onscroll 事件监听)<br>scrollLeft</p>
</li>
<li><p><code>[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;].map(parseInt) [ 1, NaN, NaN ]</code></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">parseInt(string, radix);</span><br><span class="line"></span><br><span class="line">string</span><br><span class="line">要被解析的值。如果参数不是一个字符串，则将其转换为字符串(使用  ToString 抽象操作)。字符串开头的空白符将会被忽略。</span><br><span class="line">radix 可选</span><br><span class="line">从 2 到 36，表示字符串的基数。例如指定 16 表示被解析值是十六进制数。请注意，10不是默认值！</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如果 radix 是 undefined、0或未指定的，JavaScript会假定以下情况：</span><br><span class="line">如果输入的 string以 &quot;0x&quot;或 &quot;0x&quot;（一个0，后面是小写或大写的X）开头，那么radix被假定为16，字符串的其余部分被当做十六进制数去解析。</span><br><span class="line">如果输入的 string以 &quot;0&quot;（0）开头， radix被假定为8（八进制）或10（十进制）。具体选择哪一个radix取决于实现。ECMAScript 5 澄清了应该使用 10 (十进制)，但不是所有的浏览器都支持。因此，在使用 parseInt 时，一定要指定一个 radix。</span><br><span class="line">如果输入的 string 以任何其他值开头， radix 是 10 (十进制)。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">当radix 小于 2 或大于 36 ，或第一个非空格字符不能转换为数字，parseInt会返回 NaN。</span><br><span class="line"></span><br><span class="line">parseInt(&apos;123&apos;, 5) // 将&apos;123&apos;看作5进制数，返回十进制数38 =&gt; 1*5^2 + 2*5^1 + 3*5^0 = 38</span><br><span class="line"></span><br><span class="line">以下例子均返回 NaN:</span><br><span class="line">parseInt(&quot;Hello&quot;, 8); // 根本就不是数值</span><br><span class="line">parseInt(&quot;546&quot;, 2);   // 除了“0、1”外，其它数字都不是有效二进制数字</span><br></pre></td></tr></table></figure>
<ul>
<li>use strict</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function f()&#123;</span><br><span class="line">    return !this;</span><br><span class="line">&#125;</span><br><span class="line">// 返回false，因为&quot;this&quot;指向全局对象，&quot;!this&quot;就是false</span><br><span class="line"></span><br><span class="line">function f()&#123;</span><br><span class="line">    &quot;use strict&quot;;</span><br><span class="line">    return !this;</span><br><span class="line">&#125;</span><br><span class="line">// 返回true，因为严格模式下，this的值为undefined，所以&quot;!this&quot;为true。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;use strict&quot;;</span><br><span class="line">x = &#123;p1:10, p2:20&#125;;      // 报错 (x 未定义)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;use strict&quot;;</span><br><span class="line">x = 3.14;                // 报错 (x 未定义)</span><br></pre></td></tr></table></figure>
<ul>
<li>Properties attributes</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Properties&#123;</span><br><span class="line">  标签上面的属性</span><br><span class="line">  attributes:&#123;</span><br><span class="line">   id</span><br><span class="line">   class</span><br><span class="line">  &#125;,</span><br><span class="line">  id</span><br><span class="line">  className</span><br><span class="line">  innerHTML</span><br><span class="line">  onclick</span><br><span class="line">  scrollTop</span><br><span class="line">  replaceChild</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>options 请求方法要求服务器列出可对资源实行的操作方法（Access-Control-Allow-Methods: GET），在响应头的 Allow 字段里返回。它的功能很有限，用处也不大，有的服务器（例如 Nginx）干脆就没有实现对它的支持。</li>
<li><p>HEAD：获取资源的元信息；</p>
</li>
<li><p>JavaScript 类型化数组</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">JavaScript类型化数组是一种类似数组的对象，并提供了一种用于访问原始二进制数据的机制。 正如你可能已经知道，Array 存储的对象能动态增多和减少，并且可以存储任何JavaScript值。JavaScript引擎会做一些内部优化，以便对数组的操作可以很快。然而，随着Web应用程序变得越来越强大，尤其一些新增加的功能例如：音频视频编辑，访问WebSockets的原始数据等，很明显有些时候如果使用JavaScript代码可以快速方便地通过类型化数组来操作原始的二进制数据将会非常有帮助。</span><br><span class="line"></span><br><span class="line">但是，不要把类型化数组与正常数组混淆，因为在类型数组上调用  Array.isArray()  会返回false。此外，并不是所有可用于正常数组的方法都能被类型化数组所支持（如 push 和 pop）。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">为了达到最大的灵活性和效率，JavaScript 类型数组（Typed Arrays）将实现拆分为缓冲和视图两部分。一个缓冲（由 ArrayBuffer 对象实现）描述的是一个数据块。缓冲没有格式可言，并且不提供机制访问其内容。为了访问在缓冲对象中包含的内存，你需要使用视图。视图提供了上下文 — 即数据类型、起始偏移量和元素数 — 将数据转换为实际有类型的数组。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var buffer = new ArrayBuffer(16);</span><br><span class="line">var int32View = new Int32Array(buffer);</span><br><span class="line">for (var i = 0; i &lt; int32View.length; i++) &#123;</span><br><span class="line">  int32View[i] = i * 2;</span><br><span class="line">&#125;</span><br><span class="line">该代码会将数组以0, 2, 4和6填充 （一共4个4字节元素，所以总长度为16字节）。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var int16View = new Int16Array(buffer);</span><br><span class="line"></span><br><span class="line">for (var i = 0; i &lt; int16View.length; i++) &#123;</span><br><span class="line">  console.log(&quot;Entry &quot; + i + &quot;: &quot; + int16View[i]);</span><br><span class="line">&#125;</span><br><span class="line">这里我们创建了一个2字节整数视图，该视图共享上文的4字节整数视图的缓冲，然后以2字节整数打印出缓冲里的数据，这次我们会得到0, 0, 2, 0, 4, 0, 6, 0这样的输出。</span><br></pre></td></tr></table></figure>
<ul>
<li>设计模式<ul>
<li>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。</li>
<li>观察者模式。当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知依赖它的对象。观察者模式属于行为型模式。</li>
</ul>
</li>
<li>window.onpopstate<br>注意：调用 history.pushState()或者 history.replaceState()不会触发 popstate 事件. popstate 事件只会在浏览器某些行为下触发, 比如点击后退、前进按钮(或者在 JavaScript 中调用 history.back()、history.forward()、history.go()方法)，此外，a 标签的锚点也会触发该事件.</li>
<li>Object.getOwnPropertyDescriptor() 方法返回指定对象上一个自有属性对应的属性描述符。（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）<br>一个属性描述符是一个记录，由下面属性当中的某些组成的：<br>value<br>该属性的值(仅针对数据属性描述符有效)<br>writable<br>当且仅当属性的值可以被改变时为 true。(仅针对数据属性描述有效)<br>get<br>获取该属性的访问器函数（getter）。如果没有访问器，该值为 undefined。(仅针对包含访问器或设置器的属性描述有效)<br>set<br>获取该属性的设置器函数（setter）。如果没有设置器，该值为 undefined。(仅针对包含访问器或设置器的属性描述有效)<br>configurable<br>当且仅当指定对象的属性描述可以被改变或者属性可被删除时，为 true。<br>enumerable<br>当且仅当指定对象的属性可以被枚举出时，为 true</li>
</ul>
<h3 id="typescript"><a href="#typescript" class="headerlink" title="typescript"></a>typescript</h3><ul>
<li>readonly vs const<br>最简单判断该用 readonly 还是 const 的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 const，若做为属性则使用 readonly。</li>
<li><p>对象展开还有其它一些意想不到的限制。 首先，它仅包含对象自身的可枚举属性。 大体上是说当你展开一个对象实例时，你会丢失其方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class C &#123;</span><br><span class="line">  p = 12;</span><br><span class="line">  m() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let c = new C();</span><br><span class="line">let clone = &#123; ...c &#125;;</span><br><span class="line">clone.p; // ok</span><br><span class="line">clone.m(); // error!</span><br></pre></td></tr></table></figure>
</li>
<li><p>联合类型（Union Types）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface Bird &#123;</span><br><span class="line">  fly();</span><br><span class="line">  layEggs();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">interface Fish &#123;</span><br><span class="line">  swim();</span><br><span class="line">  ayEggs();</span><br><span class="line">&#125;</span><br><span class="line">function getSmallPet(): Fish | Bird &#123;</span><br><span class="line">// ...</span><br><span class="line">&#125;</span><br><span class="line">let pet = getSmallPet();</span><br><span class="line">pet.layEggs(); // okay</span><br><span class="line">pet.swim(); // errors</span><br></pre></td></tr></table></figure>
</li>
<li><p>类型断言有两种形式。 其一是“尖括号”语法。另一个为 as 语法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let someValue: any = &quot;this is a string&quot;;</span><br><span class="line"></span><br><span class="line">let strLength: number = (&lt;string&gt;someValue).length;</span><br><span class="line"></span><br><span class="line">let someValue: any = &quot;this is a string&quot;;</span><br><span class="line"></span><br><span class="line">let strLength: number = (someValue as string).length;</span><br></pre></td></tr></table></figure>
</li>
<li><p>数组<br>有两种方式可以定义数组。 第一种，可以在元素类型后面接上 <code>[]</code>，表示由此类型元素组成的一个数组。第二种方式是使用数组泛型，<code>Array&lt;元素类型&gt;</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let list: number[] = [1, 2, 3];</span><br><span class="line">let list: Array&lt;number&gt; = [1, 2, 3];</span><br></pre></td></tr></table></figure>
</li>
<li><p>元组 Tuple<br>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string 和 number 类型的元组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Declare a tuple type</span><br><span class="line">let x: [string, number];</span><br><span class="line">// Initialize it</span><br><span class="line">x = [&apos;hello&apos;, 10]; // OK</span><br><span class="line">// Initialize it incorrectly</span><br><span class="line">x = [10, &apos;hello&apos;]; // Error</span><br></pre></td></tr></table></figure>
</li>
<li><p>接口 vs. 类型别名</p>
<ul>
<li>接口创建了一个新的名字，可以在其它任何地方使用。 类型别名并不创建新名字—比如，错误信息就不会使用别名。 在下面的示例代码里，在编译器中将鼠标悬停在 interfaced 上，显示它返回的是 Interface，但悬停在 aliased 上时，显示的却是对象字面量类型。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type Alias = &#123; num: number &#125;</span><br><span class="line">interface Interface &#123;</span><br><span class="line">    num: number;</span><br><span class="line">&#125;</span><br><span class="line">declare function aliased(arg: Alias): Alias;</span><br><span class="line">declare function interfaced(arg: Interface): Interface;</span><br></pre></td></tr></table></figure>
<ul>
<li>另一个重要区别是类型别名不能被 extends 和 implements（自己也不能 extends 和 implements 其它类型）。</li>
<li>如果你无法通过接口来描述一个类型并且需要使用联合类型或元组类型，这时通常会使用类型别名。</li>
</ul>
</li>
<li><p>类型别名</p>
<ul>
<li>类型别名有时和接口很像，但是可以作用于原始值，联合类型，元组以及其它任何你需要手写的类型。</li>
<li>起别名不会新建一个类型 - 它创建了一个新名字来引用那个类型。 给原始类型起别名通常没什么用，尽管可以做为文档的一种形式使用。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type Name = string;</span><br><span class="line">type NameResolver = () =&gt; string;</span><br><span class="line">type NameOrResolver = Name | NameResolver;</span><br><span class="line">function getName(n: NameOrResolver): Name &#123;</span><br><span class="line">    if (typeof n === &apos;string&apos;) &#123;</span><br><span class="line">        return n;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        return n();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>与交叉类型一起使用，我们可以创建出一些十分稀奇古怪的类型。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type LinkedList&lt;T&gt; = T &amp; &#123; next: LinkedList&lt;T&gt; &#125;;</span><br><span class="line"></span><br><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var people: LinkedList&lt;Person&gt;;</span><br><span class="line">var s = people.name;</span><br><span class="line">var s = people.next.name;</span><br><span class="line">var s = people.next.next.name;</span><br><span class="line">var s = people.next.next.next.name;</span><br></pre></td></tr></table></figure>
<ul>
<li>类型别名不能出现在声明右侧的任何地方。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type Yikes = Array&lt;Yikes&gt;; // error</span><br></pre></td></tr></table></figure>
<ul>
<li>同接口一样，类型别名也可以是泛型 - 我们可以添加类型参数并且在别名声明的右侧传入<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type Container&lt;T&gt; = &#123; value: T &#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>keyof 索引类型查询操作符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line">let personProps: keyof Person; // &apos;name&apos; | &apos;age&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>模块解析<br>共有两种可用的模块解析策略：Node 和 Classic。 你可以使用 –moduleResolution 标记来指定使用哪种模块解析策略。若未指定，那么在使用了 <code>--module AMD | System | ES2015</code>时的默认值为 Classic，其它情况时则为 Node。</p>
<pre><code>- Classic
  - 这种策略在以前是 TypeScript 默认的解析策略。 现在，它存在的理由主要是为了向后兼容。
    相对导入的模块是相对于导入它的文件进行解析的。 因此 `/root/src/folder/A.ts` 文件里的 `import { b } from &quot;./moduleB&quot;`会使用下面的查找流程：
    `/root/src/folder/moduleB.ts`
    `/root/src/folder/moduleB.d.ts`
  - 对于非相对模块的导入，编译器则会从包含导入文件的目录开始依次向上级目录遍历，尝试定位匹配的声明文件。
    有一个对 moduleB 的非相对导入 `import { b } from &quot;moduleB&quot;`，它是在`/root/src/folder/A.ts` 文件里，会以如下的方式来定位&quot;moduleB&quot;：
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/root/src/folder/moduleB.ts</span><br><span class="line">         /root/src/folder/moduleB.d.ts</span><br><span class="line">         /root/src/moduleB.ts</span><br><span class="line">         /root/src/moduleB.d.ts</span><br><span class="line">         /root/moduleB.ts</span><br><span class="line">         /root/moduleB.d.ts</span><br><span class="line">         /moduleB.ts</span><br><span class="line">         /moduleB.d.ts</span><br></pre></td></tr></table></figure>

- Node

  - Node.js 如何解析模块

    - 相对路径很简单。 例如，假设有一个文件路径为 `/root/src/moduleA.js`，包含了一个导入 `var x = require(&quot;./moduleB&quot;);` Node.js 以下面的顺序解析这个导入：
      检查`/root/src/moduleB.js` 文件是否存在。
      检查`/root/src/moduleB` 目录是否包含一个 package.json 文件，且 package.json 文件指定了一个&quot;main&quot;模块。 在我们的例子里，如果 Node.js 发现文件 `/root/src/moduleB/package.json` 包含了`{ &quot;main&quot;: &quot;lib/mainModule.js&quot; }`，那么 Node.js 会引用`/root/src/moduleB/lib/mainModule.js`。
      检查`/root/src/moduleB `目录是否包含一个 index.js 文件。 这个文件会被隐式地当作那个文件夹下的&quot;main&quot;模块。
    - 但是，非相对模块名的解析是个完全不同的过程。 Node 会在一个特殊的文件夹 node_modules 里查找你的模块。 node_modules 可能与当前文件在同一级目录下，或者在上层目录里。 Node 会向上级目录遍历，查找每个 node_modules 直到它找到要加载的模块。
      假设`/root/src/moduleA.js` 里使用的是非相对路径导入` var x = require(&quot;moduleB&quot;);`。 Node 则会以下面的顺序去解析 moduleB，直到有一个匹配上。
      `/root/src/node_modules/moduleB.js`
      `/root/src/node_modules/moduleB/package.json` (如果指定了&quot;main&quot;属性)
      `/root/src/node_modules/moduleB/index.js`

      `/root/node_modules/moduleB.js`
      `/root/node_modules/moduleB/package.json` (如果指定了&quot;main&quot;属性)
      `/root/node_modules/moduleB/index.js`

      `/node_modules/moduleB.js`
      `/node_modules/moduleB/package.json` (如果指定了&quot;main&quot;属性)
      `/node_modules/moduleB/index.js`

  - TypeScript 如何解析模块
    - 有一个导入语句 `import { b } from &quot;./moduleB&quot;`在`/root/src/moduleA.ts` 里，会以下面的流程来定位`&quot;./moduleB&quot;`：
      /root/src/moduleB.ts
      /root/src/moduleB.tsx
      /root/src/moduleB.d.ts
      /root/src/moduleB/package.json (如果指定了&quot;types&quot;属性)
      /root/src/moduleB/index.ts
      /root/src/moduleB/index.tsx
      /root/src/moduleB/index.d.ts
    - 非相对的导入会遵循 Node.js 的解析逻辑，首先查找文件，然后是合适的文件夹。 因此 /root/src/moduleA.ts 文件里的 `import { b } from &quot;moduleB&quot;`会以下面的查找顺序解析：
      /root/src/node_modules/moduleB.ts
      /root/src/node_modules/moduleB.tsx
      /root/src/node_modules/moduleB.d.ts
      /root/src/node_modules/moduleB/package.json (如果指定了&quot;types&quot;属性)
      /root/src/node_modules/moduleB/index.ts
      /root/src/node_modules/moduleB/index.tsx
      /root/src/node_modules/moduleB/index.d.ts

      /root/node_modules/moduleB.ts
      /root/node_modules/moduleB.tsx
      /root/node_modules/moduleB.d.ts
      /root/node_modules/moduleB/package.json (如果指定了&quot;types&quot;属性)
      /root/node_modules/moduleB/index.ts
      /root/node_modules/moduleB/index.tsx
      /root/node_modules/moduleB/index.d.ts

      /node_modules/moduleB.ts
      /node_modules/moduleB.tsx
      /node_modules/moduleB.d.ts
      /node_modules/moduleB/package.json (如果指定了&quot;types&quot;属性)
      /node_modules/moduleB/index.ts
      /node_modules/moduleB/index.tsx
      /node_modules/moduleB/index.d.ts
</code></pre></li>
<li><p>declare</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">jQuery(&apos;#foo&apos;);</span><br><span class="line"></span><br><span class="line">// index.ts(1,1): error TS2304: Cannot find name &apos;jQuery&apos;.</span><br><span class="line"></span><br><span class="line">declare var jQuery: (selector: string) =&gt; any;</span><br><span class="line"></span><br><span class="line">jQuery(&apos;#foo&apos;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Thunk-函数的含义和用法"><a href="#Thunk-函数的含义和用法" class="headerlink" title="Thunk 函数的含义和用法"></a>Thunk 函数的含义和用法</h3><p><strong><a href="https://www.ruanyifeng.com/blog/2015/05/thunk.html" target="_blank" rel="noopener">https://www.ruanyifeng.com/blog/2015/05/thunk.html</a></strong></p>
<p>在 JavaScript 语言中，Thunk 函数替换的不是表达式，而是多参数函数，将其替换成单参数的版本，且只接受回调函数作为参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 正常版本的readFile（多参数版本）</span><br><span class="line">fs.readFile(fileName, callback);</span><br><span class="line"></span><br><span class="line">// Thunk版本的readFile（单参数版本）</span><br><span class="line">var readFileThunk = Thunk(fileName);</span><br><span class="line">readFileThunk(callback);</span><br><span class="line"></span><br><span class="line">var Thunk = function (fileName)&#123;</span><br><span class="line">  return function (callback)&#123;</span><br><span class="line">    return fs.readFile(fileName, callback); </span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var thunkify = require(&apos;thunkify&apos;);</span><br><span class="line">var fs = require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">var read = thunkify(fs.readFile);</span><br><span class="line">read(&apos;package.json&apos;)(function(err, str)&#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="Thunk-函数的自动流程管理"><a href="#Thunk-函数的自动流程管理" class="headerlink" title="Thunk 函数的自动流程管理"></a>Thunk 函数的自动流程管理</h4><p>Thunk 函数真正的威力，在于可以自动执行 Generator 函数。下面就是一个基于 Thunk 函数的 Generator 执行器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function run(fn) &#123;</span><br><span class="line">  var gen = fn();</span><br><span class="line"></span><br><span class="line">  function next(err, data) &#123;</span><br><span class="line">    var result = gen.next(data);</span><br><span class="line">    if (result.done) return;</span><br><span class="line">    result.value(next);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(gen);</span><br></pre></td></tr></table></figure>
<p>上面代码的 run 函数，就是一个 Generator 函数的自动执行器。内部的 next 函数就是 Thunk 的回调函数。 next 函数先将指针移到 Generator 函数的下一步（gen.next 方法），然后判断 Generator 函数是否结束（result.done 属性），如果没结束，就将 next 函数再传入 Thunk 函数（result.value 属性），否则就直接退出。</p>
<h3 id="co-函数库的含义和用法"><a href="#co-函数库的含义和用法" class="headerlink" title="co 函数库的含义和用法"></a>co 函数库的含义和用法</h3><p>比如，有一个 Generator 函数，用于依次读取两个文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var gen = function* ()&#123;</span><br><span class="line">  var f1 = yield readFile(&apos;/etc/fstab&apos;);</span><br><span class="line">  var f2 = yield readFile(&apos;/etc/shells&apos;);</span><br><span class="line">  console.log(f1.toString());</span><br><span class="line">  console.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>co 函数库可以让你不用编写 Generator 函数的执行器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var co = require(&apos;co&apos;);</span><br><span class="line">co(gen);</span><br></pre></td></tr></table></figure>
<p>上面代码中，Generator 函数只要传入 co 函数，就会自动执行。</p>
<p>co 函数返回一个 Promise 对象，因此可以用 then 方法添加回调函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">co(gen).then(function ()&#123;</span><br><span class="line">  console.log(&apos;Generator 函数执行完成&apos;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>上面代码中，等到 Generator 函数执行结束，就会输出一行提示。</p>
<h3 id="async-函数的含义和用法"><a href="#async-函数的含义和用法" class="headerlink" title="async 函数的含义和用法"></a>async 函数的含义和用法</h3><p>async 函数对 Generator 函数的改进，体现在以下三点。</p>
<ul>
<li>内置执行器。 Generator 函数的执行必须靠执行器，所以才有了 co 函数库，而 async 函数自带执行器。也就是说，async 函数的执行，与普通函数一模一样，只要一行。</li>
<li>更好的语义。 async 和 await，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。</li>
<li>更广的适用性。 co 函数库约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以跟 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。</li>
</ul>
<h2 id="前端安全"><a href="#前端安全" class="headerlink" title="前端安全"></a>前端安全</h2><p>XSS 全称是 Cross Site Scripting，为了与“CSS”区分开来，故简称 XSS，翻译过来就是“跨站脚本”。<br>针对 XSS 攻击，主要有三种防范策略，第一种是通过服务器对输入的内容进行过滤或者转码，第二种是充分利用好 CSP，第三种是使用 HttpOnly 来保护重要的 Cookie 信息。<br>当然除了以上策略之外，我们还可以通过添加验证码防止脚本冒充用户提交危险操作。而对于一些不受信任的输入，还可以限制其输入长度，这样可以增大 XSS 攻击的难度。</p>
<p>CSRF 英文全称是 Cross-site request forgery，所以又称为“跨站请求伪造”<br>和 XSS 不同的是，CSRF 攻击不需要将恶意代码注入用户的页面，仅仅是利用服务器的漏洞和用户的登录状态来实施攻击。<br>要让服务器避免遭受到 CSRF 攻击，通常有以下几种途径。<br>充分利用好 Cookie 的 SameSite 属性<br>验证请求的来源站点<br>CSRF Token</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">在 HTTP 响应头中，通过 set-cookie 字段设置 Cookie 时，可以带上 SameSite 选项，如下：</span><br><span class="line">set-cookie: 1P_JAR=2019-10-20-06; expires=Tue, 19-Nov-2019 06:36:21 GMT; path=/; domain=.google.com; SameSite=none</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SameSite 选项通常有 Strict、Lax 和 None 三个值。</span><br><span class="line">1. Strict 最为严格。如果 SameSite 的值是 Strict，那么浏览器会完全禁止第三方 Cookie。</span><br><span class="line">简言之，如果你从a页面中访问 b的资源，而 b 的某些 Cookie 设置了 SameSite = Strict 的话，</span><br><span class="line">那么这些 Cookie 是不会被发送到 b 的服务器上的。</span><br><span class="line">只有你从 b的站点去请求 b的资源时，才会带上这些 Cookie。</span><br><span class="line">2.Lax 相对宽松一点。在跨站点的情况下，从第三方站点的链接打开和从第三方站点提交 Get 方式的表单这两种方式都会携带 Cookie。</span><br><span class="line">但如果在第三方站点中使用 Post 方法，或者通过 img、iframe 等标签加载的 URL，这些场景都不会携带 Cookie。</span><br><span class="line">3.而如果使用 None 的话，在任何情况下都会发送 Cookie 数据。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">大致分为两步：</span><br><span class="line">第一步，在浏览器向服务器发起请求时，服务器生成一个 CSRF Token。</span><br><span class="line">CSRF Token 其实就是服务器生成的字符串，然后将该字符串植入到返回的页面中。你可以参考下面示例代码：</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form action=&quot;https://diamonds.org/sendcoin&quot; method=&quot;POST&quot;&gt;</span><br><span class="line">      &lt;input type=&quot;hidden&quot; name=&quot;csrf-token&quot; value=&quot;nc98P987bcpncYhoadjoiydc9ajDlcn&quot;&gt;</span><br><span class="line">      &lt;input type=&quot;text&quot; name=&quot;user&quot;&gt;</span><br><span class="line">      &lt;input type=&quot;text&quot; name=&quot;number&quot;&gt;</span><br><span class="line">      &lt;input type=&quot;submit&quot;&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第二步，在浏览器端如果要发起转账的请求，那么需要带上页面中的 CSRF Token，然后服务器会验证该 Token 是否合法。</span><br><span class="line">如果是从第三方站点发出的请求，那么将无法获取到 CSRF Token 的值，所以即使发出了请求，服务器也会因为 CSRF Token 不正确而拒绝请求。</span><br></pre></td></tr></table></figure>
<p>现代浏览器采用了多进程架构，将渲染进程和浏览器主进程做了分离，浏览器被划分为浏览器内核和渲染内核两个核心模块，其中浏览器内核是由网络进程、浏览器主进程和 GPU 进程组成的，渲染内核就是渲染进程。<br>浏览器中的安全沙箱是利用操作系统提供的安全技术，让渲染进程在执行过程中无法访问或者修改操作系统中的数据，在渲染进程需要访问系统资源的时候，需要通过浏览器内核来实现，然后将访问的结果通过 IPC 转发给渲染进程。</p>
<h2 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h2><h3 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line">(function (modules) &#123;&#125;)(&#123;</span><br><span class="line">  &quot;&quot;: function (module,exports) &#123;&#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//--------------------------------------------</span><br><span class="line">// ES Modules</span><br><span class="line">// 1.自动采用严格模式（use strict）</span><br><span class="line">// 2.每个ESM模块都是单独的私有作用域</span><br><span class="line">// 3.ESM模块通过CORS（跨域资源共享）去请求外部js模块</span><br><span class="line">// 4.ESM的script标签会延迟脚本的执行</span><br><span class="line">//--------------------------------------------</span><br><span class="line">// url-loader  小文件使用Data URLs,减少请求次数 一个用于webpack的加载器，它将文件转换为base64 uri。</span><br><span class="line">// file-loader 大文件单独提取存放，提高加载速度  文件加载器将文件上的import/require()解析为一个url，并将文件发送到输出目录中。</span><br><span class="line"></span><br><span class="line">// css-loader 将css代码转换成js模块</span><br><span class="line">// style-loader 将css代码通过style标签插入html当中</span><br><span class="line"></span><br><span class="line">//html-loader 默认情况下，每个本地的 &lt;img src=&quot;image.png&quot;&gt; 都需要通过 require （require(&apos;./image.png&apos;)）来进行加载。你可能需要在配置中为图片指定 loader（推荐 file-loader 或 url-loader ） 你可以通过查询参数 attrs，来指定哪个标签属性组合(tag-attribute combination)应该被此 loader 处理。传递数组或以空格分隔的 &lt;tag&gt;:&lt;attribute&gt; 组合的列表。（默认值：attrs=img:src）</span><br><span class="line"></span><br><span class="line">// &#123;</span><br><span class="line">//   module: &#123;</span><br><span class="line">//     rules: [</span><br><span class="line">//       &#123; test: /\.jpg$/, use: [ &quot;file-loader&quot; ] &#125;,</span><br><span class="line">//       &#123; test: /\.png$/, use: [ &quot;url-loader?mimetype=image/png&quot; ] &#125;</span><br><span class="line">//     ]</span><br><span class="line">//   &#125;,</span><br><span class="line">//   output: &#123;</span><br><span class="line">//     publicPath: &quot;http://cdn.example.com/[hash]/&quot;</span><br><span class="line">//   &#125;</span><br><span class="line">// &#125;</span><br><span class="line">// &lt;!-- file.html --&gt;</span><br><span class="line">// &lt;img src=&quot;image.png&quot; data-src=&quot;image2x.png&quot; &gt;</span><br><span class="line">// require(&quot;html-loader!./file.html&quot;);</span><br><span class="line"></span><br><span class="line">// // =&gt; &apos;&lt;img src=&quot;http://cdn.example.com/49eba9f/a992ca.png&quot;</span><br><span class="line">// //         data-src=&quot;image2x.png&quot;&gt;&apos;</span><br><span class="line">// require(&quot;html-loader?attrs=img:data-src!./file.html&quot;);</span><br><span class="line"></span><br><span class="line">// // =&gt; &apos;&lt;img src=&quot;image.png&quot; data-src=&quot;data:image/png;base64,...&quot; &gt;&apos;</span><br><span class="line">// require(&quot;html-loader?attrs=img:src img:data-src!./file.html&quot;);</span><br><span class="line">// require(&quot;html-loader?attrs[]=img:src&amp;attrs[]=img:data-src!./file.html&quot;);</span><br><span class="line"></span><br><span class="line">// // =&gt; &apos;&lt;img  src=&quot;http://cdn.example.com/49eba9f/a992ca.png&quot;</span><br><span class="line">// //           data-src=&quot;data:image/png;base64,...&quot; &gt;&apos;</span><br><span class="line">// require(&quot;html-loader?-attrs!./file.html&quot;);</span><br><span class="line"></span><br><span class="line">// // =&gt; &apos;&lt;img  src=&quot;image.jpg&quot;  data-src=&quot;image2x.png&quot; &gt;&apos;</span><br><span class="line"></span><br><span class="line">//通过运行 webpack --optimize-minimize 来最小化</span><br><span class="line">//或者</span><br><span class="line">// module: &#123;</span><br><span class="line">//   rules: [&#123;</span><br><span class="line">//     test: /\.html$/,</span><br><span class="line">//     use: [ &#123;</span><br><span class="line">//       loader: &apos;html-loader&apos;,</span><br><span class="line">//       options: &#123;</span><br><span class="line">//         minimize: true</span><br><span class="line">//       &#125;</span><br><span class="line">//     &#125;],</span><br><span class="line">//   &#125;]</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">//extract-loader 提取HTML和CSS</span><br><span class="line">// 一个很常见的场景，将 HTML 导出到 .html 文件中，直接访问它们，而不是使用 javascript 注入。这可以通过3个 loader 的组合来实现：file-loader extract-loader html-loader</span><br><span class="line">// html-loader 将解析 URL，并请求图片和你所期望的一切资源。extract-loader 会将 javascript 解析为合适的 html 文件，确保引用的图片指向正确的路径，file-loader 将结果写入 .html 文件。示例：</span><br><span class="line">// &#123;</span><br><span class="line">//   test: /\.html$/,</span><br><span class="line">//   use: [&apos;file-loader?name=[name].[ext]&apos;, &apos;extract-loader&apos;, &apos;html-loader&apos;],</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">// mini-css-extract-plugin</span><br><span class="line">//（css文件超过150kb时可以考虑单独提取） 样式会单独存放在文件当中，不再需要style标签引入（style-loader）,通过link标签方式注入样式文件</span><br><span class="line">// module:&#123;</span><br><span class="line">//   rules:[</span><br><span class="line">//   &#123;</span><br><span class="line">//   test:/\.css$/,</span><br><span class="line">//   use:[</span><br><span class="line">//   MiniCssExtractPlugin.loader,  //通过link标签引入样式文件</span><br><span class="line">//   &apos;css-loader&apos;</span><br><span class="line">//   ]</span><br><span class="line">//   &#125;</span><br><span class="line">// ]</span><br><span class="line">// &#125;</span><br><span class="line">//--------------------------------------------</span><br><span class="line">//loader</span><br><span class="line">// 专注实现资源模块加载，实现项目打包</span><br><span class="line">// 加载过程类似于管道，可以依次使用多个loader，最终结果必须是js代码。</span><br><span class="line">// module:&#123;</span><br><span class="line">//   rules:[</span><br><span class="line">//      &#123;</span><br><span class="line">//      test:/.md$/,</span><br><span class="line">//      use:&apos;./markdown-loader&apos;  //可以是模块路径或模块名称</span><br><span class="line">//      &#125;</span><br><span class="line">//   ]</span><br><span class="line">//   &#125;</span><br><span class="line"></span><br><span class="line">//   //自定义loader  处理md文件</span><br><span class="line">//   const marked=reuqire(&apos;marked&apos;)</span><br><span class="line">//   module.exports=source=&gt;&#123;</span><br><span class="line">//    const html = marked(source)</span><br><span class="line">//    return  `export default $&#123;JSON.stringify(html)&#125;`   //最终输出结果必须是js代码 。   可以返回html，交给html-loader继续处理</span><br><span class="line">//   &#125;</span><br><span class="line"></span><br><span class="line">// 编译转换类：将资源模块转换为js代码。 //css-loader:将css代码转换成js模块</span><br><span class="line">// 文件操作类：将资源模块拷贝到输出目录，向外导出文件的访问路径 //file-loader</span><br><span class="line">// 代码检查类：对资源模块进行校验 //eslint-loader</span><br><span class="line"></span><br><span class="line">//----------------------------------------</span><br><span class="line">//plugin</span><br><span class="line">// 增强webpack自动化能力，实现大多前端工程化 //清除dist目录插件、拷贝不需要参与打包的静态资源文件到输出目录、压缩输出代码等</span><br><span class="line">// 拥有更宽的能力范围，通过钩子机制实现</span><br><span class="line">// 必须是一个函数或者包含apply方法的对象,通过在生命周期的钩子中挂载函数实现扩展</span><br><span class="line">//插件能够 钩入(hook) 到在每个编译(compilation)中触发的所有关键事件。在编译的每一步，插件都具备完全访问 compiler 对象的能力，如果情况合适，还可以访问当前 compilation 对象。</span><br><span class="line"></span><br><span class="line">//自定义插件</span><br><span class="line">// class MyPlugin&#123;</span><br><span class="line"></span><br><span class="line">//   //webpack启动时自动调用</span><br><span class="line">//   apply(compiler)&#123;</span><br><span class="line">//    compiler.hooks.emit.tap(&apos;MyPlugin&apos;,compilation=&gt;&#123;</span><br><span class="line">//      //compilation  //打包上下文</span><br><span class="line">//    //compilation.assets   //打包的资源文件 (对象)</span><br><span class="line">//    //compilation.assets[&apos;文件名&apos;].source()  //资源文件内容</span><br><span class="line"></span><br><span class="line">//    compilation.assets[&apos;文件名&apos;]=&#123;</span><br><span class="line">//     source:()=&gt; 返回更改的文件内容，</span><br><span class="line">//     size:()=&gt;返回文件的大小</span><br><span class="line">//    &#125;</span><br><span class="line">//    &#125;)</span><br><span class="line"></span><br><span class="line">//   &#125;</span><br><span class="line">//  &#125;</span><br><span class="line">// const &#123;CleanWebpackPlugin&#125;  from &apos;clean-webpack-plugin&apos; //自动清除输出目录</span><br><span class="line">// const HtmlWebpackPlugin  from &apos;html-webpack-plugin&apos; //自动生成html</span><br><span class="line">// const CopyWebpackPlugin  from &apos;copy-webpack-plugin&apos; //拷贝不需要打包静态资源到输出目录</span><br><span class="line">// optimize-css-assets-webpack-plugin  //压缩css文件</span><br><span class="line">// optimization:&#123;</span><br><span class="line">//   //webpack默认压缩js代码</span><br><span class="line">//   //production模式自动开启</span><br><span class="line">//   //自动压缩插件</span><br><span class="line">//   minimizer:[</span><br><span class="line">//     new OptimizeCssAssetsWebpackPlugin()</span><br><span class="line">//     new TerserWebpackPlugin()   //压缩js代码</span><br><span class="line">//    ]</span><br><span class="line">//  &#125;</span><br><span class="line">//--------------------------------------</span><br><span class="line">// mode</span><br><span class="line">// production //优化打包结果 代码压缩等</span><br><span class="line">// development //优化打包速度，增加辅助函数便于调试</span><br><span class="line">// none //不做处理</span><br><span class="line">//--------------------------------------</span><br><span class="line">//–-watch 监听文件改变 自动编译</span><br><span class="line">//--------------------------------------</span><br><span class="line">//实现浏览器自动刷新</span><br><span class="line">//browser-sync 文件目录  --files  &apos;**/*&apos; //启动并监听文件改变</span><br><span class="line">//---------------------------------------------</span><br><span class="line">//webpack-dev-server //集成自动编译、自动刷新功能</span><br><span class="line"></span><br><span class="line">//------------------------------------------</span><br><span class="line">//devtool</span><br><span class="line">// source-map</span><br><span class="line">// eval //通过sourceURL描述对应模块文件的资源路径 不生成对应的sourceMap,只能定位到错误出现的具体文件 构建速度快</span><br><span class="line">// cheap-eveal-source-map 阉割版 生成的sourceMap只能定位到错误具体行，没有列的信息</span><br><span class="line">// cheap-module-eveal-source-map 解析出来的源代码没有经过对应的loader加工，与手写时候的代码一样 一般开发环境使用多</span><br><span class="line">// inline-source-map 通过DataURL方式将sourceMap嵌入到代码当中，eval-source-map也是</span><br><span class="line">// hidden-source-map 代码当中没有通过注释方式引入sourceMap</span><br><span class="line">// nosources-source-map 能看到错误出现行列信息，但看不到源代码 生产环境不会暴露源代码</span><br><span class="line">// none 推荐生产环境使用</span><br><span class="line">//---------------------------------------------------</span><br><span class="line">//HMR 热更新</span><br><span class="line">// 应用运行过程中实时替换某个模块，应用运行状态不受影响</span><br><span class="line">// 不刷新页面情况下，及时更新模块</span><br><span class="line">// 提高开发效率</span><br><span class="line">// 集成在webpack-dev-server 中</span><br><span class="line">// 使用方式：webpack-dev-server --hot</span><br><span class="line">//或</span><br><span class="line">// style-loader自动处理样式文件的热更新  js模块热更新需要手动处理</span><br><span class="line">// const webpack=require(&apos;webpack&apos;)</span><br><span class="line">// devServer:&#123;</span><br><span class="line">//   hot:true  //热替换失败，自动刷新浏览器      hotOnly取消浏览器自动刷新</span><br><span class="line">// &#125;,</span><br><span class="line">// plugins:[</span><br><span class="line">//   //module.hot</span><br><span class="line">//   new webpack.HotModuleReplacementPlugin()</span><br><span class="line">// ]</span><br><span class="line">//------------------------------------------------------</span><br><span class="line">// webpack --env production //生产模式打包</span><br><span class="line">// webpack --config webpack.prod.js</span><br><span class="line">// const merge=require(&apos;webpack-merge&apos;)//合并webpack配置文件</span><br><span class="line">//-------------------------------------------------------</span><br><span class="line">//tree-shaking (基于ES Modules)</span><br><span class="line">// 移除未引用代码</span><br><span class="line">// 生产模式下自动开启</span><br><span class="line">// 由Webpack打包的代码必须使用ESM</span><br><span class="line">//-----------------------------------------------------------</span><br><span class="line">//optimization</span><br><span class="line">//优化选项</span><br><span class="line">// optimization:&#123;</span><br><span class="line">//   usedExports:true,   //只导出外部使用过的成员</span><br><span class="line">//   minimize:true, //代码压缩</span><br><span class="line">//   concatenateModules:true,  // `ScopeHoisting`作用域提升）   尽可能将所有模块合并在一起，提高运行效率，减少代码体积</span><br><span class="line">//   sideEffects:true  //production模式下会自动开启  为tree-shaking提供更大的压缩空间   （使用前应确保代码真的没有副作用。 副作用：模块执行时除了导出成员外所做的其它的事情	）          //   webpack会先检查当前项目的package.json当中是否有sideEffects字段 ,  sideEffects:false表示没有副作用，也可是数组 sideEffects:[&apos;*.css&apos;]  表示有副作用的模块</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure>
<h2 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h2><h3 id="vue初始化"><a href="#vue初始化" class="headerlink" title="vue初始化"></a>vue初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Vue.prototype.$mount</span><br><span class="line"> * 对vue组件进行挂载，基于render函数，没有render函数时，会获取template，将template解析生成render函数</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * mountComponent</span><br><span class="line"> * 挂载vue组件，在运行时版本、开发环境下如果没有render函数有template，vue会输出警告（运行时版本没有模板编译）</span><br><span class="line"> * 该方法会先触发beforeMount生命周期钩子函数</span><br><span class="line"> * new Watcher(),实例化一个渲染Watcher，传入一个updateComponent方法（该方法会调用_render方法（_render方法会调用render方法生成虚拟Dom）,通过_update方法将虚拟Dom转换成真实Dom）</span><br><span class="line"> * 接着触发mounted生命周期钩子</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * vue初始化过程</span><br><span class="line"> * 声明Vue构造函数，定义状态相关的属性和方法（$date/$props/$set/$delete/$watch）,定义事件有关的方法（$on/$emit/$off/$once），生命周期有关的方法(_update/$forceUpdate/$destroy),渲染有关的方法（$nextTick/_render）</span><br><span class="line"> * initGlobalAPI()初始化一些全局属性和方法（Vue.set/Vue.delete/Vue.nextTick/Vue.observable/Vue.options/Vue.use/Vue.mixin/Vue.extend/Vue.directive/Vue.component/Vue.filter）</span><br><span class="line"> * new Vue()时会调用_init()方法，对vue实例初始化</span><br><span class="line"> * initLifecycle() 初始化生命周期相关变量（$children/$parent/$root/$refs）/initEvents()/initRender()</span><br><span class="line"> * 接着触发beforeCreate生命周期钩子函数</span><br><span class="line"> * initInjections()在data/props之前处理injections/initState()(_props/methods/_data/computed/watch)/initProvide()在data/props之前处理provide</span><br><span class="line"> * 接着会触发created生命周期钩子函数</span><br><span class="line"> * 最后挂载并渲染页面</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<h3 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * vue响应式原理</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> * -----------</span><br><span class="line"> * vue2</span><br><span class="line"> * -----------</span><br><span class="line"> * Observer</span><br><span class="line"> * new Observer(value)，对data方法返回的对象进行响应式处理</span><br><span class="line"> * Observer类通过value记录被观察的对象，通过dep记录被观察对象的依赖</span><br><span class="line"> * value是数组时：</span><br><span class="line"> *  observeArray (items: Array&lt;any&gt;) &#123;</span><br><span class="line"> *   for (let i = 0, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line"> *    observe(items[i])</span><br><span class="line"> *   &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> * value是对象时：</span><br><span class="line"> * walk (obj: Object) &#123;</span><br><span class="line"> *    const keys = Object.keys(obj)</span><br><span class="line"> *    for (let i = 0; i &lt; keys.length; i++) &#123;</span><br><span class="line"> *      defineReactive(obj, keys[i])</span><br><span class="line"> *    &#125;</span><br><span class="line"> *  &#125;</span><br><span class="line"> *</span><br><span class="line"> * ----------</span><br><span class="line"> *</span><br><span class="line"> * defineReactive</span><br><span class="line"> * function defineReactive ( obj: Object,key: string,val: any,customSetter?: ?Function,shallow?: boolean //浅   false时为深度监听)&#123;</span><br><span class="line"> *  //收集依赖 watcher</span><br><span class="line"> *  const dep = new Dep()</span><br><span class="line"> *  let childOb = !shallow &amp;&amp; observe(val)</span><br><span class="line"> *  Object.defineProperty(obj, key, &#123;</span><br><span class="line"> *  get()&#123;&#125;,</span><br><span class="line"> *  set()&#123;&#125;</span><br><span class="line"> * &#125;)</span><br><span class="line"> * &#125;</span><br><span class="line"> * defineReactive通过shallow记录是否深度监听 false时为深度监听</span><br><span class="line"> * 通过Object.defineProperty()进行响应式处理</span><br><span class="line"> * 通过get()&#123;&#125;进行依赖收集</span><br><span class="line"> * get: function reactiveGetter () &#123;</span><br><span class="line"> * 	 //用户传入getter时先调用</span><br><span class="line"> *      const value = getter ? getter.call(obj) : val</span><br><span class="line"> * 	  //如果存在依赖对象watcher，则收集依赖</span><br><span class="line"> *       if (Dep.target) &#123;</span><br><span class="line"> * 	    //收集依赖</span><br><span class="line"> *         dep.depend()</span><br><span class="line"> *         if (childOb) &#123;</span><br><span class="line"> * 		  //子对象收集依赖</span><br><span class="line"> *           childOb.dep.depend()</span><br><span class="line"> * 		  //数组</span><br><span class="line"> *           if (Array.isArray(value)) &#123;</span><br><span class="line"> *             dependArray(value)</span><br><span class="line"> *           &#125;</span><br><span class="line"> *         &#125;</span><br><span class="line"> *      &#125;</span><br><span class="line"> *       return value</span><br><span class="line"> *  &#125;,</span><br><span class="line"> * set: function reactiveSetter (newVal) &#123;</span><br><span class="line"> *      const value = getter ? getter.call(obj) : val</span><br><span class="line"> *</span><br><span class="line"> * 	    //新值旧值相等</span><br><span class="line"> *      //  eslint-disable no-self-compare      NaN</span><br><span class="line"> *      if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line"> *        return</span><br><span class="line"> *      &#125;</span><br><span class="line"> *      // #7981: for accessor properties without setter</span><br><span class="line"> *      if (getter &amp;&amp; !setter) return</span><br><span class="line"> * 	    //存在setter时进行调用</span><br><span class="line"> *      if (setter) &#123;</span><br><span class="line"> *        setter.call(obj, newVal)</span><br><span class="line"> *      &#125; else &#123;</span><br><span class="line"> *        val = newVal</span><br><span class="line"> *      &#125;</span><br><span class="line"> *     childOb = !shallow &amp;&amp; observe(newVal)</span><br><span class="line"> *     dep.notify()</span><br><span class="line"> *  &#125;</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> * 数组处理</span><br><span class="line"> * const arrayProto = Array.prototype</span><br><span class="line"> * export const arrayMethods = Object.create(arrayProto)</span><br><span class="line"> * const methodsToPatch = [&apos;push&apos;,&apos;pop&apos;,&apos;shift&apos;,&apos;unshift&apos;,&apos;splice&apos;,&apos;sort&apos;,&apos;reverse&apos;]</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> * methodsToPatch.forEach(function (method) &#123;</span><br><span class="line"> *  // cache original method</span><br><span class="line"> *  const original = arrayProto[method]</span><br><span class="line"> *  def(arrayMethods, method, function mutator (...args) &#123;</span><br><span class="line"> *</span><br><span class="line"> *    //调用原型上的方法</span><br><span class="line"> *    const result = original.apply(this, args)</span><br><span class="line"> *    const ob = this.__ob__</span><br><span class="line"> *    let inserted</span><br><span class="line"> *    switch (method) &#123;</span><br><span class="line"> *      case &apos;push&apos;:</span><br><span class="line"> *      case &apos;unshift&apos;:</span><br><span class="line"> *        inserted = args</span><br><span class="line"> *        break</span><br><span class="line"> *      case &apos;splice&apos;:</span><br><span class="line"> *        inserted = args.slice(2)</span><br><span class="line"> *        break</span><br><span class="line"> *    &#125;</span><br><span class="line"> *</span><br><span class="line"> * 	//对新增的元素进行响应式处理</span><br><span class="line"> *     if (inserted) ob.observeArray(inserted)</span><br><span class="line"> *     // notify change</span><br><span class="line"> *</span><br><span class="line"> * 	//通知依赖更新视图</span><br><span class="line"> *     ob.dep.notify()</span><br><span class="line"> *     return result</span><br><span class="line"> *   &#125;)</span><br><span class="line"> *  &#125;)</span><br><span class="line"> * observeArray (items: Array&lt;any&gt;) &#123;</span><br><span class="line"> *    for (let i = 0, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line"> *      observe(items[i])</span><br><span class="line"> *    &#125;</span><br><span class="line"> *  &#125;</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> * -------------</span><br><span class="line"> * Dep</span><br><span class="line"> * class Dep&#123;</span><br><span class="line"> *  static target: ?Watcher;</span><br><span class="line"> *  id: number;</span><br><span class="line"> *  subs: Array&lt;Watcher&gt;;</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> *  addSub (sub: Watcher) &#123;</span><br><span class="line"> *    this.subs.push(sub)</span><br><span class="line"> *  &#125;</span><br><span class="line"> *  depend () &#123;</span><br><span class="line"> *    if (Dep.target) &#123;</span><br><span class="line"> *      Dep.target.addDep(this)</span><br><span class="line"> *    &#125;</span><br><span class="line"> *  &#125;</span><br><span class="line"> *  notify () &#123;</span><br><span class="line"> *    // stabilize the subscriber list first</span><br><span class="line"> *    const subs = this.subs.slice()</span><br><span class="line"> *   if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; !config.async) &#123;</span><br><span class="line"> *      // subs aren&apos;t sorted in scheduler if not running async</span><br><span class="line"> *      // we need to sort them now to make sure they fire in correct</span><br><span class="line"> *      // order</span><br><span class="line"> *      subs.sort((a, b) =&gt; a.id - b.id)</span><br><span class="line"> *    &#125;</span><br><span class="line"> *    for (let i = 0, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line"> *      subs[i].update()</span><br><span class="line"> *    &#125;</span><br><span class="line"> *  &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> * //Dep.target用来存放目前正在使用的watcher 全局唯一，并且一次也只能有一个watcher被使用</span><br><span class="line"> * // The current target watcher being evaluated.</span><br><span class="line"> * // This is globally unique because only one watcher</span><br><span class="line"> * // can be evaluated at a time.</span><br><span class="line"> * Dep.target = null</span><br><span class="line"> *</span><br><span class="line"> * --------------</span><br><span class="line"> * Watcher</span><br><span class="line"> * Watcher分为用户watcher/computed watcher/渲染watcher</span><br><span class="line"> * 渲染watcher:每个组件对应一个mountComponent方法，每个mountComponent对应一个Watcher对象</span><br><span class="line"> * 用户watcher/computed watcher在initState时进行初始化</span><br><span class="line"> * new Watcher时会调用Watcher的get方法，Watcher的get方法会调用Dep的pushTarget方法，Dep的pushTarget方法会设置全局Watcher给Dep.target</span><br><span class="line"> * 数据更新时调用Dep的notify方法，遍历Dep的subs，调用每个watcher的update方法，computed watcher和用户watcher调用watcher的run方法，渲染watcher调用queueWatcher方法将watcher加入队列，在queueWatcher方法中调用flushSchedulerQueue方法，在flushSchedulerQueue方法中对watcher按照id从小到大排序，接着遍历watcher，调用run方法</span><br><span class="line"> * watcher的run方法调用watcher的get方法，watcher的get方法会调用watcher的getter方法，渲染watcher的getter方法存储的是updateComponent方法,updateComponent方法调用_update()更新视图。</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> * -------------</span><br><span class="line"> * 响应式总结</span><br><span class="line"> * 在_init方法中调用initState方法，在initState方法中调用initData方法，在initData方法中调用observe(value)方法</span><br><span class="line"> * observe(value)方法会判断value是否是对象，如果是对象会接着判断是否有ob属性，有则直接返回，没有则直接创建Observe对象，返回Observe对象。</span><br><span class="line"> * Observe构造函数中会给value添加一个不可枚举ob字段，记录当前的observe对象。接着对数组、对象做响应式处理，当数据发生改变时，会找到对应的Observe对象，在Observe对象中调用dep的notify方法，通知watcher更新视图。</span><br><span class="line"> * 数组的响应式处理会对push/pop/shift/unshift/sort/reverse/splice方法进行处理，接着对数组的成员进行响应式处理。</span><br><span class="line"> * 对象的响应式处理则直接调用walk方法，遍历对象的每个属性，调用defineReactive方法</span><br><span class="line"> * defineReactive方法会为每个属性创建Dep对象收集依赖，如果属性是对象，则调用observe方法进行响应式处理。在getter中为属性收集依赖，属性的值为对象时，也会为属性的值收集依赖。在setter中，调用dep的notify方法发送通知，如果新值是对象时，调用observe进行响应式处理。</span><br><span class="line"> * 在watcher对象的get方法中调用pushTarget方法记录Dep.target属性，在访问data中成员时，出触发defineReactive的getter收集依赖，吧属性对应的watcher添加到dep的subs数组中，如果属性值也是对象，也会为属性值收集依赖。</span><br><span class="line"> * 渲染watcher，当数据发生改变时会调用dep的notify方法，通知watcher调用update方法，update方法中会调用queueWatcher方法,queueWatcher方法会判断watcher是否被处，没有被处理的话会被添加到queue队列中，并调用flushSchedulerQueue方法，flushSchedulerQueue方法中会触发beforeUpdate钩子函数/调用watcher的run方法（run()=&gt;get()=&gt;getter()=&gt;updateComponent()）/清空上一次依赖/触发activated钩子函数/触发updated钩子函数。</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> * ----------</span><br><span class="line"> * vue3</span><br><span class="line"> * ----------</span><br><span class="line"> * 通过proxy对象实现属性监听，初始化时不需要遍历所有属性</span><br><span class="line"> * 多层属性嵌套，在访问属性的过程中处理下一级属性</span><br><span class="line"> * 默认监听动态添加的属性</span><br><span class="line"> * 默认监听属性的删除操作</span><br><span class="line"> * 默认监听数组索引和length属性</span><br><span class="line"> * 可以作为单独模块使用</span><br><span class="line"> *</span><br><span class="line"> * ------------</span><br><span class="line"> * reactive</span><br><span class="line"> *</span><br><span class="line"> * const isObject =val=&gt;val!==null&amp;&amp;typeof val === &apos;object&apos;</span><br><span class="line"> * const convert=target=&gt;isObject(target)?reactive(target):target</span><br><span class="line"> * const hasOwnProperty=Object.prototype.hasOwnProperty</span><br><span class="line"> * const hasOwn=(target,key)=&gt; hasOwnProperty.call(target,key)</span><br><span class="line"> *</span><br><span class="line"> * function reactive(target)&#123;</span><br><span class="line"> *  if(!isObject(target)) return target</span><br><span class="line"> *</span><br><span class="line"> *  const handler=&#123;</span><br><span class="line"> *   get(target,key,receiver)&#123;</span><br><span class="line"> *     //收集依赖</span><br><span class="line"> *     track(target,key)</span><br><span class="line"> *     const result=Reflect.get(target,key,receiver)</span><br><span class="line"> *     return convert(result)</span><br><span class="line"> *   &#125;,</span><br><span class="line"> *   set(target,key,value,receiver)&#123;</span><br><span class="line"> *    const oldValue=Reflect.get(target,key,receiver)</span><br><span class="line"> *    let result=true</span><br><span class="line"> *    if(oldValue!==value)&#123;</span><br><span class="line"> *      result=Reflect.set(target,key,value,receiver)</span><br><span class="line"> *      //触发更新</span><br><span class="line"> *      trigger(target,key)</span><br><span class="line"> *    &#125;</span><br><span class="line"> *     return result</span><br><span class="line"> *   &#125;,</span><br><span class="line"> *   deleteProperty(target,key)&#123;</span><br><span class="line"> *    const hasKey=hasOwn(target,key)</span><br><span class="line"> *    const result=Reflect.deleteProperty(target,key)</span><br><span class="line"> *    if(hasKey&amp;&amp;result)&#123;</span><br><span class="line"> *      //触发更新</span><br><span class="line"> *      trigger(target,key)</span><br><span class="line"> *    &#125;</span><br><span class="line"> *    return result</span><br><span class="line"> *   &#125;</span><br><span class="line"> *</span><br><span class="line"> *   &#125;</span><br><span class="line"> *</span><br><span class="line"> * &#125;</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> * -----------------</span><br><span class="line"> * ref</span><br><span class="line"> * function ref(raw)&#123;</span><br><span class="line"> * //如果raw是ref创建的对象则直接返回</span><br><span class="line"> * if(isObject(raw)&amp;&amp;raw.__v_isRef) return</span><br><span class="line"> * //如果raw是对象则通过reactive处理</span><br><span class="line"> * let value=convert(raw)</span><br><span class="line"> * const r=&#123;</span><br><span class="line"> *   __v_isRef:true,</span><br><span class="line"> *   get value()&#123;</span><br><span class="line"> *     track(r,&apos;value)</span><br><span class="line"> *     return value</span><br><span class="line"> *  &#125;,</span><br><span class="line"> *   set value(newValue)&#123;</span><br><span class="line"> *    if(newValue!==value)&#123;</span><br><span class="line"> *     raw=newValue</span><br><span class="line"> *     value=convert(raw)</span><br><span class="line"> *     trigger(r,&apos;value&apos;)</span><br><span class="line"> *    &#125;</span><br><span class="line"> *  &#125;</span><br><span class="line"> *</span><br><span class="line"> * &#125;</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> *  return r</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> * &#125;</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> * -----------------</span><br><span class="line"> * toRefs</span><br><span class="line"> * function toRefs(proxy)&#123;</span><br><span class="line"> *   const ret=proxy instanceof Array?new Array(proxy.length):&#123;&#125;</span><br><span class="line"> *   for(const key in proxy)&#123;</span><br><span class="line"> *     ret[key]=toProxyRef(proxy,key)</span><br><span class="line"> *   &#125;</span><br><span class="line"> *   return ret</span><br><span class="line"> * &#125;</span><br><span class="line"> *</span><br><span class="line"> * function toProxyRef(proxy,key)&#123;</span><br><span class="line"> *  const r=&#123;</span><br><span class="line"> *     __v_isRef:true,</span><br><span class="line"> *     get value()&#123;</span><br><span class="line"> *      return proxy[key]</span><br><span class="line"> *     &#125;</span><br><span class="line"> *     set value(newvalue)&#123;</span><br><span class="line"> *      proxy[key]=newValue</span><br><span class="line"> *     &#125;</span><br><span class="line"> *</span><br><span class="line"> *  &#125;</span><br><span class="line"> *  return r</span><br><span class="line"> * &#125;</span><br><span class="line"> *</span><br><span class="line"> * ------------</span><br><span class="line"> * computed</span><br><span class="line"> * function computed(getter)&#123;</span><br><span class="line"> *   const result=ref()</span><br><span class="line"> *   effect(()=&gt;&#123;result.value=getter()&#125;)</span><br><span class="line"> *   return result</span><br><span class="line"> * &#125;</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> * -------------</span><br><span class="line"> * 收集依赖</span><br><span class="line"> * targetMap newWeakMap() key:目标对象 value:depsMap</span><br><span class="line"> * depsMap new Map() key:目标对象的属性名称 value:dep</span><br><span class="line"> * dep new Set()  value:effect函数</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> * --------------</span><br><span class="line"> * effect/track</span><br><span class="line"> * let activeEffect=null</span><br><span class="line"> * function effect(callback)&#123;</span><br><span class="line"> *   activeEffect=callback</span><br><span class="line"> *   callback()</span><br><span class="line"> *   activeEffect-null</span><br><span class="line"> * &#125;</span><br><span class="line"> * let targetMap=new WeakMap()</span><br><span class="line"> * function track(target,key)&#123;</span><br><span class="line"> *  if(!activeEffect) return</span><br><span class="line"> *  //目标对象字典</span><br><span class="line"> *  let depsMap=targetMap.get(target)</span><br><span class="line"> *  if(!depsMap)&#123;</span><br><span class="line"> *    targetMap.set(target,(depsMap=new Map()))</span><br><span class="line"> *  &#125;</span><br><span class="line"> *  let dep=depsMap.get(key)</span><br><span class="line"> *  if(!dep)&#123;</span><br><span class="line"> *    depsMap.set(key,(dep=new Set()))</span><br><span class="line"> *  &#125;</span><br><span class="line"> *  dep.add(activeEffect)</span><br><span class="line"> *</span><br><span class="line"> * &#125;</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> * -------------</span><br><span class="line"> * trigger</span><br><span class="line"> * function trigger(target,key)&#123;</span><br><span class="line"> *  const depsMap=targetMap.get(target)</span><br><span class="line"> *  if(!depsMap) return</span><br><span class="line"> *  const dep=depsMap.get(key)</span><br><span class="line"> *  //触发effect的函数</span><br><span class="line"> *  if(dep)&#123;</span><br><span class="line"> *    dep.forEach(effect=&gt; effect())</span><br><span class="line"> *  &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> *</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<h3 id="虚拟Dom"><a href="#虚拟Dom" class="headerlink" title="虚拟Dom"></a>虚拟Dom</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * patch</span><br><span class="line"> */</span><br><span class="line">//相同节点判断</span><br><span class="line">// function sameVnode (a, b) &#123;</span><br><span class="line">//   return (</span><br><span class="line">//     a.key === b.key &amp;&amp;</span><br><span class="line">//     a.asyncFactory === b.asyncFactory &amp;&amp; (</span><br><span class="line">//       (</span><br><span class="line">//         a.tag === b.tag &amp;&amp;</span><br><span class="line">//         a.isComment === b.isComment &amp;&amp;</span><br><span class="line">//         isDef(a.data) === isDef(b.data) &amp;&amp;</span><br><span class="line">//         sameInputType(a, b)</span><br><span class="line">//       ) || (</span><br><span class="line">//         isTrue(a.isAsyncPlaceholder) &amp;&amp;</span><br><span class="line">//         isUndef(b.asyncFactory.error)</span><br><span class="line">//       )</span><br><span class="line">//     )</span><br><span class="line">//   )</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">//节点比对</span><br><span class="line">// function patchVnode(</span><br><span class="line">//   oldVnode,</span><br><span class="line">//   vnode,</span><br><span class="line">//   insertedVnodeQueue,</span><br><span class="line">//   ownerArray,</span><br><span class="line">//   index,</span><br><span class="line">//   removeOnly</span><br><span class="line">// ) &#123;</span><br><span class="line">//   if (oldVnode === vnode) &#123;</span><br><span class="line">//     return;</span><br><span class="line">//   &#125;</span><br><span class="line">//   //获取子节点</span><br><span class="line">//   const oldCh = oldVnode.children;</span><br><span class="line">//   const ch = vnode.children;</span><br><span class="line">//   //新节点没有文本</span><br><span class="line">//   if (isUndef(vnode.text)) &#123;</span><br><span class="line">//     //新旧节点都有子节点时</span><br><span class="line">//     if (isDef(oldCh) &amp;&amp; isDef(ch)) &#123;</span><br><span class="line">//       if (oldCh !== ch)</span><br><span class="line">//         updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);</span><br><span class="line">//     &#125;</span><br><span class="line">//     //新节点有子节点，老节点没有子节点</span><br><span class="line">//     else if (isDef(ch)) &#123;</span><br><span class="line">//       if (process.env.NODE_ENV !== &quot;production&quot;) &#123;</span><br><span class="line">//         //检查是否有重复key</span><br><span class="line">//         checkDuplicateKeys(ch);</span><br><span class="line">//       &#125;</span><br><span class="line">//       //清空老节点文本内容</span><br><span class="line">//       if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, &quot;&quot;);</span><br><span class="line">//       //将新节点的子节点转换成dom元素并添加到dom树</span><br><span class="line">//       addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);</span><br><span class="line">//     &#125;</span><br><span class="line">//     //老节点有子节点，新点没子节点</span><br><span class="line">//     else if (isDef(oldCh)) &#123;</span><br><span class="line">//       //删除老节点中的子节点</span><br><span class="line">//       removeVnodes(oldCh, 0, oldCh.length - 1);</span><br><span class="line">//     &#125;</span><br><span class="line">//     //老节点有文本，新节点没有文本</span><br><span class="line">//     else if (isDef(oldVnode.text)) &#123;</span><br><span class="line">//       //清空老节点文本内容</span><br><span class="line">//       nodeOps.setTextContent(elm, &quot;&quot;);</span><br><span class="line">//     &#125;</span><br><span class="line">//   &#125;</span><br><span class="line">//   //新老节点都有文本节点</span><br><span class="line">//   else if (oldVnode.text !== vnode.text) &#123;</span><br><span class="line">//     //修改文本</span><br><span class="line">//     nodeOps.setTextContent(elm, vnode.text);</span><br><span class="line">//   &#125;</span><br><span class="line">// &#125;</span><br><span class="line">//更新子节点</span><br><span class="line">// function updateChildren(</span><br><span class="line">//   parentElm,</span><br><span class="line">//   oldCh,</span><br><span class="line">//   newCh,</span><br><span class="line">//   insertedVnodeQueue,</span><br><span class="line">//   removeOnly</span><br><span class="line">// ) &#123;</span><br><span class="line">//   //新老节点子节点开始节点索引</span><br><span class="line">//   let oldStartIdx = 0;</span><br><span class="line">//   let newStartIdx = 0;</span><br><span class="line">//   //老节点子节点结束节点索引</span><br><span class="line">//   let oldEndIdx = oldCh.length - 1;</span><br><span class="line">//   //老节点开始子节点</span><br><span class="line">//   let oldStartVnode = oldCh[0];</span><br><span class="line">//   let oldEndVnode = oldCh[oldEndIdx];</span><br><span class="line">//   let newEndIdx = newCh.length - 1;</span><br><span class="line">//   let newStartVnode = newCh[0];</span><br><span class="line">//   let newEndVnode = newCh[newEndIdx];</span><br><span class="line">//   let oldKeyToIdx, idxInOld, vnodeToMove, refElm;</span><br><span class="line"></span><br><span class="line">//   // removeOnly is a special flag used only by &lt;transition-group&gt;</span><br><span class="line">//   // to ensure removed elements stay in correct relative positions</span><br><span class="line">//   // during leaving transitions</span><br><span class="line">//   const canMove = !removeOnly;</span><br><span class="line"></span><br><span class="line">//   if (process.env.NODE_ENV !== &quot;production&quot;) &#123;</span><br><span class="line">//     checkDuplicateKeys(newCh);</span><br><span class="line"></span><br><span class="line">//     //当新节点和老节点都没有遍历完成时</span><br><span class="line">//     while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">//       if (isUndef(oldStartVnode)) &#123;</span><br><span class="line">//         oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left</span><br><span class="line">//       &#125; else if (isUndef(oldEndVnode)) &#123;</span><br><span class="line">//         oldEndVnode = oldCh[--oldEndIdx];</span><br><span class="line">//       &#125;</span><br><span class="line"></span><br><span class="line">//       //老节点子节点的开始节点和新节点子节点的开始节点是相同节点时</span><br><span class="line">//       else if (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">//         patchVnode(</span><br><span class="line">//           oldStartVnode,</span><br><span class="line">//           newStartVnode,</span><br><span class="line">//           insertedVnodeQueue,</span><br><span class="line">//           newCh,</span><br><span class="line">//           newStartIdx</span><br><span class="line">//         );</span><br><span class="line">//         oldStartVnode = oldCh[++oldStartIdx];</span><br><span class="line">//         newStartVnode = newCh[++newStartIdx];</span><br><span class="line">//       &#125;</span><br><span class="line">//       //老节点子节点的结束节点和新节点子节点的结束节点是相同节点时</span><br><span class="line">//       else if (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">//         patchVnode(</span><br><span class="line">//           oldEndVnode,</span><br><span class="line">//           newEndVnode,</span><br><span class="line">//           insertedVnodeQueue,</span><br><span class="line">//           newCh,</span><br><span class="line">//           newEndIdx</span><br><span class="line">//         );</span><br><span class="line">//         oldEndVnode = oldCh[--oldEndIdx];</span><br><span class="line">//         newEndVnode = newCh[--newEndIdx];</span><br><span class="line">//       &#125;</span><br><span class="line">//       //老节点子节点的开始节点和新节点子节点的结束节点是相同节点时</span><br><span class="line">//       else if (sameVnode(oldStartVnode, newEndVnode)) &#123;</span><br><span class="line">//         // Vnode moved right</span><br><span class="line"></span><br><span class="line">//         //进行patchVnode，并将oldStartVnode移动到最后</span><br><span class="line">//         patchVnode(</span><br><span class="line">//           oldStartVnode,</span><br><span class="line">//           newEndVnode,</span><br><span class="line">//           insertedVnodeQueue,</span><br><span class="line">//           newCh,</span><br><span class="line">//           newEndIdx</span><br><span class="line">//         );</span><br><span class="line">//         canMove &amp;&amp;</span><br><span class="line">//           nodeOps.insertBefore(</span><br><span class="line">//             parentElm,</span><br><span class="line">//             oldStartVnode.elm,</span><br><span class="line">//             nodeOps.nextSibling(oldEndVnode.elm)</span><br><span class="line">//           );</span><br><span class="line">//         oldStartVnode = oldCh[++oldStartIdx];</span><br><span class="line">//         newEndVnode = newCh[--newEndIdx];</span><br><span class="line">//       &#125;</span><br><span class="line">//       //老节点子节点的结束节点和新节点子节点的开始节点是相同节点时</span><br><span class="line">//       else if (sameVnode(oldEndVnode, newStartVnode)) &#123;</span><br><span class="line">//         // Vnode moved left</span><br><span class="line"></span><br><span class="line">//         //进行patchVnode，并将oldEndVnode移动到最前</span><br><span class="line">//         patchVnode(</span><br><span class="line">//           oldEndVnode,</span><br><span class="line">//           newStartVnode,</span><br><span class="line">//           insertedVnodeQueue,</span><br><span class="line">//           newCh,</span><br><span class="line">//           newStartIdx</span><br><span class="line">//         );</span><br><span class="line">//         canMove &amp;&amp;</span><br><span class="line">//           nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);</span><br><span class="line">//         oldEndVnode = oldCh[--oldEndIdx];</span><br><span class="line">//         newStartVnode = newCh[++newStartIdx];</span><br><span class="line">//       &#125;</span><br><span class="line"></span><br><span class="line">//       //以上情况都不满足时，依次对比新老节点</span><br><span class="line">//       else &#123;</span><br><span class="line">//         //从新节点子节点的开始节点开始，在老节点子节点中找相同节点</span><br><span class="line">//         //先通过key查找，如果没有找到，再通过sameVnode查找</span><br><span class="line">//         if (isUndef(oldKeyToIdx))</span><br><span class="line">//           oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);</span><br><span class="line">//         idxInOld = isDef(newStartVnode.key)</span><br><span class="line">//           ? oldKeyToIdx[newStartVnode.key]</span><br><span class="line">//           : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);</span><br><span class="line"></span><br><span class="line">//         //如果没有找到</span><br><span class="line">//         if (isUndef(idxInOld)) &#123;</span><br><span class="line">//           // New element</span><br><span class="line">//           //创建节点插入到最前面</span><br><span class="line">//           createElm(</span><br><span class="line">//             newStartVnode,</span><br><span class="line">//             insertedVnodeQueue,</span><br><span class="line">//             parentElm,</span><br><span class="line">//             oldStartVnode.elm,</span><br><span class="line">//             false,</span><br><span class="line">//             newCh,</span><br><span class="line">//             newStartIdx</span><br><span class="line">//           );</span><br><span class="line">//         &#125; else &#123;</span><br><span class="line">//           vnodeToMove = oldCh[idxInOld];</span><br><span class="line"></span><br><span class="line">//           //如果两个节点是相同节点</span><br><span class="line">//           if (sameVnode(vnodeToMove, newStartVnode)) &#123;</span><br><span class="line">//             //执行patchVnode，并将查找到的老节点移动到最前面</span><br><span class="line">//             patchVnode(</span><br><span class="line">//               vnodeToMove,</span><br><span class="line">//               newStartVnode,</span><br><span class="line">//               insertedVnodeQueue,</span><br><span class="line">//               newCh,</span><br><span class="line">//               newStartIdx</span><br><span class="line">//             );</span><br><span class="line">//             oldCh[idxInOld] = undefined;</span><br><span class="line">//             canMove &amp;&amp;</span><br><span class="line">//               nodeOps.insertBefore(</span><br><span class="line">//                 parentElm,</span><br><span class="line">//                 vnodeToMove.elm,</span><br><span class="line">//                 oldStartVnode.elm</span><br><span class="line">//               );</span><br><span class="line">//           &#125; else &#123;</span><br><span class="line">//             // same key but different element. treat as new element</span><br><span class="line">//             createElm(</span><br><span class="line">//               newStartVnode,</span><br><span class="line">//               insertedVnodeQueue,</span><br><span class="line">//               parentElm,</span><br><span class="line">//               oldStartVnode.elm,</span><br><span class="line">//               false,</span><br><span class="line">//               newCh,</span><br><span class="line">//               newStartIdx</span><br><span class="line">//             );</span><br><span class="line">//           &#125;</span><br><span class="line">//         &#125;</span><br><span class="line">//         newStartVnode = newCh[++newStartIdx];</span><br><span class="line">//       &#125;</span><br><span class="line">//     &#125;</span><br><span class="line"></span><br><span class="line">//     //老节点子节点遍历完，新节点子节点未遍历完</span><br><span class="line">//     if (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">//       //说明新节点子节点比老节点子节点多，把新节点剩余的子节点插入到老节点子节点后面</span><br><span class="line">//       refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;</span><br><span class="line">//       addVnodes(</span><br><span class="line">//         parentElm,</span><br><span class="line">//         refElm,</span><br><span class="line">//         newCh,</span><br><span class="line">//         newStartIdx,</span><br><span class="line">//         newEndIdx,</span><br><span class="line">//         insertedVnodeQueue</span><br><span class="line">//       );</span><br><span class="line">//     &#125;</span><br><span class="line">//     //新节点子节点遍历完，老节点子节点未遍历完</span><br><span class="line">//     else if (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">//       //删除老节点剩余子节点</span><br><span class="line">//       removeVnodes(oldCh, oldStartIdx, oldEndIdx);</span><br><span class="line">//     &#125;</span><br><span class="line">//   &#125;</span><br><span class="line">// &#125;</span><br><span class="line">// arr:[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;]</span><br><span class="line"></span><br><span class="line">// arr.splice(1,0,&apos;x&apos;)</span><br><span class="line"></span><br><span class="line">// arr：[&apos;a&apos;,&apos;x&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;]</span><br><span class="line"></span><br><span class="line">//没有设置key tag相同时也会被判断为相同节点</span><br><span class="line">// 没有设置key时，更新了三次dom，插入了一次dom</span><br><span class="line">// 设置key时，插入了一次dom   （key的设置决定了相同节点的判断）</span><br></pre></td></tr></table></figure>
<h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><ul>
<li>v-memo 记住一个模板的子树。元素和组件上都可以使用。该指令接收一个固定长度的数组作为依赖值进行记忆比对。如果数组中的每个值都和上次渲染的时候相同，则整个该子树的更新会被跳过。</li>
<li><p>v-cloak 这个指令保持在元素上直到关联组件实例结束编译。和 CSS 规则如 <code>[v-cloak] { display: none }</code>一起用时，这个指令可以隐藏未编译的 Mustache 标签直到组件实例准备完毕。</p>
</li>
<li><p>2.x 版本中在一个元素上同时使用 v-if 和 v-for 时，v-for 会优先作用。3.x 版本中 v-if 总是优先于 v-for 生效。</p>
</li>
</ul>
<h4 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const app = Vue.createApp(&#123;&#125;)</span><br><span class="line">// 注册一个全局自定义指令 `v-focus`</span><br><span class="line">app.directive(&apos;focus&apos;, &#123;</span><br><span class="line">  // 当被绑定的元素挂载到 DOM 中时……</span><br><span class="line">  mounted(el) &#123;</span><br><span class="line">    // 聚焦元素</span><br><span class="line">    el.focus()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">一个指令定义对象可以提供如下几个钩子函数 (均为可选)：钩子函数的参数 (即 el、binding、vnode 和 prevVnode)</span><br><span class="line">created：在绑定元素的 attribute 或事件监听器被应用之前调用。在指令需要附加须要在普通的 v-on 事件监听器前调用的事件监听器时，这很有用。</span><br><span class="line">beforeMount：当指令第一次绑定到元素并且在挂载父组件之前调用。</span><br><span class="line">mounted：在绑定元素的父组件被挂载后调用。</span><br><span class="line">beforeUpdate：在更新包含组件的 VNode 之前调用。</span><br><span class="line">updated：在包含组件的 VNode 及其子组件的 VNode 更新后调用。</span><br><span class="line">beforeUnmount：在卸载绑定元素的父组件之前调用</span><br><span class="line">unmounted：当指令与元素解除绑定且父组件已卸载时，只调用一次。</span><br></pre></td></tr></table></figure>
<h3 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h3><p>新的 setup 选项在组件创建之前执行，一旦 props 被解析，就将作为组合式 API 的入口。<br>在 setup 中你应该避免使用 this，因为它不会找到组件实例。setup 的调用发生在 data property、computed property 或 methods 被解析之前，所以它们无法在 setup 中被获取。<br>setup 函数中的第一个参数是 props。正如在一个标准组件中所期望的那样，setup 函数中的 props 是响应式的，当传入新的 prop 时，它将被更新。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// MyBook.vue</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    title: String</span><br><span class="line">  &#125;,</span><br><span class="line">  setup(props) &#123;</span><br><span class="line">    console.log(props.title)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 props 是响应式的，你不能使用 ES6 解构，它会消除 prop 的响应性。<br>如果需要解构 prop，可以在 setup 函数中使用 toRefs 函数来完成此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// MyBook.vue</span><br><span class="line"></span><br><span class="line">import &#123; toRefs &#125; from &apos;vue&apos;</span><br><span class="line"></span><br><span class="line">setup(props) &#123;</span><br><span class="line">  const &#123; title &#125; = toRefs(props)</span><br><span class="line"></span><br><span class="line">  console.log(title.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>传递给 setup 函数的第二个参数是 context。context 是一个普通 JavaScript 对象，暴露了其它可能在 setup 中有用的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// MyBook.vue</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  setup(props, context) &#123;</span><br><span class="line">    // Attribute (非响应式对象，等同于 $attrs)</span><br><span class="line">    console.log(context.attrs)</span><br><span class="line"></span><br><span class="line">    // 插槽 (非响应式对象，等同于 $slots)</span><br><span class="line">    console.log(context.slots)</span><br><span class="line"></span><br><span class="line">    // 触发事件 (方法，等同于 $emit)</span><br><span class="line">    console.log(context.emit)</span><br><span class="line"></span><br><span class="line">    // 暴露公共 property (函数)</span><br><span class="line">    console.log(context.expose)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 setup 返回一个对象，那么该对象的 property 以及传递给 setup 的 props 参数中的 property 就都可以在模板中访问到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- MyBook.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;&#123;&#123; collectionName &#125;&#125;: &#123;&#123; readersNumber &#125;&#125; &#123;&#123; book.title &#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import &#123; ref, reactive &#125; from &apos;vue&apos;</span><br><span class="line"></span><br><span class="line">  export default &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">      collectionName: String</span><br><span class="line">    &#125;,</span><br><span class="line">    setup(props) &#123;</span><br><span class="line">      const readersNumber = ref(0)</span><br><span class="line">      const book = reactive(&#123; title: &apos;Vue 3 Guide&apos; &#125;)</span><br><span class="line"></span><br><span class="line">      // 暴露给 template</span><br><span class="line">      return &#123;</span><br><span class="line">        readersNumber,</span><br><span class="line">        book</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>setup 还可以返回一个渲染函数，该函数可以直接使用在同一作用域中声明的响应式状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// MyBook.vue</span><br><span class="line"></span><br><span class="line">import &#123; h, ref, reactive &#125; from &apos;vue&apos;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const readersNumber = ref(0)</span><br><span class="line">    const book = reactive(&#123; title: &apos;Vue 3 Guide&apos; &#125;)</span><br><span class="line">    // 请注意这里我们需要显式使用 ref 的 value</span><br><span class="line">    return () =&gt; h(&apos;div&apos;, [readersNumber.value, book.title])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回一个渲染函数将阻止我们返回任何其它的东西。从内部来说这不应该成为一个问题，但当我们想要将这个组件的方法通过模板 ref 暴露给父组件时就不一样了。</p>
<p>我们可以通过调用 expose 来解决这个问题，给它传递一个对象，其中定义的 property 将可以被外部组件实例访问：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import &#123; h, ref &#125; from &apos;vue&apos;</span><br><span class="line">export default &#123;</span><br><span class="line">  setup(props, &#123; expose &#125;) &#123;</span><br><span class="line">    const count = ref(0)</span><br><span class="line">    const increment = () =&gt; ++count.value</span><br><span class="line"></span><br><span class="line">    expose(&#123;</span><br><span class="line">      increment</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    return () =&gt; h(&apos;div&apos;, count.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>keep-alive</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  name: &apos;keep-alive&apos;,</span><br><span class="line">  abstract: true,</span><br><span class="line">  props: &#123;</span><br><span class="line">    include: patternTypes,</span><br><span class="line">    exclude: patternTypes,</span><br><span class="line">    max: [String, Number]</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;&#125;,</span><br><span class="line">  created()&#123;&#125;,</span><br><span class="line">  destroyed()&#123;&#125;,</span><br><span class="line">  mounted()&#123;&#125;,</span><br><span class="line">  updated()&#123;&#125;,</span><br><span class="line">  render()&#123;</span><br><span class="line">     const slot = this.$slots.default</span><br><span class="line">     const vnode: VNode = getFirstComponentChild(slot)</span><br><span class="line">     return vnode || (slot &amp;&amp; slot[0])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="vue3"><a href="#vue3" class="headerlink" title="vue3"></a>vue3</h3><ul>
<li><p>Teleport<br> 在同一目标上使用多个 teleport。一个常见的用例场景是一个可重用的 <code>&lt;Modal&gt;</code>组件，它可能同时有多个实例处于活动状态。对于这种情况，多个 <code>&lt;teleport&gt;</code> 组件可以将其内容挂载到同一个目标元素。顺序将是一个简单的追加——稍后挂载将位于目标元素中较早的挂载之后。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;teleport to=&quot;#modals&quot;&gt;</span><br><span class="line">  &lt;div&gt;A&lt;/div&gt;</span><br><span class="line">&lt;/teleport&gt;</span><br><span class="line">&lt;teleport to=&quot;#modals&quot;&gt;</span><br><span class="line">  &lt;div&gt;B&lt;/div&gt;</span><br><span class="line">&lt;/teleport&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- result--&gt;</span><br><span class="line">&lt;div id=&quot;modals&quot;&gt;</span><br><span class="line">  &lt;div&gt;A&lt;/div&gt;</span><br><span class="line">  &lt;div&gt;B&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>在 3.x 中，组件可以包含多个根节点！但是，这要求开发者显式定义 attribute 应该分布在哪里。</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Layout.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;header&gt;...&lt;/header&gt;</span><br><span class="line">  &lt;main v-bind=&quot;$attrs&quot;&gt;...&lt;/main&gt;</span><br><span class="line">  &lt;footer&gt;...&lt;/footer&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>v-model 参数<br>默认情况下，组件上的 v-model 使用 modelValue 作为 prop 和 update:modelValue 作为事件。我们可以通过向 v-model 传递参数来修改这些名称：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component v-model:title=&quot;bookTitle&quot;&gt;&lt;/my-component&gt;</span><br></pre></td></tr></table></figure>
<p>在本例中，子组件将需要一个 title prop 并发出 update:title 事件来进行同步：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">app.component(&apos;my-component&apos;, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    title: String</span><br><span class="line">  &#125;,</span><br><span class="line">  emits: [&apos;update:title&apos;],</span><br><span class="line">  template: `</span><br><span class="line">    &lt;input</span><br><span class="line">      type=&quot;text&quot;</span><br><span class="line">      :value=&quot;title&quot;</span><br><span class="line">      @input=&quot;$emit(&apos;update:title&apos;, $event.target.value)&quot;&gt;</span><br><span class="line">  `</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>正如我们之前在 v-model 参数中所学的那样，通过利用以特定 prop 和事件为目标的能力，我们现在可以在单个组件实例上创建多个 v-model 绑定。<br>每个 v-model 将同步到不同的 prop，而不需要在组件中添加额外的选项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;user-name v-model:first-name=&quot;firstName&quot; v-model:last-name=&quot;lastName&quot;&gt;&lt;/user-name&gt;</span><br><span class="line">app.component(&apos;user-name&apos;, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    firstName: String,</span><br><span class="line">    lastName: String</span><br><span class="line">  &#125;,</span><br><span class="line">  emits: [&apos;update:firstName&apos;, &apos;update:lastName&apos;],</span><br><span class="line">  template: `</span><br><span class="line">    &lt;input</span><br><span class="line">      type=&quot;text&quot;</span><br><span class="line">      :value=&quot;firstName&quot;</span><br><span class="line">      @input=&quot;$emit(&apos;update:firstName&apos;, $event.target.value)&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;input</span><br><span class="line">      type=&quot;text&quot;</span><br><span class="line">      :value=&quot;lastName&quot;</span><br><span class="line">      @input=&quot;$emit(&apos;update:lastName&apos;, $event.target.value)&quot;&gt;</span><br><span class="line">  `</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>处理 v-model 修饰符<br>添加到组件 v-model 的修饰符将通过 modelModifiers prop 提供给组件。在下面的示例中，我们创建了一个组件，其中包含默认为空对象的 modelModifiers prop。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component v-model.capitalize=&quot;myText&quot;&gt;&lt;/my-component&gt;</span><br><span class="line">app.component(&apos;my-component&apos;, &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">      modelValue: String,</span><br><span class="line">      modelModifiers: &#123;</span><br><span class="line">        default: () =&gt; (&#123;&#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    emits: [&apos;update:modelValue&apos;],</span><br><span class="line">    template: `</span><br><span class="line">      &lt;input type=&quot;text&quot;</span><br><span class="line">        :value=&quot;modelValue&quot;</span><br><span class="line">        @input=&quot;$emit(&apos;update:modelValue&apos;, $event.target.value)&quot;&gt;</span><br><span class="line">    `,</span><br><span class="line">    created() &#123;</span><br><span class="line">      console.log(this.modelModifiers) // &#123; capitalize: true &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>对于带参数的 v-model 绑定，生成的 prop 名称将为 arg + “Modifiers”：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component v-model:description.capitalize=&quot;myText&quot;&gt;&lt;/my-component&gt;</span><br><span class="line">app.component(&apos;my-component&apos;, &#123;</span><br><span class="line">  props: [&apos;description&apos;, &apos;descriptionModifiers&apos;],</span><br><span class="line">  emits: [&apos;update:description&apos;],</span><br><span class="line">  template: `</span><br><span class="line">    &lt;input type=&quot;text&quot;</span><br><span class="line">      :value=&quot;description&quot;</span><br><span class="line">      @input=&quot;$emit(&apos;update:description&apos;, $event.target.value)&quot;&gt;</span><br><span class="line">  `,</span><br><span class="line">  created() &#123;</span><br><span class="line">    console.log(this.descriptionModifiers) // &#123; capitalize: true &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在 2.x 中，在组件上使用 v-model 相当于绑定 value prop 并触发 input 事件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;ChildComponent v-model=&quot;pageTitle&quot; /&gt;</span><br><span class="line">&lt;!-- 是以下的简写: --&gt;</span><br><span class="line">&lt;ChildComponent :value=&quot;pageTitle&quot; @input=&quot;pageTitle = $event&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- ParentComponent.vue --&gt;</span><br><span class="line"></span><br><span class="line">&lt;ChildComponent v-model=&quot;pageTitle&quot; /&gt;</span><br><span class="line"></span><br><span class="line">// ChildComponent.vue</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  model: &#123;</span><br><span class="line">    prop: &apos;title&apos;,</span><br><span class="line">    event: &apos;change&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    // 这将允许 `value` 属性用于其他用途</span><br><span class="line">    value: String,</span><br><span class="line">    // 使用 `title` 代替 `value` 作为 model 的 prop</span><br><span class="line">    title: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      default: &apos;Default title&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;ChildComponent :title=&quot;pageTitle&quot; @change=&quot;pageTitle = $event&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>在某些情况下，我们可能需要对某一个 prop 进行“双向绑定”(除了前面用 v-model 绑定 prop 的情况)。为此，我们建议使用 update:myPropName 抛出事件。例如，对于在上一个示例中带有 title prop 的 ChildComponent，我们可以通过下面的方式将分配新 value 的意图传达给父级：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.$emit(&apos;update:title&apos;, newValue)</span><br><span class="line">&lt;ChildComponent :title=&quot;pageTitle&quot; @update:title=&quot;pageTitle = $event&quot; /&gt;</span><br><span class="line">&lt;ChildComponent :title.sync=&quot;pageTitle&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>在 3.x 中，自定义组件上的 v-model 相当于传递了 modelValue prop 并接收抛出的 update:modelValue 事件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;ChildComponent v-model=&quot;pageTitle&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 是以下的简写: --&gt;</span><br><span class="line"></span><br><span class="line">&lt;ChildComponent</span><br><span class="line">  :modelValue=&quot;pageTitle&quot;</span><br><span class="line">  @update:modelValue=&quot;pageTitle = $event&quot;</span><br><span class="line">/&gt;</span><br><span class="line">&lt;ChildComponent v-model:title=&quot;pageTitle&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 是以下的简写: --&gt;</span><br><span class="line"></span><br><span class="line">&lt;ChildComponent :title=&quot;pageTitle&quot; @update:title=&quot;pageTitle = $event&quot; /&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>状态驱动的动态 CSS</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">   &lt;div class=&quot;text&quot;&gt;hello&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"> &lt;script&gt;</span><br><span class="line">   export default &#123;</span><br><span class="line">     data() &#123;</span><br><span class="line">       return &#123;</span><br><span class="line">         color: &apos;red&apos;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &lt;/script&gt;</span><br><span class="line"></span><br><span class="line"> &lt;style&gt;</span><br><span class="line"> .text &#123;</span><br><span class="line">   color: v-bind(color);</span><br><span class="line"> &#125;</span><br><span class="line"> &lt;/style&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>全局 API<br>Vue 2.x 有许多全局 API 和配置，它们可以全局改变 Vue 的行为。从技术上讲，Vue 2 没有“app”的概念，我们定义的应用只是通过 new Vue() 创建的根 Vue 实例。从同一个 Vue 构造函数创建的每个根实例共享相同的全局配置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;button-counter&apos;, &#123;</span><br><span class="line">   data: () =&gt; (&#123;</span><br><span class="line">     count: 0</span><br><span class="line">   &#125;),</span><br><span class="line">   template: &apos;&lt;button @click=&quot;count++&quot;&gt;Clicked &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&apos;</span><br><span class="line"> &#125;)</span><br><span class="line">Vue.directive(&apos;focus&apos;, &#123;</span><br><span class="line">    inserted: el =&gt; el.focus()</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>
<p>全局配置使得在同一页面上的多个“应用”在全局配置不同时共享同一个 Vue 副本非常困难。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 这会影响到所有根实例</span><br><span class="line">Vue.mixin(&#123;</span><br><span class="line">  /* ... */</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const app1 = new Vue(&#123; el: &apos;#app-1&apos; &#125;)</span><br><span class="line">const app2 = new Vue(&#123; el: &apos;#app-2&apos; &#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>一个新的全局 API：createApp。应用实例暴露了 Vue 2 全局 API 的一个子集，经验法则是，任何全局改变 Vue 行为的 API 现在都会移动到应用实例上。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createApp &#125; from &apos;vue&apos;</span><br><span class="line">const app = createApp(&#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>Vue.prototype 替换为 config.globalProperties</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> // 之前 - Vue 2</span><br><span class="line">Vue.prototype.$http = () =&gt; &#123;&#125;</span><br><span class="line">// 之后 - Vue 3</span><br><span class="line">const app = createApp(&#123;&#125;)</span><br><span class="line">app.config.globalProperties.$http = () =&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>与在 2.x 根实例中使用 provide 选项类似，Vue 3 应用实例也提供了可被应用内任意组件注入的依赖项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 在入口中</span><br><span class="line">app.provide(&apos;guide&apos;, &apos;Vue 3 Guide&apos;)</span><br><span class="line"></span><br><span class="line">// 在子组件中</span><br><span class="line">export default &#123;</span><br><span class="line">  inject: &#123;</span><br><span class="line">    book: &#123;</span><br><span class="line">      from: &apos;guide&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: `&lt;div&gt;&#123;&#123; book &#125;&#125;&lt;/div&gt;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在应用之间共享配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createApp &#125; from &apos;vue&apos;</span><br><span class="line">import Foo from &apos;./Foo.vue&apos;</span><br><span class="line">import Bar from &apos;./Bar.vue&apos;</span><br><span class="line"></span><br><span class="line">const createMyApp = options =&gt; &#123;</span><br><span class="line">  const app = createApp(options)</span><br><span class="line">  app.directive(&apos;focus&apos; /* ... */)</span><br><span class="line"></span><br><span class="line">  return app</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createMyApp(Foo).mount(&apos;#foo&apos;)</span><br><span class="line">createMyApp(Bar).mount(&apos;#bar&apos;)</span><br></pre></td></tr></table></figure>
<p>Vue.extend 移除<br>在 Vue 2.x 中，Vue.extend 曾经被用于创建一个基于 Vue 构造函数的“子类”，其参数应为一个包含组件选项的对象。在 Vue 3.x 中，我们已经没有组件构造器的概念了。应该始终使用 createApp 这个全局 API 来挂载组件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 之前 - Vue 2</span><br><span class="line"></span><br><span class="line">// 创建构造器</span><br><span class="line">const Profile = Vue.extend(&#123;</span><br><span class="line">  template: &apos;&lt;p&gt;&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125; aka &#123;&#123;alias&#125;&#125;&lt;/p&gt;&apos;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      firstName: &apos;Walter&apos;,</span><br><span class="line">      lastName: &apos;White&apos;,</span><br><span class="line">      alias: &apos;Heisenberg&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">// 创建一个 Profile 的实例，并将它挂载到一个元素上</span><br><span class="line">new Profile().$mount(&apos;#mount-point&apos;)</span><br><span class="line"></span><br><span class="line">// 之后 - Vue 3</span><br><span class="line">const Profile = &#123;</span><br><span class="line">  template: &apos;&lt;p&gt;&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125; aka &#123;&#123;alias&#125;&#125;&lt;/p&gt;&apos;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      firstName: &apos;Walter&apos;,</span><br><span class="line">      lastName: &apos;White&apos;,</span><br><span class="line">      alias: &apos;Heisenberg&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Vue.createApp(Profile).mount(&apos;#mount-point&apos;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>全局 API Treeshaking<br>在 Vue 3 中，全局和内部 API 都经过了重构，并考虑到了 tree-shaking 的支持。因此，对于 ES 模块构建版本来说，全局 API 现在通过具名导出进行访问。例如，我们之前的代码片段现在应该如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &#123; nextTick &#125; from &apos;vue&apos;</span><br><span class="line"></span><br><span class="line">nextTick(() =&gt; &#123;</span><br><span class="line">  // 一些和 DOM 有关的东西</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 Vue 2.x 中，<code>&lt;template&gt;</code> 标签不能拥有 key。不过，你可以为其每个子节点分别设置 key。在 Vue 3.x 中，key 则应该被设置在 <code>&lt;template&gt;</code> 标签上。</p>
</li>
<li>2.x 版本中在一个元素上同时使用 v-if 和 v-for 时，v-for 会优先作用。3.x 版本中 v-if 总是优先于 v-for 生效。</li>
<li>2.x 默认情况下，传递给带有 v-on 的组件的事件监听器只能通过 this.$emit 触发。要将原生 DOM 监听器添加到子组件的根元素中，可以使用 .native 修饰符。3.x v-on 的 .native 修饰符已被移除。同时，新增的 emits 选项允许子组件定义真正会被触发的事件。因此，对于子组件中未被定义为组件触发的所有事件监听器，Vue 现在将把它们作为原生事件监听器添加到子组件的根元素中 (除非在子组件的选项中设置了 inheritAttrs: false)。</li>
<li><p>v-for 中的 Ref 数组<br>在 Vue 2 中，在 v-for 中使用的 ref attribute 会用 ref 数组填充相应的 $refs property。当存在嵌套的 v-for 时，这种行为会变得不明确且效率低下。<br>在 Vue 3 中，此类用法将不再自动创建 $ref 数组。要从单个绑定获取多个 ref，请将 ref 绑定到一个更灵活的函数上 (这是一个新特性)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-for=&quot;item in list&quot; :ref=&quot;setItemRef&quot;&gt;&lt;/div&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">   data() &#123;</span><br><span class="line">     return &#123;</span><br><span class="line">       itemRefs: []</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   methods: &#123;</span><br><span class="line">     setItemRef(el) &#123;</span><br><span class="line">       if (el) &#123;</span><br><span class="line">         this.itemRefs.push(el)</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   beforeUpdate() &#123;</span><br><span class="line">     this.itemRefs = []</span><br><span class="line">   &#125;,</span><br><span class="line">   updated() &#123;</span><br><span class="line">     console.log(this.itemRefs)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>emits 选项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;button v-on:click=&quot;$emit(&apos;click&apos;, $event)&quot;&gt;OK&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">   export default &#123;</span><br><span class="line">     emits: [] // 不声明事件</span><br><span class="line">   &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;my-button v-on:click=&quot;handleClick&quot;&gt;&lt;/my-button&gt;</span><br><span class="line">该事件现在会被触发两次:一次来自 $emit() 另一次来自应用在根元素上的原生事件监听器</span><br></pre></td></tr></table></figure>
</li>
<li><p>$listeners 对象在 Vue 3 中已被移除。事件监听器现在是 $attrs 的一部分</p>
</li>
<li>在 2.x 中，开发者可以通过 object 或者是 function 定义 data 选项。 在 3.x 中，data 选项已标准化为只接受返回 object 的 function。</li>
<li>3.x 当使用 watch 选项侦听数组时，只有在数组被替换时才会触发回调。换句话说，在数组被改变时侦听回调将不再被触发。要想在数组被改变时触发侦听回调，必须指定 deep 选项。</li>
<li>在 Vue 2.x 中，当挂载一个具有 template 的应用时，被渲染的内容会替换我们要挂载的目标元素。在 Vue 3.x 中，被渲染的应用会作为子元素插入，从而替换目标元素的 innerHTML。</li>
<li>在 Vue 2 中，我们可以通过事件来监听组件生命周期中的关键阶段。这些事件名都是以 hook: 前缀开头，并跟随相应的生命周期钩子的名字。<br>在 Vue 3 中，这个前缀已被更改为 vnode-。额外地，这些事件现在也可用于 HTML 元素，和在组件上的用法一样。</li>
<li>在 2.x 中，开发者可以使用 this.$children 访问当前实例的直接子组件 在 3.x 中，$children property 已被移除，且不再支持。如果你需要访问子组件实例，我们建议使用 $refs。</li>
<li>$on，$off 和 $once 实例方法已被移除，组件实例不再实现事件触发接口。</li>
<li>在 3.x 中，过滤器已移除，且不再支持。取而代之的是，我们建议用方法调用或计算属性来替换它们。</li>
</ul>
</li>
</ul>
<h3 id="其它-1"><a href="#其它-1" class="headerlink" title="其它"></a>其它</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * $set/set</span><br><span class="line"> */</span><br><span class="line">//  export function set (target: Array&lt;any&gt; | Object, key: any, val: any): any &#123;</span><br><span class="line">//   if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp;</span><br><span class="line">//     (isUndef(target) || isPrimitive(target))</span><br><span class="line">//   ) &#123;</span><br><span class="line">//     warn(`Cannot set reactive property on undefined, null, or primitive value: $&#123;(target: any)&#125;`)</span><br><span class="line">//   &#125;</span><br><span class="line"></span><br><span class="line">//   //数组时 调用splice方法</span><br><span class="line">//   if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123;</span><br><span class="line">//     target.length = Math.max(target.length, key)</span><br><span class="line">//     target.splice(key, 1, val)</span><br><span class="line">//     return val</span><br><span class="line">//   &#125;</span><br><span class="line"></span><br><span class="line">//   if (key in target &amp;&amp; !(key in Object.prototype)) &#123;</span><br><span class="line">//     target[key] = val</span><br><span class="line">//     return val</span><br><span class="line">//   &#125;</span><br><span class="line">//   const ob = (target: any).__ob__</span><br><span class="line">//   if (target._isVue || (ob &amp;&amp; ob.vmCount)) &#123;</span><br><span class="line">//     process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; warn(</span><br><span class="line">//       &apos;Avoid adding reactive properties to a Vue instance or its root $data &apos; +</span><br><span class="line">//       &apos;at runtime - declare it upfront in the data option.&apos;</span><br><span class="line">//     )</span><br><span class="line">//     return val</span><br><span class="line">//   &#125;</span><br><span class="line">//   if (!ob) &#123;</span><br><span class="line">//     target[key] = val</span><br><span class="line">//     return val</span><br><span class="line">//   &#125;</span><br><span class="line">//   //把key设为响应式属性</span><br><span class="line">//   defineReactive(ob.value, key, val)</span><br><span class="line">//   //发送通知</span><br><span class="line">//   ob.dep.notify()</span><br><span class="line">//   return val</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * $delete/delete</span><br><span class="line"> */</span><br><span class="line">//  export function del (target: Array&lt;any&gt; | Object, key: any) &#123;</span><br><span class="line">//   if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp;</span><br><span class="line">//     (isUndef(target) || isPrimitive(target))</span><br><span class="line">//   ) &#123;</span><br><span class="line">//     warn(`Cannot delete reactive property on undefined, null, or primitive value: $&#123;(target: any)&#125;`)</span><br><span class="line">//   &#125;</span><br><span class="line"></span><br><span class="line">//   //数组处理</span><br><span class="line">//   if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123;</span><br><span class="line">//     target.splice(key, 1)</span><br><span class="line">//     return</span><br><span class="line">//   &#125;</span><br><span class="line">//   const ob = (target: any).__ob__</span><br><span class="line">//   if (target._isVue || (ob &amp;&amp; ob.vmCount)) &#123;</span><br><span class="line">//     process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; warn(</span><br><span class="line">//       &apos;Avoid deleting properties on a Vue instance or its root $data &apos; +</span><br><span class="line">//       &apos;- just set it to null.&apos;</span><br><span class="line">//     )</span><br><span class="line">//     return</span><br><span class="line">//   &#125;</span><br><span class="line">//   if (!hasOwn(target, key)) &#123;</span><br><span class="line">//     return</span><br><span class="line">//   &#125;</span><br><span class="line"></span><br><span class="line">//   //delete 操作符</span><br><span class="line">//   delete target[key]</span><br><span class="line">//   if (!ob) &#123;</span><br><span class="line">//     return</span><br><span class="line">//   &#125;</span><br><span class="line">//   ob.dep.notify()</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * $nextTick/nextTick</span><br><span class="line"> * nextTick的目的就是产生一个回调函数加入task或者microtask中，当前栈执行完以后（可能中间还有别的排在前面的函数）调用该回调函数，起到了异步触发（即下一个tick时触发）的目的。</span><br><span class="line"> * 优先使用Promise，在Promise不存在的情况下使用MutationObserver，这两个方法的回调函数都会在microtask中执行，它们会比setTimeout更早执行，所以优先使用。 如果上述两种方法都不支持的环境则会使用setTimeout，在task尾部推入这个函数，等待调用执行。</span><br><span class="line"> * JS 的 event loop 执行时会区分 task 和 microtask，引擎在每个 task 执行完毕，从队列中取下一个 task 来执行之前，会先执行完所有 microtask 队列中的 microtask。</span><br><span class="line"> * setTimeout 回调会被分配到一个新的 task 中执行，而 Promise 的 resolver、MutationObserver 的回调都会被安排到一个新的 microtask 中执行，会比 setTimeout 产生的 task 先执行。</span><br><span class="line"> * 要创建一个新的 microtask，优先使用 Promise，如果浏览器不支持，再尝试 MutationObserver。</span><br><span class="line"> * 实在不行，只能用 setTimeout 创建 task 了。</span><br><span class="line"> * 为啥要用 microtask？</span><br><span class="line"> * 根据 HTML Standard，在每个 task 运行完以后，UI 都会重渲染，那么在 microtask 中就完成数据更新，当前 task 结束就可以得到最新的 UI 了。</span><br><span class="line"> * 反之如果新建一个 task 来做数据更新，那么渲染就会进行两次。</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> * 为什么要异步更新视图?</span><br><span class="line"> * 现在有这样的一种情况，mounted的时候test的值会被++循环执行1000次。 每次++时，都会根据响应式触发setter-&gt;Dep-&gt;Watcher-&gt;update-&gt;patch。 如果这时候没有异步更新视图，那么每次++都会直接操作DOM更新视图，这是非常消耗性能的。 所以Vue.js实现了一个queue队列，在下一个tick的时候会统一执行queue中Watcher的run。同时，拥有相同id的Watcher不会被重复加入到该queue中去，所以不会执行1000次Watcher的run。最终更新视图只会直接将test对应的DOM的0变成1000。 保证更新视图操作DOM的动作是在当前栈执行完以后下一个tick的时候调用，大大优化了性能。</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Vue.use() </span><br><span class="line"> * 插件是function时直接调用,插件有install字段且install是function时调用install</span><br><span class="line"> * export function initUse (Vue: GlobalAPI) &#123;</span><br><span class="line">   //参数为函数或对象</span><br><span class="line">  Vue.use = function (plugin: Function | Object) &#123;</span><br><span class="line">   //已经安装的插件</span><br><span class="line">    const installedPlugins = (this._installedPlugins || (this._installedPlugins = []))</span><br><span class="line">	//已经安装过的插件不会再次安装</span><br><span class="line">    if (installedPlugins.indexOf(plugin) &gt; -1) &#123;</span><br><span class="line">      return this</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // additional parameters   把参数的第一个元素去除，第一个元素是插件</span><br><span class="line">    const args = toArray(arguments, 1)</span><br><span class="line">    args.unshift(this)   //args数组第一项插入this(Vue)</span><br><span class="line">	//参数为对象时，有一个install方法，调用install方法</span><br><span class="line">    if (typeof plugin.install === &apos;function&apos;) &#123;</span><br><span class="line">      plugin.install.apply(plugin, args)</span><br><span class="line">    &#125; </span><br><span class="line">	//参数为函数时,直接调用</span><br><span class="line">	else if (typeof plugin === &apos;function&apos;) &#123;</span><br><span class="line">      plugin.apply(null, args)</span><br><span class="line">    &#125;</span><br><span class="line">    installedPlugins.push(plugin)</span><br><span class="line">    return this</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<h2 id="react"><a href="#react" class="headerlink" title="react"></a>react</h2><h3 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line">function render()&#123;</span><br><span class="line"> diff()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export default function diff(virtualDOM, container, oldDOM) &#123;</span><br><span class="line">  const oldVirtualDOM = oldDOM &amp;&amp; oldDOM._virtualDOM</span><br><span class="line">  const oldComponent = oldVirtualDOM &amp;&amp; oldVirtualDOM.component</span><br><span class="line">  // 判断 oldDOM 是否存在</span><br><span class="line">  if (!oldDOM) &#123;</span><br><span class="line">    mountElement(virtualDOM, container)</span><br><span class="line">  &#125; else if (</span><br><span class="line">    // 如果要比对的两个节点类型不相同</span><br><span class="line">    virtualDOM.type !== oldVirtualDOM.type &amp;&amp;</span><br><span class="line">    // 并且节点的类型不是组件 因为组件要单独处理</span><br><span class="line">    typeof virtualDOM.type !== &quot;function&quot;</span><br><span class="line">  ) &#123;</span><br><span class="line">    // 不需要对比</span><br><span class="line">    // 使用新的 virtualDOM 对象生成真实 DOM 对象</span><br><span class="line">    const newElement = createDOMElement(virtualDOM)</span><br><span class="line">    // 使用新的 DOM 对象替换旧的 DOM 对象</span><br><span class="line">    oldDOM.parentNode.replaceChild(newElement, oldDOM)</span><br><span class="line">  &#125; else if (typeof virtualDOM.type === &quot;function&quot;) &#123;</span><br><span class="line">    // 组件</span><br><span class="line">    diffComponent(virtualDOM, oldComponent, oldDOM, container)</span><br><span class="line">  &#125; else if (oldVirtualDOM &amp;&amp; virtualDOM.type === oldVirtualDOM.type) &#123;</span><br><span class="line">    if (virtualDOM.type === &quot;text&quot;) &#123;</span><br><span class="line">      // 更新内容</span><br><span class="line">      updateTextNode(virtualDOM, oldVirtualDOM, oldDOM)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // 更新元素节点属性</span><br><span class="line">      updateNodeElement(oldDOM, virtualDOM, oldVirtualDOM)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 1. 将拥有key属性的子元素放置在一个单独的对象中</span><br><span class="line">    let keyedElements = &#123;&#125;</span><br><span class="line">    for (let i = 0, len = oldDOM.childNodes.length; i &lt; len; i++) &#123;</span><br><span class="line">      let domElement = oldDOM.childNodes[i]</span><br><span class="line">      if (domElement.nodeType === 1) &#123;</span><br><span class="line">        let key = domElement.getAttribute(&quot;key&quot;)</span><br><span class="line">        if (key) &#123;</span><br><span class="line">          keyedElements[key] = domElement</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let hasNoKey = Object.keys(keyedElements).length === 0</span><br><span class="line"></span><br><span class="line">    if (hasNoKey) &#123;</span><br><span class="line">      // 对比子节点</span><br><span class="line">      virtualDOM.children.forEach((child, i) =&gt; &#123;</span><br><span class="line">        diff(child, oldDOM, oldDOM.childNodes[i])</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // 2. 循环 virtualDOM 的子元素 获取子元素的 key 属性</span><br><span class="line">      virtualDOM.children.forEach((child, i) =&gt; &#123;</span><br><span class="line">        let key = child.props.key</span><br><span class="line">        if (key) &#123;</span><br><span class="line">          let domElement = keyedElements[key]</span><br><span class="line">          if (domElement) &#123;</span><br><span class="line">            // 3. 看看当前位置的元素是不是我们期望的元素</span><br><span class="line">            if (oldDOM.childNodes[i] &amp;&amp; oldDOM.childNodes[i] !== domElement) &#123;</span><br><span class="line">              oldDOM.insertBefore(domElement, oldDOM.childNodes[i])</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            // 新增元素</span><br><span class="line">            mountElement(child, oldDOM, oldDOM.childNodes[i])</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 删除节点</span><br><span class="line">    // 获取旧节点</span><br><span class="line">    let oldChildNodes = oldDOM.childNodes</span><br><span class="line">    // 判断旧节点的数量</span><br><span class="line">    if (oldChildNodes.length &gt; virtualDOM.children.length) &#123;</span><br><span class="line">      if (hasNoKey) &#123;</span><br><span class="line">        // 有节点需要被删除</span><br><span class="line">        for (</span><br><span class="line">          let i = oldChildNodes.length - 1;</span><br><span class="line">          i &gt; virtualDOM.children.length - 1;</span><br><span class="line">          i--</span><br><span class="line">        ) &#123;</span><br><span class="line">          unmountNode(oldChildNodes[i])</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        // 通过key属性删除节点</span><br><span class="line">        for (let i = 0; i &lt; oldChildNodes.length; i++) &#123;</span><br><span class="line">          let oldChild = oldChildNodes[i]</span><br><span class="line">          let oldChildKey = oldChild._virtualDOM.props.key</span><br><span class="line">          let found = false</span><br><span class="line">          for (let n = 0; n &lt; virtualDOM.children.length; n++) &#123;</span><br><span class="line">            if (oldChildKey === virtualDOM.children[n].props.key) &#123;</span><br><span class="line">              found = true</span><br><span class="line">              break</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          if (!found) &#123;</span><br><span class="line">            unmountNode(oldChild)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export default function mountComponent(virtualDOM, container, oldDOM) &#123;</span><br><span class="line">  let nextVirtualDOM = null</span><br><span class="line">  let component = null</span><br><span class="line">  // 判断组件是类组件还是函数组件</span><br><span class="line">  if (isFunctionComponent(virtualDOM)) &#123;</span><br><span class="line">    // 函数组件</span><br><span class="line">    nextVirtualDOM = buildFunctionComponent(virtualDOM)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // 类组件</span><br><span class="line">    nextVirtualDOM = buildClassComponent(virtualDOM)</span><br><span class="line">    component = nextVirtualDOM.component</span><br><span class="line">  &#125;</span><br><span class="line">  if (isFunction(nextVirtualDOM)) &#123;</span><br><span class="line">    mountComponent(nextVirtualDOM, container, oldDOM)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    mountNativeElement(nextVirtualDOM, container, oldDOM)</span><br><span class="line">  &#125;</span><br><span class="line">  if (component) &#123;</span><br><span class="line">    component.componentDidMount()</span><br><span class="line">    if (component.props &amp;&amp; component.props.ref) &#123;</span><br><span class="line">      component.props.ref(component)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function buildFunctionComponent(virtualDOM) &#123;</span><br><span class="line">  return virtualDOM.type(virtualDOM.props || &#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function buildClassComponent(virtualDOM) &#123;</span><br><span class="line">  const component = new virtualDOM.type(virtualDOM.props || &#123;&#125;)</span><br><span class="line">  const nextVirtualDOM = component.render()</span><br><span class="line">  nextVirtualDOM.component = component</span><br><span class="line">  return nextVirtualDOM</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">关键：insertBefore 可以使用 insertBefore 方法插入/移动已有元素。</span><br></pre></td></tr></table></figure>
<h3 id="fiber"><a href="#fiber" class="headerlink" title="fiber"></a>fiber</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//https://mp.weixin.qq.com/s/zjhCIUtJrSmw2icy2zkKFg</span><br><span class="line">// 完整的一帧中，具体做了哪些事情：</span><br><span class="line">// 1.首先需要处理输入事件，能够让用户得到最早的反馈</span><br><span class="line"></span><br><span class="line">// 2.接下来是处理定时器，需要检查定时器是否到时间，并执行对应的回调</span><br><span class="line"></span><br><span class="line">// 3.接下来处理 Begin Frame（开始帧），即每一帧的事件，包括 window.resize、scroll、media query change 等</span><br><span class="line"></span><br><span class="line">// 4.接下来执行请求动画帧 requestAnimationFrame（rAF），即在每次绘制之前，会执行 rAF 回调</span><br><span class="line"></span><br><span class="line">// 5.紧接着进行 Layout 操作，包括计算布局和更新布局，即这个元素的样式是怎样的，它应该在页面如何展示</span><br><span class="line"></span><br><span class="line">// 6.接着进行 Paint 操作，得到树中每个节点的尺寸与位置等信息，浏览器针对每个元素进行内容填充</span><br><span class="line"></span><br><span class="line">// 7.到这时以上的六个阶段都已经完成了，接下来处于空闲阶段（Idle Peroid），可以在这时执行 requestIdleCallback 里注册的任务（后面会详细讲到这个 requestIdleCallback ，它是 React Fiber 实现的基础）</span><br><span class="line"></span><br><span class="line">// js引擎和页面渲染引擎是在同一个渲染线程之内，两者是互斥关系。如果在某个阶段执行任务特别长，例如在定时器阶段或Begin Frame阶段执行时间非常长，时间已经明显超过了16ms，那么就会阻塞页面的渲染，从而出现卡顿现象。</span><br><span class="line">// 在 react16 引入 Fiber 架构之前，react 会采用递归对比虚拟DOM树，找出需要变动的节点，然后同步更新它们，这个过程 react 称为reconcilation（协调）。在reconcilation期间，react 会一直占用浏览器资源，会导致用户触发的事件得不到响应。</span><br><span class="line">// 这种遍历是递归调用，执行栈会越来越深，而且不能中断，中断后就不能恢复了。递归如果非常深，就会十分卡顿。如果递归花了100ms，则这100ms浏览器是无法响应的，代码执行时间越长卡顿越明显。传统的方法存在不能中断和执行栈太深的问题。</span><br><span class="line"></span><br><span class="line">// 因此，为了解决以上的痛点问题，React希望能够彻底解决主线程长时间占用问题，于是引入了 Fiber 来改变这种不可控的现状，把渲染/更新过程拆分为一个个小块的任务，通过合理的调度机制来调控时间，指定任务执行的时机，从而降低页面卡顿的概率，提升页面交互体验。通过Fiber架构，让reconcilation过程变得可被中断。适时地让出CPU执行权，可以让浏览器及时地响应用户的交互。</span><br><span class="line">//React16中使用了 Fiber，但是 Vue 是没有 Fiber 的，为什么呢？原因是二者的优化思路不一样：</span><br><span class="line">//Vue 是基于 template 和 watcher 的组件级更新，把每个更新任务分割得足够小，不需要使用到 Fiber 架构，将任务进行更细粒度的拆分</span><br><span class="line">//React 是不管在哪里调用 setState，都是从根节点开始更新的，更新任务还是很大，需要使用到 Fiber 将大任务分割为多个小任务，可以中断和恢复，不阻塞主进程执行高优先级的任务</span><br><span class="line"></span><br><span class="line">// Fiber 执行原理</span><br><span class="line">// 从根节点开始渲染和调度的过程可以分为两个阶段：render 阶段、commit 阶段。</span><br><span class="line">// render 阶段：这个阶段是可中断的，会找出所有节点的变更</span><br><span class="line">// commit 阶段：这个阶段是不可中断的，会执行所有的变更</span><br></pre></td></tr></table></figure>
<h3 id="其它-2"><a href="#其它-2" class="headerlink" title="其它"></a>其它</h3><ul>
<li>受控组件 非受控组件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">受控组件</span><br><span class="line">class NameForm extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;value: &apos;&apos;&#125;;</span><br><span class="line"></span><br><span class="line">    this.handleChange = this.handleChange.bind(this);</span><br><span class="line">    this.handleSubmit = this.handleSubmit.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(event) &#123;</span><br><span class="line">    this.setState(&#123;value: event.target.value&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSubmit(event) &#123;</span><br><span class="line">    alert(&apos;提交的名字: &apos; + this.state.value);</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          名字:</span><br><span class="line">          &lt;input type=&quot;text&quot; value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt;</span><br><span class="line">        &lt;/label&gt;</span><br><span class="line">        &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;</span><br><span class="line">      &lt;/form&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">非受控组件</span><br><span class="line">class NameForm extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.handleSubmit = this.handleSubmit.bind(this);</span><br><span class="line">    this.input = React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSubmit(event) &#123;</span><br><span class="line">    alert(&apos;A name was submitted: &apos; + this.input.current.value);</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          Name:</span><br><span class="line">          &lt;input type=&quot;text&quot; ref=&#123;this.input&#125; /&gt;</span><br><span class="line">        &lt;/label&gt;</span><br><span class="line">        &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;</span><br><span class="line">      &lt;/form&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>高阶组件 高阶组件是参数为组件，返回值为新组件的函数。</li>
<li>React.Children 提供了用于处理 this.props.children 不透明数据结构的实用方法。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">React.Children.map</span><br><span class="line">在 children 里的每个直接子节点上调用一个函数，并将 this 设置为 thisArg。如果 children 是一个数组，它将被遍历并为数组中的每个子节点调用该函数。如果子节点为 null 或是 undefined，则此方法将返回 null 或是 undefined，而不会返回数组。</span><br></pre></td></tr></table></figure>
<h2 id="node"><a href="#node" class="headerlink" title="node"></a>node</h2><h2 id="各种手写"><a href="#各种手写" class="headerlink" title="各种手写"></a>各种手写</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br></pre></td><td class="code"><pre><span class="line">1.call/apply/bind</span><br><span class="line"></span><br><span class="line">Function.prototype.call = function (context, ...args) &#123;</span><br><span class="line">  var context = context || window;</span><br><span class="line"></span><br><span class="line">  //当前this指向Function.prototype上面的方法</span><br><span class="line">  context.fn = this;</span><br><span class="line">  var result = eval(&quot;context.fn(...args)&quot;);</span><br><span class="line"></span><br><span class="line">  delete context.fn;</span><br><span class="line"></span><br><span class="line">  return result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Function.prototype.apply = function (context, args) &#123;</span><br><span class="line"></span><br><span class="line">  let context = context || window;</span><br><span class="line"></span><br><span class="line">  context.fn = this;</span><br><span class="line"></span><br><span class="line">  let result = eval(&apos;context.fn(...args)&apos;);</span><br><span class="line"></span><br><span class="line">  delete context.fn</span><br><span class="line"></span><br><span class="line">  return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Function.prototype.bind = function (context, ...args) &#123;</span><br><span class="line">  if (typeof this !== &quot;function&quot;) &#123;</span><br><span class="line">    throw new Error(&quot;this must be a function&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  var self = this;</span><br><span class="line">  var fbound = function () &#123;  </span><br><span class="line">    self.apply(</span><br><span class="line">      this instanceof fbound ? this : context,</span><br><span class="line">      args.concat(Array.prototype.slice.call(arguments))</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  if (this.prototype) &#123;</span><br><span class="line">    fbound.prototype = Object.create(this.prototype);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return fbound;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">2.promise</span><br><span class="line"></span><br><span class="line">class APromise &#123;</span><br><span class="line">  //容器状态</span><br><span class="line">  status = &quot;pending&quot;;</span><br><span class="line">  //处理成功时的容器值</span><br><span class="line">  value = &quot;&quot;;</span><br><span class="line">  //处理失败时的原因</span><br><span class="line">  reason = &quot;&quot;;</span><br><span class="line">  //处理成功回调函数     then方法被多次调用时，采用数组进行存储回调函数</span><br><span class="line">  fullFilledCallbacks = [];</span><br><span class="line">  //处理失败回调函数</span><br><span class="line">  rejectedCallBacks = [];</span><br><span class="line">  //处理成功</span><br><span class="line">  resolve = (value) =&gt; &#123;</span><br><span class="line">    if (this.status === &quot;pending&quot;) &#123;</span><br><span class="line">      this.status = &quot;fullFilled&quot;;</span><br><span class="line">      this.value = value;</span><br><span class="line"></span><br><span class="line">      //处理成功回调</span><br><span class="line">      while (this.fullFilledCallbacks.length) &#123;</span><br><span class="line">        this.fullFilledCallbacks.shift()(value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  //处理成败</span><br><span class="line">  reject = (reason) =&gt; &#123;</span><br><span class="line">    if (this.status === &quot;pending&quot;) &#123;</span><br><span class="line">      this.status = &quot;rejected&quot;;</span><br><span class="line">      this.reason = reason;</span><br><span class="line"></span><br><span class="line">      //处理失败回调</span><br><span class="line">      while (this.rejectedCallBacks.length) &#123;</span><br><span class="line">        this.rejectedCallBacks.shift()(reason);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  //处理then方法回调函数返回值</span><br><span class="line">  resolvePromise = (promise, res, resolve, reject) =&gt; &#123;</span><br><span class="line">    //then方法成功回调返回值和then方法返回值一样时</span><br><span class="line">    if (promise === res) &#123;</span><br><span class="line">      //避免循环引用</span><br><span class="line">      reject(new TypeError(&quot;Chaining cycle detected for promise #&lt;Promise&gt;&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //返回值为promise（这里的promise指then方法成功回调时返回的promise）时</span><br><span class="line">    if (res instanceof APromise) &#123;</span><br><span class="line">      //对返回的promise（这里的promise指then方法成功回调时返回的promise）的处理结果进行处理</span><br><span class="line">      //通过resolve/reject对返回的promise（这里的promise指调用then方法时返回的promise）状态进行处理</span><br><span class="line">      res.then(resolve, reject);</span><br><span class="line">    &#125;</span><br><span class="line">    //普通值</span><br><span class="line">    else &#123;</span><br><span class="line">      resolve(res);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  //处理完成   (rejected/pending逻辑参考fullFilled状态)</span><br><span class="line">  then = (onFullFilled, onRejected) =&gt; &#123;</span><br><span class="line">    // 如果不传，就使用默认函数</span><br><span class="line">    onFullFilled =</span><br><span class="line">      typeof onFullFilled === &quot;function&quot; ? onFullFilled : (value) =&gt; value;</span><br><span class="line">    // 如果不传，就使用默认函数</span><br><span class="line">    onRejected =</span><br><span class="line">      typeof onRejected === &quot;function&quot;</span><br><span class="line">        ? onRejected</span><br><span class="line">        : (reason) =&gt; &#123;</span><br><span class="line">            throw reason;</span><br><span class="line">          &#125;;</span><br><span class="line"></span><br><span class="line">    //返回promise用于链式调用</span><br><span class="line">    const promise = new APromise((resolve, reject) =&gt; &#123;</span><br><span class="line">      //成功回调</span><br><span class="line">      if (this.status === &quot;fullFilled&quot;) &#123;</span><br><span class="line">        // 为了拿到上面返回的promise实例对象，需要创建一个微任务等待promise初始化</span><br><span class="line">        //否则，会报ReferenceError: Cannot access &apos;promise&apos; before initialization</span><br><span class="line">        queueMicrotask(() =&gt; &#123;</span><br><span class="line">          //异常捕获</span><br><span class="line">          try &#123;</span><br><span class="line">            const res = onFullFilled(this.value);</span><br><span class="line">            this.resolvePromise(promise, res, resolve, reject);</span><br><span class="line">          &#125; catch (error) &#123;</span><br><span class="line">            reject(error);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      //失败回调</span><br><span class="line">      if (this.status === &quot;rejected&quot;) &#123;</span><br><span class="line">        queueMicrotask(() =&gt; &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">            const res = onRejected(this.reason);</span><br><span class="line">            this.resolvePromise(promise, res, resolve, reject);</span><br><span class="line">          &#125; catch (error) &#123;</span><br><span class="line">            reject(error);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      //处理异步任务</span><br><span class="line">      if (this.status === &quot;pending&quot;) &#123;</span><br><span class="line">        //对成功、失败回调进行存储。异步任务执行成功后再进行处理</span><br><span class="line">        //对成功处理函数存储</span><br><span class="line">        this.fullFilledCallbacks.push(() =&gt; &#123;</span><br><span class="line">          //异常捕获</span><br><span class="line">          try &#123;</span><br><span class="line">            const res = onFullFilled(this.value);</span><br><span class="line">            this.resolvePromise(promise, res, resolve, reject);</span><br><span class="line">          &#125; catch (error) &#123;</span><br><span class="line">            reject(error);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        //对失败处理函数进行存储</span><br><span class="line">        this.rejectedCallBacks.push(() =&gt; &#123;</span><br><span class="line">          queueMicrotask(() =&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">              const res = onRejected(this.reason);</span><br><span class="line">              this.resolvePromise(promise, res, resolve, reject);</span><br><span class="line">            &#125; catch (error) &#123;</span><br><span class="line">              reject(error);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return promise;</span><br><span class="line">  &#125;;</span><br><span class="line">  constructor(executor) &#123;</span><br><span class="line">    //异常捕获</span><br><span class="line">    try &#123;</span><br><span class="line">      //执行器</span><br><span class="line">      executor(this.resolve, this.reject);</span><br><span class="line">    &#125; catch (error) &#123;</span><br><span class="line">      console.log(error);</span><br><span class="line">      this.reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default APromise;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------------</span><br><span class="line">/**</span><br><span class="line"> * Promise.all Promise.race Promise.allSettled Promise.any</span><br><span class="line"> *</span><br><span class="line"> * Promise.all()方法只适合所有异步操作都成功的情况，如果有一个操作失败，就无法满足要求。</span><br><span class="line"> * ES2020 引入了Promise.allSettled()方法，用来确定一组异步操作是否都结束了（不管成功或失败）。</span><br><span class="line"> * Promise.any()跟Promise.race()方法很像，只有一点不同，就是Promise.any()不会因为某个 Promise 变成rejected状态而结束，必须等到所有参数 Promise 变成rejected状态才会结束。</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">Promise.all = function (promiseArr) &#123;</span><br><span class="line">  let index = 0,</span><br><span class="line">    result = [];</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    promiseArr.forEach((p, i) =&gt; &#123;</span><br><span class="line">      Promise.resolve(p).then(</span><br><span class="line">        (val) =&gt; &#123;</span><br><span class="line">          index++;</span><br><span class="line">          result[i] = val;</span><br><span class="line">          if (index === promiseArr.length) &#123;</span><br><span class="line">            resolve(result);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        (err) =&gt; &#123;</span><br><span class="line">          reject(err);</span><br><span class="line">        &#125;</span><br><span class="line">      );</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Promise.race = function (promiseArr) &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    promiseArr.forEach((p) =&gt; &#123;</span><br><span class="line">      Promise.resolve(p).then(</span><br><span class="line">        (val) =&gt; &#123;</span><br><span class="line">          resolve(val);</span><br><span class="line">        &#125;,</span><br><span class="line">        (err) =&gt; &#123;</span><br><span class="line">          reject(err);</span><br><span class="line">        &#125;</span><br><span class="line">      );</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Promise.allSettled = function(promiseArr) &#123;</span><br><span class="line">  let result = []</span><br><span class="line"></span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      promiseArr.forEach((p, i) =&gt; &#123;</span><br><span class="line">          Promise.resolve(p).then(val =&gt; &#123;</span><br><span class="line">              result.push(&#123;</span><br><span class="line">                  status: &apos;fulfilled&apos;,</span><br><span class="line">                  value: val</span><br><span class="line">              &#125;)</span><br><span class="line">              if (result.length === promiseArr.length) &#123;</span><br><span class="line">                  resolve(result)</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;, err =&gt; &#123;</span><br><span class="line">              result.push(&#123;</span><br><span class="line">                  status: &apos;rejected&apos;,</span><br><span class="line">                  reason: err</span><br><span class="line">              &#125;)</span><br><span class="line">              if (result.length === promiseArr.length) &#123;</span><br><span class="line">                  resolve(result)</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise.any = function(promiseArr) &#123;</span><br><span class="line">  let index = 0</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      if (promiseArr.length === 0) return</span><br><span class="line">      promiseArr.forEach((p, i) =&gt; &#123;</span><br><span class="line">          Promise.resolve(p).then(val =&gt; &#123;</span><br><span class="line">              resolve(val)</span><br><span class="line"></span><br><span class="line">          &#125;, err =&gt; &#123;</span><br><span class="line">              index++</span><br><span class="line">              if (index === promiseArr.length) &#123;</span><br><span class="line">                reject(new AggregateError(&apos;All promises were rejected&apos;))</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3.JSON.stringify/JSON.parse</span><br><span class="line"></span><br><span class="line">function jsonStringify(data) &#123;</span><br><span class="line">  let type = typeof data;</span><br><span class="line"></span><br><span class="line">  if (type !== &quot;object&quot;) &#123;</span><br><span class="line">    let result = data;</span><br><span class="line"></span><br><span class="line">    //data 可能是基础数据类型的情况在这里处理</span><br><span class="line"></span><br><span class="line">    if (Number.isNaN(data) || data === Infinity) &#123;</span><br><span class="line">      //NaN 和 Infinity 序列化返回 &quot;null&quot;</span><br><span class="line"></span><br><span class="line">      result = &quot;null&quot;;</span><br><span class="line">    &#125; else if (</span><br><span class="line">      type === &quot;function&quot; ||</span><br><span class="line">      type === &quot;undefined&quot; ||</span><br><span class="line">      type === &quot;symbol&quot;</span><br><span class="line">    ) &#123;</span><br><span class="line">      // 由于 function 序列化返回 undefined，因此和 undefined、symbol 一起处理</span><br><span class="line"></span><br><span class="line">      return undefined;</span><br><span class="line">    &#125; else if (type === &quot;string&quot;) &#123;</span><br><span class="line">      result = &apos;&quot;&apos; + data + &apos;&quot;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return String(result);</span><br><span class="line">  &#125; else if (type === &quot;object&quot;) &#123;</span><br><span class="line">    //null</span><br><span class="line">    if (data === null) &#123;</span><br><span class="line">      return &quot;null&quot;; // 第01讲有讲过 typeof null 为&apos;object&apos;的特殊情况</span><br><span class="line">    &#125;</span><br><span class="line">    //date类型</span><br><span class="line">    else if (data.toJSON &amp;&amp; typeof data.toJSON === &quot;function&quot;) &#123;</span><br><span class="line">      return jsonStringify(data.toJSON());</span><br><span class="line">    &#125;</span><br><span class="line">    //数组</span><br><span class="line">    else if (data instanceof Array) &#123;</span><br><span class="line">      let result = [];</span><br><span class="line"></span><br><span class="line">      //如果是数组，那么数组里面的每一项类型又有可能是多样的</span><br><span class="line"></span><br><span class="line">      data.forEach((item, index) =&gt; &#123;</span><br><span class="line">        if (</span><br><span class="line">          typeof item === &quot;undefined&quot; ||</span><br><span class="line">          typeof item === &quot;function&quot; ||</span><br><span class="line">          typeof item === &quot;symbol&quot;</span><br><span class="line">        ) &#123;</span><br><span class="line">          result[index] = &quot;null&quot;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          result[index] = jsonStringify(item);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      result = &quot;[&quot; + result + &quot;]&quot;;</span><br><span class="line"></span><br><span class="line">      return result.replace(/&apos;/g, &apos;&quot;&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    //普通对象</span><br><span class="line">    else &#123;</span><br><span class="line">      // 处理普通对象</span><br><span class="line"></span><br><span class="line">      let result = [];</span><br><span class="line"></span><br><span class="line">      Object.keys(data).forEach((item, index) =&gt; &#123;</span><br><span class="line">        if (typeof item !== &quot;symbol&quot;) &#123;</span><br><span class="line">          //key 如果是 symbol 对象，忽略</span><br><span class="line"></span><br><span class="line">          if (</span><br><span class="line">            data[item] !== undefined &amp;&amp;</span><br><span class="line">            typeof data[item] !== &quot;function&quot; &amp;&amp;</span><br><span class="line">            typeof data[item] !== &quot;symbol&quot;</span><br><span class="line">          ) &#123;</span><br><span class="line">            //键值如果是 undefined、function、symbol 为属性值，忽略</span><br><span class="line"></span><br><span class="line">            result.push(&apos;&quot;&apos; + item + &apos;&quot;&apos; + &quot;:&quot; + jsonStringify(data[item]));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      return (&quot;&#123;&quot; + result + &quot;&#125;&quot;).replace(/&apos;/g, &apos;&quot;&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------------------------------</span><br><span class="line">eval(`($&#123;&apos;&#123;&quot;p&quot;: 5,&quot;p2&quot;: 52&#125;&apos;&#125;)`)</span><br><span class="line">new Function(`return ($&#123;&apos;&#123;&quot;p&quot;: 5,&quot;p2&quot;: 52&#125;&apos;&#125;)`)()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4.EventEmitter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function EventEmitter() &#123;</span><br><span class="line">  this.__events = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventEmitter.VERSION = &quot;1.0.0&quot;;</span><br><span class="line"></span><br><span class="line">//绑定事件</span><br><span class="line">EventEmitter.prototype.on = function (eventName, event) &#123;</span><br><span class="line">  let events = (this.__events[eventName] = this.__events[eventName] || []);</span><br><span class="line">  //是否存在该事件</span><br><span class="line">  let isExist = events.find((ev) =&gt; ev.listener === (event.listener || event));</span><br><span class="line">  if (!isExist) &#123;</span><br><span class="line">    events.push(</span><br><span class="line">      //对象或函数</span><br><span class="line">      event.listener</span><br><span class="line">        ? event</span><br><span class="line">        : &#123;</span><br><span class="line">            once: false,</span><br><span class="line">            listener: event,</span><br><span class="line">          &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return this;</span><br><span class="line">&#125;;</span><br><span class="line">//触发事件</span><br><span class="line">EventEmitter.prototype.emit = function (eventName, args) &#123;</span><br><span class="line">  let events = this.__events[eventName] || [];</span><br><span class="line"></span><br><span class="line">  //多个事件</span><br><span class="line">  for (let event of events) &#123;</span><br><span class="line">    event.listener.apply(this, args || []);</span><br><span class="line">    if (event.once) &#123;</span><br><span class="line">      this.off(eventName, event);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//执行一次</span><br><span class="line">EventEmitter.prototype.once = function (eventName, event) &#123;</span><br><span class="line">  return this.on(eventName, &#123;</span><br><span class="line">    once: true,</span><br><span class="line">    listener: event.listener || event,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">//移除事件</span><br><span class="line">EventEmitter.prototype.off = function (eventName, event) &#123;</span><br><span class="line">  let events = this.__events[eventName] || [];</span><br><span class="line">  //事件下标</span><br><span class="line">  let eventIndex = events.findIndex(</span><br><span class="line">    (ev) =&gt; ev.listener === (event.listener || event)</span><br><span class="line">  );</span><br><span class="line">  //存在该事件时</span><br><span class="line">  if (eventIndex !== -1) events.splice(eventIndex, 1);</span><br><span class="line">&#125;;</span><br><span class="line">//移除所有事件</span><br><span class="line">EventEmitter.prototype.allOff = function (eventName) &#123;</span><br><span class="line">  if (this.__events[eventName]) this.__events[eventName] = [];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5.继承</span><br><span class="line"></span><br><span class="line">//原型链继承</span><br><span class="line">function Parent1() &#123;</span><br><span class="line">  this.name = &quot;parent1&quot;;</span><br><span class="line"></span><br><span class="line">  this.play = [1, 2, 3];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child1() &#123;</span><br><span class="line">  this.type = &quot;child2&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child1.prototype = new Parent1();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//构造函数继承</span><br><span class="line">function Parent1() &#123;</span><br><span class="line">  this.name = &quot;parent1&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent1.prototype.getName = function () &#123;</span><br><span class="line">  return this.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Child1() &#123;</span><br><span class="line">  Parent1.call(this);</span><br><span class="line"></span><br><span class="line">  this.type = &quot;child1&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//组合继承</span><br><span class="line"></span><br><span class="line">function Parent3() &#123;</span><br><span class="line">  this.name = &quot;parent3&quot;;</span><br><span class="line"></span><br><span class="line">  this.play = [1, 2, 3];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent3.prototype.getName = function () &#123;</span><br><span class="line">  return this.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Child3() &#123;</span><br><span class="line"></span><br><span class="line">  Parent3.call(this);</span><br><span class="line"></span><br><span class="line">  this.type = &quot;child3&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Child3.prototype = new Parent3();</span><br><span class="line"></span><br><span class="line">// 手动挂上构造器，指向自己的构造函数</span><br><span class="line">Child3.prototype.constructor = Child3;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">6.new</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//new 关键字会进行如下的操作：</span><br><span class="line"></span><br><span class="line">//创建一个空的简单JavaScript对象（即&#123;&#125;）；</span><br><span class="line">//为步骤1新创建的对象添加属性__proto__，将该属性链接至构造函数的原型对象 ；</span><br><span class="line">//将步骤1新创建的对象作为this的上下文 ；</span><br><span class="line">//如果该函数没有返回对象，则返回this。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function _new(ctor, ...args) &#123;</span><br><span class="line">  if (typeof ctor !== &quot;function&quot;) &#123;</span><br><span class="line">    throw &quot;ctor must be a function&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let obj = new Object();</span><br><span class="line"></span><br><span class="line">  obj.__proto__ = Object.create(ctor.prototype);</span><br><span class="line"></span><br><span class="line">  //关键  this指向</span><br><span class="line">  let res = ctor.apply(obj, [...args]);</span><br><span class="line"></span><br><span class="line">  let isObject = typeof res === &quot;object&quot; &amp;&amp; res !== null;</span><br><span class="line"></span><br><span class="line">  let isFunction = typeof res === &quot;function&quot;;</span><br><span class="line"></span><br><span class="line">  return isObject || isFunction ? res : obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">7.对象拷贝</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const isComplexDataType = (obj) =&gt;</span><br><span class="line">  (typeof obj === &quot;object&quot; || typeof obj === &quot;function&quot;) &amp;&amp; obj !== null;</span><br><span class="line"></span><br><span class="line">const deepClone = function (obj, hash = new WeakMap()) &#123;</span><br><span class="line">  if (obj.constructor === Date) return new Date(obj); // 日期对象直接返回一个新的日期对象</span><br><span class="line"></span><br><span class="line">  if (obj.constructor === RegExp) return new RegExp(obj); //正则对象直接返回一个新的正则对象</span><br><span class="line"></span><br><span class="line">  //如果循环引用了就用 weakMap 来解决</span><br><span class="line"></span><br><span class="line">  if (hash.has(obj)) return hash.get(obj);</span><br><span class="line"></span><br><span class="line">  let allDesc = Object.getOwnPropertyDescriptors(obj);</span><br><span class="line"></span><br><span class="line">  //遍历传入参数所有键的特性</span><br><span class="line"></span><br><span class="line">  let cloneObj = Object.create(Object.getPrototypeOf(obj), allDesc);</span><br><span class="line"></span><br><span class="line">  //继承原型链</span><br><span class="line"></span><br><span class="line">  hash.set(obj, cloneObj);</span><br><span class="line"></span><br><span class="line">  for (let key of Reflect.ownKeys(obj)) &#123;</span><br><span class="line">    cloneObj[key] =</span><br><span class="line">      isComplexDataType(obj[key]) &amp;&amp; typeof obj[key] !== &quot;function&quot;</span><br><span class="line">        ? deepClone(obj[key], hash)</span><br><span class="line">        : obj[key];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return cloneObj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">8.字符串模板</span><br><span class="line"></span><br><span class="line">function render(template, data) &#123;</span><br><span class="line">  const reg = /\&#123;\&#123;(\w+)\&#125;\&#125;/; // 模板字符串正则</span><br><span class="line">  if (reg.test(template)) &#123; // 判断模板里是否有模板字符串</span><br><span class="line">      const name = reg.exec(template)[1]; // 查找当前模板里第一个模板字符串的字段</span><br><span class="line">      template = template.replace(reg, data[name]); // 将第一个模板字符串渲染</span><br><span class="line">      return render(template, data); // 递归的渲染并返回渲染后的结构</span><br><span class="line">  &#125;</span><br><span class="line">  return template; // 如果模板没有模板字符串直接返回</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">9.防抖/节流</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//节流</span><br><span class="line">//leading 是否第一次执行</span><br><span class="line">//trailing 是否最后一次执行</span><br><span class="line">function throttle(fn, wait, options) &#123;</span><br><span class="line">  var timeout, result;</span><br><span class="line">  var previous = 0;</span><br><span class="line">  if (!options) options = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  var later = function () &#123;</span><br><span class="line">    previous = options.leading === false ? 0 : Date.now();</span><br><span class="line">    timeout = null;</span><br><span class="line">    result = fn.apply(null);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  var throttled = function () &#123;</span><br><span class="line">    var now = Date.now();</span><br><span class="line"></span><br><span class="line">    if (!previous &amp;&amp; options.leading === false) previous = now;</span><br><span class="line"></span><br><span class="line">    //计算剩余时间</span><br><span class="line">    var remaining = wait - (now - previous);</span><br><span class="line">    //立即执行</span><br><span class="line">    if (remaining &lt;= 0 || remaining &gt; wait) &#123;</span><br><span class="line">      //设置options中leading为false时 remaining=wait  不执行函数</span><br><span class="line">      if (timeout) &#123;</span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        timeout = null;</span><br><span class="line">      &#125;</span><br><span class="line">      previous = now;</span><br><span class="line">      result = fn.apply(null);</span><br><span class="line">    &#125;</span><br><span class="line">    //延迟执行</span><br><span class="line">    else if (!timeout &amp;&amp; options.trailing !== false) &#123;</span><br><span class="line">      timeout = setTimeout(later, remaining);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;;</span><br><span class="line">  return throttled;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//防抖</span><br><span class="line"></span><br><span class="line">function debounce(func, wait, immediate) &#123;</span><br><span class="line">  var timeout, result;</span><br><span class="line"></span><br><span class="line">  var later = function () &#123;</span><br><span class="line">    timeout = null;</span><br><span class="line">    result = func.apply(null);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  var debounced = function () &#123;</span><br><span class="line">    if (timeout) clearTimeout(timeout);</span><br><span class="line">    //立即执行</span><br><span class="line">    if (immediate) &#123;</span><br><span class="line">      //存在定时器时无法立即执行（通俗讲就是wait秒内该事件又触发了，需要再等wait秒才能触发）</span><br><span class="line">      var callNow = !timeout;</span><br><span class="line">      timeout = setTimeout(later, wait);</span><br><span class="line">      //不存在定时器，立即执行该事件</span><br><span class="line">      if (callNow) result = func.apply(null);</span><br><span class="line">    &#125;</span><br><span class="line">    //指定时间后执行</span><br><span class="line">    else &#123;</span><br><span class="line">      timeout = setTimeout(later, wait);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return debounced;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">10.柯里化</span><br><span class="line">//什么叫函数柯里化？其实就是将使用多个参数的函数转换成一系列使用一个参数的函数的技术。</span><br><span class="line">function curry(fn) &#123;</span><br><span class="line">  let func;</span><br><span class="line"></span><br><span class="line">  func = (...args) =&gt; &#123;</span><br><span class="line">    if (args.length === fn.length) return fn(...args);</span><br><span class="line">    else return (...arg) =&gt; func(...arg, ...args);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return func;</span><br><span class="line">&#125;</span><br><span class="line">11.偏函数</span><br><span class="line">//什么是偏函数？偏函数就是将一个 n 参的函数转换成固定 x 参的函数，剩余参数（n - x）将在下次调用全部传入。</span><br><span class="line"> function partial(fn, ...args) &#123;</span><br><span class="line">  return (...arg) =&gt; &#123;</span><br><span class="line">      return fn(...args, ...arg)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">12.instance</span><br><span class="line"></span><br><span class="line">function instanceOf(left, right) &#123;</span><br><span class="line">  let proto = left.__proto__;</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    if (proto === null) return false;</span><br><span class="line">    if (proto === right.prototype) &#123;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">    proto = proto.__proto__;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">13.sleep</span><br><span class="line">function sleep(time) &#123;</span><br><span class="line">  return new Promise((resolve) =&gt; setTimeout(resolve, time));</span><br><span class="line">&#125;</span><br><span class="line">async function testSleep() &#123;</span><br><span class="line">  console.log(1);</span><br><span class="line">  await sleep(2000);</span><br><span class="line">  console.log(2);</span><br><span class="line">&#125;</span><br><span class="line">testSleep();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">14.Object.create</span><br><span class="line">Object.create2 = function (proto, propertyObject = undefined) &#123;</span><br><span class="line">  if (typeof proto !== &quot;object&quot; &amp;&amp; typeof proto !== &quot;function&quot;) &#123;</span><br><span class="line">    throw new TypeError(&quot;Object prototype may only be an Object or null.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  if (propertyObject == null) &#123;</span><br><span class="line">    new TypeError(&quot;Cannot convert undefined or null to object&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  function F() &#123;&#125;</span><br><span class="line">  F.prototype = proto;</span><br><span class="line">  const obj = new F();</span><br><span class="line">  if (propertyObject != undefined) &#123;</span><br><span class="line">    Object.defineProperties(obj, propertyObject);</span><br><span class="line">  &#125;</span><br><span class="line">  if (proto === null) &#123;</span><br><span class="line">    // 创建一个没有原型对象的对象，Object.create(null)</span><br><span class="line">    obj.__proto__ = null;</span><br><span class="line">  &#125;</span><br><span class="line">  return obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2021/09/01/interview/">起个名字真难</a></p>
        <p><span>文章作者:</span><a href="/" title="访问 DiamondsZz 的个人博客">DiamondsZz</a></p>
        <p><span>发布时间:</span>2021年09月01日</p>
        <p><span>最后更新:</span>2022年10月09日 - 22时36分</p>    
    </div>



<nav id="article-nav">
  
    <a href="/2022/01/01/vue3/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          玩转vue3全家桶
        
      </div>
    </a>
  
  
    <a href="/2021/08/01/optimize/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">前端性能优化</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>


  
</article>

    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前端基础"><span class="toc-number">1.</span> <span class="toc-text">前端基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#http-https"><span class="toc-number">1.1.</span> <span class="toc-text">http/https</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#从输入URL到页面展示，这中间发生了什么？"><span class="toc-number">1.2.</span> <span class="toc-text">从输入URL到页面展示，这中间发生了什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事件循环"><span class="toc-number">1.3.</span> <span class="toc-text">事件循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#垃圾回收"><span class="toc-number">1.4.</span> <span class="toc-text">垃圾回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#前端异常"><span class="toc-number">1.5.</span> <span class="toc-text">前端异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#js编译执行"><span class="toc-number">1.6.</span> <span class="toc-text">js编译执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#渲染相关"><span class="toc-number">1.7.</span> <span class="toc-text">渲染相关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DOM-树如何生成"><span class="toc-number">1.7.1.</span> <span class="toc-text">DOM 树如何生成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JavaScript-是如何影响-DOM-生成的"><span class="toc-number">1.7.2.</span> <span class="toc-text">JavaScript 是如何影响 DOM 生成的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSS-如何影响首次加载时的白屏时间"><span class="toc-number">1.7.3.</span> <span class="toc-text">CSS 如何影响首次加载时的白屏时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#影响页面展示的因素以及优化策略"><span class="toc-number">1.7.4.</span> <span class="toc-text">影响页面展示的因素以及优化策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么-CSS-动画比-JavaScript-高效？"><span class="toc-number">1.7.5.</span> <span class="toc-text">为什么 CSS 动画比 JavaScript 高效？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何利用分层技术优化代码"><span class="toc-number">1.7.6.</span> <span class="toc-text">如何利用分层技术优化代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何系统地优化页面？"><span class="toc-number">1.7.7.</span> <span class="toc-text">如何系统地优化页面？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#浏览器缓存"><span class="toc-number">1.8.</span> <span class="toc-text">浏览器缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#强制缓存"><span class="toc-number">1.8.1.</span> <span class="toc-text">强制缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#协商缓存"><span class="toc-number">1.8.2.</span> <span class="toc-text">协商缓存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据类型"><span class="toc-number">1.9.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#数据类型检测"><span class="toc-number">1.9.1.</span> <span class="toc-text">数据类型检测</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#typeof"><span class="toc-number">1.9.1.1.</span> <span class="toc-text">typeof</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#instanceof"><span class="toc-number">1.9.1.2.</span> <span class="toc-text">instanceof</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Object-prototype-toString"><span class="toc-number">1.9.1.3.</span> <span class="toc-text">Object.prototype.toString</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数据类型转换"><span class="toc-number">1.9.2.</span> <span class="toc-text">数据类型转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其它"><span class="toc-number">1.10.</span> <span class="toc-text">其它</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#http-proxy-middleware"><span class="toc-number">1.10.1.</span> <span class="toc-text">http-proxy-middleware</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#typescript"><span class="toc-number">1.11.</span> <span class="toc-text">typescript</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Thunk-函数的含义和用法"><span class="toc-number">1.12.</span> <span class="toc-text">Thunk 函数的含义和用法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Thunk-函数的自动流程管理"><span class="toc-number">1.12.1.</span> <span class="toc-text">Thunk 函数的自动流程管理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#co-函数库的含义和用法"><span class="toc-number">1.13.</span> <span class="toc-text">co 函数库的含义和用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#async-函数的含义和用法"><span class="toc-number">1.14.</span> <span class="toc-text">async 函数的含义和用法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#前端安全"><span class="toc-number">2.</span> <span class="toc-text">前端安全</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#前端工程化"><span class="toc-number">3.</span> <span class="toc-text">前端工程化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#webpack"><span class="toc-number">3.1.</span> <span class="toc-text">webpack</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue"><span class="toc-number">4.</span> <span class="toc-text">vue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vue初始化"><span class="toc-number">4.1.</span> <span class="toc-text">vue初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#响应式原理"><span class="toc-number">4.2.</span> <span class="toc-text">响应式原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#虚拟Dom"><span class="toc-number">4.3.</span> <span class="toc-text">虚拟Dom</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#指令"><span class="toc-number">4.4.</span> <span class="toc-text">指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#自定义指令"><span class="toc-number">4.4.1.</span> <span class="toc-text">自定义指令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Setup"><span class="toc-number">4.5.</span> <span class="toc-text">Setup</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue3"><span class="toc-number">4.6.</span> <span class="toc-text">vue3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其它-1"><span class="toc-number">4.7.</span> <span class="toc-text">其它</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#react"><span class="toc-number">5.</span> <span class="toc-text">react</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#diff"><span class="toc-number">5.1.</span> <span class="toc-text">diff</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fiber"><span class="toc-number">5.2.</span> <span class="toc-text">fiber</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其它-2"><span class="toc-number">5.3.</span> <span class="toc-text">其它</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#node"><span class="toc-number">6.</span> <span class="toc-text">node</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#各种手写"><span class="toc-number">7.</span> <span class="toc-text">各种手写</span></a></li></ol>
</div>
<style>
    .left-col .switch-btn {
        display: none;
    }
    .left-col .switch-area {
        display: none;
    }
</style>
<input type="button" id="tocButton" value="隐藏目录" title="点击按钮隐藏或者显示文章目录">

<script src="https://www.unpkg.com/jquery@3.6.0/dist/jquery.js"></script>

<script>
    var valueHide = "隐藏目录";
    var valueShow = "显示目录";
    if ($(".left-col").is(":hidden")) {
        $("#tocButton").attr("value", valueShow);
    }
    $("#tocButton").click(function() {
        if ($("#toc").is(":hidden")) {
            $("#tocButton").attr("value", valueHide);
            $("#toc").slideDown(320);
            $(".switch-btn, .switch-area").fadeOut(300);
        }
        else {
            $("#tocButton").attr("value", valueShow);
            $("#toc").slideUp(350);
            $(".switch-btn, .switch-area").fadeIn(500);
        }
    })
    if ($(".toc").length < 1) {
        $("#toc, #tocButton").hide();
        $(".switch-btn, .switch-area").show();
    }
</script>






    



    <div class="scroll" id="post-nav-button">
        
            <a href="/2022/01/01/vue3/" title="上一篇: 玩转vue3全家桶">
                <i class="fa fa-angle-left"></i>
            </a>
        
        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>
        
            <a href="/2021/08/01/optimize/" title="下一篇: 前端性能优化">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>
    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2022/11/26/graph/">可视化</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/08/28/react+/">深入浅出react</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/01/vue3/">玩转vue3全家桶</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/09/01/interview/">起个名字真难</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/08/01/optimize/">前端性能优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/08/01/test/">前端测试</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/07/18/node/">node学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/01/performance/">performance</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/25/http/">http协议</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/25/vue/">vue进阶</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/25/react/">react进阶</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/25/core/">核心进阶</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/25/browser/">浏览器工作原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/08/module_webpack/">模块化/webpack</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/08/yeoman/">脚手架/yeoman/gulp</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/16/question/">知识点</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/02/life/">记录生活</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/03/wfe/">前端笔记（旧）</a></li></ul>
    
<script src="https://www.unpkg.com/jquery@3.6.0/dist/jquery.js"></script>

    <script>
        $(".post-list").addClass("toc-article");
        // $(".post-list-item a").attr("target","_blank");
        $("#post-nav-button > a:nth-child(2)").click(function() {
            $(".fa-bars, .fa-times").toggle();
            $(".post-list").toggle(300);
            if ($(".toc").length > 0) {
                $("#toc, #tocButton").toggle(200, function() {
                    if ($(".switch-area").is(":visible")) {
                        $("#toc, .switch-btn, .switch-area").toggle();
                        $("#tocButton").attr("value", valueHide);
                        }
                    })
            }
            else {
                $(".switch-btn, .switch-area").fadeToggle(300);
            }
        })
    </script>




    <script>
        
    </script>

</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2022 DiamondsZz
            </div>        
        </div>
    </div>
</footer>

    </div>
    
<script src="https://www.unpkg.com/jquery@3.6.0/dist/jquery.js"></script>

<script src="/js/main.js"></script>

    <script>
        $(document).ready(function() {
            var backgroundnum = 1;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>






<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" "="">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(
            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


  </div>
</body>
</html>