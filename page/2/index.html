<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  <meta name="baidu-site-verification" content="L6Lm9d5Crl">
  
  
  
  
  <title>DiamondsZz</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="来自一只野生程序猿...">
<meta property="og:type" content="website">
<meta property="og:title" content="DiamondsZz">
<meta property="og:url" content="https://DiamondsZz.github.io/page/2/index.html">
<meta property="og:site_name" content="DiamondsZz">
<meta property="og:description" content="来自一只野生程序猿...">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="DiamondsZz">
<meta name="twitter:description" content="来自一只野生程序猿...">
  
    <link rel="alternative" href="/atom.xml" title="DiamondsZz" type="application/atom+xml">
  
  
  
  <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
    
    
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet">
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: true,
          isPost: false,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        
<script src="https://www.unpkg.com/jquery@3.6.0/dist/jquery.js"></script>

        <a href="/" class="profilepic">
            
            <img lazy-src="/img/iu.jpeg" class="js-avatar">
            
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">DiamondsZz</a></h1>
        </hgroup>
        
        <p class="header-subtitle">DiamondsZz</p>
        
        
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        
        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                        </ul>
                    </nav>
                </section>
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/css/" style="font-size: 13.33px;">css</a> <a href="/tags/js/" style="font-size: 16.67px;">js</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/学习/" style="font-size: 20px;">学习</a> <a href="/tags/生活，心情/" style="font-size: 10px;">生活，心情</a> <a href="/tags/网站/" style="font-size: 20px;">网站</a> <a href="/tags/资源/" style="font-size: 20px;">资源</a>
                    </div>
                </section>
                
                
                
                
                <section class="switch-part switch-part3">
                
                    <div id="js-aboutme">矮穷矬!</div>
                </section>
                
            </div>
        </div>
    </header>
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">DiamondsZz</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/img/iu.jpeg" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">DiamondsZz</a></h1>
            </hgroup>
            
            <p class="header-subtitle">DiamondsZz</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                </div>
            </nav>
        </header>
    </div>
</nav>
      <div class="body-wrap">
  
    <article id="post-browser" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2021/03/25/browser/" class="article-date">
      <time datetime="2021-03-24T16:00:00.000Z" itemprop="datePublished">2021-03-25</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/25/browser/">浏览器工作原理</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="Chrome架构：仅仅打开了1个页面，为什么有4个进程？"><a href="#Chrome架构：仅仅打开了1个页面，为什么有4个进程？" class="headerlink" title="Chrome架构：仅仅打开了1个页面，为什么有4个进程？"></a>Chrome架构：仅仅打开了1个页面，为什么有4个进程？</h2><h3 id="什么是并行处理？"><a href="#什么是并行处理？" class="headerlink" title="什么是并行处理？"></a>什么是并行处理？</h3><ul>
<li>计算机中的并行处理就是同一时刻处理多个任务，比如我们要计算下面这三个表达式的值，并显示出结果。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">A = 1+2</span><br><span class="line">B = 20/5</span><br><span class="line">C = 7*8</span><br><span class="line"></span><br><span class="line">在编写代码的时候，我们可以把这个过程拆分为四个任务：</span><br><span class="line">任务 1 是计算 A=1+2；</span><br><span class="line">任务 2 是计算 B=20/5；</span><br><span class="line">任务 3 是计算 C=7*8；</span><br><span class="line">任务 4 是显示最后计算的结果。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">正常情况下程序可以使用单线程来处理，也就是分四步按照顺序分别执行这四个任务。</span><br><span class="line">如果采用多线程，会怎么样呢？我们只需分“两步走”：第一步，使用三个线程同时执行前三个任务；第二步，再执行第四个显示任务。</span><br><span class="line"></span><br><span class="line">通过对比分析，你会发现用单线程执行需要四步，而使用多线程只需要两步。因此，使用并行处理能大大提升性能。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="线程-VS-进程"><a href="#线程-VS-进程" class="headerlink" title="线程 VS 进程"></a>线程 VS 进程</h3><ul>
<li>多线程可以并行处理任务，但是线程是不能单独存在的，它是由进程来启动和管理的</li>
<li>一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。</li>
<li>线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率。</li>
<li>进程中的任意一线程执行出错，都会导致整个进程的崩溃。</li>
<li>线程之间共享进程中的数据。</li>
<li>当一个进程关闭之后，操作系统会回收进程所占用的内存。</li>
</ul>
<ol>
<li>当一个进程退出时，操作系统会回收该进程所申请的所有资源；即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。</li>
<li>比如之前的 IE 浏览器，支持很多插件，而这些插件很容易导致内存泄漏，这意味着只要浏览器开着，内存占用就有可能会越来越多，但是当关闭浏览器进程时，这些内存就都会被系统回收掉。</li>
</ol>
<ul>
<li>进程之间的内容相互隔离。</li>
</ul>
<ol>
<li>进程隔离是为保护操作系统中进程互不干扰的技术，每一个进程只能访问自己占有的数据，也就避免出现进程 A 写入数据到进程 B 的情况。</li>
<li>正是因为进程之间的数据是严格隔离的，所以一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。</li>
<li>如果进程之间需要进行数据的通信，这时候，就需要使用用于进程间通信（IPC）的机制了。<h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h3></li>
</ol>
<ul>
<li>采用多进程架构的额外好处是可以使用安全沙箱，你可以把沙箱看成是操作系统给进程上了一把锁，沙箱里面的程序可以运行，但是不能在你的硬盘上写入任何数据，也不能在敏感位置读取任何数据，例如你的文档和桌面。Chrome 把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。</li>
<li>最新的 Chrome 浏览器包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。</li>
</ul>
<ol>
<li>浏览器进程。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。</li>
<li>渲染进程。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</li>
<li>GPU 进程。其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。</li>
<li>网络进程。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。</li>
<li>插件进程。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。</li>
</ol>
<ul>
<li>因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源。<h2 id="TCP协议：如何保证页面文件能被完整送达浏览器？"><a href="#TCP协议：如何保证页面文件能被完整送达浏览器？" class="headerlink" title="TCP协议：如何保证页面文件能被完整送达浏览器？"></a>TCP协议：如何保证页面文件能被完整送达浏览器？</h2></li>
<li>在使用 UDP 发送数据时，有各种因素会导致数据包出错，虽然 UDP 可以校验数据是否正确，但是对于错误的数据包，UDP 并不提供重发机制，只是丢弃当前的包，而且 UDP 在发送之后也无法知道是否能达到目的地。</li>
<li>虽说 UDP 不能保证数据可靠性，但是传输速度却非常快，所以 UDP 会应用在一些关注速度、但不那么严格要求数据完整性的领域，如在线视频、互动游戏等。</li>
<li>如果使用 UDP 来传输会存在两个问题：</li>
</ul>
<ol>
<li>数据包在传输过程中容易丢失；</li>
<li>大文件会被拆分成很多小的数据包来传输，这些小的数据包会经过不同的路由，并在不同的时间到达接收端，而 UDP 协议并不知道如何组装这些数据包，从而把这些数据包还原成完整的文件。</li>
</ol>
<ul>
<li>TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。相对于 UDP，TCP 有下面两个特点:</li>
</ul>
<ol>
<li>对于数据包丢失的情况，TCP 提供重传机制；</li>
<li>TCP 引入了数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件。</li>
</ol>
<ul>
<li>和 UDP 头一样，TCP 头除了包含了目标端口和本机端口号外，还提供了用于排序的序列号，以便接收端通过序号来重排数据包。</li>
</ul>
<h2 id="HTTP请求流程：为什么很多站点第二次打开速度会很快？"><a href="#HTTP请求流程：为什么很多站点第二次打开速度会很快？" class="headerlink" title="HTTP请求流程：为什么很多站点第二次打开速度会很快？"></a>HTTP请求流程：为什么很多站点第二次打开速度会很快？</h2><ul>
<li>HTTP 协议，正是建立在 TCP 连接基础之上的。HTTP 是一种允许浏览器向服务器获取资源的协议，是 Web 的基础</li>
</ul>
<h3 id="浏览器端发起-HTTP-请求流程"><a href="#浏览器端发起-HTTP-请求流程" class="headerlink" title="浏览器端发起 HTTP 请求流程"></a>浏览器端发起 HTTP 请求流程</h3><ul>
<li><p>构建请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">首先，浏览器构建请求行信息（如下所示），构建好后，浏览器准备发起网络请求。</span><br><span class="line"></span><br><span class="line">GET /index.html HTTP1.1</span><br></pre></td></tr></table></figure>
</li>
<li><p>查找缓存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件。</span><br><span class="line">其中，浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术。</span><br></pre></td></tr></table></figure>
</li>
<li><p>准备 IP 地址和端口</p>
</li>
</ul>
<ol>
<li>浏览器会请求 DNS 返回域名对应的 IP。</li>
<li>当然浏览器还提供了 DNS 数据缓存服务，如果某个域名已经解析过了，那么浏览器会缓存解析的结果，以供下次查询时直接使用，这样也会减少一次网络请求。</li>
</ol>
<ul>
<li>等待 TCP 队列</li>
</ul>
<ol>
<li>Chrome 有个机制，同一个域名同时最多只能建立 6 个 TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。</li>
<li>当然，如果当前请求数量少于 6，会直接进入下一步，建立 TCP 连接。</li>
</ol>
<ul>
<li>建立 TCP 连接</li>
<li>发送 HTTP 请求</li>
</ul>
<ol>
<li>首先浏览器会向服务器发送请求行，它包括了请求方法、请求 URI（Uniform Resource Identifier）和 HTTP 版本协议。</li>
<li>请求头把浏览器的一些基础信息告诉服务器。比如包含了浏览器所使用的操作系统、浏览器内核等信息，以及当前请求的域名信息、浏览器端的 Cookie 信息，等等。</li>
<li>如果使用 POST 方法，那么浏览器还要准备数据给服务器，这里准备的数据是通过请求体来发送。<h3 id="服务器端处理-HTTP-请求流程"><a href="#服务器端处理-HTTP-请求流程" class="headerlink" title="服务器端处理 HTTP 请求流程"></a>服务器端处理 HTTP 请求流程</h3></li>
</ol>
<ul>
<li>返回请求</li>
</ul>
<ol>
<li>首先服务器会返回响应行，包括协议版本和状态码</li>
<li>服务器也会随同响应向浏览器发送响应头。响应头包含了服务器自身的一些信息，比如服务器生成返回数据的时间、返回的数据类型（JSON、HTML、流媒体等类型），以及服务器要在客户端保存的 Cookie 等信息。</li>
<li>发送完响应头后，服务器就可以继续发送响应体的数据，通常，响应体就包含了 HTML 的实际内容。</li>
</ol>
<ul>
<li>断开连接</li>
</ul>
<ol>
<li>通常情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接。不过如果浏览器或者服务器在其头信息中加入了：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Connection:Keep-Alive </span><br><span class="line">那么 TCP 连接在发送后将仍然保持打开状态，这样浏览器就可以继续通过同一个 TCP 连接发送请求。</span><br><span class="line">保持 TCP 连接可以省去下次请求时需要建立连接的时间，提升资源加载速度。</span><br><span class="line">比如，一个 Web 页面中内嵌的图片就都来自同一个 Web 站点，如果初始化了一个持久连接，你就可以复用该连接，以请求其他资源，而不需要重新再建立新的 TCP 连接。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>重定向</li>
</ul>
<ol>
<li>状态 301 就是告诉浏览器，我需要重定向到另外一个网址，而需要重定向的网址正是包含在响应头的 Location 字段中，接下来，浏览器获取 Location 字段中的地址，并使用该地址重新导航，这就是一个完整重定向的执行流程。</li>
</ol>
<h3 id="为什么很多站点第二次打开速度会很快？"><a href="#为什么很多站点第二次打开速度会很快？" class="headerlink" title="为什么很多站点第二次打开速度会很快？"></a>为什么很多站点第二次打开速度会很快？</h3><ul>
<li>如果第二次页面打开很快，主要原因是第一次加载页面过程中，缓存了一些耗时的数据。</li>
<li>DNS 缓存和页面资源缓存这两块数据是会被浏览器缓存的。DNS 缓存比较简单，它主要就是在浏览器本地把对应的 IP 和域名关联起来</li>
<li>当服务器返回 HTTP 响应头给浏览器时，浏览器是通过响应头中的 Cache-Control 字段来设置是否缓存该资源。</li>
<li><p>通常，我们还需要为这个资源设置一个缓存过期时长，而这个时长是通过 Cache-Control 中的 Max-age 参数来设置的，比如上图设置的缓存过期时间是 2000 秒。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Cache-Control:Max-age=2000</span><br><span class="line">这也就意味着，在该缓存资源还未过期的情况下, 如果再次请求该资源，会直接返回缓存中的资源给浏览器。</span><br></pre></td></tr></table></figure>
</li>
<li><p>但如果缓存过期了，浏览器则会继续发起网络请求，并且在 HTTP 请求头中带上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-None-Match:&quot;4f80f-13c-3a1xb12a&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>服务器收到请求头后，会根据 If-None-Match 的值来判断请求的资源是否有更新。</p>
</li>
</ul>
<ol>
<li>如果没有更新，就返回 304 状态码，相当于服务器告诉浏览器：“这个缓存可以继续使用，这次就不重复发送数据给你了。“</li>
<li>如果资源有更新，服务器就直接返回最新资源给浏览器。</li>
</ol>
<h3 id="登录状态是如何保持的？"><a href="#登录状态是如何保持的？" class="headerlink" title="登录状态是如何保持的？"></a>登录状态是如何保持的？</h3><ul>
<li><p>服务器接收到浏览器提交的信息之后，查询后台，验证用户登录信息是否正确，如果正确的话，会生成一段表示用户身份的字符串，并把该字符串写到响应头的 Set-Cookie 字段里，如下所示，然后把响应头发送给浏览器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Set-Cookie: UID=3431uad;</span><br></pre></td></tr></table></figure>
</li>
<li><p>浏览器在接收到服务器的响应头后，开始解析响应头，如果遇到响应头里含有 Set-Cookie 字段的情况，浏览器就会把这个字段信息保存到本地。比如把UID=3431uad保持到本地。</p>
</li>
<li><p>当用户再次访问时，浏览器会发起 HTTP 请求，但在发起请求之前，浏览器会读取之前保存的 Cookie 数据，并把数据写进请求头里的 Cookie 字段里（如下所示），然后浏览器再将请求头发送给服务器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Cookie: UID=3431uad;</span><br></pre></td></tr></table></figure>
</li>
<li><p>服务器在收到 HTTP 请求头数据之后，就会查找请求头里面的“Cookie”字段信息，当查找到包含UID=3431uad的信息时，服务器查询后台，并判断该用户是已登录状态，然后生成含有该用户信息的页面数据，并把生成的数据发送给浏览器。</p>
</li>
<li>简单地说，如果服务器端发送的响应头内有 Set-Cookie 的字段，那么浏览器就会将该字段的内容保持到本地。当下次客户端再往该服务器发送请求时，客户端会自动在请求头中加入 Cookie 值后再发送出去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到该用户的状态信息。</li>
<li>浏览器中的 HTTP 请求从发起到结束一共经历了如下八个阶段：构建请求、查找缓存、准备 IP 和端口、等待 TCP 队列、建立 TCP 连接、发起 HTTP 请求、服务器处理请求、服务器返回请求和断开连接。</li>
</ul>
<h2 id="导航流程：从输入URL到页面展示，这中间发生了什么？"><a href="#导航流程：从输入URL到页面展示，这中间发生了什么？" class="headerlink" title="导航流程：从输入URL到页面展示，这中间发生了什么？"></a>导航流程：从输入URL到页面展示，这中间发生了什么？</h2><ul>
<li>整个过程需要各个进程之间的配合，所以在开始正式流程之前，我们还是先来快速回顾下浏览器进程、渲染进程和网络进程的主要职责。</li>
</ul>
<ol>
<li>浏览器进程主要负责用户交互、子进程管理和文件储存等功能。</li>
<li>网络进程是面向渲染进程和浏览器进程等提供网络下载功能。</li>
<li>渲染进程的主要职责是把从网络下载的 HTML、JavaScript、CSS、图片等资源解析为可以显示和交互的页面。因为渲染进程所有的内容都是通过网络获取的，会存在一些恶意代码利用浏览器漏洞对系统进行攻击，所以运行在渲染进程里面的代码是不被信任的。这也是为什么 Chrome 会让渲染进程运行在安全沙箱里，就是为了保证系统的安全。</li>
</ol>
<ul>
<li>大致描述为如下。</li>
</ul>
<ol>
<li>首先，浏览器进程接收到用户输入的 URL 请求，浏览器进程便将该 URL 转发给网络进程。</li>
<li>然后，在网络进程中发起真正的 URL 请求。</li>
<li>接着网络进程接收到了响应头数据，便解析响应头数据，并将数据转发给浏览器进程。</li>
<li>浏览器进程接收到网络进程的响应头数据之后，发送“提交导航 (CommitNavigation)”消息到渲染进程；</li>
<li>渲染进程接收到“提交导航”的消息之后，便开始准备接收 HTML 数据，接收数据的方式是直接和网络进程建立数据管道；</li>
<li>最后渲染进程会向浏览器进程“确认提交”，这是告诉浏览器进程：“已经准备好接受和解析页面数据了”。</li>
<li>浏览器进程接收到渲染进程“提交文档”的消息之后，便开始移除之前旧的文档，然后更新浏览器进程中的页面状态。<h3 id="用户输入"><a href="#用户输入" class="headerlink" title="用户输入"></a>用户输入</h3></li>
</ol>
<ul>
<li>当用户在地址栏中输入一个查询关键字时，地址栏会判断输入的关键字是搜索内容，还是请求的 URL。</li>
<li>当用户输入关键字并键入回车之后，这意味着当前页面即将要被替换成新的页面，不过在这个流程继续之前，浏览器还给了当前页面一次执行 beforeunload 事件的机会，beforeunload 事件允许页面在退出之前执行一些数据清理操作，还可以询问用户是否要离开当前页面，比如当前页面可能有未提交完成的表单等情况，因此用户可以通过 beforeunload 事件来取消导航，让浏览器不再执行任何后续工作。<h3 id="URL-请求过程"><a href="#URL-请求过程" class="headerlink" title="URL 请求过程"></a>URL 请求过程</h3></li>
<li>浏览器进程会通过进程间通信（IPC）把 URL 请求发送至网络进程，网络进程接收到 URL 请求后，会在这里发起真正的 URL 请求流程。</li>
<li>网络进程会查找本地缓存是否缓存了该资源。如果有缓存资源，那么直接返回资源给浏览器进程；如果在缓存中没有查找到资源，那么直接进入网络请求流程。</li>
<li>请求前的第一步是要进行 DNS 解析，以获取请求域名的服务器 IP 地址。如果请求协议是 HTTPS，那么还需要建立 TLS 连接。</li>
<li>接下来就是利用 IP 地址和服务器建立 TCP 连接。连接建立之后，浏览器端会构建请求行、请求头等信息，并把和该域名相关的 Cookie 等数据附加到请求头中，然后向服务器发送构建的请求信息。</li>
<li>服务器接收到请求信息后，会根据请求信息生成响应数据（包括响应行、响应头和响应体等信息），并发给网络进程。等网络进程接收了响应行和响应头之后，就开始解析响应头的内容了。</li>
<li>在接收到服务器返回的响应头后，网络进程开始解析响应头，如果发现返回的状态码是 301 或者 302，那么说明服务器需要浏览器重定向到其他 URL。这时网络进程会从响应头的 Location 字段里面读取重定向的地址，然后再发起新的 HTTP 或者 HTTPS 请求，一切又重头开始了。</li>
<li>在导航过程中，如果服务器响应行的状态码包含了 301、302 一类的跳转信息，浏览器会跳转到新的地址继续导航；如果响应行是 200，那么表示浏览器可以继续处理该请求。</li>
<li>Content-Type 是 HTTP 头中一个非常重要的字段， 它告诉浏览器服务器返回的响应体数据是什么类型，然后浏览器会根据 Content-Type 的值来决定如何显示响应体的内容。</li>
<li>Content-Type 的值是 application/octet-stream，显示数据是字节流类型的，通常情况下，浏览器会按照下载类型来处理该请求。</li>
<li>如果 Content-Type 字段的值被浏览器判断为下载类型，那么该请求会被提交给浏览器的下载管理器，同时该 URL 请求的导航流程就此结束。但如果是 HTML，那么浏览器则会继续进行导航流程。由于 Chrome 的页面渲染是运行在渲染进程中的，所以接下来就需要准备渲染进程了。<h3 id="渲染进程"><a href="#渲染进程" class="headerlink" title="渲染进程"></a>渲染进程</h3></li>
<li>默认情况下，Chrome 会为每个页面分配一个渲染进程，也就是说，每打开一个新页面就会配套创建一个新的渲染进程。但是，也有一些例外，在某些情况下，浏览器会让多个页面直接运行在同一个渲染进程中。</li>
<li>那什么情况下多个页面会同时运行在一个渲染进程中呢？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https://time.diamonds.org</span><br><span class="line">https://www.diamonds.org</span><br><span class="line">https://www.diamonds.org:8080</span><br><span class="line"></span><br><span class="line">它们都是属于同一站点，因为它们的协议都是 HTTPS，而且根域名也都是 diamonds.org。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li>Chrome 的默认策略是，每个标签对应一个渲染进程。但如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程。官方把这个默认策略叫 process-per-site-instance。</li>
</ol>
<ul>
<li>总结来说，打开一个新页面采用的渲染进程策略就是：</li>
</ul>
<ol>
<li>通常情况下，打开新的页面都会使用单独的渲染进程；如果从 A 页面打开 B 页面，且 A 和 B 都属于同一站点的话，那么 B 页面复用 A 页面的渲染进程；</li>
<li>如果是其他情况，浏览器进程则会为 B 创建一个新的渲染进程。</li>
</ol>
<ul>
<li>渲染进程准备好之后，还不能立即进入文档解析状态，因为此时的文档数据还在网络进程中，并没有提交给渲染进程，所以下一步就进入了提交文档阶段。<h3 id="提交文档"><a href="#提交文档" class="headerlink" title="提交文档"></a>提交文档</h3></li>
<li>所谓提交文档，就是指浏览器进程将网络进程接收到的 HTML 数据提交给渲染进程，具体流程是这样的：</li>
</ul>
<ol>
<li>首先当浏览器进程接收到网络进程的响应头数据之后，便向渲染进程发起“提交文档”的消息；</li>
<li>渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”；</li>
<li>等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程；</li>
<li>浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。</li>
</ol>
<ul>
<li>这也就解释了为什么在浏览器的地址栏里面输入了一个地址后，之前的页面没有立马消失，而是要加载一会儿才会更新页面。<h3 id="渲染阶段"><a href="#渲染阶段" class="headerlink" title="渲染阶段"></a>渲染阶段</h3></li>
<li>一旦文档被提交，渲染进程便开始页面解析和子资源加载了</li>
</ul>
<h2 id="渲染流程（上）：HTML、CSS和JavaScript，是如何变成页面的？"><a href="#渲染流程（上）：HTML、CSS和JavaScript，是如何变成页面的？" class="headerlink" title="渲染流程（上）：HTML、CSS和JavaScript，是如何变成页面的？"></a>渲染流程（上）：HTML、CSS和JavaScript，是如何变成页面的？</h2><ul>
<li>HTML 的内容是由标记和文本组成。标记也称为标签，每个标签都有它自己的语义，浏览器会根据标签的语义来正确展示 HTML 内容。</li>
<li>CSS 又称为层叠样式表，是由选择器和属性组成</li>
<li>至于 JavaScript（简称为 JS），使用它可以使网页的内容“动”起来</li>
<li>由于渲染机制过于复杂，所以渲染模块在执行过程中会被划分为很多子阶段，输入的 HTML 经过这些子阶段，最后输出像素。我们把这样的一个处理流程叫做渲染流水线</li>
<li>按照渲染的时间顺序，流水线可分为如下几个子阶段：构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成。<h3 id="构建-DOM-树"><a href="#构建-DOM-树" class="headerlink" title="构建 DOM 树"></a>构建 DOM 树</h3></li>
<li>为什么要构建 DOM 树呢？这是因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM 树。<h3 id="样式计算（Recalculate-Style）"><a href="#样式计算（Recalculate-Style）" class="headerlink" title="样式计算（Recalculate Style）"></a>样式计算（Recalculate Style）</h3></li>
<li>样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式，这个阶段大体可分为三步来完成。</li>
<li>把 CSS 转换为浏览器能够理解的结构<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CSS 样式来源主要有三种：</span><br><span class="line">通过 link 引用的外部 CSS 文件</span><br><span class="line">&lt;style&gt;标记内的 CSS</span><br><span class="line">元素的 style 属性内嵌的 CSS</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li>和 HTML 文件一样，浏览器也是无法直接理解这些纯文本的 CSS 样式，所以当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets。</li>
</ol>
<ul>
<li><p>转换样式表中的属性值，使其标准化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">现在我们已经把现有的 CSS 文本转化为浏览器可以理解的结构了，那么接下来就要对其进行属性值的标准化操作。</span><br><span class="line">要理解什么是属性值标准化，你可以看下面这样一段 CSS 文本：</span><br><span class="line"></span><br><span class="line">body &#123; font-size: 2em &#125;  =&gt; body &#123; font-size: 32px &#125;</span><br><span class="line">p &#123;color:blue;&#125;  =&gt; p &#123;rgba(0,0,255)&#125;</span><br><span class="line">span  &#123;display: none&#125;</span><br><span class="line">div &#123;font-weight: bold&#125;  =&gt; div &#123;font-weight: 700)&#125;</span><br><span class="line">div  p &#123;color:green;&#125; =&gt; div &#123;rgba(0,128,0)&#125;</span><br><span class="line">div &#123;color:red; &#125;  =&gt; div &#123;rgba(255,0,0)&#125;</span><br><span class="line"></span><br><span class="line">可以看到上面的 CSS 文本中有很多属性值，如 2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算出 DOM 树中每个节点的具体样式</p>
</li>
<li>涉及到 CSS 的继承规则和层叠规则</li>
</ul>
<ol>
<li><p>首先是 CSS 继承。CSS 继承就是每个 DOM 节点都包含有父节点的样式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">body &#123; font-size: 20px &#125;</span><br><span class="line">p &#123;color:blue;&#125;</span><br><span class="line">span  &#123;display: none&#125;</span><br><span class="line">div &#123;font-weight: bold;color:red&#125;</span><br><span class="line">div  p &#123;color:green;&#125;</span><br><span class="line">所有子节点都继承了父节点样式。</span><br><span class="line">比如 body 节点的 font-size 属性是 20，那 body 节点下面的所有节点的 font-size 都等于 20。</span><br></pre></td></tr></table></figure>
</li>
<li><p>样式计算过程中的第二个规则是样式层叠。层叠是 CSS 的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法。它在 CSS 处于核心地位，CSS 的全称“层叠样式表”正是强调了这一点。</p>
</li>
</ol>
<ul>
<li>总之，样式计算阶段的目的是为了计算出 DOM 节点中每个元素的具体样式，在计算过程中需要遵守 CSS 的继承和层叠两个规则。这个阶段最终输出的内容是每个 DOM 节点的样式，并被保存在 ComputedStyle 的结构内。<h3 id="布局阶段"><a href="#布局阶段" class="headerlink" title="布局阶段"></a>布局阶段</h3></li>
<li>有 DOM 树和 DOM 树中元素的样式，但这还不足以显示页面，因为我们还不知道 DOM 元素的几何位置信息。那么接下来就需要计算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做布局。</li>
<li>Chrome 在布局阶段需要完成两个任务：创建布局树和布局计算。</li>
<li>创建布局树</li>
</ul>
<ol>
<li>DOM 树还含有很多不可见的元素，比如 head 标签，还有使用了 display:none 属性的元素。所以在显示之前，我们还要额外地构建一棵只包含可见元素布局树。</li>
<li>DOM 树中所有不可见的节点都没有包含到布局树中。</li>
<li>为了构建布局树，浏览器大体上完成了下面这些工作：<br>遍历 DOM 树中的所有可见节点，并把这些节点加到布局树中；<br>而不可见的节点会被布局树忽略掉，如 head 标签下面的全部内容，再比如 body.p.span 这个元素，因为它的属性包含 dispaly:none，所以这个元素也没有被包进布局树。</li>
</ol>
<ul>
<li>布局计算</li>
</ul>
<ol>
<li>有了一棵完整的布局树。那么接下来，就要计算布局树节点的坐标位置了。</li>
<li>在执行布局操作的时候，会把布局运算的结果重新写回布局树中，所以布局树既是输入内容也是输出内容，这是布局阶段一个不合理的地方，因为在布局阶段并没有清晰地将输入内容和输出内容区分开来。<br>针对这个问题，Chrome 团队正在重构布局代码，下一代布局系统叫 LayoutNG，试图更清晰地分离输入和输出，从而让新设计的布局算法更加简单。<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3></li>
</ol>
<ul>
<li>渲染流程的前三个阶段：DOM 生成、样式计算和布局。要点可大致总结为如下：</li>
</ul>
<ol>
<li>浏览器不能直接理解 HTML 数据，所以第一步需要将其转换为浏览器能够理解的 DOM 树结构；</li>
<li>生成 DOM 树后，还需要根据 CSS 样式表，来计算出 DOM 树所有节点的样式；</li>
<li>最后计算 DOM 元素的布局信息，使其都保存在布局树中。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">当从服务器接收HTML页面的第一批数据时，DOM解析器就开始工作了，在解析过程中，如果遇到了JS脚本，如下所示：</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        极客时间</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">        document.write(&quot;--foo&quot;)</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">那么DOM解析器会先执行JavaScript脚本，执行完成之后，再继续往下解析。</span><br><span class="line"></span><br><span class="line">那么第二种情况复杂点了，我们内联的脚本替换成js外部文件，如下所示：</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        极客时间</span><br><span class="line">        &lt;script type=&quot;text/javascript&quot; src=&quot;foo.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">这种情况下，当解析到JavaScript的时候，会先暂停DOM解析，并下载foo.js文件，下载完成之后执行该段JS文件，然后再继续往下解析DOM。这就是JavaScript文件为什么会阻塞DOM渲染。</span><br><span class="line"></span><br><span class="line">我们再看第三种情况，还是看下面代码：</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;style type=&quot;text/css&quot; src = &quot;theme.css&quot; /&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;p&gt;极客时间&lt;/p&gt;</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            let e = document.getElementsByTagName(&apos;p&apos;)[0]</span><br><span class="line">            e.style.color = &apos;blue&apos;</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">当我在JavaScript中访问了某个元素的样式，那么这时候就需要等待这个样式被下载完成才能继续往下执行，所以在这种情况下，CSS也会阻塞DOM的解析。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">所以JS和CSS都有可能会阻塞DOM解析</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="渲染流程（下）：HTML、CSS和JavaScript，是如何变成页面的？"><a href="#渲染流程（下）：HTML、CSS和JavaScript，是如何变成页面的？" class="headerlink" title="渲染流程（下）：HTML、CSS和JavaScript，是如何变成页面的？"></a>渲染流程（下）：HTML、CSS和JavaScript，是如何变成页面的？</h2><h3 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h3><ul>
<li>页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）。</li>
<li>如果你熟悉 PS，相信你会很容易理解图层的概念，正是这些图层叠加在一起构成了最终的页面图像。</li>
<li>浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。</li>
<li>通常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层</li>
<li>拥有层叠上下文属性的元素会被提升为单独的一层。页面是个二维平面，但是层叠上下文能够让 HTML 元素具有三维概念，这些 HTML 元素按照自身属性的优先级分布在垂直于这个二维平面的 z 轴上。</li>
<li>明确定位属性的元素、定义透明属性的元素、使用 CSS 滤镜的元素等，都拥有层叠上下文属性。</li>
<li>需要剪裁（clip）的地方也会被创建为图层。<h3 id="图层绘制"><a href="#图层绘制" class="headerlink" title="图层绘制"></a>图层绘制</h3></li>
<li>在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制<h3 id="栅格化（raster）操作"><a href="#栅格化（raster）操作" class="headerlink" title="栅格化（raster）操作"></a>栅格化（raster）操作</h3></li>
<li>绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。</li>
<li>当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程</li>
<li>通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做视口（viewport）。</li>
<li>在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。基于这个原因，合成线程会将图层划分为图块（tile）。</li>
<li>合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的</li>
<li>通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。GPU 操作是运行在 GPU 进程中，如果栅格化操作使用了 GPU，那么最终生成位图的操作是在 GPU 中完成的，这就涉及到了跨进程操作</li>
<li>渲染进程把生成图块的指令发送给 GPU，然后在 GPU 中执行生成图块的位图，并保存在 GPU 的内存中。<h3 id="合成和显示"><a href="#合成和显示" class="headerlink" title="合成和显示"></a>合成和显示</h3></li>
<li>一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。</li>
<li>浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。<h3 id="渲染总结"><a href="#渲染总结" class="headerlink" title="渲染总结"></a>渲染总结</h3></li>
<li>一个完整的渲染流程大致可总结为如下：</li>
</ul>
<ol>
<li>渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。</li>
<li>渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。</li>
<li>创建布局树，并计算元素的布局信息。</li>
<li>对布局树进行分层，并生成分层树。</li>
<li>为每个图层生成绘制列表，并将其提交到合成线程。</li>
<li>合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。</li>
<li>合成线程发送绘制图块命令 DrawQuad 给浏览器进程。</li>
<li>浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。<h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3></li>
</ol>
<ul>
<li>更新了元素的几何属性（重排）</li>
</ul>
<ol>
<li>如果你通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。</li>
<li>无疑，重排需要更新完整的渲染流水线，所以开销也是最大的。</li>
</ol>
<ul>
<li>更新元素的绘制属性（重绘）</li>
</ul>
<ol>
<li>如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。</li>
<li>相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。</li>
</ol>
<ul>
<li>直接合成阶段</li>
</ul>
<ol>
<li>使用 CSS 的 transform 来实现动画效果，可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。</li>
<li>这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，</li>
<li>所以相对于重绘和重排，合成能大大提升绘制效率。</li>
</ol>
<h2 id="变量提升：JavaScript代码是按顺序执行的吗？"><a href="#变量提升：JavaScript代码是按顺序执行的吗？" class="headerlink" title="变量提升：JavaScript代码是按顺序执行的吗？"></a>变量提升：JavaScript代码是按顺序执行的吗？</h2><h3 id="变量提升（Hoisting）"><a href="#变量提升（Hoisting）" class="headerlink" title="变量提升（Hoisting）"></a>变量提升（Hoisting）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var myname = &apos;diamonds&apos;</span><br><span class="line">这段代码你可以把它看成是两行代码组成的：</span><br><span class="line">var myname    //声明部分</span><br><span class="line">myname = &apos;diamonds&apos;  //赋值部分</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function foo()&#123;</span><br><span class="line">  console.log(&apos;foo&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var bar = function()&#123;</span><br><span class="line">  console.log(&apos;bar&apos;)</span><br><span class="line">&#125;</span><br><span class="line">第一个函数 foo 是一个完整的函数声明，也就是说没有涉及到赋值操作；</span><br><span class="line">第二个函数是先声明变量 bar，再把function()&#123;console.log(&apos;bar&apos;)&#125;赋值给 bar。</span><br></pre></td></tr></table></figure>
<ul>
<li>所谓的变量提升，是指在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。</li>
<li>变量被提升后，会给变量设置默认值，这个默认值就是我们熟悉的 undefined。<h3 id="JavaScript-代码的执行流程"><a href="#JavaScript-代码的执行流程" class="headerlink" title="JavaScript 代码的执行流程"></a>JavaScript 代码的执行流程</h3></li>
<li>实际上变量和函数声明在代码里的位置是不会改变的，而且是在编译阶段被 JavaScript 引擎放入内存中。<h4 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h4></li>
<li>输入一段代码，经过编译后，会生成两部分内容：执行上下文（Execution context）和可执行代码。</li>
<li>执行上下文是 JavaScript 执行一段代码时的运行环境，比如调用一个函数，就会进入这个函数的执行上下文，确定该函数在执行期间用到的诸如 this、变量、对象以及函数等。</li>
<li>在执行上下文中存在一个变量环境的对象（Viriable Environment），该对象中保存了变量提升的内容<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">showName()</span><br><span class="line">console.log(myname)</span><br><span class="line">var myname = &apos;diamonds&apos;</span><br><span class="line">function showName() &#123;</span><br><span class="line">    console.log(&apos;函数showName被执行&apos;);</span><br><span class="line">&#125;</span><br><span class="line">第 1 行和第 2 行，由于这两行代码不是声明操作，所以 JavaScript 引擎不会做任何处理；</span><br><span class="line">第 3 行，由于这行是经过 var 声明的，因此 JavaScript 引擎将在环境对象中创建一个名为 myname 的属性，并使用 undefined 对其初始化；</span><br><span class="line">第 4 行，JavaScript 引擎发现了一个通过 function 定义的函数，所以它将函数定义存储到堆 (HEAP）中，并在环境对象中创建一个 showName 的属性，然后将该属性值指向堆中函数的位置（不了解堆也没关系，JavaScript 的执行堆和执行栈我会在后续文章中介绍）。</span><br><span class="line"></span><br><span class="line"> JavaScript 引擎会把声明以外的代码编译为字节码</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">showName()</span><br><span class="line">console.log(myname)</span><br><span class="line">var myname = &apos;diamonds&apos;</span><br><span class="line">function showName() &#123;</span><br><span class="line">    console.log(&apos;函数showName被执行&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当执行到 showName 函数时，JavaScript 引擎便开始在变量环境对象中查找该函数，由于变量环境对象中存在该函数的引用，所以 JavaScript 引擎便开始执行该函数，并输出“函数 showName 被执行”结果。</span><br><span class="line">接下来打印“myname”信息，JavaScript 引擎继续在变量环境对象中查找该对象，由于变量环境存在 myname 变量，并且其值为 undefined，所以这时候就输出 undefined。</span><br><span class="line">接下来执行第 3 行，把“diamonds”赋给 myname 变量，赋值后变量环境中的 myname 属性值改变为“diamonds</span><br></pre></td></tr></table></figure>
<ul>
<li>实际上，编译阶段和执行阶段都是非常复杂的，包括了词法分析、语法解析、代码优化、代码生成等<h3 id="代码中出现相同的变量或者函数怎么办？"><a href="#代码中出现相同的变量或者函数怎么办？" class="headerlink" title="代码中出现相同的变量或者函数怎么办？"></a>代码中出现相同的变量或者函数怎么办？</h3></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function showName() &#123;</span><br><span class="line">    console.log(&apos;diamond&apos;);</span><br><span class="line">&#125;</span><br><span class="line">showName();</span><br><span class="line">function showName() &#123;</span><br><span class="line">    console.log(&apos;diamonds&apos;);</span><br><span class="line">&#125;</span><br><span class="line">showName(); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">首先是编译阶段。遇到了第一个 showName 函数，会将该函数体存放到变量环境中。</span><br><span class="line">接下来是第二个 showName 函数，继续存放至变量环境中，但是变量环境中已经存在一个 showName 函数了，此时，第二个 showName 函数会将第一个 showName 函数覆盖掉。这样变量环境中就只存在第二个 showName 函数了。</span><br><span class="line">接下来是执行阶段。先执行第一个 showName 函数，但由于是从变量环境中查找 showName 函数，而变量环境中只保存了第二个 showName 函数，所以最终调用的是第二个函数，打印的内容是“diamonds”。第二次执行 showName 函数也是走同样的流程，所以输出的结果也是“diamonds”。</span><br></pre></td></tr></table></figure>
<h2 id="调用栈：为什么JavaScript代码会出现栈溢出？"><a href="#调用栈：为什么JavaScript代码会出现栈溢出？" class="headerlink" title="调用栈：为什么JavaScript代码会出现栈溢出？"></a>调用栈：为什么JavaScript代码会出现栈溢出？</h2><ul>
<li>当一段代码被执行时，JavaScript 引擎先会对其进行编译，并创建执行上下文。</li>
</ul>
<ol>
<li>当 JavaScript 执行全局代码的时候，会编译全局代码并创建全局执行上下文，而且在整个页面的生存周期内，全局执行上下文只有一份。</li>
<li>当调用一个函数的时候，函数体内的代码会被编译，并创建函数执行上下文，一般情况下，函数执行结束之后，创建的函数执行上下文会被销毁。</li>
<li>当使用 eval 函数的时候，eval 的代码也会被编译，并创建执行上下文。</li>
</ol>
<ul>
<li>用栈就是用来管理函数调用关系的一种数据结构。</li>
</ul>
<h3 id="什么是函数调用"><a href="#什么是函数调用" class="headerlink" title="什么是函数调用"></a>什么是函数调用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var a = 2</span><br><span class="line">function add()&#123;</span><br><span class="line">var b = 10</span><br><span class="line">return  a+b</span><br><span class="line">&#125;</span><br><span class="line">add()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在执行到函数 add() 之前，JavaScript 引擎会为上面这段代码创建全局执行上下文，包含了声明的函数和变量。</span><br><span class="line">代码中全局变量和函数都保存在全局上下文的变量环境中。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">执行上下文准备好之后，便开始执行全局代码，当执行到 add 这儿时，JavaScript 判断这是一个函数调用，那么将执行以下操作：</span><br><span class="line">1.首先，从全局执行上下文中，取出 add 函数代码。</span><br><span class="line">2.其次，对 add 函数的这段代码进行编译，并创建该函数的执行上下文和可执行代码。</span><br><span class="line">3.最后，执行代码，输出结果。</span><br><span class="line"></span><br><span class="line">当执行到 add 函数的时候，我们就有了两个执行上下文了——全局执行上下文和 add 函数的执行上下文。也就是说在执行 JavaScript 时，可能会存在多个执行上下文。</span><br><span class="line"></span><br><span class="line">JavaScript 引擎通过一种叫栈的数据结构来管理执行上下文。</span><br></pre></td></tr></table></figure>
<h3 id="什么是-JavaScript-的调用栈"><a href="#什么是-JavaScript-的调用栈" class="headerlink" title="什么是 JavaScript 的调用栈"></a>什么是 JavaScript 的调用栈</h3><ul>
<li><p>JavaScript 引擎正是利用栈的这种结构来管理执行上下文的。在执行上下文创建好后，JavaScript 引擎会将执行上下文压入栈中，通常把这种用来管理执行上下文的栈称为执行上下文栈，又称调用栈。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var a = 2</span><br><span class="line">function add(b,c)&#123;</span><br><span class="line">  return b+c</span><br><span class="line">&#125;</span><br><span class="line">function addAll(b,c)&#123;</span><br><span class="line">var d = 10</span><br><span class="line">result = add(b,c)</span><br><span class="line">return  a+result+d</span><br><span class="line">&#125;</span><br><span class="line">addAll(3,6)</span><br><span class="line"></span><br><span class="line">第一步，创建全局上下文，并将其压入栈底</span><br><span class="line">变量 a、函数 add 和 addAll 都保存到了全局上下文的变量环境对象中。</span><br><span class="line">全局执行上下文压入到调用栈后，JavaScript 引擎便开始执行全局代码了。</span><br><span class="line">首先会执行 a=2 的赋值操作，执行该语句会将全局上下文变量环境中 a 的值设置为 2。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第二步是调用 addAll 函数。</span><br><span class="line">当调用该函数时，JavaScript 引擎会编译该函数，并为其创建一个执行上下文，最后还将该函数的执行上下文压入栈中</span><br><span class="line">addAll 函数的执行上下文创建好之后，便进入了函数代码的执行阶段了，这里先执行的是 d=10 的赋值操作，执行语句会将 addAll 函数执行上下文中的 d 由 undefined 变成了 10。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第三步，当执行到 add 函数调用语句时，同样会为其创建执行上下文，并将其压入调用栈</span><br><span class="line">当 add 函数返回时，该函数的执行上下文就会从栈顶弹出，并将 result 的值设置为 add 函数的返回值，也就是 9</span><br><span class="line">紧接着 addAll 执行最后一个相加操作后并返回，addAll 的执行上下文也会从栈顶部弹出，此时调用栈中就只剩下全局上下文了。</span><br><span class="line">至此，整个 JavaScript 流程执行结束了。</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用栈是 JavaScript 引擎追踪函数执行的一个机制，当一次有多个函数被调用时，通过调用栈就能够追踪到哪个函数正在被执行以及各函数之间的调用关系。</p>
</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol>
<li>每调用一个函数，JavaScript 引擎会为其创建执行上下文，并把该执行上下文压入调用栈，然后 JavaScript 引擎开始执行函数代码。</li>
<li>如果在一个函数 A 中调用了另外一个函数 B，那么 JavaScript 引擎会为 B 函数创建执行上下文，并将 B 函数的执行上下文压入栈顶。</li>
<li>当前函数执行完毕后，JavaScript 引擎会将该函数的执行上下文弹出栈。</li>
<li>当分配的调用栈空间被占满时，会引发“堆栈溢出”问题。</li>
</ol>
<h2 id="块级作用域：var缺陷以及为什么要引入let和const？"><a href="#块级作用域：var缺陷以及为什么要引入let和const？" class="headerlink" title="块级作用域：var缺陷以及为什么要引入let和const？"></a>块级作用域：var缺陷以及为什么要引入let和const？</h2><ul>
<li>作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。</li>
<li>在 ES6 之前，ES 的作用域只有两种：全局作用域和函数作用域。</li>
</ul>
<ol>
<li>全局作用域中的对象在代码中的任何地方都能访问，其生命周期伴随着页面的生命周期。</li>
<li>函数作用域就是在函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部被访问。函数执行结束之后，函数内部定义的变量会被销毁。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function foo()&#123;</span><br><span class="line">  for (var i = 0; i &lt; 7; i++) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(i); </span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line">如果你使用 C 语言或者其他的大部分语言实现类似代码，在 for 循环结束之后，i 就已经被销毁了，</span><br><span class="line">但是在 JavaScript 代码中，i 的值并未被销毁，所以最后打印出来的是 7。</span><br><span class="line">这同样也是由变量提升而导致的，在创建执行上下文阶段，变量 i 就已经被提升了，所以当 for 循环结束之后，变量 i 并没有被销毁。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="JavaScript-是如何支持块级作用域的"><a href="#JavaScript-是如何支持块级作用域的" class="headerlink" title="JavaScript 是如何支持块级作用域的"></a>JavaScript 是如何支持块级作用域的</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function foo()&#123;</span><br><span class="line">    var a = 1</span><br><span class="line">    let b = 2</span><br><span class="line">    &#123;</span><br><span class="line">      let b = 3</span><br><span class="line">      var c = 4</span><br><span class="line">      let d = 5</span><br><span class="line">      console.log(a)</span><br><span class="line">      console.log(b)</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(b) </span><br><span class="line">    console.log(c)</span><br><span class="line">    console.log(d)</span><br><span class="line">&#125;   </span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line">第一步是编译并创建执行上下文</span><br><span class="line">函数内部通过 var 声明的变量，在编译阶段全都被存放到变量环境里面了。</span><br><span class="line">通过 let 声明的变量，在编译阶段会被存放到词法环境（Lexical Environment）中。</span><br><span class="line">在函数的作用域块内部，通过 let 声明的变量并没有被存放到词法环境中。</span><br><span class="line"></span><br><span class="line">第二步继续执行代码，当执行到代码块里面时，变量环境中 a 的值已经被设置成了 1，词法环境中 b 的值已经被设置成了 2</span><br><span class="line">当进入函数的作用域块时，作用域块中通过 let 声明的变量，会被存放在词法环境的一个单独的区域中，这个区域中的变量并不影响作用域块外面的变量，比如在作用域外面声明了变量 b，在该作用域块内部也声明了变量 b，当执行到作用域内部时，它们都是独立的存在。</span><br><span class="line">其实，在词法环境内部，维护了一个小型栈结构，栈底是函数最外层的变量，进入一个作用域块后，就会把该作用域块内部的变量压到栈顶；当作用域执行完成之后，该作用域的信息就会从栈顶弹出，这就是词法环境的结构。</span><br><span class="line">需要注意下，我这里所讲的变量是指通过 let 或者 const 声明的变量。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">再接下来，当执行到作用域块中的console.log(a)这行代码时，就需要在词法环境和变量环境中查找变量 a 的值了，</span><br><span class="line">具体查找方式是：沿着词法环境的栈顶向下查询，如果在词法环境中的某个块中查找到了，就直接返回给 JavaScript 引擎，</span><br><span class="line">如果没有查找到，那么继续在变量环境中查找。</span><br></pre></td></tr></table></figure>
<h2 id="作用域链和闭包-：代码中出现相同的变量，JavaScript引擎是如何选择的？"><a href="#作用域链和闭包-：代码中出现相同的变量，JavaScript引擎是如何选择的？" class="headerlink" title="作用域链和闭包 ：代码中出现相同的变量，JavaScript引擎是如何选择的？"></a>作用域链和闭包 ：代码中出现相同的变量，JavaScript引擎是如何选择的？</h2><ul>
<li>ES6 是如何通过变量环境和词法环境来同时支持变量提升和块级作用域</li>
<li>在每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，我们把这个外部引用称为 outer。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function bar() &#123;</span><br><span class="line">    console.log(myName)</span><br><span class="line">&#125;</span><br><span class="line">function foo() &#123;</span><br><span class="line">    var myName = &quot;diamonds&quot;</span><br><span class="line">    bar()</span><br><span class="line">&#125;</span><br><span class="line">var myName = &quot;diamond&quot;</span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line">上面那段代码在查找 myName 变量时，如果在当前的变量环境中没有查找到，那么 JavaScript 引擎会继续在 outer 所指向的执行上下文中查找。</span><br><span class="line">bar 函数和 foo 函数的 outer 都是指向全局上下文的，这也就意味着如果在 bar 函数或者 foo 函数中使用了外部变量，那么 JavaScript 引擎会去全局执行上下文中查找。我们把这个查找的链条就称为作用域链。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foo 函数调用的 bar 函数，那为什么 bar 函数的外部引用是全局执行上下文，而不是 foo 函数的执行上下文？</span><br><span class="line">要回答这个问题，你还需要知道什么是词法作用域。这是因为在 JavaScript 执行过程中，其作用域链是由词法作用域决定的。</span><br><span class="line">这是因为根据词法作用域，foo 和 bar 的上级作用域都是全局作用域，所以如果 foo 或者 bar 函数使用了一个它们没有定义的变量，那么它们会到全局作用域去查找。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><ul>
<li><p>词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let count=1</span><br><span class="line">function main()&#123;</span><br><span class="line">let count=2</span><br><span class="line">function bar()&#123;</span><br><span class="line">let count=3</span><br><span class="line">function foo()&#123;</span><br><span class="line">let count=4</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">词法作用域就是根据代码的位置来决定的，其中 main 函数包含了 bar 函数，bar 函数中包含了 foo 函数，因为 JavaScript 作用域链是由词法作用域决定的，所以整个词法作用域链的顺序是：foo 函数作用域—&gt;bar 函数作用域—&gt;main 函数作用域—&gt; 全局作用域。</span><br></pre></td></tr></table></figure>
</li>
<li><p>词法作用域是代码编译阶段就决定好的，和函数是怎么调用的没有关系。</p>
</li>
</ul>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">    var myName = &quot;diamond&quot;</span><br><span class="line">    let test1 = 1</span><br><span class="line">    const test2 = 2</span><br><span class="line">    var innerBar = &#123;</span><br><span class="line">        getName:function()&#123;</span><br><span class="line">            console.log(test1)</span><br><span class="line">            return myName</span><br><span class="line">        &#125;,</span><br><span class="line">        setName:function(newName)&#123;</span><br><span class="line">            myName = newName</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return innerBar</span><br><span class="line">&#125;</span><br><span class="line">var bar = foo()</span><br><span class="line">bar.setName(&quot;diamonds&quot;)</span><br><span class="line">bar.getName()</span><br><span class="line">console.log(bar.getName())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。</span><br><span class="line">比如外部函数是 foo，那么这些变量的集合就称为 foo 函数的闭包。</span><br></pre></td></tr></table></figure>
<ul>
<li>如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一个局部变量。</li>
</ul>
<h2 id="this：从JavaScript执行上下文的视角讲清楚this"><a href="#this：从JavaScript执行上下文的视角讲清楚this" class="headerlink" title="this：从JavaScript执行上下文的视角讲清楚this"></a>this：从JavaScript执行上下文的视角讲清楚this</h2><ul>
<li>this 是和执行上下文绑定的，也就是说每个执行上下文中都有一个 this</li>
<li>执行上下文主要分为三种——全局执行上下文、函数执行上下文和 eval 执行上下文，所以对应的 this 也只有这三种——全局执行上下文中的 this、函数中的 this 和 eval 中的 this。<h3 id="this-的设计缺陷以及应对方案"><a href="#this-的设计缺陷以及应对方案" class="headerlink" title="this 的设计缺陷以及应对方案"></a>this 的设计缺陷以及应对方案</h3></li>
<li><p>嵌套函数中的 this 不会从外层函数中继承</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var myObj = &#123;</span><br><span class="line">  name : &quot;diamonds&quot;, </span><br><span class="line">  showThis: function()&#123;</span><br><span class="line">    console.log(this)</span><br><span class="line">    function bar()&#123;console.log(this)&#125;</span><br><span class="line">    bar()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myObj.showThis()</span><br><span class="line"></span><br><span class="line">执行这段代码后，你会发现函数 bar 中的 this 指向的是全局 window 对象，而函数 showThis 中的 this 指向的是 myObj 对象。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var myObj = &#123;</span><br><span class="line">  name : &quot;diamond&quot;, </span><br><span class="line">  showThis: function()&#123;</span><br><span class="line">    console.log(this)</span><br><span class="line">    var bar = ()=&gt;&#123;</span><br><span class="line">      this.name = &quot;diamonds&quot;</span><br><span class="line">      console.log(this)</span><br><span class="line">    &#125;</span><br><span class="line">    bar()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myObj.showThis()</span><br><span class="line">console.log(myObj.name)</span><br><span class="line">console.log(window.name)</span><br><span class="line"></span><br><span class="line">ES6 中的箭头函数并不会创建其自身的执行上下文，所以箭头函数中的 this 取决于它的外部函数。</span><br><span class="line">因为箭头函数没有自己的执行上下文，所以箭头函数的 this 就是它外层函数的 this。</span><br></pre></td></tr></table></figure>
</li>
<li><p>普通函数中的 this 默认指向全局对象 window</p>
</li>
</ul>
<ol>
<li>在严格模式下，默认执行一个函数，其函数的执行上下文中的 this 值是 undefined</li>
</ol>
<h2 id="栈空间和堆空间：数据是如何存储的？"><a href="#栈空间和堆空间：数据是如何存储的？" class="headerlink" title="栈空间和堆空间：数据是如何存储的？"></a>栈空间和堆空间：数据是如何存储的？</h2><ul>
<li>我们把这种在使用之前就需要确认其变量数据类型的称为静态语言。</li>
<li>相反地，我们把在运行过程中需要检查数据类型的语言称为动态语言。</li>
<li>JavaScript 就是动态语言，因为在声明变量之前并不需要确认其数据类型。</li>
<li>支持隐式类型转换的语言称为弱类型语言，不支持隐式类型转换的语言称为强类型语言。</li>
<li>JavaScript 是一种弱类型的、动态的语言。</li>
</ul>
<ol>
<li>弱类型，意味着你不需要告诉 JavaScript 引擎这个或那个变量是什么数据类型，JavaScript 引擎在运行代码的时候自己会计算出来。</li>
<li>动态，意味着你可以使用同一个变量保存不同类型的数据。</li>
</ol>
<ul>
<li>使用 typeof 检测 Null 类型时，返回的是 Object。这是当初 JavaScript 语言的一个 Bug，一直保留至今，之所以一直没修改过来，主要是为了兼容老的代码。</li>
<li>Object 类型比较特殊，Object 是由 key-value 组成的，其中的 vaule 可以是任何类型，包括函数，这也就意味着你可以通过 Object 来存储函数，Object 中的函数又称为方法</li>
<li>在 JavaScript 的执行过程中， 主要有三种类型内存空间，分别是代码空间、栈空间和堆空间。代码空间主要是存储可执行代码的。<h3 id="栈空间和堆空间"><a href="#栈空间和堆空间" class="headerlink" title="栈空间和堆空间"></a>栈空间和堆空间</h3></li>
<li>调用栈，是用来存储执行上下文的</li>
<li>对象类型是存放在堆空间的，在栈空间中只是保留了对象的引用地址，当 JavaScript 需要访问该数据的时候，是通过栈中的引用地址来访问的</li>
<li>JavaScript 引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。</li>
<li>通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据。而引用类型的数据占用的空间都比较大，所以这一类数据会被存放到堆中，堆空间很大，能存放很多大的数据，不过缺点是分配内存和回收内存都会占用一定的时间</li>
<li>原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址。</li>
</ul>
<h2 id="垃圾回收：垃圾数据是如何自动回收的？"><a href="#垃圾回收：垃圾数据是如何自动回收的？" class="headerlink" title="垃圾回收：垃圾数据是如何自动回收的？"></a>垃圾回收：垃圾数据是如何自动回收的？</h2><ul>
<li>有些数据被使用之后，可能就不再需要了，我们把这种数据称为垃圾数据。如果这些垃圾数据一直保存在内存中，那么内存会越用越多，所以我们需要对这些垃圾数据进行回收，以释放有限的内存空间。</li>
<li>通常情况下，垃圾数据回收分为手动回收和自动回收两种策略。<h3 id="调用栈中的数据是如何回收的"><a href="#调用栈中的数据是如何回收的" class="headerlink" title="调用栈中的数据是如何回收的"></a>调用栈中的数据是如何回收的</h3></li>
<li>当一个函数执行结束之后，JavaScript 引擎会通过向下移动 ESP（记录当前执行状态的指针） 来销毁该函数保存在栈中的执行上下文。<h3 id="堆中的数据是如何回收的"><a href="#堆中的数据是如何回收的" class="headerlink" title="堆中的数据是如何回收的"></a>堆中的数据是如何回收的</h3></li>
<li>要回收堆中的垃圾数据，就需要用到 JavaScript 中的垃圾回收器了。<h3 id="代际假说和分代收集"><a href="#代际假说和分代收集" class="headerlink" title="代际假说和分代收集"></a>代际假说和分代收集</h3></li>
<li>代际假说（The Generational Hypothesis）的内容，这是垃圾回收领域中一个重要的术语，后续垃圾回收的策略都是建立在该假说的基础之上的，所以很是重要。</li>
<li>代际假说有以下两个特点：</li>
</ul>
<ol>
<li>第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；</li>
<li>第二个是不死的对象，会活得更久。</li>
</ol>
<ul>
<li>通常，垃圾回收算法有很多种，但是并没有哪一种能胜任所有的场景，你需要权衡各种场景，根据对象的生存周期的不同而使用不同的算法，以便达到最好的效果。</li>
<li>在 V8 中会把堆分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象。</li>
<li>新生区通常只支持 1～8M 的容量，而老生区支持的容量就大很多了。对于这两块区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。</li>
<li>副垃圾回收器，主要负责新生代的垃圾回收。主垃圾回收器，主要负责老生代的垃圾回收。<h3 id="垃圾回收器的工作流程"><a href="#垃圾回收器的工作流程" class="headerlink" title="垃圾回收器的工作流程"></a>垃圾回收器的工作流程</h3></li>
<li>V8 把堆分成两个区域——新生代和老生代，并分别使用两个不同的垃圾回收器。其实不论什么类型的垃圾回收器，它们都有一套共同的执行流程。</li>
</ul>
<ol>
<li>第一步是标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。</li>
<li>第二步是回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。</li>
<li>第三步是做内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为内存碎片。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。所以最后一步需要整理这些内存碎片，但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片，比如接下来我们要介绍的副垃圾回收器。<h4 id="副垃圾回收器"><a href="#副垃圾回收器" class="headerlink" title="副垃圾回收器"></a>副垃圾回收器</h4></li>
</ol>
<ul>
<li>副垃圾回收器主要负责新生区的垃圾回收。而通常情况下，大多数小的对象都会被分配到新生区，所以说这个区域虽然不大，但是垃圾回收还是比较频繁的。</li>
<li>新生代中用 Scavenge 算法来处理。所谓 Scavenge 算法，是把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域</li>
<li>新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。</li>
<li>在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。</li>
<li>完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时这种角色翻转的操作还能让新生代中的这两块区域无限重复使用下去。</li>
<li>由于新生代中采用的 Scavenge 算法，所以每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域。但复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以为了执行效率，一般新生区的空间会被设置得比较小。</li>
<li>也正是因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JavaScript 引擎采用了对象晋升策略，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。<h4 id="主垃圾回收器"><a href="#主垃圾回收器" class="headerlink" title="主垃圾回收器"></a>主垃圾回收器</h4></li>
<li>主垃圾回收器主要负责老生区中的垃圾回收。除了新生区中晋升的对象，一些大的对象会直接被分配到老生区。因此老生区中的对象有两个特点，一个是对象占用空间大，另一个是对象存活时间长。</li>
<li>由于老生区的对象比较大，若要在老生区中使用 Scavenge 算法进行垃圾回收，复制这些大的对象将会花费比较多的时间，从而导致回收执行效率不高，同时还会浪费一半的空间。因而，主垃圾回收器是采用标记 - 清除（Mark-Sweep）的算法进行垃圾回收的。</li>
<li><p>首先是标记过程阶段。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function foo()&#123;</span><br><span class="line">    var a = 1</span><br><span class="line">    var b = &#123;name:&quot;diamond&quot;&#125;  堆地址：  1050</span><br><span class="line">    function showName()&#123;</span><br><span class="line">      var c = 2</span><br><span class="line">      var d = &#123;name:&quot;diamonds&quot;&#125; 堆地址：   1003</span><br><span class="line">    &#125;</span><br><span class="line">    showName()</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">当 showName 函数执行结束之后，ESP 向下移动，指向了 foo 函数的执行上下文，这时候如果遍历调用栈，是不会找到引用 1003 地址的变量，也就意味着 1003 这块数据为垃圾数据，被标记为红色。</span><br><span class="line">由于 1050 这块数据被变量 b 引用了，所以这块数据会被标记为活动对象。这就是大致的标记过程。</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来就是垃圾的清除过程。它和副垃圾回收器的垃圾清除过程完全不同</p>
</li>
<li>对一块内存多次执行标记 - 清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存，于是又产生了另外一种算法——标记 - 整理（Mark-Compact），这个标记过程仍然与标记 - 清除算法里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。<h3 id="全停顿"><a href="#全停顿" class="headerlink" title="全停顿"></a>全停顿</h3></li>
<li>由于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做全停顿（Stop-The-World）。</li>
<li>比如堆中的数据有 1.5GB，V8 实现一次完整的垃圾回收需要 1 秒以上的时间，这也是由于垃圾回收而引起 JavaScript 线程暂停执行的时间，若是这样的时间花销，那么应用的性能和响应能力都会直线下降。</li>
<li>在 V8 新生代的垃圾回收中，因其空间较小，且存活对象较少，所以全停顿的影响不大</li>
<li>老生代就不一样了。如果在执行垃圾回收的过程中，占用主线程时间过久，主线程是不能做其他事情的。比如页面正在执行一个 JavaScript 动画，因为垃圾回收器在工作，就会导致这个动画在这 200 毫秒内无法执行的，这将会造成页面的卡顿现象。</li>
<li>为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为增量标记（Incremental Marking）算法</li>
<li>使用增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的 JavaScript 任务中间执行，这样当执行上述动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了。<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3></li>
<li>无论是垃圾回收的策略，还是处理全停顿的策略，往往都没有一个完美的解决方案，你需要花一些时间来做权衡，而这需要牺牲当前某几方面的指标来换取其他几个指标的提升。</li>
<li>其实站在工程师的视角，我们经常需要在满足需求的前提下，权衡各个指标的得失，把系统设计得尽可能适应最核心的需求。</li>
<li>生活中处理事情的原则也与之类似，古人很早就说过“两害相权取其轻，两利相权取其重”，所以与其患得患失，不如冷静地分析哪些才是核心诉求，然后果断决策牺牲哪些以使得利益最大化。</li>
</ul>
<h2 id="编译器和解释器：V8是如何执行一段JavaScript代码的？"><a href="#编译器和解释器：V8是如何执行一段JavaScript代码的？" class="headerlink" title="编译器和解释器：V8是如何执行一段JavaScript代码的？"></a>编译器和解释器：V8是如何执行一段JavaScript代码的？</h2><ul>
<li>要深入理解 V8 的工作原理，你需要搞清楚一些概念和原理，比如编译器（Compiler）、解释器（Interpreter）、抽象语法树（AST）、字节码（Bytecode）、即时编译器（JIT）等概念<h3 id="编译器和解释器"><a href="#编译器和解释器" class="headerlink" title="编译器和解释器"></a>编译器和解释器</h3></li>
<li>之所以存在编译器和解释器，是因为机器不能直接理解我们所写的代码，所以在执行程序之前，需要将我们所写的代码“翻译”成机器能读懂的机器语言。</li>
<li>按语言的执行流程，可以把语言划分为编译型语言和解释型语言。</li>
<li>编译型语言在程序执行之前，需要经过编译器的编译过程，并且编译之后会直接保留机器能读懂的二进制文件，这样每次运行程序时，都可以直接运行该二进制文件，而不需要再次重新编译了。比如 C/C++、GO 等都是编译型语言。</li>
<li>解释型语言编写的程序，在每次运行时都需要通过解释器对程序进行动态解释和执行。比如 Python、JavaScript 等都属于解释型语言。</li>
<li>在编译型语言的编译过程中，编译器首先会依次对源代码进行词法分析、语法分析，生成抽象语法树（AST），然后是优化代码，最后再生成处理器能够理解的机器码。如果编译成功，将会生成一个可执行的文件。但如果编译过程发生了语法或者其他的错误，那么编译器就会抛出异常，最后的二进制文件也不会生成成功。</li>
<li>在解释型语言的解释过程中，同样解释器也会对源代码进行词法分析、语法分析，并生成抽象语法树（AST），不过它会再基于抽象语法树生成字节码，最后再根据字节码来执行程序、输出结果。<h3 id="V8-是如何执行一段-JavaScript-代码的"><a href="#V8-是如何执行一段-JavaScript-代码的" class="headerlink" title="V8 是如何执行一段 JavaScript 代码的"></a>V8 是如何执行一段 JavaScript 代码的</h3></li>
<li>V8 在执行过程中既有解释器 Ignition，又有编译器 TurboFan<h4 id="生成抽象语法树（AST）和执行上下文"><a href="#生成抽象语法树（AST）和执行上下文" class="headerlink" title="生成抽象语法树（AST）和执行上下文"></a>生成抽象语法树（AST）和执行上下文</h4></li>
<li>将源代码转换为抽象语法树，并生成执行上下文</li>
<li>高级语言是开发者可以理解的语言，但是让编译器或者解释器来理解就非常困难了。</li>
<li>对于编译器或者解释器来说，它们可以理解的就是 AST 了。所以无论你使用的是解释型语言还是编译型语言，在编译过程中，它们都会生成一个 AST。这和渲染引擎将 HTML 格式文件转换为计算机可以理解的 DOM 树的情况类似。</li>
<li>AST 的结构和代码的结构非常相似，其实你也可以把 AST 看成代码的结构化的表示，编译器或者解释器后续的工作都需要依赖于 AST，而不是源代码。</li>
<li>AST 是非常重要的一种数据结构，在很多项目中有着广泛的应用。其中最著名的一个项目是 Babel。</li>
<li>Babel 是一个被广泛使用的代码转码器，可以将 ES6 代码转为 ES5 代码，这意味着你可以现在就用 ES6 编写程序，而不用担心现有环境是否支持 ES6。Babel 的工作原理就是先将 ES6 源码转换为 AST，然后再将 ES6 语法的 AST 转换为 ES5 语法的 AST，最后利用 ES5 的 AST 生成 JavaScript 源代码。</li>
<li>除了 Babel 外，还有 ESLint 也使用 AST。ESLint 是一个用来检查 JavaScript 编写规范的插件，其检测流程也是需要将源码转换为 AST，然后再利用 AST 来检查代码规范化的问题。</li>
<li>通常，生成 AST 需要经过两个阶段。</li>
</ul>
<ol>
<li><p>第一阶段是分词（tokenize），又称为词法分析，其作用是将一行行的源码拆解成一个个 token。所谓 token，指的是语法上不可能再分的、最小的单个字符或字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var myName = “diamond”</span><br><span class="line"></span><br><span class="line">通过var myName = “diamond”简单地定义了一个变量，</span><br><span class="line">其中关键字“var”、标识符“myName” 、赋值运算符“=”、字符串“极客时间”四个都是 token，而且它们代表的属性还不一样。</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二阶段是解析（parse），又称为语法分析，其作用是将上一步生成的 token 数据，根据语法规则转为 AST。如果源码符合语法规则，这一步就会顺利完成。但如果源码存在语法错误，这一步就会终止，并抛出一个“语法错误”。</p>
</li>
<li>这就是 AST 的生成过程，先分词，再解析。有了 AST 后，那接下来 V8 就会生成该段代码的执行上下文。<h4 id="生成字节码"><a href="#生成字节码" class="headerlink" title="生成字节码"></a>生成字节码</h4></li>
</ol>
<ul>
<li>有了 AST 和执行上下文后，那接下来的第二步，解释器 Ignition 就登场了，它会根据 AST 生成字节码，并解释执行字节码。</li>
<li>其实一开始 V8 并没有字节码，而是直接将 AST 转换为机器码，由于执行机器码的效率是非常高效的，所以这种方式在发布后的一段时间内运行效果是非常好的。但是随着 Chrome 在手机上的广泛普及，特别是运行在 512M 内存的手机上，内存占用问题也暴露出来了，因为 V8 需要消耗大量的内存来存放转换后的机器码。</li>
<li>为了解决内存占用问题，V8 团队大幅重构了引擎架构，引入字节码，并且抛弃了之前的编译器，最终花了将进四年的时间，实现了现在的这套架构。</li>
<li>字节码就是介于 AST 和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行。机器码所占用的空间远远超过了字节码，所以使用字节码可以减少系统的内存使用。<h4 id="执行代码"><a href="#执行代码" class="headerlink" title="执行代码"></a>执行代码</h4></li>
<li>生成字节码之后，接下来就要进入执行阶段了。</li>
<li>解释器 Ignition 除了负责生成字节码之外，它还有另外一个作用，就是解释执行字节码。</li>
<li>在 Ignition 执行字节码的过程中，如果发现有热点代码（HotSpot），比如一段代码被重复执行多次，这种就称为热点代码，那么后台的编译器 TurboFan 就会把该段热点的字节码编译为高效的机器码，然后当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了，这样就大大提升了代码的执行效率。</li>
<li>字节码配合解释器和编译器是最近一段时间很火的技术，比如 Java 和 Python 的虚拟机也都是基于这种技术实现的，我们把这种技术称为即时编译（JIT）。具体到 V8，就是指解释器 Ignition 在解释执行字节码的同时，收集代码信息，当它发现某一部分代码变热了之后，TurboFan 编译器便闪亮登场，把热点的字节码转换为机器码，并把转换后的机器码保存起来，以备下次使用。<h3 id="JavaScript-的性能优化"><a href="#JavaScript-的性能优化" class="headerlink" title="JavaScript 的性能优化"></a>JavaScript 的性能优化</h3></li>
<li>对于优化 JavaScript 执行效率，你应该将优化的中心聚焦在单次脚本的执行时间和脚本的网络下载上，主要关注以下三点内容：</li>
</ul>
<ol>
<li>提升单次脚本的执行速度，避免 JavaScript 的长任务霸占主线程，这样可以使得页面快速响应交互；</li>
<li>避免大的内联脚本，因为在解析 HTML 的过程中，解析和编译也会占用主线程；</li>
<li>减少 JavaScript 文件的容量，因为更小的文件会提升下载速度，并且占用更低的内存。</li>
</ol>
<h2 id="消息队列和事件循环：页面是怎么“活”起来的？"><a href="#消息队列和事件循环：页面是怎么“活”起来的？" class="headerlink" title="消息队列和事件循环：页面是怎么“活”起来的？"></a>消息队列和事件循环：页面是怎么“活”起来的？</h2><ul>
<li>主线程非常繁忙，既要处理 DOM，又要计算样式，还要处理布局，同时还需要处理 JavaScript 任务以及各种输入事件。要让这么多不同类型的任务在主线程中有条不紊地执行，这就需要一个系统来统筹调度这些任务，这个统筹调度系统就是我们今天要讲的消息队列和事件循环系统。</li>
<li>消息队列中的任务类型：如输入事件（鼠标滚动、点击、移动）、微任务、文件读写、WebSocket、JavaScript 定时器等等。除此之外，消息队列中还包含了很多与页面相关的事件，如 JavaScript 执行、解析 DOM、样式计算、布局计算、CSS 动画等。以上这些事件都是在主线程中执行的，所以在编写 Web 应用时，你还需要衡量这些事件所占用的时长，并想办法解决单个任务占用主线程过久的问题。</li>
<li>如何安全退出？确定要退出当前页面时，页面主线程会设置一个退出标志的变量，在每次执行完一个任务时，判断是否有设置退出标志。如果设置了，那么就直接中断当前的所有任务，退出线程</li>
<li>通常我们把消息队列中的任务称为宏任务，每个宏任务中都包含了一个微任务队列，在执行宏任务的过程中，如果 DOM 有变化，那么就会将该变化添加到微任务列表中，这样就不会影响到宏任务的继续执行，因此也就解决了执行效率的问题。</li>
<li>等宏任务中的主要功能都直接完成之后，这时候，渲染引擎并不着急去执行下一个宏任务，而是执行当前宏任务中的微任务，因为 DOM 变化的事件都保存在这些微任务队列中，这样也就解决了实时性问题。<h2 id="WebAPI：setTimeout是如何实现的？"><a href="#WebAPI：setTimeout是如何实现的？" class="headerlink" title="WebAPI：setTimeout是如何实现的？"></a>WebAPI：setTimeout是如何实现的？</h2></li>
<li>定时器，用来指定某个函数在多少毫秒之后执行。它会返回一个整数，表示定时器的编号，同时你还可以通过该编号来取消这个定时器。<h3 id="浏览器怎么实现-setTimeout"><a href="#浏览器怎么实现-setTimeout" class="headerlink" title="浏览器怎么实现 setTimeout"></a>浏览器怎么实现 setTimeout</h3></li>
<li>渲染进程中所有运行在主线程上的任务都需要先添加到消息队列，然后事件循环系统再按照顺序执行消息队列中的任务。下面我们来看看那些典型的事件：</li>
</ul>
<ol>
<li>当接收到 HTML 文档数据，渲染引擎就会将“解析 DOM”事件添加到消息队列中，</li>
<li>当用户改变了 Web 页面的窗口大小，渲染引擎就会将“重新布局”的事件添加到消息队列中。</li>
<li>当触发了 JavaScript 引擎垃圾回收机制，渲染引擎会将“垃圾回收”任务添加到消息队列中。</li>
<li>同样，如果要执行一段异步 JavaScript 代码，也是需要将执行任务添加到消息队列中。</li>
</ol>
<ul>
<li>在 Chrome 中除了正常使用的消息队列之外，还有另外一个消息队列（其实是一个hashmap结构，等到执行这个结构的时候，会计算hashmap中的每个任务是否到期了，到期了就去执行，直到所有到期的任务都执行结束，才会进入下一轮循环！），这个队列中维护了需要延迟执行的任务列表，包括了定时器和 Chromium 内部一些需要延迟执行的任务。所以当通过 JavaScript 创建一个定时器时，渲染进程会将该定时器的回调任务添加到延迟队列中。</li>
<li>浏览器内部实现取消定时器的操作也是非常简单的，就是直接从延迟队列中，通过 ID 查找到对应的任务，然后再将其从队列中删除掉就可以了。</li>
<li>使用 setTimeout 的一些注意事项</li>
</ul>
<ol>
<li>如果当前任务执行时间过久，会影响定时器任务的执行</li>
<li>如果 setTimeout 存在嵌套调用，那么系统会设置最短时间间隔为 4 毫秒。在 Chrome 中，定时器被嵌套调用 5 次以上，系统会判断该函数方法被阻塞了，如果定时器的调用时间间隔小于 4 毫秒，那么浏览器会将每次调用的时间间隔设置为 4 毫秒。所以，一些实时性较高的需求就不太适合使用 setTimeout 了，比如你用 setTimeout 来实现 JavaScript 动画就不是一个很好的主意。</li>
<li>未激活的页面，setTimeout 执行最小间隔是 1000 毫秒，目的是为了优化后台页面的加载损耗以及降低耗电量。</li>
<li>延时执行时间有最大值。Chrome、Safari、Firefox 都是以 32 个 bit 来存储延时值的，32bit 最大只能存放的数字是 2147483647 毫秒，这就意味着，如果 setTimeout 设置的延迟值大于 2147483647 毫秒（大约 24.8 天）时就会溢出，那么相当于延时值被设置为 0 了，这导致定时器会被立即执行。</li>
<li>使用 setTimeout 设置的回调函数中的 this 不符合直觉。如果被 setTimeout 推迟执行的回调函数是某个对象的方法，那么该方法中的 this 关键字将指向全局环境，而不是定义时所在的那个对象。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var name= 1;</span><br><span class="line">var MyObj = &#123;</span><br><span class="line">  name: 2,</span><br><span class="line">  showName: function()&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(MyObj.showName,1000)</span><br><span class="line">这里输出的是 1，因为这段代码在编译的时候，执行上下文中的 this 会被设置为全局 window，如果是严格模式，会被设置为 undefined。</span><br><span class="line">那么该怎么解决这个问题呢？通常可以使用下面这两种方法。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//箭头函数</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    MyObj.showName()</span><br><span class="line">&#125;, 1000);</span><br><span class="line">//或者function函数</span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">  MyObj.showName();</span><br><span class="line">&#125;, 1000)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">setTimeout(MyObj.showName.bind(MyObj), 1000)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="WebAPI：XMLHttpRequest是怎么实现的？"><a href="#WebAPI：XMLHttpRequest是怎么实现的？" class="headerlink" title="WebAPI：XMLHttpRequest是怎么实现的？"></a>WebAPI：XMLHttpRequest是怎么实现的？</h2><h3 id="回调函数-VS-系统调用栈"><a href="#回调函数-VS-系统调用栈" class="headerlink" title="回调函数 VS 系统调用栈"></a>回调函数 VS 系统调用栈</h3><ul>
<li><p>将一个函数作为参数传递给另外一个函数，那作为参数的这个函数就是回调函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">let callback = function()&#123;</span><br><span class="line">    console.log(&apos;i am do homework&apos;)</span><br><span class="line">&#125;</span><br><span class="line">function doWork(cb) &#123;</span><br><span class="line">    console.log(&apos;start do work&apos;)</span><br><span class="line">    cb()</span><br><span class="line">    console.log(&apos;end do work&apos;)</span><br><span class="line">&#125;</span><br><span class="line">doWork(callback)</span><br><span class="line"></span><br><span class="line">上面的回调方法有个特点，就是回调函数 callback 是在主函数 doWork 返回之前执行的，我们把这个回调过程称为同步回调。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let callback = function()&#123;</span><br><span class="line">    console.log(&apos;i am do homework&apos;)</span><br><span class="line">&#125;</span><br><span class="line">function doWork(cb) &#123;</span><br><span class="line">    console.log(&apos;start do work&apos;)</span><br><span class="line">    setTimeout(cb,1000)   </span><br><span class="line">    console.log(&apos;end do work&apos;)</span><br><span class="line">&#125;</span><br><span class="line">doWork(callback)</span><br><span class="line"></span><br><span class="line">在这个例子中，我们使用了 setTimeout 函数让 callback 在 doWork 函数执行结束后，又延时了 1 秒再执行，</span><br><span class="line">这次 callback 并没有在主函数 doWork 内部被调用，我们把这种回调函数在主函数外部执行的过程称为异步回调。</span><br></pre></td></tr></table></figure>
</li>
<li><p>消息队列和主线程循环机制保证了页面有条不紊地运行。那就是当循环系统在执行一个任务的时候，都要为这个任务维护一个系统调用栈。这个系统调用栈类似于 JavaScript 的调用栈，只不过系统调用栈是 Chromium 的开发语言 C++ 来维护的</p>
<h3 id="XMLHttpRequest-运作机制"><a href="#XMLHttpRequest-运作机制" class="headerlink" title="XMLHttpRequest 运作机制"></a>XMLHttpRequest 运作机制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"> function GetWebData(URL)&#123;</span><br><span class="line">    /**</span><br><span class="line">     * 1:新建XMLHttpRequest请求对象</span><br><span class="line">     */</span><br><span class="line">    let xhr = new XMLHttpRequest()</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 2:注册相关事件回调处理函数 </span><br><span class="line">     */</span><br><span class="line">    xhr.onreadystatechange = function () &#123;</span><br><span class="line">        switch(xhr.readyState)&#123;</span><br><span class="line">          case 0: //请求未初始化</span><br><span class="line">            console.log(&quot;请求未初始化&quot;)</span><br><span class="line">            break;</span><br><span class="line">          case 1://OPENED</span><br><span class="line">            console.log(&quot;OPENED&quot;)</span><br><span class="line">            break;</span><br><span class="line">          case 2://HEADERS_RECEIVED</span><br><span class="line">            console.log(&quot;HEADERS_RECEIVED&quot;)</span><br><span class="line">            break;</span><br><span class="line">          case 3://LOADING  </span><br><span class="line">            console.log(&quot;LOADING&quot;)</span><br><span class="line">            break;</span><br><span class="line">          case 4://DONE</span><br><span class="line">            if(this.status == 200||this.status == 304)&#123;</span><br><span class="line">                console.log(this.responseText);</span><br><span class="line">                &#125;</span><br><span class="line">            console.log(&quot;DONE&quot;)</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    xhr.ontimeout = function(e) &#123; console.log(&apos;ontimeout&apos;) &#125;</span><br><span class="line">    xhr.onerror = function(e) &#123; console.log(&apos;onerror&apos;) &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 3:打开请求</span><br><span class="line">     */</span><br><span class="line">    xhr.open(&apos;Get&apos;, URL, true);//创建一个Get请求,采用异步</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 4:配置参数</span><br><span class="line">     */</span><br><span class="line">    xhr.timeout = 3000 //设置xhr请求的超时时间</span><br><span class="line">    xhr.responseType = &quot;text&quot; //设置响应返回的数据格式</span><br><span class="line">    xhr.setRequestHeader(&quot;X_TEST&quot;,&quot;time.geekbang&quot;)</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 5:发送请求</span><br><span class="line">     */</span><br><span class="line">    xhr.send();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>渲染进程会将请求发送给网络进程，然后网络进程负责资源的下载，等网络进程接收到数据之后，就会利用 IPC 来通知渲染进程；渲染进程接收到消息之后，会将 xhr 的回调函数封装成任务并添加到消息队列中，等主线程循环系统执行到该任务的时候，就会根据相关的状态来调用对应的回调函数。</p>
<h3 id="XMLHttpRequest-使用过程中的“坑”"><a href="#XMLHttpRequest-使用过程中的“坑”" class="headerlink" title="XMLHttpRequest 使用过程中的“坑”"></a>XMLHttpRequest 使用过程中的“坑”</h3></li>
<li>跨域问题</li>
<li>HTTPS 混合内容的问题</li>
</ul>
<ol>
<li>HTTPS 混合内容是 HTTPS 页面中包含了不符合 HTTPS 安全要求的内容，比如包含了 HTTP 资源，通过 HTTP 加载的图像、视频、样式表、脚本等，都属于混合内容。</li>
<li>通过 HTML 文件加载的混合资源，虽然给出警告，但大部分类型还是能加载的。而使用 XMLHttpRequest 请求时，浏览器认为这种请求可能是攻击者发起的，会阻止此类危险的请求。</li>
</ol>
<h2 id="宏任务和微任务：不是所有任务都是一个待遇"><a href="#宏任务和微任务：不是所有任务都是一个待遇" class="headerlink" title="宏任务和微任务：不是所有任务都是一个待遇"></a>宏任务和微任务：不是所有任务都是一个待遇</h2><h3 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h3><ul>
<li>页面中的大部分任务都是在主线程上执行的，这些任务包括了：</li>
</ul>
<ol>
<li>渲染事件（如解析 DOM、计算布局、绘制）；</li>
<li>用户交互事件（如鼠标点击、滚动页面、放大缩小等）；</li>
<li>JavaScript 脚本执行事件；</li>
<li>网络请求完成、文件读写完成事件。</li>
</ol>
<ul>
<li>为了协调这些任务有条不紊地在主线程上执行，页面进程引入了消息队列和事件循环机制，渲染进程内部会维护多个消息队列，比如延迟执行队列和普通的消息队列。</li>
<li>然后主线程采用一个 for 循环，不断地从这些任务队列中取出任务并执行任务。我们把这些消息队列中的任务称为宏任务。</li>
<li>页面的渲染事件、各种 IO 的完成事件、执行 JavaScript 脚本的事件、用户交互的事件等都随时有可能被添加到消息队列中，而且添加事件是由系统操作的，JavaScript 代码不能准确掌控任务要添加到队列中的位置，控制不了任务在消息队列中的位置，所以很难控制开始执行任务的时间。</li>
<li>宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合了，比如后面要介绍的监听 DOM 变化的需求。<h3 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h3></li>
<li>异步回调的概念，其主要有两种方式</li>
</ul>
<ol>
<li>第一种是把异步回调函数封装成一个宏任务，添加到消息队列尾部，当循环系统执行到该任务的时候执行回调函数。这种比较好理解，我们前面介绍的 setTimeout 和 XMLHttpRequest 的回调函数都是通过这种方式来实现的。</li>
<li>第二种方式的执行时机是在主函数执行结束之后、当前宏任务结束之前执行回调函数，这通常都是以微任务形式体现的。</li>
</ol>
<ul>
<li>微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。</li>
<li>当 JavaScript 执行一段脚本的时候，V8 会为其创建一个全局执行上下文，在创建全局执行上下文的同时，V8 引擎也会在内部创建一个微任务队列。顾名思义，这个微任务队列就是用来存放微任务的，因为在当前宏任务执行的过程中，有时候会产生多个微任务，这时候就需要使用这个微任务队列来保存这些微任务了。不过这个微任务队列是给 V8 引擎内部使用的，所以你是无法通过 JavaScript 直接访问的。</li>
<li>在现代浏览器里面，产生微任务有两种方式。</li>
</ul>
<ol>
<li>第一种方式是使用 MutationObserver 监控某个 DOM 节点，然后再通过 JavaScript 来修改这个节点，或者为这个节点添加、删除部分子节点，当 DOM 节点发生变化时，就会产生 DOM 变化记录的微任务。</li>
<li>第二种方式是使用 Promise，当调用 Promise.resolve() 或者 Promise.reject() 的时候，也会产生微任务。</li>
</ol>
<ul>
<li>通常情况下，在当前宏任务中的 JavaScript 快执行完成时，也就在 JavaScript 引擎准备退出全局执行上下文并清空调用栈的时候，JavaScript 引擎会检查全局执行上下文中的微任务队列，然后按照顺序执行队列中的微任务。WHATWG 把执行微任务的时间点称为检查点。当然除了在退出全局执行上下文式这个检查点之外，还有其他的检查点。</li>
<li>如果在执行微任务的过程中，产生了新的微任务，同样会将该微任务添加到微任务队列中，V8 引擎一直循环执行微任务队列中的任务，直到队列为空才算执行结束。也就是说在执行微任务过程中产生的新的微任务并不会推迟到下个宏任务中执行，而是在当前的宏任务中继续执行。<h3 id="监听-DOM-变化方法演变"><a href="#监听-DOM-变化方法演变" class="headerlink" title="监听 DOM 变化方法演变"></a>监听 DOM 变化方法演变</h3></li>
<li>早期页面并没有提供对监听的支持，所以那时要观察 DOM 是否变化，唯一能做的就是轮询检测，比如使用 setTimeout 或者 setInterval 来定时检测 DOM 是否有改变。这种方式简单粗暴，但是会遇到两个问题：如果时间间隔设置过长，DOM 变化响应不够及时；反过来如果时间间隔设置过短，又会浪费很多无用的工作量去检查 DOM，会让页面变得低效。</li>
<li>直到 2000 年的时候引入了 Mutation Event，Mutation Event 采用了观察者的设计模式，当 DOM 有变动时就会立刻触发相应的事件，这种方式属于同步回调。</li>
<li>采用 Mutation Event 解决了实时性的问题，因为 DOM 一旦发生变化，就会立即调用 JavaScript 接口。但也正是这种实时性造成了严重的性能问题，因为每次 DOM 变动，渲染引擎都会去调用 JavaScript，这样会产生较大的性能开销。</li>
<li>为了解决了 Mutation Event 由于同步调用 JavaScript 而造成的性能问题，从 DOM4 开始，推荐使用 MutationObserver 来代替 Mutation Event。MutationObserver API 可以用来监视 DOM 的变化，包括属性的变化、节点的增减、内容的变化等。</li>
</ul>
<ol>
<li>MutationObserver 将响应函数改成异步调用，可以不用在每次 DOM 变化都触发异步调用，而是等多次 DOM 变化后，一次触发异步调用，并且还会使用一个数据结构来记录这期间所有的 DOM 变化。这样即使频繁地操纵 DOM，也不会对性能造成太大的影响。</li>
<li>在每次 DOM 节点发生变化的时候，渲染引擎将变化记录封装成微任务，并将微任务添加进当前的微任务队列中。这样当执行到检查点的时候，V8 引擎就会按照顺序执行微任务了。</li>
<li>综上所述， MutationObserver 采用了“异步 + 微任务”的策略。通过异步操作解决了同步操作的性能问题；通过微任务解决了实时性的问题。</li>
</ol>
<h2 id="async-await：使用同步的方式去写异步代码"><a href="#async-await：使用同步的方式去写异步代码" class="headerlink" title="async/await：使用同步的方式去写异步代码"></a>async/await：使用同步的方式去写异步代码</h2><ul>
<li>ES7 引入了 async/await，这是 JavaScript 异步编程的一个重大改进，提供了在不阻塞主线程的情况下使用同步代码实现异步访问资源的能力，并且使得代码逻辑更加清晰。</li>
<li>async 是一个通过异步执行并隐式返回 Promise 作为结果的函数。</li>
</ul>
<h3 id="生成器-VS-协程"><a href="#生成器-VS-协程" class="headerlink" title="生成器 VS 协程"></a>生成器 VS 协程</h3><ul>
<li><p>生成器函数是一个带星号函数，而且是可以暂停执行和恢复执行的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function* genDemo() &#123;</span><br><span class="line">    console.log(&quot;开始执行第一段&quot;)</span><br><span class="line">    yield &apos;generator 2&apos;</span><br><span class="line"></span><br><span class="line">    console.log(&quot;开始执行第二段&quot;)</span><br><span class="line">    yield &apos;generator 2&apos;</span><br><span class="line"></span><br><span class="line">    console.log(&quot;开始执行第三段&quot;)</span><br><span class="line">    yield &apos;generator 2&apos;</span><br><span class="line"></span><br><span class="line">    console.log(&quot;执行结束&quot;)</span><br><span class="line">    return &apos;generator 2&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(&apos;main 0&apos;)</span><br><span class="line">let gen = genDemo()</span><br><span class="line">console.log(gen.next().value)</span><br><span class="line">console.log(&apos;main 1&apos;)</span><br><span class="line">console.log(gen.next().value)</span><br><span class="line">console.log(&apos;main 2&apos;)</span><br><span class="line">console.log(gen.next().value)</span><br><span class="line">console.log(&apos;main 3&apos;)</span><br><span class="line">console.log(gen.next().value)</span><br><span class="line">console.log(&apos;main 4&apos;)</span><br><span class="line">执行上面这段代码，观察输出结果，你会发现函数 genDemo 并不是一次执行完的，全局代码和 genDemo 函数交替执行。其实这就是生成器函数的特性，可以暂停执行，也可以恢复执行。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">可以看出来协程的四点规则：</span><br><span class="line">1.通过调用生成器函数 genDemo 来创建一个协程 gen，创建之后，gen 协程并没有立即执行。</span><br><span class="line">2.要让 gen 协程执行，需要通过调用 gen.next。</span><br><span class="line">3.当协程正在执行的时候，可以通过 yield 关键字来暂停 gen 协程的执行，并返回主要信息给父协程。</span><br><span class="line">4.如果协程在执行期间，遇到了 return 关键字，那么 JavaScript 引擎会结束当前协程，并将 return 后面的内容返回给父协程。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gen 协程和父协程是在主线程上交互执行的，并不是并发执行的，它们之前的切换是通过 yield 和 gen.next 来配合完成的。</span><br><span class="line">当在 gen 协程中调用了 yield 方法时，JavaScript 引擎会保存 gen 协程当前的调用栈信息，并恢复父协程的调用栈信息。同样，当在父协程中执行 gen.next 时，JavaScript 引擎会保存父协程的调用栈信息，并恢复 gen 协程的调用栈信息。</span><br></pre></td></tr></table></figure>
</li>
<li><p>一个线程上可以存在多个协程，但是在线程上同时只能执行一个协程，比如当前执行的是 A 协程，要启动 B 协程，那么 A 协程就需要将主线程的控制权交给 B 协程，这就体现在 A 协程暂停执行，B 协程恢复执行；同样，也可以从 B 协程中启动 A 协程。通常，如果从 A 协程启动 B 协程，我们就把 A 协程称为 B 协程的父协程。</p>
</li>
<li><p>正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。最重要的是，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">//foo函数</span><br><span class="line">function* foo() &#123;</span><br><span class="line">    let response1 = yield fetch(&apos;https://www.geekbang.org&apos;)</span><br><span class="line">    console.log(&apos;response1&apos;)</span><br><span class="line">    console.log(response1)</span><br><span class="line">    let response2 = yield fetch(&apos;https://www.geekbang.org/test&apos;)</span><br><span class="line">    console.log(&apos;response2&apos;)</span><br><span class="line">    console.log(response2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//执行foo函数的代码</span><br><span class="line">let gen = foo()</span><br><span class="line">function getGenPromise(gen) &#123;</span><br><span class="line">    return gen.next().value</span><br><span class="line">&#125;</span><br><span class="line">getGenPromise(gen).then((response) =&gt; &#123;</span><br><span class="line">    console.log(&apos;response1&apos;)</span><br><span class="line">    console.log(response)</span><br><span class="line">    return getGenPromise(gen)</span><br><span class="line">&#125;).then((response) =&gt; &#123;</span><br><span class="line">    console.log(&apos;response2&apos;)</span><br><span class="line">    console.log(response)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">面我们就来分析下这段代码是如何工作的。</span><br><span class="line">1.首先执行的是let gen = foo()，创建了 gen 协程。</span><br><span class="line">2.然后在父协程中通过执行 gen.next 把主线程的控制权交给 gen 协程。</span><br><span class="line">3.gen 协程获取到主线程的控制权后，就调用 fetch 函数创建了一个 Promise 对象 response1，然后通过 yield 暂停 gen 协程的执行，并将 response1 返回给父协程。</span><br><span class="line">4.父协程恢复执行后，调用 response1.then 方法等待请求结果。</span><br><span class="line">5.等通过 fetch 发起的请求完成之后，会调用 then 中的回调函数，then 中的回调函数拿到结果之后，通过调用 gen.next 放弃主线程的控制权，将控制权交 gen 协程继续执行下个请求。</span><br></pre></td></tr></table></figure>
</li>
<li><p>通常，我们把执行生成器的代码封装成一个函数，并把这个执行生成器代码的函数称为执行器（可参考著名的 co 框架），如下面这种方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">function* foo() &#123;</span><br><span class="line">    let response1 = yield fetch(&apos;https://www.geekbang.org&apos;)</span><br><span class="line">    console.log(&apos;response1&apos;)</span><br><span class="line">    console.log(response1)</span><br><span class="line">    let response2 = yield fetch(&apos;https://www.geekbang.org/test&apos;)</span><br><span class="line">    console.log(&apos;response2&apos;)</span><br><span class="line">    console.log(response2)</span><br><span class="line">&#125;</span><br><span class="line">co(foo());</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Chrome开发者工具：利用网络面板做性能分析"><a href="#Chrome开发者工具：利用网络面板做性能分析" class="headerlink" title="Chrome开发者工具：利用网络面板做性能分析"></a>Chrome开发者工具：利用网络面板做性能分析</h2><h3 id="单个资源的时间线"><a href="#单个资源的时间线" class="headerlink" title="单个资源的时间线"></a>单个资源的时间线</h3><ul>
<li>我们介绍过发起一个 HTTP 请求之后，浏览器首先查找缓存，如果缓存没有命中，那么继续发起 DNS 请求获取 IP 地址，然后利用 IP 地址和服务器端建立 TCP 连接，再发送 HTTP 请求，等待服务器响应；不过，如果服务器响应头中包含了重定向的信息，那么整个流程就需要重新再走一遍。这就是在浏览器中一个 HTTP 请求的基础流程。</li>
<li>当浏览器发起一个请求的时候，会有很多原因导致该请求不能被立即执行，而是需要排队等待。导致请求处于排队状态的原因有很多。</li>
</ul>
<ol>
<li>首先，页面中的资源是有优先级的，比如 CSS、HTML、JavaScript 等都是页面中的核心文件，所以优先级最高；而图片、视频、音频这类资源就不是核心资源，优先级就比较低。通常当后者遇到前者时，就需要“让路”，进入待排队状态。</li>
<li>其次，我们前面也提到过，浏览器会为每个域名最多维护 6 个 TCP 连接，如果发起一个 HTTP 请求时，这 6 个 TCP 连接都处于忙碌状态，那么这个请求就会处于排队状态</li>
<li>最后，网络进程在为数据分配磁盘空间时，新的 HTTP 请求也需要短暂地等待磁盘分配结束。</li>
</ol>
<ul>
<li>等待排队完成之后，就要进入发起连接的状态了。不过在发起连接之前，还有一些原因可能导致连接过程被推迟，这个推迟就表现在面板中的 Stalled 上，它表示停滞的意思。</li>
<li>这里需要额外说明的是，如果你使用了代理服务器，还会增加一个 Proxy Negotiation 阶段，也就是代理协商阶段，它表示代理服务器连接协商所用的时间。</li>
<li>接下来，就到了 Initial connection/SSL 阶段了，也就是和服务器建立连接的阶段，这包括了建立 TCP 连接所花费的时间；不过如果你使用了 HTTPS 协议，那么还需要一个额外的 SSL 握手时间，这个过程主要是用来协商一些加密信息的。</li>
<li>和服务器建立好连接之后，网络进程会准备请求数据，并将其发送给网络，这就是 Request sent 阶段。通常这个阶段非常快，因为只需要把浏览器缓冲区的数据发送出去就结束了，并不需要判断服务器是否接收到了，所以这个时间通常不到 1 毫秒。</li>
<li>数据发送出去了，接下来就是等待接收服务器第一个字节的数据，这个阶段称为 Waiting (TTFB)，通常也称为“第一字节时间”。 TTFB 是反映服务端响应速度的重要指标，对服务器来说，TTFB 时间越短，就说明服务器响应越快。</li>
<li>接收到第一个字节之后，进入陆续接收完整数据的阶段，也就是 Content Download 阶段，这意味着从第一字节时间到接收到全部响应数据所用的时间。<h3 id="优化时间线上耗时项"><a href="#优化时间线上耗时项" class="headerlink" title="优化时间线上耗时项"></a>优化时间线上耗时项</h3></li>
<li>排队（Queuing）时间过久</li>
</ul>
<ol>
<li>排队时间过久，大概率是由浏览器为每个域名最多维护 6 个连接导致的。那么基于这个原因，你就可以让 1 个站点下面的资源放在多个域名下面，比如放到 3 个域名下面，这样就可以同时支持 18 个连接了，这种方案称为域名分片技术。</li>
<li>还可以把站点升级到 HTTP2，因为 HTTP2 已经没有每个域名最多维护 6 个 TCP 连接的限制了。</li>
</ol>
<ul>
<li>第一字节时间（TTFB）时间过久，这可能的原因有如下：</li>
</ul>
<ol>
<li>服务器生成页面数据的时间过久。对于动态网页来说，服务器收到用户打开一个页面的请求时，首先要从数据库中读取该页面需要的数据，然后把这些数据传入到模板中，模板渲染后，再返回给用户。服务器在处理这个数据的过程中，可能某个环节会出问题。</li>
<li>网络的原因。比如使用了低带宽的服务器，或者本来用的是电信的服务器，可联通的网络用户要来访问你的服务器，这样也会拖慢网速。</li>
<li>发送请求头时带上了多余的用户信息。比如一些不必要的 Cookie 信息，服务器接收到这些 Cookie 信息之后可能需要对每一项都做处理，这样就加大了服务器的处理时长</li>
</ol>
<ul>
<li>Content Download 时间过久</li>
</ul>
<ol>
<li>如果单个请求的 Content Download 花费了大量时间，有可能是字节数太多的原因导致的。这时候你就需要减少文件大小，比如压缩、去掉源码中不必要的注释等方法。</li>
</ol>
<h2 id="DOM树：JavaScript是如何影响DOM树构建的？"><a href="#DOM树：JavaScript是如何影响DOM树构建的？" class="headerlink" title="DOM树：JavaScript是如何影响DOM树构建的？"></a>DOM树：JavaScript是如何影响DOM树构建的？</h2><h3 id="什么是-DOM"><a href="#什么是-DOM" class="headerlink" title="什么是 DOM"></a>什么是 DOM</h3><ul>
<li>在渲染引擎中，DOM 有三个层面的作用。</li>
</ul>
<ol>
<li>从页面的视角来看，DOM 是生成页面的基础数据结构。</li>
<li>从 JavaScript 脚本视角来看，DOM 提供给 JavaScript 脚本操作的接口，通过这套接口，JavaScript 可以对 DOM 结构进行访问，从而改变文档的结构、样式和内容</li>
<li>从安全视角来看，DOM 是一道安全防护线，一些不安全的内容在 DOM 解析阶段就被拒之门外了。<h3 id="DOM-树如何生成"><a href="#DOM-树如何生成" class="headerlink" title="DOM 树如何生成"></a>DOM 树如何生成</h3></li>
</ol>
<ul>
<li>在渲染引擎内部，有一个叫 HTML 解析器（HTMLParser）的模块，它的职责就是负责将 HTML 字节流转换为 DOM 结构。</li>
<li>HTML 解析器并不是等整个文档加载完成之后再解析的，而是网络进程加载了多少数据，HTML 解析器便解析多少数据。</li>
<li>网络进程接收到响应头之后，会根据响应头中的 content-type 字段来判断文件的类型，比如 content-type 的值是“text/html”，那么浏览器就会判断这是一个 HTML 类型的文件，然后为该请求选择或者创建一个渲染进程。渲染进程准备好之后，网络进程和渲染进程之间会建立一个共享数据的管道，网络进程接收到数据后就往这个管道里面放，而渲染进程则从管道的另外一端不断地读取数据，并同时将读取的数据“喂”给 HTML 解析器。你可以把这个管道想象成一个“水管”，网络进程接收到的字节流像水一样倒进这个“水管”，而“水管”的另外一端是渲染进程的 HTML 解析器，它会动态接收字节流，并将其解析为 DOM。</li>
<li>字节流转换为 DOM 需要三个阶段：</li>
</ul>
<ol>
<li>第一个阶段，通过分词器将字节流转换为 Token。V8 编译 JavaScript 过程中的第一步是做词法分析，将 JavaScript 先分解为一个个 Token。解析 HTML 也是一样的，需要通过分词器先将字节流转换为一个个 Token，分为 Tag Token 和文本 Token。<br>Tag Token 又分 StartTag 和 EndTag，比如<body>就是 StartTag ，</body>就是EndTag。</li>
</ol>
<ul>
<li>至于后续的第二个和第三个阶段是同步进行的，需要将 Token 解析为 DOM 节点，并将 DOM 节点添加到 DOM 树中。</li>
<li>HTML 解析器维护了一个 Token 栈结构，该 Token 栈主要用来计算节点之间的父子关系，在第一个阶段中生成的 Token 会被按照顺序压到这个栈中。具体的处理规则如下所示：</li>
</ul>
<ol>
<li>如果压入到栈中的是 StartTag Token，HTML 解析器会为该 Token 创建一个 DOM 节点，然后将该节点加入到 DOM 树中，它的父节点就是栈中相邻的那个元素生成的节点。</li>
<li>如果分词器解析出来是文本 Token，那么会生成一个文本节点，然后将该节点加入到 DOM 树中，文本 Token 是不需要压入到栈中，它的父节点就是当前栈顶 Token 所对应的 DOM 节点。</li>
<li>如果分词器解析出来的是 EndTag 标签，比如是 EndTag div，HTML 解析器会查看 Token 栈顶的元素是否是 StarTag div，如果是，就将 StartTag  div 从栈中弹出，表示该 div 元素解析完成。</li>
</ol>
<ul>
<li>通过分词器产生的新 Token 就这样不停地压栈和出栈，整个解析过程就这样一直持续下去，直到分词器将所有字节流分词完成。</li>
<li>为了更加直观地理解整个过程，下面我们结合一段 HTML 代码（如下），来一步步分析 DOM 树的生成过程。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;1&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;test&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这段代码以字节流的形式传给了 HTML 解析器，经过分词器处理，解析出来的第一个 Token 是 StartTag html，解析出来的 Token 会被压入到栈中，并同时创建一个 html 的 DOM 节点，将其加入到 DOM 树中。</span><br><span class="line"></span><br><span class="line">HTML 解析器开始工作时，会默认创建了一个根为 document 的空 DOM 结构，同时会将一个 StartTag document 的 Token 压入栈底。然后经过分词器解析出来的第一个 StartTag html Token 会被压入到栈中，并创建一个 html 的 DOM 节点，添加到 document 上</span><br><span class="line"></span><br><span class="line">然后按照同样的流程解析出来 StartTag body 和 StartTag div，</span><br><span class="line"></span><br><span class="line">接下来解析出来的是第一个 div 的文本 Token，渲染引擎会为该 Token 创建一个文本节点，并将该 Token 添加到 DOM 中，它的父节点就是当前 Token 栈顶元素对应的节点</span><br><span class="line"></span><br><span class="line">再接下来，分词器解析出来第一个 EndTag div，这时候 HTML 解析器会去判断当前栈顶的元素是否是 StartTag div，如果是则从栈顶弹出 StartTag div</span><br><span class="line"></span><br><span class="line">不过在实际生产环境中，HTML 源文件中既包含 CSS 和 JavaScript，又包含图片、音频、视频等文件，所以处理过程远比上面这个示范 Demo 复杂。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="JavaScript-是如何影响-DOM-生成的"><a href="#JavaScript-是如何影响-DOM-生成的" class="headerlink" title="JavaScript 是如何影响 DOM 生成的"></a>JavaScript 是如何影响 DOM 生成的</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;1&lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">    let div1 = document.getElementsByTagName(&apos;div&apos;)[0]</span><br><span class="line">    div1.innerText = &apos;time.geekbang&apos;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">    &lt;div&gt;test&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在两段 div 中间插入了一段 JavaScript 脚本，这段脚本的解析过程就有点不一样了。&lt;script&gt;标签之前，所有的解析流程还是和之前介绍的一样，但是解析到&lt;script&gt;标签时，渲染引擎判断这是一段脚本，此时 HTML 解析器就会暂停 DOM 的解析，因为接下来的 JavaScript 可能要修改当前已经生成的 DOM 结构。</span><br><span class="line"></span><br><span class="line">这时候 HTML 解析器暂停工作，JavaScript 引擎介入，并执行 script 标签中的这段脚本，因为这段 JavaScript 脚本修改了 DOM 中第一个 div 中的内容，所以执行这段脚本之后，div 节点内容已经修改为 time.geekbang 了。脚本执行完成之后，HTML 解析器恢复解析过程，继续解析后续的内容，直至生成最终的 DOM。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//foo.js</span><br><span class="line">let div1 = document.getElementsByTagName(&apos;div&apos;)[0]</span><br><span class="line">div1.innerText = &apos;time.geekbang&apos;</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;1&lt;/div&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot; src=&apos;foo.js&apos;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;div&gt;test&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">这段代码的功能还是和前面那段代码是一样的，不过这里把内嵌 JavaScript 脚本修改成了通过 JavaScript 文件加载。其整个执行流程还是一样的，执行到 JavaScript 标签时，暂停整个 DOM 的解析，执行 JavaScript 代码，不过这里执行 JavaScript 时，需要先下载这段 JavaScript 代码。</span><br><span class="line"></span><br><span class="line">这里需要重点关注下载环境，因为 JavaScript 文件的下载过程会阻塞 DOM 解析，而通常下载又是非常耗时的，会受到网络环境、JavaScript 文件大小等因素的影响。</span><br><span class="line"></span><br><span class="line">不过 Chrome 浏览器做了很多优化，其中一个主要的优化是预解析操作。当渲染引擎收到字节流之后，会开启一个预解析线程，用来分析 HTML 文件中包含的 JavaScript、CSS 等相关文件，解析到相关文件之后，预解析线程会提前下载这些文件。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">再回到 DOM 解析上，我们知道引入 JavaScript 线程会阻塞 DOM，不过也有一些相关的策略来规避，比如使用 CDN 来加速 JavaScript 文件的加载，压缩 JavaScript 文件的体积。另外，如果 JavaScript 文件中没有操作 DOM 相关代码，就可以将该 JavaScript 脚本设置为异步加载，通过 async 或 defer 来标记代码，使用方式如下所示：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script async type=&quot;text/javascript&quot; src=&apos;foo.js&apos;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script defer type=&quot;text/javascript&quot; src=&apos;foo.js&apos;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">async 和 defer 虽然都是异步的，不过还有一些差异，使用 async 标志的脚本文件一旦加载完成，会立即执行；</span><br><span class="line">而使用了 defer 标记的脚本文件，需要在 DOMContentLoaded 事件之前执行。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">现在我们知道了 JavaScript 是如何阻塞 DOM 解析的了，那接下来我们再来结合文中代码看看另外一种情况：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//theme.css</span><br><span class="line">div &#123;color:blue&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;style src=&apos;theme.css&apos;&gt;&lt;/style&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;1&lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">            let div1 = document.getElementsByTagName(&apos;div&apos;)[0]</span><br><span class="line">            div1.innerText = &apos;time.geekbang&apos; //需要DOM</span><br><span class="line">            div1.style.color = &apos;red&apos;  //需要CSSOM</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">    &lt;div&gt;test&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">该示例中，JavaScript 代码出现了 div1.style.color = ‘red&apos; 的语句，它是用来操纵 CSSOM 的，所以在执行 JavaScript 之前，需要先解析 JavaScript 语句之上所有的 CSS 样式。所以如果代码里引用了外部的 CSS 文件，那么在执行 JavaScript 之前，还需要等待外部的 CSS 文件下载完成，并解析生成 CSSOM 对象之后，才能执行 JavaScript 脚本。</span><br><span class="line"></span><br><span class="line">而 JavaScript 引擎在解析 JavaScript 之前，是不知道 JavaScript 是否操纵了 CSSOM 的，所以渲染引擎在遇到 JavaScript 脚本时，不管该脚本是否操纵了 CSSOM，都会执行 CSS 文件下载，解析操作，再执行 JavaScript 脚本。</span><br><span class="line"></span><br><span class="line">所以说 JavaScript 脚本是依赖样式表的，这又多了一个阻塞过程。JavaScript 会阻塞 DOM 生成，而样式文件又会阻塞 JavaScript 的执行。</span><br></pre></td></tr></table></figure>
<h2 id="渲染流水线：CSS如何影响首次加载时的白屏时间？"><a href="#渲染流水线：CSS如何影响首次加载时的白屏时间？" class="headerlink" title="渲染流水线：CSS如何影响首次加载时的白屏时间？"></a>渲染流水线：CSS如何影响首次加载时的白屏时间？</h2><h3 id="渲染流水线视角下的-CSS"><a href="#渲染流水线视角下的-CSS" class="headerlink" title="渲染流水线视角下的 CSS"></a>渲染流水线视角下的 CSS</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//theme.css</span><br><span class="line">div&#123; </span><br><span class="line">    color : coral;</span><br><span class="line">    background-color:black</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;link href=&quot;theme.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;geekbang com&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">首先是发起主页面的请求，这个发起请求方可能是渲染进程，也有可能是浏览器进程，发起的请求被送到网络进程中去执行。</span><br><span class="line">网络进程接收到返回的 HTML 数据之后，将其发送给渲染进程，渲染进程会解析 HTML 数据并构建 DOM。</span><br><span class="line">这里你需要特别注意下，请求 HTML 数据和构建 DOM 中间有一段空闲时间，这个空闲时间有可能成为页面渲染的瓶颈。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">当渲染进程接收 HTML 文件字节流时，会先开启一个预解析线程，如果遇到 JavaScript 文件或者 CSS 文件，那么预解析线程会提前下载这些数据。对于上面的代码，预解析线程会解析出来一个外部的 theme.css 文件，并发起 theme.css 的下载。</span><br><span class="line">这里也有一个空闲时间需要你注意一下，就是在 DOM 构建结束之后、theme.css 文件还未下载完成的这段时间内，渲染流水线无事可做，因为下一步是合成布局树，而合成布局树需要 CSSOM 和 DOM，所以这里需要等待 CSS 加载结束并解析成 CSSOM。</span><br></pre></td></tr></table></figure>
<h4 id="那渲染流水线为什么需要-CSSOM-呢？"><a href="#那渲染流水线为什么需要-CSSOM-呢？" class="headerlink" title="那渲染流水线为什么需要 CSSOM 呢？"></a>那渲染流水线为什么需要 CSSOM 呢？</h4><ul>
<li>和 HTML 一样，渲染引擎也是无法直接理解 CSS 文件内容的，所以需要将其解析成渲染引擎能够理解的结构，这个结构就是 CSSOM。</li>
<li>和 DOM 一样，CSSOM 也具有两个作用，第一个是提供给 JavaScript 操作样式表的能力，第二个是为布局树的合成提供基础的样式信息。这个 CSSOM 体现在 DOM 中就是document.styleSheets。</li>
<li>等 DOM 和 CSSOM 都构建好之后，渲染引擎就会构造布局树。布局树的结构基本上就是复制 DOM 树的结构，不同之处在于 DOM 树中那些不需要显示的元素会被过滤掉，如 display:none 属性的元素、head 标签、script 标签等。</li>
<li>复制好基本的布局树结构之后，渲染引擎会为对应的 DOM 元素选择对应的样式信息，这个过程就是样式计算。</li>
<li>样式计算完成之后，渲染引擎还需要计算布局树中每个元素对应的几何位置，这个过程就是计算布局。</li>
<li>通过样式计算和计算布局就完成了最终布局树的构建。再之后，就该进行后续的绘制操作了。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//theme.css</span><br><span class="line">div&#123; </span><br><span class="line">    color : coral;</span><br><span class="line">    background-color:black</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;link href=&quot;theme.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;geekbang com&lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        console.log(&apos;time.geekbang.org&apos;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">    &lt;div&gt;geekbang com&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在解析 DOM 的过程中，如果遇到了 JavaScript 脚本，那么需要先暂停 DOM 解析去执行 JavaScript，因为 JavaScript 有可能会修改当前状态下的 DOM。</span><br><span class="line">不过在执行 JavaScript 脚本之前，如果页面中包含了外部 CSS 文件的引用，或者通过 style 标签内置了 CSS 内容，那么渲染引擎还需要将这些内容转换为 CSSOM，因为 JavaScript 有修改 CSSOM 的能力，所以在执行 JavaScript 之前，还需要依赖 CSSOM。</span><br><span class="line">也就是说 CSS 在部分情况下也会阻塞 DOM 的生成。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//theme.css</span><br><span class="line">div&#123; </span><br><span class="line">    color : coral;</span><br><span class="line">    background-color:black</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//foo.js</span><br><span class="line">console.log(&apos;time.geekbang.org&apos;)</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;link href=&quot;theme.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;geekbang com&lt;/div&gt;</span><br><span class="line">    &lt;script src=&apos;foo.js&apos;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;div&gt;geekbang com&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">在接收到 HTML 数据之后的预解析过程中，HTML 预解析器识别出来了有 CSS 文件和 JavaScript 文件需要下载，然后就同时发起这两个文件的下载请求，需要注意的是，这两个文件的下载过程是重叠的，所以下载时间按照最久的那个文件来算。</span><br><span class="line"></span><br><span class="line">后面的流水线就和前面是一样的了，不管 CSS 文件和 JavaScript 文件谁先到达，都要先等到 CSS 文件下载完成并生成 CSSOM，然后再执行 JavaScript 脚本，最后再继续构建 DOM，构建布局树，绘制页面。</span><br></pre></td></tr></table></figure>
<h3 id="影响页面展示的因素以及优化策略"><a href="#影响页面展示的因素以及优化策略" class="headerlink" title="影响页面展示的因素以及优化策略"></a>影响页面展示的因素以及优化策略</h3><ul>
<li>为什么要花这么多文字来分析渲染流水线呢？主要原因就是渲染流水线影响到了首次页面展示的速度，而首次页面展示的速度又直接影响到了用户体验</li>
<li>从发起 URL 请求开始，到首次显示页面的内容，在视觉上经历的三个阶段。</li>
</ul>
<ol>
<li>第一个阶段，等请求发出去之后，到提交数据阶段，这时页面展示出来的还是之前页面的内容。</li>
<li>第二个阶段，提交数据之后渲染进程会创建一个空白页面，我们通常把这段时间称为解析白屏，并等待 CSS 文件和 JavaScript 文件的加载完成，生成 CSSOM 和 DOM，然后合成布局树，最后还要经过一系列的步骤准备首次渲染。</li>
<li>第三个阶段，等首次渲染完成之后，就开始进入完整页面的生成阶段了，然后页面会一点点被绘制出来。</li>
</ol>
<ul>
<li>影响第一个阶段的因素主要是网络或者是服务器处理这块儿,</li>
<li>第二个阶段，这个阶段的主要问题是白屏时间，通常情况下的瓶颈主要体现在下载 CSS 文件、下载 JavaScript 文件和执行 JavaScript。所以要想缩短白屏时长，可以有以下策略：</li>
</ul>
<ol>
<li>通过内联 JavaScript、内联 CSS 来移除这两种类型的文件下载，这样获取到 HTML 文件之后就可以直接开始渲染流程了。</li>
<li>并不是所有的场合都适合内联，那么还可以尽量减少文件大小，比如通过 webpack 等工具移除一些不必要的注释，并压缩 JavaScript 文件。</li>
<li>还可以将一些不需要在解析 HTML 阶段使用的 JavaScript 标记上 async 或者 defer。</li>
<li>对于大的 CSS 文件，可以通过媒体查询属性，将其拆分为多个不同用途的 CSS 文件，这样只有在特定的场景下才会加载特定的 CSS 文件。</li>
</ol>
<h2 id="分层和合成机制：为什么CSS动画比JavaScript高效？"><a href="#分层和合成机制：为什么CSS动画比JavaScript高效？" class="headerlink" title="分层和合成机制：为什么CSS动画比JavaScript高效？"></a>分层和合成机制：为什么CSS动画比JavaScript高效？</h2><h3 id="显示器是怎么显示图像的"><a href="#显示器是怎么显示图像的" class="headerlink" title="显示器是怎么显示图像的"></a>显示器是怎么显示图像的</h3><ul>
<li>每个显示器都有固定的刷新频率，通常是 60HZ，也就是每秒更新 60 张图片，更新的图片都来自于显卡中一个叫前缓冲区的地方，显示器所做的任务很简单，就是每秒固定读取 60 次前缓冲区中的图像，并将读取的图像显示到显示器上。</li>
<li>显卡的职责就是合成新的图像，并将图像保存到后缓冲区中，一旦显卡把合成的图像写到后缓冲区，系统就会让后缓冲区和前缓冲区互换，这样就能保证显示器能读取到最新显卡合成的图像。通常情况下，显卡的更新频率和显示器的刷新频率是一致的。但有时候，在一些复杂的场景中，显卡处理一张图片的速度会变慢，这样就会造成视觉上的卡顿。<h3 id="帧-VS-帧率"><a href="#帧-VS-帧率" class="headerlink" title="帧 VS 帧率"></a>帧 VS 帧率</h3></li>
<li>当你通过滚动条滚动页面，或者通过手势缩放页面时，屏幕上就会产生动画的效果。之所以你能感觉到有动画的效果，是因为在滚动或者缩放操作时，渲染引擎会通过渲染流水线生成新的图片，并发送到显卡的后缓冲区。</li>
<li>大多数设备屏幕的更新频率是 60 次 / 秒，这也就意味着正常情况下要实现流畅的动画效果，渲染引擎需要每秒更新 60 张图片到显卡的后缓冲区。</li>
<li>我们把渲染流水线生成的每一副图片称为一帧，把渲染流水线每秒更新了多少帧称为帧率，比如滚动过程中 1 秒更新了 60 帧，那么帧率就是 60Hz（或者 60FPS）</li>
<li>由于用户很容易观察到那些丢失的帧，如果在一次动画过程中，渲染引擎生成某些帧的时间过久，那么用户就会感受到卡顿，这会给用户造成非常不好的印象。</li>
<li>要解决卡顿问题，就要解决每帧生成时间过久的问题，为此 Chrome 对浏览器渲染方式做了大量的工作，其中最卓有成效的策略就是引入了分层和合成机制。<h3 id="如何生成一帧图像"><a href="#如何生成一帧图像" class="headerlink" title="如何生成一帧图像"></a>如何生成一帧图像</h3></li>
<li>重排、重绘和合成这三种方式的渲染路径是不同的，通常渲染路径越长，生成图像花费的时间就越多。</li>
</ul>
<ol>
<li>比如重排，它需要重新根据 CSSOM 和 DOM 来计算布局树，这样生成一幅图片时，会让整个渲染流水线的每个阶段都执行一遍，如果布局复杂的话，就很难保证渲染的效率了。</li>
<li>而重绘因为没有了重新布局的阶段，操作效率稍微高点，但是依然需要重新计算绘制信息，并触发绘制操作之后的一系列操作。</li>
<li>相较于重排和重绘，合成操作的路径就显得非常短了，并不需要触发布局和绘制两个阶段，如果采用了 GPU，那么合成的效率会非常高。</li>
</ol>
<ul>
<li>所以，关于渲染引擎生成一帧图像的几种方式，按照效率我们推荐合成方式优先，若实在不能满足需求，那么就再退后一步使用重绘或者重排的方式。</li>
<li>Chrome 中的合成技术，可以用三个词来概括总结：分层、分块和合成。<h3 id="分层和合成"><a href="#分层和合成" class="headerlink" title="分层和合成"></a>分层和合成</h3></li>
<li>通常页面的组成是非常复杂的，有的页面里要实现一些复杂的动画效果，如果没有采用分层机制，从布局树直接生成目标图片的话，那么每次页面有很小的变化时，都会触发重排或者重绘机制，这种“牵一发而动全身”的绘制策略会严重影响页面的渲染效率。</li>
<li>为了提升每帧的渲染效率，Chrome 引入了分层和合成的机制。那该怎么来理解分层和合成机制呢？</li>
</ul>
<ol>
<li>你可以把一张网页想象成是由很多个图片叠加在一起的，每个图片就对应一个图层，Chrome 合成器最终将这些图层合成了用于显示页面的图片。</li>
<li>如果你熟悉 PhotoShop 的话，就能很好地理解这个过程了，PhotoShop 中一个项目是由很多图层构成的，每个图层都可以是一张单独图片，可以设置透明度、边框阴影，可以旋转或者设置图层的上下位置，将这些图层叠加在一起后，就能呈现出最终的图片了。</li>
<li>在这个过程中，将素材分解为多个图层的操作就称为分层，最后将这些图层合并到一起的操作就称为合成。所以，分层和合成通常是一起使用的。</li>
<li>考虑到一个页面被划分为两个层，当进行到下一帧的渲染时，上面的一帧可能需要实现某些变换，如平移、旋转、缩放、阴影或者 Alpha 渐变，这时候合成器只需要将两个层进行相应的变化操作就可以了，显卡处理这些操作驾轻就熟，所以这个合成过程时间非常短。</li>
</ol>
<ul>
<li>理解了为什么要引入合成和分层机制，下面我们再来看看 Chrome 是怎么实现分层和合成机制的。</li>
</ul>
<ol>
<li>在 Chrome 的渲染流水线中，分层体现在生成布局树之后，渲染引擎会根据布局树的特点将其转换为层树（Layer Tree），层树是渲染流水线后续流程的基础结构。</li>
<li>层树中的每个节点都对应着一个图层，下一步的绘制阶段就依赖于层树中的节点。</li>
<li>绘制阶段其实并不是真正地绘出图片，而是将绘制指令组合成一个列表，比如一个图层要设置的背景为黑色，并且还要在中间画一个圆形，那么绘制过程会生成|Paint BackGroundColor:Black | Paint Circle|这样的绘制指令列表，绘制过程就完成了。</li>
<li>有了绘制列表之后，就需要进入光栅化阶段了，光栅化就是按照绘制列表中的指令生成图片。每一个图层都对应一张图片，合成线程有了这些图片之后，会将这些图片合成为“一张”图片，并最终将生成的图片发送到后缓冲区。这就是一个大致的分层、合成流程。</li>
<li>合成操作是在合成线程上完成的，这也就意味着在执行合成操作时，是不会影响到主线程执行的。这就是为什么经常主线程卡住了，但是 CSS 动画依然能执行的原因。<h3 id="分块"><a href="#分块" class="headerlink" title="分块"></a>分块</h3></li>
</ol>
<ul>
<li>如果说分层是从宏观上提升了渲染效率，那么分块则是从微观层面提升了渲染效率。</li>
<li>通常情况下，页面的内容都要比屏幕大得多，显示一个页面时，如果等待所有的图层都生成完毕，再进行合成的话，会产生一些不必要的开销，也会让合成图片的时间变得更久。</li>
<li>因此，合成线程会将每个图层分割为大小固定的图块，然后优先绘制靠近视口的图块，这样就可以大大加速页面的显示速度。不过有时候， 即使只绘制那些优先级最高的图块，也要耗费不少的时间，因为涉及到一个很关键的因素——纹理上传，这是因为从计算机内存上传到 GPU 内存的操作会比较慢。</li>
<li>为了解决这个问题，Chrome 又采取了一个策略：在首次合成图块的时候使用一个低分辨率的图片。比如可以是正常分辨率的一半，分辨率减少一半，纹理就减少了四分之三。在首次显示页面内容的时候，将这个低分辨率的图片显示出来，然后合成器继续绘制正常比例的网页内容，当正常比例的网页内容绘制完成后，再替换掉当前显示的低分辨率内容。这种方式尽管会让用户在开始时看到的是低分辨率的内容，但是也比用户在开始时什么都看不到要好。<h3 id="如何利用分层技术优化代码"><a href="#如何利用分层技术优化代码" class="headerlink" title="如何利用分层技术优化代码"></a>如何利用分层技术优化代码</h3></li>
<li><p>你可以使用 will-change 来告诉渲染引擎你会对该元素做一些特效变换，CSS 代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.box &#123;</span><br><span class="line">will-change: transform, opacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">这段代码就是提前告诉渲染引擎 box 元素将要做几何变换和透明度变换操作，这时候渲染引擎会将该元素单独实现一帧，</span><br><span class="line">等这些变换发生时，渲染引擎会通过合成线程直接去处理变换，这些变换并没有涉及到主线程，这样就大大提升了渲染的效率。</span><br><span class="line">这也是 CSS 动画比 JavaScript 动画高效的原因。</span><br></pre></td></tr></table></figure>
</li>
<li><p>所以，如果涉及到一些可以使用合成线程来处理 CSS 特效或者动画的情况，就尽量使用 will-change 来提前告诉渲染引擎，让它为该元素准备独立的层。但是凡事都有两面性，每当渲染引擎为一个元素准备一个独立层的时候，它占用的内存也会大大增加，因为从层树开始，后续每个阶段都会多一个层结构，这些都需要额外的内存，所以你需要恰当地使用 will-change。</p>
</li>
</ul>
<h2 id="页面性能：如何系统地优化页面？"><a href="#页面性能：如何系统地优化页面？" class="headerlink" title="页面性能：如何系统地优化页面？"></a>页面性能：如何系统地优化页面？</h2><ul>
<li>通常一个页面有三个阶段：加载阶段、交互阶段和关闭阶段。</li>
</ul>
<ol>
<li>加载阶段，是指从发出请求到渲染出完整页面的过程，影响到这个阶段的主要因素有网络和 JavaScript 脚本。</li>
<li>交互阶段，主要是从页面加载完成到用户交互的整合过程，影响到这个阶段的主要因素是 JavaScript 脚本。</li>
<li>关闭阶段，主要是用户发出关闭指令后页面所做的一些清理操作。<h3 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h3></li>
</ol>
<ul>
<li>图片、音频、视频等文件就不会阻塞页面的首次渲染；而 JavaScript、首次请求的 HTML 资源文件、CSS 文件是会阻塞首次渲染的，因为在构建 DOM 的过程中需要 HTML 和 JavaScript 文件，在构造渲染树的过程中需要用到 CSS 文件。</li>
<li>我们把这些能阻塞网页首次渲染的资源称为关键资源。基于关键资源，我们可以继续细化出来三个影响页面首次渲染的核心因素。</li>
</ul>
<ol>
<li>第一个是关键资源个数。关键资源个数越多，首次页面的加载时间就会越长。比如上图中的关键资源个数就是 3 个，1 个 HTML 文件、1 个 JavaScript 和 1 个 CSS 文件。</li>
<li>第二个是关键资源大小。通常情况下，所有关键资源的内容越小，其整个资源的下载时间也就越短，那么阻塞渲染的时间也就越短。上图中关键资源的大小分别是 6KB、8KB 和 9KB，那么整个关键资源大小就是 23KB。</li>
<li>第三个是请求关键资源需要多少个 RTT（Round Trip Time）。那什么是 RTT 呢？<br>当使用 TCP 协议传输一个文件时，比如这个文件大小是 0.1M，由于 TCP 的特性，这个数据并不是一次传输到服务端的，而是需要拆分成一个个数据包来回多次进行传输的。<br>RTT 就是这里的往返时延。它是网络中一个重要的性能指标，表示从发送端发送数据开始，到发送端收到来自接收端的确认，总共经历的时延。<br>通常 1 个 HTTP 的数据包在 14KB 左右，所以 1 个 0.1M 的页面就需要拆分成 8 个包来传输了，也就是说需要 8 个 RTT。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">首先是请求 HTML 资源，大小是 6KB，小于 14KB，所以 1 个 RTT 就可以解决了。</span><br><span class="line">至于 JavaScript 和 CSS 文件，这里需要注意一点，由于渲染引擎有一个预解析的线程，在接收到 HTML 数据之后，预解析线程会快速扫描 HTML 数据中的关键资源，一旦扫描到了，会立马发起请求，你可以认为 JavaScript 和 CSS 是同时发起请求的，所以它们的请求是重叠的，那么计算它们的 RTT 时，只需要计算体积最大的那个数据就可以了。这里最大的是 CSS 文件（9KB），所以我们就按照 9KB 来计算，同样由于 9KB 小于 14KB，所以 JavaScript 和 CSS 资源也就可以算成 1 个 RTT。也就是说，关键资源请求共花费了 2 个 RTT。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>总的优化原则就是减少关键资源个数，降低关键资源大小，降低关键资源的 RTT 次数。</li>
</ul>
<ol>
<li>如何减少关键资源的个数？一种方式是可以将 JavaScript 和 CSS 改成内联的形式，比如上图的 JavaScript 和 CSS，若都改成内联模式，那么关键资源的个数就由 3 个减少到了 1 个。另一种方式，如果 JavaScript 代码没有 DOM 或者 CSSOM 的操作，则可以改成 async 或者 defer 属性；同样对于 CSS，如果不是在构建页面之前加载的，则可以添加媒体取消阻止显现的标志。当 JavaScript 标签加上了 async 或者 defer、CSSlink 属性之前加上了取消阻止显现的标志后，它们就变成了非关键资源了。</li>
<li>如何减少关键资源的大小？可以压缩 CSS 和 JavaScript 资源，移除 HTML、CSS、JavaScript 文件中一些注释内容，也可以通过前面讲的取消 CSS 或者 JavaScript 中关键资源的方式。</li>
<li>如何减少关键资源 RTT 的次数？可以通过减少关键资源的个数和减少关键资源的大小搭配来实现。除此之外，还可以使用 CDN 来减少每次 RTT 时长<h3 id="交互阶段"><a href="#交互阶段" class="headerlink" title="交互阶段"></a>交互阶段</h3></li>
</ol>
<ul>
<li>如果在计算样式阶段发现有布局信息的修改，那么就会触发重排操作，然后触发后续渲染流水线的一系列操作，这个代价是非常大的。</li>
<li>同样如果在计算样式阶段没有发现有布局信息的修改，只是修改了颜色一类的信息，那么就不会涉及到布局相关的调整，所以可以跳过布局阶段，直接进入绘制阶段，这个过程叫重绘。不过重绘阶段的代价也是不小的。</li>
<li>还有另外一种情况，通过 CSS 实现一些变形、渐变、动画等特效，这是由 CSS 触发的，并且是在合成线程上执行的，这个过程称为合成。因为它不会触发重排或者重绘，而且合成操作本身的速度就非常快，所以执行合成是效率最高的方式。</li>
<li>分析下在交互阶段渲染流水线中有哪些因素影响了帧的生成速度以及如何去优化。</li>
</ul>
<ol>
<li>减少 JavaScript 脚本执行时间，针对这种情况我们可以采用以下两种策略：一种是将一次执行的函数分解为多个任务，使得每次的执行时间不要过久。另一种是采用 Web Workers。你可以把 Web Workers 当作主线程之外的一个线程，在 Web Workers 中是可以执行 JavaScript 脚本的，不过 Web Workers 中没有 DOM、CSSOM 环境，这意味着在 Web Workers 中是无法通过 JavaScript 来访问 DOM 的，所以我们可以把一些和 DOM 操作无关且耗时的任务放到 Web Workers 中去执行。</li>
<li><p>避免强制同步布局<br>所谓强制同步布局，是指 JavaScript 强制将计算样式和布局操作提前到当前的任务中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;mian_div&quot;&gt;</span><br><span class="line">        &lt;li id=&quot;time_li&quot;&gt;time&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;geekbang&lt;/li&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;p id=&quot;demo&quot;&gt;强制布局demo&lt;/p&gt;</span><br><span class="line">    &lt;button onclick=&quot;foo()&quot;&gt;添加新元素&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        function foo() &#123;</span><br><span class="line">            let main_div = document.getElementById(&quot;mian_div&quot;)      </span><br><span class="line">            let new_node = document.createElement(&quot;li&quot;)</span><br><span class="line">            let textnode = document.createTextNode(&quot;time.geekbang&quot;)</span><br><span class="line">            new_node.appendChild(textnode);</span><br><span class="line">            document.getElementById(&quot;mian_div&quot;).appendChild(new_node);</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">执行 JavaScript 添加元素是在一个任务中执行的，重新计算样式布局是在另外一个任务中执行，这就是正常情况下的布局操作。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">    let main_div = document.getElementById(&quot;mian_div&quot;)</span><br><span class="line">    let new_node = document.createElement(&quot;li&quot;)</span><br><span class="line">    let textnode = document.createTextNode(&quot;time.geekbang&quot;)</span><br><span class="line">    new_node.appendChild(textnode);</span><br><span class="line">    document.getElementById(&quot;mian_div&quot;).appendChild(new_node);</span><br><span class="line">    //由于要获取到offsetHeight，</span><br><span class="line">    //但是此时的offsetHeight还是老的数据，</span><br><span class="line">    //所以需要立即执行布局操作</span><br><span class="line">    console.log(main_div.offsetHeight)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">将新的元素添加到 DOM 之后，我们又调用了main_div.offsetHeight来获取新 main_div 的高度信息。</span><br><span class="line">如果要获取到 main_div 的高度，就需要重新布局，所以这里在获取到 main_div 的高度之前，JavaScript 还需要强制让渲染引擎默认执行一次布局操作。</span><br><span class="line">我们把这个操作称为强制同步布局。</span><br></pre></td></tr></table></figure>
</li>
<li><p>避免布局抖动<br>所谓布局抖动，是指在一次 JavaScript 执行过程中，多次执行强制布局和抖动操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">    let time_li = document.getElementById(&quot;time_li&quot;)</span><br><span class="line">    for (let i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">        let main_div = document.getElementById(&quot;mian_div&quot;)</span><br><span class="line">        let new_node = document.createElement(&quot;li&quot;)</span><br><span class="line">        let textnode = document.createTextNode(&quot;time.geekbang&quot;)</span><br><span class="line">        new_node.appendChild(textnode);</span><br><span class="line">        new_node.offsetHeight = time_li.offsetHeight;</span><br><span class="line">        document.getElementById(&quot;mian_div&quot;).appendChild(new_node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在 foo 函数内部重复执行计算样式和布局，这会大大影响当前函数的执行效率。这种情况的避免方式和强制同步布局一样，都是尽量不要在修改 DOM 结构时再去查询一些相关值。</span><br></pre></td></tr></table></figure>
</li>
<li><p>合理利用 CSS 合成动画<br>合成动画是直接在合成线程上执行的，这和在主线程上执行的布局、绘制等操作不同，如果主线程被 JavaScript 或者一些布局任务占用，CSS 动画依然能继续执行。所以要尽量利用好 CSS 合成动画，如果能让 CSS 处理动画，就尽量交给 CSS 来操作。<br>另外，如果能提前知道对某个元素执行动画操作，那就最好将其标记为 will-change，这是告诉渲染引擎需要将该元素单独生成一个图层。</p>
</li>
<li>避免频繁的垃圾回收<br>如果在一些函数中频繁创建临时对象，那么垃圾回收器也会频繁地去执行垃圾回收策略。这样当垃圾回收操作发生时，就会占用主线程，从而影响到其他任务的执行，严重的话还会让用户产生掉帧、不流畅的感觉。</li>
</ol>
<h2 id="虚拟DOM：虚拟DOM和实际的DOM有何不同？"><a href="#虚拟DOM：虚拟DOM和实际的DOM有何不同？" class="headerlink" title="虚拟DOM：虚拟DOM和实际的DOM有何不同？"></a>虚拟DOM：虚拟DOM和实际的DOM有何不同？</h2><h3 id="DOM-的缺陷"><a href="#DOM-的缺陷" class="headerlink" title="DOM 的缺陷"></a>DOM 的缺陷</h3><ul>
<li>调用document.body.appendChild(node)往 body 节点上添加一个元素，调用该 API 之后会引发一系列的连锁反应。首先渲染引擎会将 node 节点添加到 body 节点之上，然后触发样式计算、布局、绘制、栅格化、合成等任务，我们把这一过程称为重排。除了重排之外，还有可能引起重绘或者合成操作，形象地理解就是“牵一发而动全身”。另外，对于 DOM 的不当操作还有可能引发强制同步布局和布局抖动的问题，这些操作都会大大降低渲染效率。因此，对于 DOM 的操作我们时刻都需要非常小心谨慎。</li>
<li>为 DOM 结构复杂，所生成的页面结构也会很复杂，对于这些复杂的页面，执行一次重排或者重绘操作都是非常耗时的，这就给我们带来了真正的性能问题。<h3 id="什么是虚拟-DOM"><a href="#什么是虚拟-DOM" class="headerlink" title="什么是虚拟 DOM"></a>什么是虚拟 DOM</h3></li>
<li>将页面改变的内容应用到虚拟 DOM 上，而不是直接应用到 DOM 上。</li>
<li>变化被应用到虚拟 DOM 上时，虚拟 DOM 并不急着去渲染页面，而仅仅是调整虚拟 DOM 的内部状态，这样操作虚拟 DOM 的代价就变得非常轻了。</li>
<li>在虚拟 DOM 收集到足够的改变时，再把这些变化一次性应用到真实的 DOM 上。<h3 id="虚拟-DOM-到底怎么运行的"><a href="#虚拟-DOM-到底怎么运行的" class="headerlink" title="虚拟 DOM 到底怎么运行的"></a>虚拟 DOM 到底怎么运行的</h3></li>
<li>创建阶段。首先依据 JSX 和基础数据创建出来虚拟 DOM，它反映了真实的 DOM 树的结构。然后由虚拟 DOM 树创建出真实 DOM 树，真实的 DOM 树生成完后，再触发渲染流水线往屏幕输出页面。</li>
<li>新阶段。如果数据发生了改变，那么就需要根据新的数据创建一个新的虚拟 DOM 树；然后 React 比较两个树，找出变化的地方，并把变化的地方一次性更新到真实的 DOM 树上；最后渲染引擎更新渲染流水线，并生成新的页面。<h3 id="React-Fiber-更新机制。"><a href="#React-Fiber-更新机制。" class="headerlink" title="React Fiber 更新机制。"></a>React Fiber 更新机制。</h3></li>
<li>最开始的时候，比较两个虚拟 DOM 的过程是在一个递归函数里执行的，其核心算法是 reconciliation。</li>
<li>常情况下，这个比较过程执行得很快，不过当虚拟 DOM 比较复杂的时候，执行比较函数就有可能占据主线程比较久的时间，这样就会导致其他任务的等待，造成页面卡顿。</li>
<li>为了解决这个问题，React 团队重写了 reconciliation 算法，新的算法称为 Fiber reconciler，之前老的算法称为 Stack reconciler。</li>
<li>其实协程的另外一个称呼就是 Fiber，所以在这里我们可以把 Fiber 和协程关联起来，那么所谓的 Fiber reconciler ，就是在执行算法的过程中出让主线程，这样就解决了 Stack reconciler 函数占用时间过久的问题。<h4 id="双缓存"><a href="#双缓存" class="headerlink" title="双缓存"></a>双缓存</h4></li>
<li>在开发游戏或者处理其他图像的过程中，屏幕从前缓冲区读取数据然后显示。但是很多图形操作都很复杂且需要大量的运算，比如一幅完整的画面，可能需要计算多次才能完成，如果每次计算完一部分图像，就将其写入缓冲区，那么就会造成一个后果，那就是在显示一个稍微复杂点的图像的过程中，你看到的页面效果可能是一部分一部分地显示出来，因此在刷新页面的过程中，会让用户感受到界面的闪烁。</li>
<li>而使用双缓存，可以让你先将计算的中间结果存放在另一个缓冲区中，等全部的计算结束，该缓冲区已经存储了完整的图形之后，再将该缓冲区的图形数据一次性复制到显示缓冲区，这样就使得整个图像的输出非常稳定。</li>
<li>双缓存是一种经典的思路，应用在很多场合，能解决页面无效刷新和闪屏的问题，虚拟 DOM 就是双缓存思想的一种体现。<h4 id="MVC-模式"><a href="#MVC-模式" class="headerlink" title="MVC 模式"></a>MVC 模式</h4></li>
<li>其核心思想就是将数据和视图分离，也就是说视图和模型之间是不允许直接通信的，它们之间的通信都是通过控制器来完成的。</li>
<li>基于 MVC 又能衍生出很多其他的模式，如 MVP、MVVM 等，不过万变不离其宗，它们的基础骨架都是基于 MVC 而来。</li>
<li>我们可以把虚拟 DOM 看成是 MVC 的视图部分，其控制器和模型都是由 Redux 提供的。其具体实现过程如下：</li>
</ul>
<ol>
<li>控制器是用来监控 DOM 的变化，一旦 DOM 发生变化，控制器便会通知模型，让其更新数据；</li>
<li>模型数据更新好之后，控制器会通知视图，告诉它模型的数据发生了变化；</li>
<li>视图接收到更新消息之后，会根据模型所提供的数据来生成新的虚拟 DOM；</li>
<li>新的虚拟 DOM 生成好之后，就需要与之前的虚拟 DOM 进行比较，找出变化的节点；</li>
<li>比较出变化的节点之后，React 将变化的虚拟节点应用到 DOM 上，这样就会触发 DOM 节点的更新；</li>
<li>DOM 节点的变化又会触发后续一系列渲染流水线的变化，从而实现页面的更新</li>
</ol>
<h2 id="渐进式网页应用（PWA）：它究竟解决了Web应用的哪些问题？"><a href="#渐进式网页应用（PWA）：它究竟解决了Web应用的哪些问题？" class="headerlink" title="渐进式网页应用（PWA）：它究竟解决了Web应用的哪些问题？"></a>渐进式网页应用（PWA）：它究竟解决了Web应用的哪些问题？</h2><ul>
<li>它是一套理念，渐进式增强 Web 的优势，并通过技术手段渐进式缩短和本地应用或者小程序的距离。</li>
<li>Web 应用缺少离线使用能力，在离线或者在弱网环境下基本上是无法使用的。而用户需要的是沉浸式的体验，在离线或者弱网环境下能够流畅地使用是用户对一个应用的基本要求。</li>
<li>Web 应用还缺少了消息推送的能力，因为作为一个 App 厂商，需要有将消息送达到应用的能力。</li>
<li>Web 应用缺少一级入口，也就是将 Web 应用安装到桌面，在需要的时候直接从桌面打开 Web 应用，而不是每次都需要通过浏览器来打开。</li>
<li>针对以上 Web 缺陷，PWA 提出了两种解决方案：通过引入 Service Worker 来试着解决离线存储和消息推送的问题，通过引入 manifest.json 来解决一级入口的问题。</li>
<li>另外，PWA 还提供了 manifest.json 配置文件，可以让开发者自定义桌面的图标、显示名称、启动方式等信息，还可以设置启动画面、页面主题颜色等信息。<h3 id="什么是-Service-Worker"><a href="#什么是-Service-Worker" class="headerlink" title="什么是 Service Worker"></a>什么是 Service Worker</h3></li>
<li>它的主要思想是在页面和网络之间增加一个拦截器，用来缓存和拦截请求。</li>
<li>在没有安装 Service Worker 之前，WebApp 都是直接通过网络模块来请求资源的。安装了 Service Worker 模块之后，WebApp 请求资源时，会先通过 Service Worker，让它判断是返回 Service Worker 缓存的资源还是重新去网络请求资源。一切的控制权都交由 Service Worker 来处理。</li>
<li>为了避免 JavaScript 过多占用页面主线程时长的情况，浏览器实现了 Web Worker 的功能。Web Worker 的目的是让 JavaScript 能够运行在页面主线程之外，不过由于 Web Worker 中是没有当前页面的 DOM 环境的，所以在 Web Worker 中只能执行一些和 DOM 无关的 JavaScript 脚本，并通过 postMessage 方法将执行的结果返回给主线程。所以说在 Chrome 中， Web Worker 其实就是在渲染进程中开启的一个新线程，它的生命周期是和页面关联的。</li>
<li>“让其运行在主线程之外”就是 Service Worker 来自 Web Worker 的一个核心思想。不过 Web Worker 是临时的，每次 JavaScript 脚本执行完成之后都会退出，执行结果也不能保存下来，如果下次还有同样的操作，就还得重新来一遍。所以 Service Worker 需要在 Web Worker 的基础之上加上储存功能。</li>
<li>由于 Service Worker 还需要会为多个页面提供服务，所以还不能把 Service Worker 和单个页面绑定起来。在目前的 Chrome 架构中，Service Worker 是运行在浏览器进程中的，因为浏览器进程生命周期是最长的，所以在浏览器的生命周期内，能够为所有的页面提供服务。</li>
<li>消息推送也是基于 Service Worker 来实现的。因为消息推送时，浏览器页面也许并没有启动，这时就需要 Service Worker 来接收服务器推送的消息，并将消息通过一定方式展示给用户</li>
<li>HTTP 采用的是明文传输信息，存在被窃听、被篡改和被劫持的风险，在项目中使用 HTTP 来传输数据无疑是“裸奔”。所以在设计之初，就考虑对 Service Worker 采用 HTTPS 协议，因为采用 HTTPS 的通信数据都是经过加密的，即便拦截了数据，也无法破解数据内容，而且 HTTPS 还有校验机制，通信双方很容易知道数据是否被篡改。</li>
<li>除了必须要使用 HTTPS，Service Worker 还需要同时支持 Web 页面默认的安全策略、储入同源策略、内容安全策略（CSP）等</li>
</ul>
<h2 id="WebComponent：像搭积木一样构建Web应用"><a href="#WebComponent：像搭积木一样构建Web应用" class="headerlink" title="WebComponent：像搭积木一样构建Web应用"></a>WebComponent：像搭积木一样构建Web应用</h2><ul>
<li>WebComponent 是一套技术的组合，具体涉及到了 Custom elements（自定义元素）、Shadow DOM（影子 DOM）和HTML templates（HTML 模板）</li>
<li>要使用 WebComponent，通常要实现下面三个步骤。</li>
</ul>
<ol>
<li>首先，使用 template 属性来创建模板。<br>利用 DOM 可以查找到模板的内容，但是模板元素是不会被渲染到页面上的，也就是说 DOM 树中的 template 节点不会出现在布局树中，所以我们可以使用 template 来自定义一些基础的元素结构，这些基础的元素结构是可以被重复使用的。一般模板定义好之后，我们还需要在模板的内部定义样式信息。</li>
<li>其次，我们需要创建一个类。在该类的构造函数中要完成三件事：查找模板内容；创建影子 DOM；再将模板添加到影子 DOM 上。<br>影子 DOM 的作用是将模板中的内容与全局 DOM 和 CSS 进行隔离，这样我们就可以实现元素和样式的私有化了。<br>你可以把影子 DOM 看成是一个作用域，其内部的样式和元素是不会影响到全局的样式和元素的，而在全局环境下，要访问影子 DOM 内部的样式或者元素也是需要通过约定好的接口的。<br>通过影子 DOM，我们就实现了 CSS 和元素的封装，在创建好封装影子 DOM 的类之后，我们就可以使用 customElements.define 来自定义元素了</li>
<li>最后，就很简单了，可以像正常使用 HTML 元素一样使用该元素<br>影子 DOM 内部的样式是不会影响到全局 CSSOM 的。另外，使用 DOM 接口也是无法直接查询到影子 DOM 内部元素的，比如你可以使用document.getElementsByTagName(‘div’)来查找所有 div 元素，这时候你会发现影子 DOM 内部的元素都是无法查找的，因为要想查找影子 DOM 内部的元素需要专门的接口，所以通过这种方式又将影子内部的 DOM 和外部的 DOM 进行了隔离。<br>影子 DOM 的 JavaScript 脚本是不会被隔离的，比如在影子 DOM 定义的 JavaScript 函数依然可以被外部访问，这是因为 JavaScript 语言本身已经可以很好地实现组件化了。<h3 id="浏览器如何实现影子-DOM"><a href="#浏览器如何实现影子-DOM" class="headerlink" title="浏览器如何实现影子 DOM"></a>浏览器如何实现影子 DOM</h3></li>
</ol>
<ul>
<li>影子 DOM 的作用主要有以下两点：</li>
</ul>
<ol>
<li>影子 DOM 中的元素对于整个网页是不可见的；</li>
<li>影子 DOM 的 CSS 不会影响到整个网页的 CSSOM，影子 DOM 内部的 CSS 只对内部的元素起作用。</li>
</ol>
<ul>
<li>每个影子 DOM 都有一个 shadow root 的根节点，我们可以将要展示的样式或者元素添加到影子 DOM 的根节点上，每个影子 DOM 你都可以看成是一个独立的 DOM，它有自己的样式、自己的属性，内部样式不会影响到外部样式，外部样式也不会影响到内部样式。</li>
</ul>
<h2 id="HTTP-1：HTTP性能优化"><a href="#HTTP-1：HTTP性能优化" class="headerlink" title="HTTP/1：HTTP性能优化"></a>HTTP/1：HTTP性能优化</h2><h3 id="超文本传输协议-HTTP-0-9"><a href="#超文本传输协议-HTTP-0-9" class="headerlink" title="超文本传输协议 HTTP/0.9"></a>超文本传输协议 HTTP/0.9</h3><ul>
<li>HTTP/0.9 的实现有以下三个特点。</li>
</ul>
<ol>
<li>第一个是只有一个请求行，并没有 HTTP 请求头和请求体，因为只需要一个请求行就可以完整表达客户端的需求了。</li>
<li>第二个是服务器也没有返回头信息，这是因为服务器端并不需要告诉客户端太多信息，只需要返回数据就可以了。</li>
<li>第三个是返回的文件内容是以 ASCII 字符流来传输的，因为都是 HTML 格式的文件，所以使用 ASCII 字节码来传输是最合适的。<h3 id="被浏览器推动的-HTTP-1-0"><a href="#被浏览器推动的-HTTP-1-0" class="headerlink" title="被浏览器推动的 HTTP/1.0"></a>被浏览器推动的 HTTP/1.0</h3></li>
</ol>
<ul>
<li>浏览器中展示的不单是 HTML 文件了，还包括了 JavaScript、CSS、图片、音频、视频等不同类型的文件。因此支持多种类型的文件下载是 HTTP/1.0 的一个核心诉求，而且文件格式不仅仅局限于 ASCII 编码，还有很多其他类型编码的文件。</li>
<li>HTTP/1.0 引入了请求头和响应头，它们都是以为 Key-Value 形式保存的，在 HTTP 发送请求时，会带上请求头信息，服务器返回数据时，会先返回响应头信息。</li>
<li>HTTP/1.0 是怎么通过请求头和响应头来支持多种不同类型的数据呢？</li>
</ul>
<ol>
<li>首先，浏览器需要知道服务器返回的数据是什么类型的，然后浏览器才能根据不同的数据类型做针对性的处理。</li>
<li>其次，由于万维网所支持的应用变得越来越广，所以单个文件的数据量也变得越来越大。为了减轻传输性能，服务器会对数据进行压缩后再传输，所以浏览器需要知道服务器压缩的方法。</li>
<li>再次，由于万维网是支持全球范围的，所以需要提供国际化的支持，服务器需要对不同的地区提供不同的语言版本，这就需要浏览器告诉服务器它想要什么语言版本的页面。</li>
<li>最后，由于增加了各种不同类型的文件，而每种文件的编码形式又可能不一样，为了能够准确地读取文件，浏览器需要知道文件的编码类型。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 的方案是通过请求头和响应头来进行协商，在发起请求时候会通过 HTTP 请求头告诉服务器它期待服务器返回什么类型的文件、采取什么形式的压缩、提供什么语言的文件以及文件的具体编码。</span><br><span class="line">最终发送出来的请求头内容如下：</span><br><span class="line">accept: text/html   表示期望服务器返回 html 类型的文件</span><br><span class="line">accept-encoding: gzip, deflate, br   期望服务器可以采用 gzip、deflate 或者 br 其中的一种压缩方式</span><br><span class="line">accept-Charset: ISO-8859-1,utf-8  期望返回的文件编码是 UTF-8 或者 ISO-8859-1</span><br><span class="line">accept-language: zh-CN,zh  望页面的优先语言是中文。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">服务器接收到浏览器发送过来的请求头信息之后，会根据请求头的信息来准备响应数据。</span><br><span class="line">不过有时候会有一些意外情况发生，比如浏览器请求的压缩类型是 gzip，但是服务器不支持 gzip，只支持 br 压缩，那么它会通过响应头中的 content-encoding 字段告诉浏览器最终的压缩类型，也就是说最终浏览器需要根据响应头的信息来处理数据。</span><br><span class="line">下面是一段响应头的数据信息：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">content-encoding: br   表示服务器采用了 br 的压缩方法</span><br><span class="line">content-type: text/html; charset=UTF-8   表示服务器返回的是 html 文件，并且该文件的编码类型是 UTF-8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">有了响应头的信息，浏览器就会使用 br 方法来解压文件，</span><br><span class="line">再按照 UTF-8 的编码格式来处理原始文件，最后按照 HTML 的方式来解析该文件。</span><br><span class="line">这就是 HTTP/1.0 支持多文件的一个基本的处理流程。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>HTTP/1.0 除了对多文件提供良好的支持外，还依据当时实际的需求引入了很多其他的特性，这些特性都是通过请求头和响应头来实现的。</li>
</ul>
<ol>
<li>有的请求服务器可能无法处理，或者处理出错，这时候就需要告诉浏览器服务器最终处理该请求的情况，这就引入了状态码。状态码是通过响应行的方式来通知浏览器的。</li>
<li>为了减轻服务器的压力，在 HTTP/1.0 中提供了 Cache 机制，用来缓存已经下载过的数据。</li>
<li>服务器需要统计客户端的基础信息，比如 Windows 和 macOS 的用户数量分别是多少，所以 HTTP/1.0 的请求头中还加入了用户代理的字段。<h3 id="缝缝补补的-HTTP-1-1"><a href="#缝缝补补的-HTTP-1-1" class="headerlink" title="缝缝补补的 HTTP/1.1"></a>缝缝补补的 HTTP/1.1</h3></li>
</ol>
<ul>
<li>改进持久连接</li>
</ul>
<ol>
<li>HTTP/1.0 每进行一次 HTTP 通信，都需要经历建立 TCP 连接、传输 HTTP 数据和断开 TCP 连接三个阶段</li>
<li>随着浏览器普及，单个页面中的图片文件越来越多，有时候一个页面可能包含了几百个外部引用的资源文件，如果在下载每个文件的时候，都需要经历建立 TCP 连接、传输数据和断开连接这样的步骤，无疑会增加大量无谓的开销。<br>为了解决这个问题，HTTP/1.1 中增加了持久连接的方法，它的特点是在一个 TCP 连接上可以传输多个 HTTP 请求，只要浏览器或者服务器没有明确断开连接，那么该 TCP 连接会一直保持。</li>
<li>HTTP 的持久连接可以有效减少 TCP 建立连接和断开连接的次数，这样的好处是减少了服务器额外的负担，并提升整体 HTTP 的请求时长。</li>
<li>持久连接在 HTTP/1.1 中是默认开启的，所以你不需要专门为了持久连接去 HTTP 请求头设置信息，如果你不想要采用持久连接，可以在 HTTP 请求头中加上Connection: close。</li>
<li>目前浏览器中对于同一个域名，默认允许同时建立 6 个 TCP 持久连接。</li>
</ol>
<ul>
<li>不成熟的 HTTP 管线化</li>
</ul>
<ol>
<li>持久连接虽然能减少 TCP 的建立和断开次数，但是它需要等待前面的请求返回之后，才能进行下一次请求。<br>如果 TCP 通道中的某个请求因为某些原因没有及时返回，那么就会阻塞后面的所有请求，这就是著名的队头阻塞的问题。</li>
<li>HTTP/1.1 中试图通过管线化的技术来解决队头阻塞的问题。HTTP/1.1 中的管线化是指将多个 HTTP 请求整批提交给服务器的技术，虽然可以整批发送请求，不过服务器依然需要根据请求顺序来回复浏览器的请求。<br>FireFox、Chrome 都做过管线化的试验，但是由于各种原因，它们最终都放弃了管线化技术。</li>
</ol>
<ul>
<li>提供虚拟主机的支持</li>
</ul>
<ol>
<li>在 HTTP/1.0 中，每个域名绑定了一个唯一的 IP 地址，因此一个服务器只能支持一个域名。但是随着虚拟主机技术的发展，需要实现在一台物理主机上绑定多个虚拟主机，每个虚拟主机都有自己的单独的域名，这些单独的域名都公用同一个 IP 地址。</li>
<li>HTTP/1.1 的请求头中增加了 Host 字段，用来表示当前的域名地址，这样服务器就可以根据不同的 Host 值做不同的处理。</li>
</ol>
<ul>
<li>对动态生成的内容提供了完美支持</li>
</ul>
<ol>
<li>在设计 HTTP/1.0 时，需要在响应头中设置完整的数据大小，如Content-Length: 901，这样浏览器就可以根据设置的数据大小来接收数据。</li>
<li>随着服务器端的技术发展，很多页面的内容都是动态生成的，因此在传输数据之前并不知道最终的数据大小，这就导致了浏览器不知道何时会接收完所有的文件数据。</li>
<li>HTTP/1.1 通过引入 Chunk transfer 机制来解决这个问题，服务器会将数据分割成若干个任意大小的数据块，每个数据块发送时会附上上个数据块的长度，最后使用一个零长度的块作为发送数据完成的标志。这样就提供了对动态内容的支持。</li>
</ol>
<ul>
<li>客户端 Cookie、安全机制</li>
</ul>
<ol>
<li>HTTP/1.1 还引入了客户端 Cookie 机制和安全机制。</li>
</ol>
<h2 id="HTTP-2：如何提升网络速度？"><a href="#HTTP-2：如何提升网络速度？" class="headerlink" title="HTTP/2：如何提升网络速度？"></a>HTTP/2：如何提升网络速度？</h2><ul>
<li>HTTP/1.1 为网络效率做了大量的优化，最核心的有如下三种方式：</li>
</ul>
<ol>
<li>增加了持久连接；</li>
<li>浏览器为每个域名最多同时维护 6 个 TCP 持久连接；</li>
<li>使用 CDN 的实现域名分片机制。<br>引入了 CDN，并同时为每个域名维护 6 个连接，这样就大大减轻了整个资源的下载时间。<br>这里我们可以简单计算下：如果使用单个 TCP 的持久连接，下载 100 个资源所花费的时间为 100 <em> n </em> RTT；<br>若通过上面的技术，就可以把整个时间缩短为 100 <em> n </em> RTT/(6 * CDN 个数)。<br>从这个计算结果来看，我们的页面加载速度变快了不少。<h3 id="HTTP-1-1-的主要问题"><a href="#HTTP-1-1-的主要问题" class="headerlink" title="HTTP/1.1 的主要问题"></a>HTTP/1.1 的主要问题</h3></li>
</ol>
<ul>
<li>HTTP/1.1对带宽的利用率却并不理想，这也是 HTTP/1.1 的一个核心问题。</li>
<li>带宽是指每秒最大能发送或者接收的字节数。我们把每秒能发送的最大字节数称为上行带宽，每秒能够接收的最大字节数称为下行带宽。</li>
<li>之所以说 HTTP/1.1 对带宽的利用率不理想，是因为 HTTP/1.1 很难将带宽用满。比如我们常说的 100M 带宽，实际的下载速度能达到 12.5M/S，而采用 HTTP/1.1 时，也许在加载页面资源时最大只能使用到 2.5M/S，很难将 12.5M 全部用满。</li>
<li>主要是由以下三个原因导致的。</li>
</ul>
<ol>
<li>TCP 的慢启动。<br>一旦一个 TCP 连接建立之后，就进入了发送数据状态，刚开始 TCP 协议会采用一个非常慢的速度去发送数据，<br>然后慢慢加快发送数据的速度，直到发送数据的速度达到一个理想状态，我们把这个过程称为慢启动。</li>
</ol>
<p>慢启动是 TCP 为了减少网络拥塞的一种策略，我们是没有办法改变的。<br>之所以说慢启动会带来性能问题，是因为页面中常用的一些关键资源文件本来就不大，如 HTML 文件、CSS 文件和 JavaScript 文件，通常这些文件在 TCP 连接建立好之后就要发起请求的，但这个过程是慢启动，所以耗费的时间比正常的时间要多很多，这样就推迟了宝贵的首次渲染页面的时长了。</p>
<ol start="2">
<li>同时开启了多条 TCP 连接，那么这些连接会竞争固定的带宽。<br>系统同时建立了多条 TCP 连接，当带宽充足时，每条连接发送或者接收速度会慢慢向上增加；<br>而一旦带宽不足时，这些 TCP 连接又会减慢发送或者接收的速度。</li>
</ol>
<p>比如一个页面有 200 个文件，使用了 3 个 CDN，那么加载该网页的时候就需要建立 6 * 3，也就是 18 个 TCP 连接来下载资源；<br>在下载过程中，当发现带宽不足的时候，各个 TCP 连接就需要动态减慢接收数据的速度。</p>
<p>这样就会出现一个问题，因为有的 TCP 连接下载的是一些关键资源，如 CSS 文件、JavaScript 文件等，而有的 TCP 连接下载的是图片、视频等普通的资源文件，<br>但是多条 TCP 连接之间又不能协商让哪些关键资源优先下载，这样就有可能影响那些关键资源的下载速度了。</p>
<ol start="3">
<li>HTTP/1.1 队头阻塞的问题。<br>HTTP/1.1 中使用持久连接时，虽然能公用一个 TCP 管道，但是在一个管道中同一时刻只能处理一个请求，在当前的请求没有结束之前，其他的请求只能处于阻塞状态。<br>这意味着我们不能随意在一个管道中发送请求和接收内容。</li>
</ol>
<p>这是一个很严重的问题，因为阻塞请求的因素有很多，并且都是一些不确定性的因素，<br>假如有的请求被阻塞了 5 秒，那么后续排队的请求都要延迟等待 5 秒，<br>在这个等待的过程中，带宽、CPU 都被白白浪费了。</p>
<h3 id="HTTP-2-的多路复用"><a href="#HTTP-2-的多路复用" class="headerlink" title="HTTP/2 的多路复用"></a>HTTP/2 的多路复用</h3><ul>
<li>HTTP/2 的思路就是一个域名只使用一个 TCP 长连接来传输数据，这样整个页面资源的下载过程只需要一次慢启动，同时也避免了多个 TCP 连接竞争带宽所带来的问题。</li>
<li>HTTP/2 需要实现资源的并行请求，也就是任何时候都可以将请求发送给服务器，而并不需要等待其他请求的完成，然后服务器也可以随时返回处理好的请求资源给浏览器。</li>
<li>HTTP/2 最核心、最重要且最具颠覆性的多路复用机制。</li>
</ul>
<ol>
<li>每个请求都有一个对应的 ID，如 stream1 表示 index.html 的请求，stream2 表示 foo.css 的请求。这样在浏览器端，就可以随时将请求发送给服务器了。</li>
<li>服务器端接收到这些请求后，会根据自己的喜好来决定优先返回哪些内容，<br>比如服务器可能早就缓存好了 index.html 和 bar.js 的响应头信息，<br>那么当接收到请求的时候就可以立即把 index.html 和 bar.js 的响应头信息返回给浏览器，<br>然后再将 index.html 和 bar.js 的响应体数据返回给浏览器。</li>
<li>之所以可以随意发送，是因为每份数据都有对应的 ID，浏览器接收到之后，会筛选出相同 ID 的内容，将其拼接为完整的 HTTP 响应数据。</li>
<li>HTTP/2 使用了多路复用技术，可以将请求分成一帧一帧的数据去传输，<br>这样带来了一个额外的好处，就是当收到一个优先级高的请求时，比如接收到 JavaScript 或者 CSS 关键资源的请求，服务器可以暂停之前的请求来优先处理关键资源的请求。</li>
</ol>
<h3 id="多路复用的实现"><a href="#多路复用的实现" class="headerlink" title="多路复用的实现"></a>多路复用的实现</h3><ul>
<li>HTTP/2 添加了一个二进制分帧层</li>
</ul>
<ol>
<li>首先，浏览器准备好请求数据，包括了请求行、请求头等信息，如果是 POST 方法，那么还要有请求体。</li>
<li>这些数据经过二进制分帧层处理之后，会被转换为一个个带有请求 ID 编号的帧，通过协议栈将这些帧发送给服务器。</li>
<li>服务器接收到所有帧之后，会将所有相同 ID 的帧合并为一条完整的请求信息。</li>
<li>然后服务器处理该条请求，并将处理的响应行、响应头和响应体分别发送至二进制分帧层。</li>
<li>同样，二进制分帧层会将这些响应数据转换为一个个带有请求 ID 编号的帧，经过协议栈发送给浏览器。</li>
<li>浏览器接收到响应帧之后，会根据 ID 编号将帧的数据提交给对应的请求。</li>
</ol>
<ul>
<li>通过引入二进制分帧层，就实现了 HTTP 的多路复用技术。</li>
</ul>
<h3 id="HTTP-2-其他特性"><a href="#HTTP-2-其他特性" class="headerlink" title="HTTP/2 其他特性"></a>HTTP/2 其他特性</h3><ul>
<li>可以设置请求的优先级</li>
</ul>
<ol>
<li>HTTP/2 提供了请求优先级，可以在发送请求时，标上该请求的优先级，这样服务器接收到请求之后，会优先处理优先级高的请求。</li>
</ol>
<ul>
<li>服务器推送</li>
</ul>
<ol>
<li>HTTP/2 还可以直接将数据提前推送到浏览器。<br>当用户请求一个 HTML 页面之后，服务器知道该 HTML 页面会引用几个重要的 JavaScript 文件和 CSS 文件，<br>那么在接收到 HTML 请求之后，附带将要使用的 CSS 文件和 JavaScript 文件一并发送给浏览器，<br>这样当浏览器解析完 HTML 文件之后，就能直接拿到需要的 CSS 文件和 JavaScript 文件，<br>这对首次打开页面的速度起到了至关重要的作用。</li>
</ol>
<ul>
<li>头部压缩</li>
</ul>
<ol>
<li>HTTP/2 对请求头和响应头进行了压缩<br>你可能觉得一个 HTTP 的头文件没有多大，压不压缩可能关系不大，<br>但你这样想一下，在浏览器发送请求的时候，基本上都是发送 HTTP 请求头，很少有请求体的发送，<br>通常情况下页面也有 100 个左右的资源，如果将这 100 个请求头的数据压缩为原来的 20%，那么传输效率肯定能得到大幅提升。</li>
</ol>
<h2 id="HTTP-3：甩掉TCP、TLS-的包袱，构建高效网络"><a href="#HTTP-3：甩掉TCP、TLS-的包袱，构建高效网络" class="headerlink" title="HTTP/3：甩掉TCP、TLS 的包袱，构建高效网络"></a>HTTP/3：甩掉TCP、TLS 的包袱，构建高效网络</h2><ul>
<li>从目前的情况来看，HTTP/2 似乎可以完美取代 HTTP/1 了，不过 HTTP/2 依然存在一些缺陷，于是就有了 HTTP/3。和通常一样，介绍 HTTP/3 之前，我们先来看看 HTTP/2 到底有什么缺陷。<h3 id="TCP-的队头阻塞"><a href="#TCP-的队头阻塞" class="headerlink" title="TCP 的队头阻塞"></a>TCP 的队头阻塞</h3></li>
<li>虽然 HTTP/2 解决了应用层面的队头阻塞问题，不过和 HTTP/1.1 一样，HTTP/2 依然是基于 TCP 协议的，而 TCP 最初就是为了单连接而设计的</li>
<li>你可以把 TCP 连接看成是两台计算机之前的一个虚拟管道，计算机的一端将要传输的数据按照顺序放入管道，最终数据会以相同的顺序出现在管道的另外一头。</li>
<li>HTTP/1.1 协议栈中 TCP 是如何传输数据的</li>
</ul>
<ol>
<li>从一端发送给另外一端的数据会被拆分为一个个按照顺序排列的数据包</li>
<li>这些数据包通过网络传输到了接收端，接收端再按照顺序将这些数据包组合成原始数据，这样就完成了数据传输。</li>
<li>如果在数据传输的过程中，有一个数据因为网络故障或者其他原因而丢包了，那么整个 TCP 的连接就会处于暂停状态，需要等待丢失的数据包被重新传输过来。</li>
<li>你可以把 TCP 连接看成是一个按照顺序传输数据的管道，管道中的任意一个数据丢失了，那之后的数据都需要等待该数据的重新传输。</li>
</ol>
<ul>
<li>在 TCP 传输过程中，由于单个数据包的丢失而造成的阻塞称为 TCP 上的队头阻塞。</li>
<li>HTTP/2 是怎么传输多路请求的</li>
</ul>
<ol>
<li>在 HTTP/2 中，多个请求是跑在一个 TCP 管道中的，如果其中任意一路数据流中出现了丢包的情况，那么就会阻塞该 TCP 连接中的所有请求。</li>
<li>这不同于 HTTP/1.1，使用 HTTP/1.1 时，浏览器为每个域名开启了 6 个 TCP 连接，如果其中的 1 个 TCP 连接发生了队头阻塞，那么其他的 5 个连接依然可以继续传输数据。</li>
<li>所以随着丢包率的增加，HTTP/2 的传输效率也会越来越差。有测试数据表明，当系统达到了 2% 的丢包率时，HTTP/1.1 的传输效率反而比 HTTP/2 表现得更好<h3 id="TCP-建立连接的延时"><a href="#TCP-建立连接的延时" class="headerlink" title="TCP 建立连接的延时"></a>TCP 建立连接的延时</h3></li>
</ol>
<ul>
<li>网络延迟又称为 RTT（Round Trip Time）。我们把从浏览器发送一个数据包到服务器，再从服务器返回数据包到浏览器的整个往返时间称为 RTT。RTT 是反映网络性能的一个重要指标。</li>
<li>建立 TCP 连接时，需要花费多少个 RTT 呢？下面我们来计算下。</li>
</ul>
<ol>
<li>如果使用 HTTPS 的话，还需要使用 TLS 协议进行安全传输，而使用 TLS 也需要一个握手过程，这样就需要有两个握手延迟过程。</li>
<li>在建立 TCP 连接的时候，需要和服务器进行三次握手来确认连接成功，也就是说需要在消耗完 1.5 个 RTT 之后才能进行数据传输。</li>
<li>进行 TLS 连接，TLS 有两个版本——TLS1.2 和 TLS1.3，每个版本建立连接所花的时间不同，大致是需要 1～2 个 RTT</li>
<li>总之，在传输数据之前，我们需要花掉 3～4 个 RTT。如果浏览器和服务器的物理距离较近，那么 1 个 RTT 的时间可能在 10 毫秒以内，也就是说总共要消耗掉 30～40 毫秒。这个时间也许用户还可以接受，但如果服务器相隔较远，那么 1 个 RTT 就可能需要 100 毫秒以上了，这种情况下整个握手过程需要 300～400 毫秒，这时用户就能明显地感受到“慢”了。<h3 id="TCP-协议僵化"><a href="#TCP-协议僵化" class="headerlink" title="TCP 协议僵化"></a>TCP 协议僵化</h3></li>
</ol>
<ul>
<li>中间设备的僵化。</li>
</ul>
<ol>
<li>我们知道互联网是由多个网络互联的网状结构，为了能够保障互联网的正常工作，我们需要在互联网的各处搭建各种设备，这些设备就被称为中间设备。</li>
<li>这些中间设备有很多种类型，并且每种设备都有自己的目的，这些设备包括了路由器、防火墙、NAT、交换机等。它们通常依赖一些很少升级的软件，这些软件使用了大量的 TCP 特性，这些功能被设置之后就很少更新了。</li>
<li>所以，如果我们在客户端升级了 TCP 协议，但是当新协议的数据包经过这些中间设备时，它们可能不理解包的内容，于是这些数据就会被丢弃掉。这就是中间设备僵化，它是阻碍 TCP 更新的一大障碍。</li>
</ol>
<ul>
<li>除了中间设备僵化外，操作系统也是导致 TCP 协议僵化的另外一个原因。</li>
</ul>
<ol>
<li>因为 TCP 协议都是通过操作系统内核来实现的，应用程序只能使用不能修改。通常操作系统的更新都滞后于软件的更新，因此要想自由地更新内核中的 TCP 协议也是非常困难的。QUIC 协议<h3 id="QUIC-协议"><a href="#QUIC-协议" class="headerlink" title="QUIC 协议"></a>QUIC 协议</h3></li>
</ol>
<ul>
<li>HTTP/3 选择了一个折衷的方法——UDP 协议，基于 UDP 实现了类似于 TCP 的多路数据流、传输可靠性等功能，我们把这套功能称为 QUIC 协议。</li>
<li>HTTP/3 中的 QUIC 协议集合了以下几点功能。</li>
</ul>
<ol>
<li>实现了类似 TCP 的流量控制、传输可靠性的功能。虽然 UDP 不提供可靠性的传输，但 QUIC 在 UDP 的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些 TCP 中存在的特性。</li>
<li>集成了 TLS 加密功能。目前 QUIC 使用的是 TLS1.3，相较于早期版本 TLS1.3 有更多的优点，其中最重要的一点是减少了握手所花费的 RTT 个数。</li>
<li>实现了 HTTP/2 中的多路复用功能。和 TCP 不同，QUIC 实现了在同一物理连接上可以有多个独立的逻辑数据流。实现了数据流的单独传输，就解决了 TCP 中队头阻塞的问题。</li>
<li>实现了快速握手功能。由于 QUIC 是基于 UDP 的，所以 QUIC 可以实现使用 0-RTT 或者 1-RTT 来建立连接，这意味着 QUIC 可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度。<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3></li>
</ol>
<ul>
<li>HTTP/3 正是基于 QUIC 协议的，你可以把 QUIC 看成是集成了“TCP+HTTP/2 的多路复用 +TLS 等功能”的一套协议。</li>
<li>这是集众家所长的一个协议，从协议最底层对 Web 的文件传输做了比较彻底的优化，所以等生态相对成熟时，可以用来打造比现在的 HTTP/2 还更加高效的网络。</li>
</ul>
<h2 id="同源策略：为什么XMLHttpRequest不能跨域请求资源？"><a href="#同源策略：为什么XMLHttpRequest不能跨域请求资源？" class="headerlink" title="同源策略：为什么XMLHttpRequest不能跨域请求资源？"></a>同源策略：为什么XMLHttpRequest不能跨域请求资源？</h2><h3 id="什么是同源策略"><a href="#什么是同源策略" class="headerlink" title="什么是同源策略"></a>什么是同源策略</h3><ul>
<li>如果两个 URL 的协议、域名和端口都相同，我们就称这两个 URL 同源。</li>
<li>浏览器默认两个相同的源之间是可以相互访问资源和操作 DOM 的。两个不同的源之间若想要相互访问资源或者操作 DOM，那么会有一套基础的安全策略的制约，我们把这称为同源策略。</li>
<li>同源策略主要表现在 DOM、Web 数据和网络这三个层面。</li>
</ul>
<ol>
<li><p>第一个，DOM 层面。同源策略限制了来自不同源的 JavaScript 脚本对当前 DOM 对象读和写的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">let pdom = opener.document</span><br><span class="line">pdom.body.style.display = &quot;none&quot;</span><br><span class="line">&#125;</span><br><span class="line">该代码中，对象 opener 就是指向第一个页面的 window 对象，我们可以通过操作 opener 来控制第一个页面中的 DOM。</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二个，数据层面。同源策略限制了不同源的站点读取当前站点的 Cookie、IndexDB、LocalStorage 等数据。</p>
</li>
<li>第三个，网络层面。同源策略限制了通过 XMLHttpRequest 等方式将站点的数据发送给不同源的站点。</li>
</ol>
<h3 id="安全和便利性的权衡"><a href="#安全和便利性的权衡" class="headerlink" title="安全和便利性的权衡"></a>安全和便利性的权衡</h3><ul>
<li>页面中可以嵌入第三方资源</li>
</ul>
<ol>
<li>为了解决 XSS 攻击，浏览器中引入了内容安全策略，称为 CSP。</li>
<li>CSP 的核心思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联 JavaScript 代码。通过这些手段就可以大大减少 XSS 攻击。</li>
</ol>
<ul>
<li>跨域资源共享和跨文档消息机制</li>
</ul>
<ol>
<li>跨域资源共享（CORS），使用该机制可以进行跨域访问控制，从而使跨域数据传输得以安全进行。</li>
<li>在实际应用中，经常需要两个不同源的 DOM 之间进行通信，于是浏览器中又引入了跨文档消息机制，可以通过 window.postMessage 的 JavaScript 接口来和不同源的 DOM 进行通信。</li>
</ol>
<h2 id="跨站脚本攻击（XSS）：为什么Cookie中有HttpOnly属性？"><a href="#跨站脚本攻击（XSS）：为什么Cookie中有HttpOnly属性？" class="headerlink" title="跨站脚本攻击（XSS）：为什么Cookie中有HttpOnly属性？"></a>跨站脚本攻击（XSS）：为什么Cookie中有HttpOnly属性？</h2><h3 id="什么是-XSS-攻击"><a href="#什么是-XSS-攻击" class="headerlink" title="什么是 XSS 攻击"></a>什么是 XSS 攻击</h3><ul>
<li>XSS 全称是 Cross Site Scripting，为了与“CSS”区分开来，故简称 XSS，翻译过来就是“跨站脚本”。</li>
<li>XSS 攻击是指黑客往 HTML 文件中或者 DOM 中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段。</li>
<li>如果页面被注入了恶意 JavaScript 脚本，恶意脚本都能做哪些事情</li>
</ul>
<ol>
<li>可以窃取 Cookie 信息。恶意 JavaScript 可以通过“document.cookie”获取 Cookie 信息，然后通过 XMLHttpRequest 或者 Fetch 加上 CORS 功能将数据发送给恶意服务器；恶意服务器拿到用户的 Cookie 信息之后，就可以在其他电脑上模拟用户的登录，然后进行转账等操作。</li>
<li>可以监听用户行为。恶意 JavaScript 可以使用“addEventListener”接口来监听键盘事件，比如可以获取用户输入的信用卡等信息，将其发送到恶意服务器。黑客掌握了这些信息之后，又可以做很多违法的事情。</li>
<li>可以通过修改 DOM 伪造假的登录窗口，用来欺骗用户输入用户名和密码等信息。</li>
<li>还可以在页面内生成浮窗广告，这些广告会严重地影响用户体验。<h3 id="恶意脚本是怎么注入的"><a href="#恶意脚本是怎么注入的" class="headerlink" title="恶意脚本是怎么注入的"></a>恶意脚本是怎么注入的</h3></li>
</ol>
<ul>
<li>通常情况下，主要有存储型 XSS 攻击、反射型 XSS 攻击和基于 DOM 的 XSS 攻击三种方式来注入恶意脚本。</li>
</ul>
<ol>
<li>存储型 XSS 攻击<br>①首先黑客利用站点漏洞将一段恶意 JavaScript 代码提交到网站的数据库中；<br>②然后用户向网站请求包含了恶意 JavaScript 脚本的页面；<br>③当用户浏览该页面的时候，恶意脚本就会将用户的 Cookie 信息等数据上传到服务器<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">下面我们来看个例子，2015 年喜马拉雅就被曝出了存储型 XSS 漏洞。</span><br><span class="line">起因是在用户设置专辑名称时，服务器对关键字过滤不严格，比如可以将专辑名称设置为一段 JavaScript，</span><br><span class="line"></span><br><span class="line">当黑客将专辑名称设置为一段 JavaScript 代码并提交时，喜马拉雅的服务器会保存该段 JavaScript 代码到数据库中。</span><br><span class="line">然后当用户打开黑客设置的专辑时，这段代码就会在用户的页面里执行，这样就可以获取用户的 Cookie 等数据信息。</span><br><span class="line">当用户打开黑客设置的专辑页面时，服务器也会将这段恶意 JavaScript 代码返回给用户，因此这段恶意脚本就在用户的页面中执行了。</span><br><span class="line"></span><br><span class="line">恶意脚本可以通过 XMLHttpRequest 或者 Fetch 将用户的 Cookie 数据上传到黑客的服务器。</span><br><span class="line">黑客拿到了用户 Cookie 信息之后，就可以利用 Cookie 信息在其他机器上登录该用户的账号，并利用用户账号进行一些恶意操作。</span><br><span class="line"></span><br><span class="line">以上就是存储型 XSS 攻击的一个典型案例，这是乌云网在 2015 年曝出来的。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="反射型-XSS-攻击"><a href="#反射型-XSS-攻击" class="headerlink" title="反射型 XSS 攻击"></a>反射型 XSS 攻击</h3><ul>
<li>在一个反射型 XSS 攻击过程中，恶意 JavaScript 脚本属于用户发送给网站请求中的一部分，随后网站又把恶意 JavaScript 脚本返回给用户。当恶意 JavaScript 脚本在用户页面中被执行时，黑客就可以利用该脚本做一些恶意操作。</li>
<li><p>下面我们结合一个简单的 Node 服务程序来看看什么是反射型 XSS。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">首先我们使用 Node 来搭建一个简单的页面环境，搭建好的服务代码如下所示：</span><br><span class="line">var express = require(&apos;express&apos;);</span><br><span class="line">var router = express.Router();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* GET home page. */</span><br><span class="line">router.get(&apos;/&apos;, function(req, res, next) &#123;</span><br><span class="line">  res.render(&apos;index&apos;, &#123; title: &apos;Express&apos;,xss:req.query.xss &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">module.exports = router;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;title&gt;&lt;%= title %&gt;&lt;/title&gt;</span><br><span class="line">  &lt;link rel=&apos;stylesheet&apos; href=&apos;/stylesheets/style.css&apos; /&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;h1&gt;&lt;%= title %&gt;&lt;/h1&gt;</span><br><span class="line">  &lt;p&gt;Welcome to &lt;%= title %&gt;&lt;/p&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">      &lt;%- xss %&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">上面这两段代码，第一段是路由，第二段是视图，作用是将 URL 中 xss 参数的内容显示在页面。我们可以在本地演示下，比如打开http://localhost:3000/?xss=123这个链接，这样在页面中展示就是“123”了，是正常的，没有问题的。</span><br><span class="line">但当打开http://localhost:3000/?xss=&lt;script&gt;alert(&apos;你被xss攻击了&apos;)&lt;/script&gt;这段 URL 时</span><br><span class="line"></span><br><span class="line">通过这个操作，我们会发现用户将一段含有恶意代码的请求提交给 Web 服务器，Web 服务器接收到请求时，又将恶意代码反射给了浏览器端，这就是反射型 XSS 攻击。</span><br><span class="line">在现实生活中，黑客经常会通过 QQ 群或者邮件等渠道诱导用户去点击这些恶意链接，所以对于一些链接我们一定要慎之又慎。</span><br></pre></td></tr></table></figure>
</li>
<li><p>另外需要注意的是，Web 服务器不会存储反射型 XSS 攻击的恶意脚本，这是和存储型 XSS 攻击不同的地方。</p>
</li>
</ul>
<h3 id="基于-DOM-的-XSS-攻击"><a href="#基于-DOM-的-XSS-攻击" class="headerlink" title="基于 DOM 的 XSS 攻击"></a>基于 DOM 的 XSS 攻击</h3><ul>
<li>基于 DOM 的 XSS 攻击是不牵涉到页面 Web 服务器的。具体来讲，黑客通过各种手段将恶意脚本注入用户的页面中，比如通过网络劫持在页面传输过程中修改 HTML 页面的内容，这种劫持类型很多，有通过 WiFi 路由器劫持的，有通过本地恶意软件来劫持的，它们的共同点是在 Web 资源传输过程或者在用户使用页面的过程中修改 Web 页面的数据。</li>
</ul>
<h3 id="如何阻止-XSS-攻击"><a href="#如何阻止-XSS-攻击" class="headerlink" title="如何阻止 XSS 攻击"></a>如何阻止 XSS 攻击</h3><ul>
<li>存储型 XSS 攻击和反射型 XSS 攻击都是需要经过 Web 服务器来处理的，因此可以认为这两种类型的漏洞是服务端的安全漏洞。</li>
<li>而基于 DOM 的 XSS 攻击全部都是在浏览器端完成的，因此基于 DOM 的 XSS 攻击是属于前端的安全漏洞。</li>
<li>无论是何种类型的 XSS 攻击，它们都有一个共同点，那就是首先往浏览器中注入恶意脚本，然后再通过恶意脚本将用户信息发送至黑客部署的恶意服务器上。</li>
<li>一些常用的阻止 XSS 攻击的策略。</li>
</ul>
<ol>
<li><p>服务器对输入脚本进行过滤或转码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">不管是反射型还是存储型 XSS 攻击，我们都可以在服务器端将一些关键的字符进行转码，比如最典型的：</span><br><span class="line">code:&lt;script&gt;alert(&apos;你被xss攻击了&apos;)&lt;/script&gt;</span><br><span class="line">这段代码过滤后，只留下了：</span><br><span class="line">code:</span><br><span class="line">这样，当用户再次请求该页面时，由于&lt;script&gt;标签的内容都被过滤了，所以这段脚本在客户端是不可能被执行的。</span><br><span class="line">除了过滤之外，服务器还可以对这些内容进行转码，还是上面那段代码，经过转码之后，效果如下所示：</span><br><span class="line">code:&amp;lt;script&amp;gt;alert(&amp;#39;你被xss攻击了&amp;#39;)&amp;lt;/script&amp;gt;</span><br><span class="line">经过转码之后的内容，如&lt;script&gt;标签被转换为&amp;lt;script&amp;gt;，因此即使这段脚本返回给页面，页面也不会执行这段脚本。</span><br></pre></td></tr></table></figure>
</li>
<li><p>充分利用 CSP<br>虽然在服务器端执行过滤或者转码可以阻止 XSS 攻击的发生，但完全依靠服务器端依然是不够的，我们还需要把 CSP 等策略充分地利用起来，以降低 XSS 攻击带来的风险和后果。<br>实施严格的 CSP 可以有效地防范 XSS 攻击，具体来讲 CSP 有如下几个功能：<br>①限制加载其他域下的资源文件，这样即使黑客插入了一个 JavaScript 文件，这个 JavaScript 文件也是无法被加载的；<br>②禁止向第三方域提交数据，这样用户数据也不会外泄；<br>③禁止执行内联脚本和未授权的脚本；<br>④还提供了上报机制，这样可以帮助我们尽快发现有哪些 XSS 攻击，以便尽快修复问题</p>
</li>
<li>使用 HttpOnly 属性<br>由于很多 XSS 攻击都是来盗用 Cookie 的，因此还可以通过使用 HttpOnly 属性来保护我们 Cookie 的安全。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">通常服务器可以将某些 Cookie 设置为 HttpOnly 标志，HttpOnly 是服务器通过 HTTP 响应头来设置的，下面是打开 Google 时，HTTP 响应头中的一段：</span><br><span class="line"></span><br><span class="line">set-cookie: NID=189=M8q2FtWbsR8RlcldPVt7qkrqR38LmFY9jUxkKo3-4Bi6Qu_ocNOat7nkYZUTzolHjFnwBw0izgsATSI7TZyiiiaV94qGh-BzEYsNVa7TZmjAYTxYTOM9L_-0CN9ipL6cXi8l6-z41asXtm2uEwcOC5oh9djkffOMhWqQrlnCtOI; expires=Sat, 18-Apr-2020 06:52:22 GMT; path=/; domain=.google.com; HttpOnly</span><br><span class="line"></span><br><span class="line">我们可以看到，set-cookie 属性值最后使用了 HttpOnly 来标记该 Cookie。顾名思义，使用 HttpOnly 标记的 Cookie 只能使用在 HTTP 请求过程中，所以无法通过 JavaScript 来读取这段 Cookie。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">由于 JavaScript 无法读取设置了 HttpOnly 的 Cookie 数据，所以即使页面被注入了恶意 JavaScript 脚本，也是无法获取到设置了 HttpOnly 的数据。因此一些比较重要的数据我们建议设置 HttpOnly 标志。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><ul>
<li>XSS 攻击就是黑客往页面中注入恶意脚本，然后将页面的一些重要数据上传到恶意服务器。常见的三种 XSS 攻击模式是存储型 XSS 攻击、反射型 XSS 攻击和基于 DOM 的 XSS 攻击。</li>
<li>针对这些 XSS 攻击，主要有三种防范策略，第一种是通过服务器对输入的内容进行过滤或者转码，第二种是充分利用好 CSP，第三种是使用 HttpOnly 来保护重要的 Cookie 信息。</li>
<li>当然除了以上策略之外，我们还可以通过添加验证码防止脚本冒充用户提交危险操作。而对于一些不受信任的输入，还可以限制其输入长度，这样可以增大 XSS 攻击的难度。</li>
</ul>
<h2 id="CSRF攻击：陌生链接不要随便点"><a href="#CSRF攻击：陌生链接不要随便点" class="headerlink" title="CSRF攻击：陌生链接不要随便点"></a>CSRF攻击：陌生链接不要随便点</h2><ul>
<li>结合一个真实的关于 CSRF 攻击的典型案例来分析下，在 2007 年的某一天，David 无意间打开了 Gmail 邮箱中的一份邮件，并点击了该邮件中的一个链接。过了几天，David 就发现他的域名被盗了。不过几经周折，David 还是要回了他的域名，也弄清楚了他的域名之所以被盗，就是因为无意间点击的那个链接。</li>
<li>那 David 的域名是怎么被盗的呢？</li>
</ul>
<ol>
<li>首先 David 发起登录 Gmail 邮箱请求，然后 Gmail 服务器返回一些登录状态给 David 的浏览器，这些信息包括了 Cookie、Session 等，这样在 David 的浏览器中，Gmail 邮箱就处于登录状态了。</li>
<li>接着黑客通过各种手段引诱 David 去打开他的链接，比如 hacker.com，然后在 hacker.com 页面中，黑客编写好了一个邮件过滤器，并通过 Gmail 提供的 HTTP 设置接口设置好了新的邮件过滤功能，该过滤器会将 David 所有的邮件都转发到黑客的邮箱中。</li>
<li>最后的事情就很简单了，因为有了 David 的邮件内容，所以黑客就可以去域名服务商那边重置 David 域名账户的密码，重置好密码之后，就可以将其转出到黑客的账户了。<h3 id="什么是-CSRF-攻击"><a href="#什么是-CSRF-攻击" class="headerlink" title="什么是 CSRF 攻击"></a>什么是 CSRF 攻击</h3></li>
</ol>
<ul>
<li>CSRF 英文全称是 Cross-site request forgery，所以又称为“跨站请求伪造”</li>
<li>指黑客引诱用户打开黑客的网站，在黑客的网站中，利用用户的登录状态发起的跨站请求。</li>
<li>简单来讲，CSRF 攻击就是黑客利用了用户的登录状态，并通过第三方的站点来做一些坏事。</li>
<li>通常当用户打开了黑客的页面后，黑客有三种方式去实施 CSRF 攻击。</li>
</ul>
<ol>
<li><p>自动发起 Get 请求<br>黑客最容易实施的攻击方式是自动发起 Get 请求，具体攻击方式你可以参考下面这段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;h1&gt;黑客的站点：CSRF攻击演示&lt;/h1&gt;</span><br><span class="line">    &lt;img src=&quot;https://diamonds.org/sendcoin?user=hacker&amp;number=100&quot;&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这是黑客页面的 HTML 代码，在这段代码中，黑客将转账的请求接口隐藏在 img 标签内，欺骗浏览器这是一张图片资源。</span><br><span class="line">当该页面被加载时，浏览器会自动发起 img 的资源请求，如果服务器没有对该请求做判断的话，那么服务器就会认为该请求是一个转账请求，于是用户账户上的钱就被转移到黑客的账户上去了。</span><br></pre></td></tr></table></figure>
</li>
<li><p>自动发起 POST 请求</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">除了自动发送 Get 请求之外，有些服务器的接口是使用 POST 方法的，所以黑客还需要在他的站点上伪造 POST 请求，</span><br><span class="line">当用户打开黑客的站点时，是自动提交 POST 请求，具体的方式你可以参考下面示例代码：</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;h1&gt;黑客的站点：CSRF攻击演示&lt;/h1&gt;</span><br><span class="line">  &lt;form id=&apos;hacker-form&apos; action=&quot;https://diamonds.org/sendcoin&quot; method=POST&gt;</span><br><span class="line">    &lt;input type=&quot;hidden&quot; name=&quot;user&quot; value=&quot;hacker&quot; /&gt;</span><br><span class="line">    &lt;input type=&quot;hidden&quot; name=&quot;number&quot; value=&quot;100&quot; /&gt;</span><br><span class="line">  &lt;/form&gt;</span><br><span class="line">  &lt;script&gt; document.getElementById(&apos;hacker-form&apos;).submit(); &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在这段代码中，我们可以看到黑客在他的页面中构建了一个隐藏的表单，该表单的内容就是网站的转账接口。</span><br><span class="line">当用户打开该站点之后，这个表单会被自动执行提交；</span><br><span class="line">当表单被提交之后，服务器就会执行转账操作。</span><br><span class="line">因此使用构建自动提交表单这种方式，就可以自动实现跨站点 POST 数据提交。</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>引诱用户点击链接<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">除了自动发起 Get 和 Post 请求之外，还有一种方式是诱惑用户点击黑客站点上的链接，这种方式通常出现在论坛或者恶意邮件上。</span><br><span class="line">黑客会采用很多方式去诱惑用户点击链接，示例代码如下所示：</span><br><span class="line"></span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;img width=150 src=http://images.xuejuzi.cn/1612/1_161230185104_1.jpg&gt; &lt;/img&gt; &lt;/div&gt; &lt;div&gt;</span><br><span class="line">  &lt;a href=&quot;https://diamonds.org/sendcoin?user=hacker&amp;number=100&quot; taget=&quot;_blank&quot;&gt;</span><br><span class="line">    点击下载美女照片</span><br><span class="line">  &lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">这段黑客站点代码，页面上放了一张美女图片，下面放了图片下载地址，而这个下载地址实际上是黑客用来转账的接口，一旦用户点击了这个链接，那么他的钱就被转到黑客账户上了。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>和 XSS 不同的是，CSRF 攻击不需要将恶意代码注入用户的页面，仅仅是利用服务器的漏洞和用户的登录状态来实施攻击。<h3 id="如何防止-CSRF-攻击"><a href="#如何防止-CSRF-攻击" class="headerlink" title="如何防止 CSRF 攻击"></a>如何防止 CSRF 攻击</h3></li>
<li>CSRF 攻击的三个必要条件：</li>
</ul>
<ol>
<li>第一个，目标站点一定要有 CSRF 漏洞；</li>
<li>第二个，用户要登录过目标站点，并且在浏览器上保持有该站点的登录状态；</li>
<li>第三个，需要用户打开一个第三方站点，可以是黑客的站点，也可以是一些论坛。</li>
</ol>
<ul>
<li>满足以上三个条件之后，黑客就可以对用户进行 CSRF 攻击了。这里还需要额外注意一点，与 XSS 攻击不同，CSRF 攻击不会往页面注入恶意脚本，因此黑客是无法通过 CSRF 攻击来获取用户页面数据的；</li>
<li>其最关键的一点是要能找到服务器的漏洞，所以说对于 CSRF 攻击我们主要的防护手段是提升服务器的安全性。</li>
<li>要让服务器避免遭受到 CSRF 攻击，通常有以下几种途径。</li>
</ul>
<ol>
<li>充分利用好 Cookie 的 SameSite 属性<br>①黑客会利用用户的登录状态来发起 CSRF 攻击，而 Cookie 正是浏览器和服务器之间维护登录状态的一个关键数据，因此要阻止 CSRF 攻击，我们首先就要考虑在 Cookie 上来做文章。<br>②通常 CSRF 攻击都是从第三方站点发起的，要防止 CSRF 攻击，我们最好能实现从第三方站点发送请求时禁止 Cookie 的发送，因此在浏览器通过不同来源发送 HTTP 请求时，有如下区别：<br>如果是从第三方站点发起的请求，那么需要浏览器禁止发送某些关键 Cookie 数据到服务器；<br>如果是同一个站点发起的请求，那么就需要保证 Cookie 数据正常发送。<br>③而我们要聊的 Cookie 中的 SameSite 属性正是为了解决这个问题的，通过使用 SameSite 可以有效地降低 CSRF 攻击的风险。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在 HTTP 响应头中，通过 set-cookie 字段设置 Cookie 时，可以带上 SameSite 选项，如下：</span><br><span class="line">set-cookie: 1P_JAR=2019-10-20-06; expires=Tue, 19-Nov-2019 06:36:21 GMT; path=/; domain=.google.com; SameSite=none</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SameSite 选项通常有 Strict、Lax 和 None 三个值。</span><br><span class="line">1. Strict 最为严格。如果 SameSite 的值是 Strict，那么浏览器会完全禁止第三方 Cookie。</span><br><span class="line">简言之，如果你从a页面中访问 b的资源，而 b 的某些 Cookie 设置了 SameSite = Strict 的话，</span><br><span class="line">那么这些 Cookie 是不会被发送到 b 的服务器上的。</span><br><span class="line">只有你从 b的站点去请求 b的资源时，才会带上这些 Cookie。</span><br><span class="line">2.Lax 相对宽松一点。在跨站点的情况下，从第三方站点的链接打开和从第三方站点提交 Get 方式的表单这两种方式都会携带 Cookie。</span><br><span class="line">但如果在第三方站点中使用 Post 方法，或者通过 img、iframe 等标签加载的 URL，这些场景都不会携带 Cookie。</span><br><span class="line">3.而如果使用 None 的话，在任何情况下都会发送 Cookie 数据。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>④对于防范 CSRF 攻击，我们可以针对实际情况将一些关键的 Cookie 设置为 Strict 或者 Lax 模式，这样在跨站点请求时，这些关键的 Cookie 就不会被发送到服务器，从而使得黑客的 CSRF 攻击失效。</p>
<ol start="2">
<li>验证请求的来源站点<br>①在服务器端验证请求来源的站点。<br>②Referer 是 HTTP 请求头中的一个字段，记录了该 HTTP 请求的来源地址。<br>③虽然可以通过 Referer 告诉服务器 HTTP 请求的来源，但是有一些场景是不适合将来源 URL 暴露给服务器的，因此浏览器提供给开发者一个选项，可以不用上传 Referer 值，具体可参考 Referrer Policy。<br>④但在服务器端验证请求头中的 Referer 并不是太可靠，因此标准委员会又制定了 Origin 属性，在一些重要的场合，比如通过 XMLHttpRequest、Fecth 发起跨站请求或者通过 Post 方法发送请求时，都会带上 Origin 属性<br>Origin 属性只包含了域名信息，并没有包含具体的 URL 路径，这是 Origin 和 Referer 的一个主要区别。<br>Origin 的值之所以不包含详细路径信息，是有些站点因为安全考虑，不想把源站点的详细路径暴露给服务器。<br>⑤因此，服务器的策略是优先判断 Origin，如果请求头中没有包含 Origin 属性，再根据实际情况判断是否使用 Referer 值。</li>
<li>CSRF Token<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">大致分为两步：</span><br><span class="line">第一步，在浏览器向服务器发起请求时，服务器生成一个 CSRF Token。</span><br><span class="line">CSRF Token 其实就是服务器生成的字符串，然后将该字符串植入到返回的页面中。你可以参考下面示例代码：</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form action=&quot;https://diamonds.org/sendcoin&quot; method=&quot;POST&quot;&gt;</span><br><span class="line">      &lt;input type=&quot;hidden&quot; name=&quot;csrf-token&quot; value=&quot;nc98P987bcpncYhoadjoiydc9ajDlcn&quot;&gt;</span><br><span class="line">      &lt;input type=&quot;text&quot; name=&quot;user&quot;&gt;</span><br><span class="line">      &lt;input type=&quot;text&quot; name=&quot;number&quot;&gt;</span><br><span class="line">      &lt;input type=&quot;submit&quot;&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第二步，在浏览器端如果要发起转账的请求，那么需要带上页面中的 CSRF Token，然后服务器会验证该 Token 是否合法。</span><br><span class="line">如果是从第三方站点发出的请求，那么将无法获取到 CSRF Token 的值，所以即使发出了请求，服务器也会因为 CSRF Token 不正确而拒绝请求。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="安全沙箱：页面和系统之间的隔离墙"><a href="#安全沙箱：页面和系统之间的隔离墙" class="headerlink" title="安全沙箱：页面和系统之间的隔离墙"></a>安全沙箱：页面和系统之间的隔离墙</h2><ul>
<li>在最开始的阶段，浏览器是单进程的，这意味着渲染过程、JavaScript 执行过程、网络加载过程、UI 绘制过程和页面显示过程等都是在同一个进程中执行的，这种结构虽然简单，但是也带来了很多问题。</li>
<li>从稳定性视角来看，单进程架构的浏览器是不稳定的，因为只要浏览器进程中的任意一个功能出现异常都有可能影响到整个浏览器，如页面卡死、浏览器崩溃等。</li>
<li>浏览器本身的漏洞是单进程浏览器的一个主要问题，如果浏览器被曝出存在漏洞，那么在这些漏洞没有被及时修复的情况下，黑客就有可能通过恶意的页面向浏览器中注入恶意程序，其中最常见的攻击方式是利用缓冲区溢出，不过需要注意这种类型的攻击和 XSS 注入的脚本是不一样的。</li>
</ul>
<ol>
<li>XSS 攻击只是将恶意的 JavaScript 脚本注入到页面中，虽然能窃取一些 Cookie 相关的数据，但是 XSS 无法对操作系统进行攻击。</li>
<li>而通过浏览器漏洞进行的攻击是可以入侵到浏览器进程内部的，可以读取和修改浏览器进程内部的任意内容，还可以穿透浏览器，在用户的操作系统上悄悄地安装恶意软件、监听用户键盘输入信息以及读取用户硬盘上的文件内容。</li>
<li>和 XSS 攻击页面相比，这类攻击无疑是枚“核弹”，它会将整个操作系统的内容都暴露给黑客，这样我们操作系统上所有的资料都是不安全的了。</li>
</ol>
<ul>
<li>现代浏览器采用了多进程架构，将渲染进程和浏览器主进程做了分离，浏览器被划分为浏览器内核和渲染内核两个核心模块，其中浏览器内核是由网络进程、浏览器主进程和 GPU 进程组成的，渲染内核就是渲染进程。</li>
</ul>
<ol>
<li>所有的网络资源都是通过浏览器内核来下载的，下载后的资源会通过 IPC 将其提交给渲染进程（浏览器内核和渲染进程之间都是通过 IPC 来通信的）。</li>
<li>然后渲染进程会对这些资源进行解析、绘制等操作，最终生成一幅图片。</li>
<li>但是渲染进程并不负责将图片显示到界面上，而是将最终生成的图片提交给浏览器内核模块，由浏览器内核模块负责显示这张图片。</li>
</ol>
<ul>
<li>虽然设计成了多进程架构，不过这些模块之间的沟通方式却有些复杂，也许你还有以下问题：</li>
</ul>
<ol>
<li>为什么一定要通过浏览器内核去请求资源，再将数据转发给渲染进程，而不直接从进程内部去请求网络资源？</li>
<li>为什么渲染进程只负责生成页面图片，生成图片还要经过 IPC 通知浏览器内核模块，然后让浏览器内核去负责展示图片？<h3 id="安全沙箱"><a href="#安全沙箱" class="headerlink" title="安全沙箱"></a>安全沙箱</h3></li>
</ol>
<ul>
<li>由于渲染进程需要执行 DOM 解析、CSS 解析、网络图片解码等操作，如果渲染进程中存在系统级别的漏洞，那么以上操作就有可能让恶意的站点获取到渲染进程的控制权限，进而又获取操作系统的控制权限，这对于用户来说是非常危险的。</li>
<li>如果你下载了一个恶意程序，但是没有执行它，那么恶意程序是不会生效的。同理，浏览器之于网络内容也是如此，浏览器可以安全地下载各种网络资源，但是如果要执行这些网络资源，比如解析 HTML、解析 CSS、执行 JavaScript、图片编解码等操作，就需要非常谨慎了，因为一不小心，黑客就会利用这些操作对含有漏洞的浏览器发起攻击。</li>
<li>基于以上原因，我们需要在渲染进程和操作系统之间建一道墙，即便渲染进程由于存在漏洞被黑客攻击，但由于这道墙，黑客就获取不到渲染进程之外的任何操作权限。将渲染进程和操作系统隔离的这道墙就是我们要聊的安全沙箱。</li>
<li>浏览器中的安全沙箱是利用操作系统提供的安全技术，让渲染进程在执行过程中无法访问或者修改操作系统中的数据，在渲染进程需要访问系统资源的时候，需要通过浏览器内核来实现，然后将访问的结果通过 IPC 转发给渲染进程。</li>
<li>安全沙箱最小的保护单位是进程。因为单进程浏览器需要频繁访问或者修改操作系统的数据，所以单进程浏览器是无法被安全沙箱保护的，而现代浏览器采用的多进程架构使得安全沙箱可以发挥作用。<h4 id="安全沙箱如何影响各个模块功能"><a href="#安全沙箱如何影响各个模块功能" class="headerlink" title="安全沙箱如何影响各个模块功能"></a>安全沙箱如何影响各个模块功能</h4></li>
<li>如果要让安全沙箱应用在某个进程上，那么这个进程必须没有读写操作系统的功能，比如读写本地文件、发起网络请求、调用 GPU 接口等。</li>
<li>那安全沙箱是如何影响到各个模块功能的呢？</li>
</ul>
<ol>
<li>持久存储<br>①由于安全沙箱需要负责确保渲染进程无法直接访问用户的文件系统，<br>但是在渲染进程内部有访问 Cookie 的需求、有上传文件的需求，为了解决这些文件的访问需求，<br>所以现代浏览器将读写文件的操作全部放在了浏览器内核中实现，然后通过 IPC 将操作结果转发给渲染进程。<br>②存储 Cookie 数据的读写。通常浏览器内核会维护一个存放所有 Cookie 的 Cookie 数据库，<br>然后当渲染进程通过 JavaScript 来读取 Cookie 时，渲染进程会通过 IPC 将读取 Cookie 的信息发送给浏览器内核，<br>浏览器内核读取 Cookie 之后再将内容返回给渲染进程。<br>③一些缓存文件的读写也是由浏览器内核实现的，比如网络文件缓存的读取。</li>
<li>网络访问<br>① 在渲染进程内部也是不能直接访问网络的，如果要访问网络，则需要通过浏览器内核。<br>② 不过浏览器内核在处理 URL 请求之前，会检查渲染进程是否有权限请求该 URL，比如检查 XMLHttpRequest 或者 Fetch 是否是跨站点请求，或者检测 HTTPS 的站点中是否包含了 HTTP 的请求。</li>
<li>用户交互<br>①通常情况下，如果你要实现一个 UI 程序，操作系统会提供一个界面给你，该界面允许应用程序与用户交互，允许应用程序在该界面上进行绘制，比如 Windows 提供的是 HWND，Linux 提供的 X Window，我们就把 HWND 和 X Window 统称为窗口句柄。应用程序可以在窗口句柄上进行绘制和接收键盘鼠标消息。<br>②在现代浏览器中，由于每个渲染进程都有安全沙箱的保护，所以在渲染进程内部是无法直接操作窗口句柄的，这也是为了限制渲染进程监控到用户的输入事件。<br>③由于渲染进程不能直接访问窗口句柄，所以渲染进程需要完成以下两点大的改变。<br>第一点，渲染进程需要渲染出位图。为了向用户显示渲染进程渲染出来的位图，渲染进程需要将生成好的位图发送到浏览器内核，然后浏览器内核将位图复制到屏幕上。<br>第二点，操作系统没有将用户输入事件直接传递给渲染进程，而是将这些事件传递给浏览器内核。然后浏览器内核再根据当前浏览器界面的状态来判断如何调度这些事件，如果当前焦点位于浏览器地址栏中，则输入事件会在浏览器内核内部处理；如果当前焦点在页面的区域内，则浏览器内核会将输入事件转发给渲染进程。<br>④之所以这样设计，就是为了限制渲染进程有监控到用户输入事件的能力，所以所有的键盘鼠标事件都是由浏览器内核来接收的，然后浏览器内核再通过 IPC 将这些事件发送给渲染进程。<h3 id="站点隔离（Site-Isolation）"><a href="#站点隔离（Site-Isolation）" class="headerlink" title="站点隔离（Site Isolation）"></a>站点隔离（Site Isolation）</h3></li>
</ol>
<ul>
<li>所谓站点隔离是指 Chrome 将同一站点（包含了相同根域名和相同协议的地址）中相互关联的页面放到同一个渲染进程中执行。</li>
<li>最开始 Chrome 划分渲染进程是以标签页为单位，也就是说整个标签页会被划分给某个渲染进程。但是，按照标签页划分渲染进程存在一些问题，原因就是一个标签页中可能包含了多个 iframe，而这些 iframe 又有可能来自于不同的站点，这就导致了多个不同站点中的内容通过 iframe 同时运行在同一个渲染进程中。</li>
<li>目前所有操作系统都面临着两个 A 级漏洞——幽灵（Spectre）和熔毁（Meltdown），这两个漏洞是由处理器架构导致的，很难修补，黑客通过这两个漏洞可以直接入侵到进程的内部，如果入侵的进程没有安全沙箱的保护，那么黑客还可以发起对操作系统的攻击。</li>
<li>所以如果一个银行站点包含了一个恶意 iframe，然后这个恶意的 iframe 利用这两个 A 级漏洞去入侵渲染进程，那么恶意程序就能读取银行站点渲染进程内的所有内容了，这对于用户来说就存在很大的风险了。</li>
<li>因此 Chrome 几年前就开始重构代码，将标签级的渲染进程重构为 iframe 级的渲染进程，然后严格按照同一站点的策略来分配渲染进程，这就是 Chrome 中的站点隔离。</li>
<li>实现了站点隔离，就可以将恶意的 iframe 隔离在恶意进程内部，使得它无法继续访问其他 iframe 进程的内容，因此也就无法攻击其他站点了。</li>
<li>值得注意是，2019 年 10 月 20 日 Chrome 团队宣布安卓版的 Chrome 已经全面支持站点隔离。</li>
</ul>
<h2 id="HTTPS：让数据传输更安全"><a href="#HTTPS：让数据传输更安全" class="headerlink" title="HTTPS：让数据传输更安全"></a>HTTPS：让数据传输更安全</h2><ul>
<li>使用 HTTP 传输的内容很容易被中间人窃取、伪造和篡改，通常我们把这种攻击方式称为中间人攻击。</li>
<li>在将 HTTP 数据提交给 TCP 层之后，数据会经过用户电脑、WiFi 路由器、运营商和目标服务器，在这中间的每个环节中，数据都有可能被窃取或篡改。</li>
<li>比如用户电脑被黑客安装了恶意软件，那么恶意软件就能抓取和篡改所发出的 HTTP 请求的内容。或者用户一不小心连接上了 WiFi 钓鱼路由器，那么数据也都能被黑客抓取或篡改。<h3 id="在-HTTP-协议栈中引入安全层"><a href="#在-HTTP-协议栈中引入安全层" class="headerlink" title="在 HTTP 协议栈中引入安全层"></a>在 HTTP 协议栈中引入安全层</h3></li>
<li>HTTPS 并非是一个新的协议，通常 HTTP 直接和 TCP 通信，HTTPS 则先和安全层通信，然后安全层再和 TCP 层通信。</li>
<li>HTTPS 所有的安全核心都在安全层，它不会影响到上面的 HTTP 协议，也不会影响到下面的 TCP/IP</li>
<li>安全层有两个主要的职责：对发起 HTTP 请求的数据进行加密操作和对接收到 HTTP 的内容进行解密操作。<h3 id="第一版：使用对称加密"><a href="#第一版：使用对称加密" class="headerlink" title="第一版：使用对称加密"></a>第一版：使用对称加密</h3></li>
<li>所谓对称加密是指加密和解密都使用的是相同的密钥。</li>
<li>HTTPS 首先要协商加解密方式，这个过程就是 HTTPS 建立安全连接的过程。为了让加密的密钥更加难以破解，我们让服务器和客户端同时决定密钥，具体过程如下：</li>
</ul>
<ol>
<li>浏览器发送它所支持的加密套件列表和一个随机数 client-random，这里的加密套件是指加密的方法，加密套件列表就是指浏览器能支持多少种加密方法列表。</li>
<li>服务器会从加密套件列表中选取一个加密套件，然后还会生成一个随机数 service-random，并将 service-random 和加密套件列表返回给浏览器。</li>
<li>最后浏览器和服务器分别返回确认消息。</li>
<li>这样浏览器端和服务器端都有相同的 client-random 和 service-random 了，然后它们再使用相同的方法将 client-random 和 service-random 混合起来生成一个密钥 master secret，有了密钥 master secret 和加密套件之后，双方就可以进行数据的加密传输了。</li>
</ol>
<ul>
<li>虽然这个版本能够很好地工作，但是其中传输 client-random 和 service-random 的过程却是明文的，这意味着黑客也可以拿到协商的加密套件和双方的随机数，由于利用随机数合成密钥的算法是公开的，所以黑客拿到随机数之后，也可以合成密钥，这样数据依然可以被破解，那么黑客也就可以使用密钥来伪造或篡改数据了。<h3 id="第二版：使用非对称加密"><a href="#第二版：使用非对称加密" class="headerlink" title="第二版：使用非对称加密"></a>第二版：使用非对称加密</h3></li>
<li>非对称加密算法有 A、B 两把密钥，如果你用 A 密钥来加密，那么只能使用 B 密钥来解密；反过来，如果你要 B 密钥来加密，那么只能用 A 密钥来解密。</li>
<li>在 HTTPS 中，服务器会将其中的一个密钥通过明文的形式发送给浏览器，我们把这个密钥称为公钥，服务器自己留下的那个密钥称为私钥。顾名思义，公钥是每个人都能获取到的，而私钥只有服务器才能知道，不对任何人公开。</li>
<li>我们来分析下使用非对称加密的请求流程。</li>
</ul>
<ol>
<li>首先浏览器还是发送加密套件列表给服务器。</li>
<li>然后服务器会选择一个加密套件，不过和对称加密不同的是，使用非对称加密时服务器上需要有用于浏览器加密的公钥和服务器解密 HTTP 数据的私钥，由于公钥是给浏览器加密使用的，因此服务器会将加密套件和公钥一道发送给浏览器。</li>
<li>最后就是浏览器和服务器返回确认消息。</li>
<li>这样浏览器端就有了服务器的公钥，在浏览器端向服务器端发送数据时，就可以使用该公钥来加密数据。由于公钥加密的数据只有私钥才能解密，所以即便黑客截获了数据和公钥，他也是无法使用公钥来解密数据的。</li>
</ol>
<ul>
<li>因此采用非对称加密，就能保证浏览器发送给服务器的数据是安全的了，这看上去似乎很完美，不过这种方式依然存在两个严重的问题。</li>
</ul>
<ol>
<li>第一个是非对称加密的效率太低。这会严重影响到加解密数据的速度，进而影响到用户打开页面的速度。</li>
<li>第二个是无法保证服务器发送给浏览器的数据安全。虽然浏览器端可以使用公钥来加密，但是服务器端只能采用私钥来加密，私钥加密只有公钥能解密，但黑客也是可以获取得到公钥的，这样就不能保证服务器端数据的安全了。<h3 id="第三版：对称加密和非对称加密搭配使用"><a href="#第三版：对称加密和非对称加密搭配使用" class="headerlink" title="第三版：对称加密和非对称加密搭配使用"></a>第三版：对称加密和非对称加密搭配使用</h3></li>
</ol>
<ul>
<li>在传输数据阶段依然使用对称加密，但是对称加密的密钥我们采用非对称加密来传输。</li>
<li>改造后的流程是这样的：</li>
</ul>
<ol>
<li>首先浏览器向服务器发送对称加密套件列表、非对称加密套件列表和随机数 client-random；</li>
<li>服务器保存随机数 client-random，选择对称加密和非对称加密的套件，然后生成随机数 service-random，向浏览器发送选择的加密套件、service-random 和公钥；</li>
<li>浏览器保存公钥，并生成随机数 pre-master，然后利用公钥对 pre-master 加密，并向服务器发送加密后的数据；</li>
<li>最后服务器拿出自己的私钥，解密出 pre-master 数据，并返回确认消息。</li>
<li>到此为止，服务器和浏览器就有了共同的 client-random、service-random 和 pre-master，然后服务器和浏览器会使用这三组随机数生成对称密钥，因为服务器和浏览器使用同一套方法来生成密钥，所以最终生成的密钥也是相同的。</li>
<li>需要特别注意的一点，pre-master 是经过公钥加密之后传输的，所以黑客无法获取到 pre-master，这样黑客就无法生成密钥，也就保证了黑客无法破解传输过程中的数据了<h3 id="第四版：添加数字证书"><a href="#第四版：添加数字证书" class="headerlink" title="第四版：添加数字证书"></a>第四版：添加数字证书</h3></li>
</ol>
<ul>
<li>通过对称和非对称混合方式，我们完美地实现了数据的加密传输。不过这种方式依然存在着问题，比如我要打开a的官网，但是黑客通过 DNS 劫持将a的官网的 IP 地址替换成了黑客的 IP 地址，这样我访问的其实是黑客的服务器了，黑客就可以在自己的服务器上实现公钥和私钥，而对浏览器来说，它完全不知道现在访问的是个黑客的站点。</li>
<li>结合实际生活中的一个例子，比如你要买房子，首先你需要给房管局提交你买房的材料，包括银行流水、银行证明、身份证等，然后房管局工作人员在验证无误后，会发给你一本盖了章的房产证，房产证上包含了你的名字、身份证号、房产地址、实际面积、公摊面积等信息。在这个例子中，你之所以能证明房子是你自己的，是因为引进了房管局这个权威机构，并通过这个权威机构给你颁发一个证书：房产证。</li>
<li>对于浏览器来说，数字证书有两个作用：一个是通过数字证书向浏览器证明服务器的身份，另一个是数字证书里面包含了服务器公钥。</li>
<li>相较于第三版的 HTTPS 协议，这里主要有两点改变：</li>
</ul>
<ol>
<li>服务器没有直接返回公钥给浏览器，而是返回了数字证书，而公钥正是包含在数字证书中的；</li>
<li>在浏览器端多了一个证书验证的操作，验证了证书之后，才继续后续流程。</li>
</ol>
<ul>
<li>通过引入数字证书，我们就实现了服务器的身份认证功能，这样即便黑客伪造了服务器，但是由于证书是没有办法伪造的，所以依然无法欺骗用户。</li>
</ul>
<h2 id="如何计算Chrome中渲染进程的个数？"><a href="#如何计算Chrome中渲染进程的个数？" class="headerlink" title="如何计算Chrome中渲染进程的个数？"></a>如何计算Chrome中渲染进程的个数？</h2><ul>
<li>同一站点，从 A 标签页中打开 B 标签页，就会使用同一个渲染进程，而分别打开这两个标签页，会分别使用不同的渲染进程<h3 id="标签页之间的连接"><a href="#标签页之间的连接" class="headerlink" title="标签页之间的连接"></a>标签页之间的连接</h3></li>
<li>第一种是通过<a>标签来和新标签建立连接</a></li>
<li>还可以通过 JavaScript 中的 window.open 方法来和新标签页建立连接</li>
<li>通过上述两种方式打开的新标签页，不论这两个标签页是否属于同一站点，他们之间都能通过 opener 来建立连接，所以他们之间是有联系的。在 WhatWG 规范中，把这一类具有相互连接关系的标签页称为浏览上下文组 ( browsing context group)。</li>
<li>既然提到浏览上下文组，就有必要提下浏览上下文，通常情况下，我们把一个标签页所包含的内容，诸如 window 对象，历史记录，滚动条位置等信息称为浏览上下文。这些通过脚本相互连接起来的浏览上下文就是浏览上下文组。</li>
<li>Chrome 浏览器会将浏览上下文组中属于同一站点的标签分配到同一个渲染进程中，这是因为如果一组标签页，既在同一个浏览上下文组中，又属于同一站点，那么它们可能需要在对方的标签页中执行脚本。因此，它们必须运行在同一渲染进程中。<h3 id="一个“例外”"><a href="#一个“例外”" class="headerlink" title="一个“例外”"></a>一个“例外”</h3></li>
<li>通常，将 noopener 的值引入 rel 属性中，就是告诉浏览器通过这个链接打开的标签页中的 opener 值设置为 null，引入 noreferrer 是告诉浏览器，新打开的标签页不要有引用关系。<h3 id="站点隔离"><a href="#站点隔离" class="headerlink" title="站点隔离"></a>站点隔离</h3></li>
<li>目前 Chrome 浏览器已经默认实现了站点隔离的功能，这意味着标签页中的 iframe 也会遵守同一站点的分配原则，如果标签页中的 iframe 和标签页是同一站点，并且有连接关系，那么标签页依然会和当前标签页运行在同一个渲染进程中，如果 iframe 和标签页不属于同一站点，那么 iframe 会运行在单独的渲染进程中。</li>
</ul>
<h2 id="任务调度：有了setTimeOut，为什么还要使用rAF？"><a href="#任务调度：有了setTimeOut，为什么还要使用rAF？" class="headerlink" title="任务调度：有了setTimeOut，为什么还要使用rAF？"></a>任务调度：有了setTimeOut，为什么还要使用rAF？</h2><ul>
<li>用 JavaScript 实现高性能的动画，那就得使用 requestAnimationFrame 这个 API，我们简称 rAF，那么为什么都推荐使用 rAF 而不是 setTimeOut 呢？</li>
</ul>
<ol>
<li>要解释清楚这个问题，就要从渲染进程的任务调度系统讲起，理解了渲染进程任务调度系统，你自然就明白了 rAF 和 setTimeOut 的区别。</li>
<li>渲染进程内部的大多数任务都是在主线程上执行的，诸如 JavaScript 执行、DOM、CSS、计算布局、V8 的垃圾回收等任务。要让这些任务能够在主线程上有条不紊地运行，就需要引入消息队列。</li>
<li>主线程维护了一个普通的消息队列和一个延迟消息队列，调度模块会按照规则依次取出这两个消息队列中的任务，并在主线程上执行。</li>
</ol>
<ul>
<li>CSS 动画是由渲染进程自动处理的，所以渲染进程会让 CSS 渲染每帧动画的过程与 VSync 的时钟保持一致, 这样就能保证 CSS 动画的高效率执行。</li>
<li>但是 JavaScript 是由用户控制的，如果采用 setTimeout 来触发动画每帧的绘制，那么其绘制时机是很难和 VSync 时钟保持一致的，所以 JavaScript 中又引入了 window.requestAnimationFrame，用来和 VSync 的时钟周期同步</li>
</ul>
<h3 id="单消息队列的队头阻塞问题"><a href="#单消息队列的队头阻塞问题" class="headerlink" title="单消息队列的队头阻塞问题"></a>单消息队列的队头阻塞问题</h3><ul>
<li>渲染主线程会按照先进先出的顺序执行消息队列中的任务，具体地讲，当产生了新的任务，渲染进程会将其添加到消息队列尾部，在执行任务过程中，渲染进程会顺序地从消息队列头部取出任务并依次执行。在最初，采用这种方式没有太大的问题，因为页面中的任务还不算太多，渲染主线程也不是太繁忙。</li>
<li>不过浏览器是向前不停进化的，其进化路线体现在架构的调整、功能的增加以及更加精细的优化策略等方面，这些变化让渲染进程所需要处理的任务变多了，对应的渲染进程的主线程也变得越拥挤。</li>
<li>在基于这种单消息队列的架构下，如果用户发出一个点击事件或者缩放页面的事件，而在此时，该任务前面可能还有很多不太重要的任务在排队等待着被执行，诸如 V8 的垃圾回收、DOM 定时器等任务，如果执行这些任务需要花费的时间过久的话，那么就会让用户产生卡顿的感觉。</li>
<li>因此，在单消息队列架构下，存在着低优先级任务会阻塞高优先级任务的情况，比如在一些性能不高的手机上，有时候滚动页面需要等待一秒以上。这像极了我们在介绍 HTTP 协议时所谈论的队头阻塞问题<h3 id="Chromium-是如何解决队头阻塞问题的？"><a href="#Chromium-是如何解决队头阻塞问题的？" class="headerlink" title="Chromium 是如何解决队头阻塞问题的？"></a>Chromium 是如何解决队头阻塞问题的？</h3></li>
</ul>
<h3 id="第一次迭代：引入一个高优先级队列"><a href="#第一次迭代：引入一个高优先级队列" class="headerlink" title="第一次迭代：引入一个高优先级队列"></a>第一次迭代：引入一个高优先级队列</h3><ul>
<li>在交互阶段，下面几种任务都应该视为高优先级的任务：</li>
</ul>
<ol>
<li>通过鼠标触发的点击任务、滚动页面任务；</li>
<li>通过手势触发的页面缩放任务；</li>
<li>通过 CSS、JavaScript 等操作触发的动画特效等任务</li>
</ol>
<ul>
<li>这些任务被触发后，用户想立即得到页面的反馈，所以我们需要让这些任务能够优先与其他的任务执行。</li>
<li>要实现这种效果，我们可以增加一个高优级的消息队列，将高优先级的任务都添加到这个队列里面，然后优先执行该消息队列中的任务。</li>
<li>我们使用了一个优先级高的消息队列和一个优先级低消息队列，渲染进程会将它认为是紧急的任务添加到高优先级队列中，不紧急的任务就添加到低优先级的队列中。</li>
<li>然后我们再在渲染进程中引入一个任务调度器，负责从多个消息队列中选出合适的任务，通常实现的逻辑，先按照顺序从高优先级队列中取出任务，如果高优先级的队列为空，那么再按照顺序从低优级队列中取出任务。</li>
<li>还可以更进一步，将任务划分为多个不同的优先级，来实现更加细粒度的任务调度，比如可以划分为高优先级，普通优先级和低优先级</li>
<li>不过大多数任务需要保持其相对执行顺序，如果将用户输入的消息或者合成消息添加进多个不同优先级的队列中，那么这种任务的相对执行顺序就会被打乱，甚至有可能出现还未处理输入事件，就合成了该事件要显示的图片。因此我们需要让一些相同类型的任务保持其相对执行顺序。<h3 id="第二次迭代：根据消息类型来实现消息队列"><a href="#第二次迭代：根据消息类型来实现消息队列" class="headerlink" title="第二次迭代：根据消息类型来实现消息队列"></a>第二次迭代：根据消息类型来实现消息队列</h3></li>
<li>我们可以为不同类型的任务创建不同优先级的消息队列，比如：</li>
</ul>
<ol>
<li>可以创建输入事件的消息队列，用来存放输入事件。</li>
<li>可以创建合成任务的消息队列，用来存放合成事件。</li>
<li>可以创建默认消息队列，用来保存如资源加载的事件和定时器回调等事件。</li>
<li>还可以创建一个空闲消息队列，用来存放 V8 的垃圾自动垃圾回收这一类实时性不高的事件。</li>
</ol>
<ul>
<li>但是它依然存在着问题，那就是这几种消息队列的优先级都是固定的，任务调度器会按照这种固定好的静态的优先级来分别调度任务。</li>
<li>页面大致的生存周期大体分为两个阶段，加载阶段和交互阶段。</li>
<li>虽然在交互阶段，采用上述这种静态优先级的策略没有什么太大问题的，但是在页面加载阶段，如果依然要优先执行用户输入事件和合成事件，那么页面的解析速度将会被拖慢。Chromium 团队曾测试过这种情况，使用静态优先级策略，网页的加载速度会被拖慢 14%。<h3 id="第三次迭代：动态调度策略"><a href="#第三次迭代：动态调度策略" class="headerlink" title="第三次迭代：动态调度策略"></a>第三次迭代：动态调度策略</h3></li>
<li>页面加载阶段的场景，在这个阶段，用户的最高诉求是在尽可能短的时间内看到页面，至于交互和合成并不是这个阶段的核心诉求，因此我们需要调整策略，在加载阶段将页面解析，JavaScript 脚本执行等任务调整为优先级最高的队列，降低交互合成这些队列的优先级。</li>
<li>页面加载完成之后就进入了交互阶段</li>
</ul>
<ol>
<li>在显卡中有一块叫着前缓冲区的地方，这里存放着显示器要显示的图像，显示器会按照一定的频率来读取这块前缓冲区，并将前缓冲区中的图像显示在显示器上，不同的显示器读取的频率是不同的，通常情况下是 60HZ，也就是说显示器会每间隔 1/60 秒就读取一次前缓冲区。</li>
<li>如果浏览器要更新显示的图片，那么浏览器会将新生成的图片提交到显卡的后缓冲区中，提交完成之后，GPU 会将后缓冲区和前缓冲区互换位置，也就是前缓冲区变成了后缓冲区，后缓冲区变成了前缓冲区，这就保证了显示器下次能读取到 GPU 中最新的图片。</li>
<li>显示器从前缓冲区读取图片，和浏览器生成新的图像到后缓冲区的过程是不同步的，这种显示器读取图片和浏览器生成图片不同步，容易造成众多问题。<br>如果渲染进程生成的帧速比屏幕的刷新率慢，那么屏幕会在两帧中显示同一个画面，当这种断断续续的情况持续发生时，用户将会很明显地察觉到动画卡住了。<br>如果渲染进程生成的帧速率实际上比屏幕刷新率快，那么也会出现一些视觉上的问题，比如当帧速率在 100fps 而刷新率只有 60Hz 的时候，GPU 所渲染的图像并非全都被显示出来，这就会造成丢帧现象。<br>就算屏幕的刷新频率和 GPU 更新图片的频率一样，由于它们是两个不同的系统，所以屏幕生成帧的周期和 VSync 的周期也是很难同步起来的。</li>
<li>所以 VSync 和系统的时钟不同步就会造成掉帧、卡顿、不连贯等问题。为了解决这些问题，就需要将显示器的时钟同步周期和浏览器生成页面的周期绑定起来。</li>
<li>当显示器将一帧画面绘制完成后，并在准备读取下一帧之前，显示器会发出一个垂直同步信号（vertical synchronization）给 GPU，简称 VSync。这时候浏览器就会充分利用好 VSync 信号。</li>
<li>具体地讲，当 GPU 接收到 VSync 信号后，会将 VSync 信号同步给浏览器进程，浏览器进程再将其同步到对应的渲染进程，渲染进程接收到 VSync 信号之后，就可以准备绘制新的一帧了</li>
<li>当渲染进程接收到用户交互的任务后，接下来大概率是要进行绘制合成操作，因此我们可以设置，当在执行用户交互的任务时，将合成任务的优先级调整到最高。</li>
<li>处理完成 DOM，计算好布局和绘制，就需要将信息提交给合成线程来合成最终图片了，然后合成线程进入工作状态。</li>
</ol>
<ul>
<li>现在的场景是合成线程在工作了，那么我们就可以把下个合成任务的优先级调整为最低，并将页面解析、定时器等任务优先级提升。</li>
<li>在合成完成之后，合成线程会提交给渲染主线程提交完成合成的消息，如果当前合成操作执行的非常快，比如从用户发出消息到完成合成操作只花了 8 毫秒，因为 VSync 同步周期是 16.66（1/60）毫秒，那么这个 VSync 时钟周期内就不需要再次生成新的页面了。那么从合成结束到下个 VSync 周期内，就进入了一个空闲时间阶段，那么就可以在这段空闲时间内执行一些不那么紧急的任务，比如 V8 的垃圾回收，或者通过 window.requestIdleCallback() 设置的回调任务等，都会在这段空闲时间内执行。4. 第四次迭代：任务饿死<h3 id="第四次迭代：任务饿死"><a href="#第四次迭代：任务饿死" class="headerlink" title="第四次迭代：任务饿死"></a>第四次迭代：任务饿死</h3></li>
<li>以上方案看上去似乎非常完美了，不过依然存在一个问题，那就是在某个状态下，一直有新的高优先级的任务加入到队列中，这样就会导致其他低优先级的任务得不到执行，这称为任务饿死。</li>
<li>Chromium 为了解决任务饿死的问题，给每个队列设置了执行权重，也就是如果连续执行了一定个数的高优先级的任务，那么中间会执行一次低优先级的任务，这样就缓解了任务饿死的情况。</li>
</ul>
<h2 id="加载阶段性能：使用Audits来优化Web性能"><a href="#加载阶段性能：使用Audits来优化Web性能" class="headerlink" title="加载阶段性能：使用Audits来优化Web性能"></a>加载阶段性能：使用Audits来优化Web性能</h2><h3 id="到底什么是-Web-性能"><a href="#到底什么是-Web-性能" class="headerlink" title="到底什么是 Web 性能?"></a>到底什么是 Web 性能?</h3><ul>
<li>Web 性能描述了 Web 应用在浏览器上的加载和显示的速度。</li>
<li>关于 Web 应用的速度，我们需要从两个阶段来考虑：页面加载阶段；页面交互阶段。<h3 id="性能检测工具：Performance-vs-Audits"><a href="#性能检测工具：Performance-vs-Audits" class="headerlink" title="性能检测工具：Performance vs Audits"></a>性能检测工具：Performance vs Audits</h3></li>
<li>Chrome 为我们提供了非常完善的性能检测工具：Performance 和 Audits，它们能够准确统计页面在加载阶段和运行阶段的一些核心数据，诸如任务执行记录、首屏展示花费的时长等，有了这些数据我们就能很容易定位到 Web 应用的性能瓶颈 。</li>
<li>首先 Performance 非常强大，因为它为我们提供了非常多的运行时数据，利用这些数据我们就可以分析出来 Web 应用的瓶颈。但是要完全学会其使用方式却是非常有难度的，其难点在于这些数据涉及到了特别多的概念，而这些概念又和浏览器的系统架构、消息循环机制、渲染流水线等知识紧密联系在了一起。</li>
<li>相反，Audtis 就简单了许多，它将检测到的细节数据隐藏在背后，只提供给我们一些直观的性能数据，同时，还会给我们提供一些优化建议。<h3 id="利用-Audits-生成-Web-性能报告"><a href="#利用-Audits-生成-Web-性能报告" class="headerlink" title="利用 Audits 生成 Web 性能报告"></a>利用 Audits 生成 Web 性能报告</h3></li>
<li>这里我们可以拿B 站作为分析的列子。</li>
<li>首先我们打开浏览器的隐身窗口，Windows 系统下面的快捷键是 Control+Shift+N，Mac 系统下面的快捷键是 Command+Shift+N。我们需要在 Chrome 的隐身模式下工作，这样可以确保我们安装的扩展、浏览器缓存、Cookie 等数据不会影响到检测结果。</li>
<li>然后在隐身窗口中输入 B 站的网站。</li>
<li>打开 Chrome 的开发者工具，选择 Audits 标签。</li>
<li>在生成报告之前，我们需要先配置 Audits，配置模块主要有两部分组成，一个是监测类型 (Categories)，另外一个是设备类型 (Device)。</li>
<li>监控类型 (Categories) 是指需要监控哪些内容，这里有五个对应的选项，它们的功能分别是：</li>
</ul>
<ol>
<li>监测并分析 Web 性能 (Performance)</li>
<li>监测并分析 PWA(Progressive Web App) 程序的性能；</li>
<li>监测并分析 Web 应用是否采用了最佳实践策略 (Best practices)；</li>
<li>监测并分析是否实施了无障碍功能 (Accessibility)，无障碍功能让一些身体有障碍的人可以方便地浏览你的 Web 应用。</li>
<li>监测并分析 Web 应用是否采实施了 SEO 搜素引擎优化 (SEO)。</li>
</ol>
<ul>
<li>设备 (Device) 部分，它给了我们两个选项，Moblie 选项是用来模拟移动设备环境的，另外一个 Desktop 选项是用来模拟桌面环境的。这里我们选择移动设备选项，因为目前大多数流量都是由移动设备产生的，所以移动设备上的 Web 性能显得更加重要。</li>
<li>配置好选项之后，我们就可以点击最上面的生成报告 (Generate report) 按钮来生成报告了。<h3 id="解读性能报告"><a href="#解读性能报告" class="headerlink" title="解读性能报告"></a>解读性能报告</h3></li>
<li>中间圆圈中的数字表示该站点在加载过程中的总体 Web 性能得分，总分是 100 分。</li>
<li>Audits 除了生成性能指标以外，还会分析该站点并提供了很多优化建议，我们可以根据这些建议来改进 Web 应用以获得更高的得分，进而获得更好的用户体验效果。</li>
<li>报告的第一个部分是性能指标 (Metrics)，性能指标下面一共有六项内容，这六项内容分别对应了从 Web 应用的加载到页面展示完成的这段时间中，各个阶段所消耗的时长。在中间还有一个 View Trace 按钮，点击该按钮可以跳转到 Performance 标签，并且查看这些阶段在 Performance 中所对应的位置。</li>
<li>报告的第二个部分是可优化项 (Opportunities)，这些可优化项是 Audits 发现页面中的一些可以直接优化的部分，你可以对照 Audits 给的这些提示来优化你的 Web 应用。</li>
<li>报告的第三部分是手动诊断 (Diagnostics)，在手动诊断部分，采集了一些可能存在性能问题的指标，这些指标可能会影响到页面的加载性能，Audits 把详情列出来，并让你依据实际情况，来手动排查每一项。</li>
<li>报告的最后一部分是运行时设置 (Runtime Settings)，这是运行时的一些基本数据，如果选择移动设备模式，你可以看到发送网络请求时的 User Agent 会变成设备相关信息，还有会模拟设备的网速，这个体现在网络限速上。<h3 id="根据性能报告优化-Web-性能"><a href="#根据性能报告优化-Web-性能" class="headerlink" title="根据性能报告优化 Web 性能"></a>根据性能报告优化 Web 性能</h3></li>
<li>最直接的方式是想办法提高性能指标的分数，而性能指标的分数是由六项指标决定的，它们分别是</li>
</ul>
<ol>
<li>首次绘制 (First Paint)；</li>
<li>首次有效绘制 (First Meaningfull Paint)；</li>
<li>首屏时间 (Speed Index)；</li>
<li>首次 CPU 空闲时间 (First CPU Idle)；</li>
<li>完全可交互时间 (Time to Interactive)；</li>
<li>最大估计输入延时 (Max Potential First Input Delay)。</li>
</ol>
<ul>
<li>在渲染进程确认要渲染当前的请求后，渲染进程会创建一个空白页面，我们把创建空白页面的这个时间点称为 First Paint，简称 FP。</li>
</ul>
<ol>
<li>关键资源包括了 JavaScript 文件和 CSS 文件，因为关键资源会阻塞页面的渲染，所以我们需要等待关键资源加载完成后，才能执行进一步的页面绘制。</li>
</ol>
<ul>
<li>当页面中绘制了第一个像素时，我们把这个时间点称为 First Content Paint，简称 FCP。</li>
<li>接下来继续执行 JavaScript 脚本，当首屏内容完全绘制完成时，我们把这个时间点称为 Largest Content Paint，简称 LCP。</li>
<li>在 FCP 和 LCP 中间，还有一个 FMP，这个是首次有效绘制，由于 FMP 计算复杂，而且容易出错，现在不推荐使用该指标</li>
<li>接下来 JavaScript 脚本执行结束，渲染进程判断该页面的 DOM 生成完毕，于是触发 DOMContentLoad 事件。等所有资源都加载结束之后，再触发 onload 事件。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">第一项指标 FP，如果 FP 时间过久，那么直接说明了一个问题，那就是页面的 HTML 文件可能由于网络原因导致加载时间过久</span><br><span class="line">第二项是 FMP，,如果 FMP 和 LCP 消耗时间过久，那么有可能是加载关键资源花的时间过久，也有可能是 JavaScript 执行过程中所花的时间过久，所以我们可以针对具体的情况来具体分析。</span><br><span class="line">第三项是首屏时间 (Speed Index)，这就是我们上面提到的 LCP，它表示填满首屏页面所消耗的时间，首屏时间的值越大，那么加载速度越慢，具体的优化方式同优化第二项 FMP 是一样。</span><br><span class="line">第四项是首次 CPU 空闲时间 (First CPU Idle)，也称为 First Interactive，它表示页面达到最小化可交互的时间，也就是说并不需要等到页面上的所有元素都可交互，只要可以对大部分用户输入做出响应即可。要缩短首次 CPU 空闲时长，我们就需要尽可能快地加载完关键资源，尽可能快地渲染出来首屏内容，因此优化方式和第二项 FMP 和第三项 LCP 是一样的。</span><br><span class="line">第五项是完全可交互时间 (Time to Interactive)，简称 TTI，它表示页面中所有元素都达到了可交互的时长。简单理解就这时候页面的内容已经完全显示出来了，所有的 JavaScript 事件已经注册完成，页面能够对用户的交互做出快速响应，通常满足响应速度在 50 毫秒以内。如果要解决 TTI 时间过久的问题，我们可以推迟执行一些和生成页面无关的 JavaScript 工作。</span><br><span class="line">第六项是最大估计输入延时 (Max Potential First Input Delay），这个指标是估计你的 Web 页面在加载最繁忙的阶段， 窗口中响应用户输入所需的时间，为了改善该指标，我们可以使用 WebWorker 来执行一些计算，从而释放主线程。另一个有用的措施是重构 CSS 选择器，以确保它们执行较少的计算。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="页面性能工具：如何使用Performance？"><a href="#页面性能工具：如何使用Performance？" class="headerlink" title="页面性能工具：如何使用Performance？"></a>页面性能工具：如何使用Performance？</h2><ul>
<li>通常，使用 Performance 需要分三步走：</li>
</ul>
<ol>
<li>第一步是配置 Performance；</li>
<li>第二步是生成报告页；</li>
<li>第三步就是人工分析报告页，并找出页面的性能瓶颈。<h3 id="配置-Performance"><a href="#配置-Performance" class="headerlink" title="配置 Performance"></a>配置 Performance</h3></li>
</ol>
<ul>
<li>我们可以设置该区域中的“Network”来限制网络加载速度，设置“CPU”来限制 CPU 的运算速度。通过设置，我们就可以在 Chrome 浏览器上来模拟手机等性能不高的设备了。</li>
<li>不同于 Audits 只能监控加载阶段的性能数据，Performance 还可以监控交互阶段的性能数据，不过 Performance 是分别录制这两个阶段的，黑色按钮是用来记录交互阶段性能数据的，下面那个带箭头的圆圈形按钮用来记录加载阶段的性能数据。</li>
<li>当你录制加载阶段的性能数据时，Performance 会重新刷新页面，并等到页面完全渲染出来后，Performance 就会自动停止录制。</li>
<li>如果你是录制交互阶段的性能时，那么需要手动停止录制过程。<h3 id="认识报告页"><a href="#认识报告页" class="headerlink" title="认识报告页"></a>认识报告页</h3></li>
<li>分为三个主要的部分，分别为概览面板、性能指标面板和详情面板。</li>
<li>概览面板</li>
</ul>
<ol>
<li>引入了时间线，Performance 就会将几个关键指标，诸如页面帧速 (FPS)、CPU 资源消耗、网络请求流量、V8 内存使用量 (堆内存) 等，按照时间顺序做成图表的形式展现出来，这就是概览面板</li>
<li>如果 FPS 图表上出现了红色块，那么就表示红色块附近渲染出一帧所需时间过久，帧的渲染时间过久，就有可能导致页面卡顿。</li>
<li>如果 CPU 图形占用面积太大，表示 CPU 使用率就越高，那么就有可能因为某个 JavaScript 占用太多的主线程时间，从而影响其他任务的执行。</li>
<li>如果 V8 的内存使用量一直在增加，就有可能是某种原因导致了内存泄漏。</li>
</ol>
<ul>
<li>性能面板</li>
</ul>
<ol>
<li>在性能面板中，记录了非常多的性能指标项，比如 Main 指标记录渲染主线程的任务执行过程，Compositor 指标记录了合成线程的任务执行过程，GPU 指标记录了 GPU 进程主线程的任务执行过程。</li>
<li>简而言之，我们通过概览面板来定位问题的时间节点，然后再使用性能面板分析该时间节点内的性能数据。</li>
</ol>
<ul>
<li>解读性能面板的各项指标</li>
</ul>
<ol>
<li>一条完整的渲染流水线包括了解析 HTML 文件生成 DOM、解析 CSS 生成 CSSOM、执行 JavaScript、样式计算、构造布局树、准备绘制列表、光栅化、合成、显示等一系列操作。</li>
<li>渲染流水线主要是在渲染进程中执行的，在执行渲染流水线的过程中，渲染进程又需要网络进程、浏览器进程、GPU 等进程配合，才能完成如此复杂的任务。另外在渲染进程内部，又有很多线程来相互配合。</li>
<li>主线程上跑了特别多的任务，诸如渲染流水线的大部分流程，JavaScript 执行、V8 的垃圾回收、定时器设置的回调任务等等，因此 Main 指标的内容非常多，而且非常重要，所以我们在使用 Perofrmance 的时候，大部分时间都是在分析 Main 指标。</li>
<li>通过渲染流水线，我们知道了渲染主线程在生成层树 (LayerTree) 之后，然后根据层树生成每一层的绘制列表，我们把这个过程称为绘制 (Paint)。</li>
<li>在绘制阶段结束之后，渲染主线程会将这些绘列表制提交 (commit)给合成线程，并由合成线程合成出来漂亮的页面。因此，监控合成线程的任务执行记录也相对比较重要，所以 Chrome 又在性能面板中引入了Compositor 指标，也就是合成线程的任务执行记录。</li>
<li>在合成线程执行任务的过程中，还需要 GPU 进程的配合来生成位图，我们把这个 GPU 生成位图的过程称为光栅化。</li>
<li>如果合成线程直接和 GPU 进程进行通信，那么势必会阻塞后面的合成任务，因此合成线程又维护了一个光栅化线程池 (Raster)，用来让 GPU 执行光栅化的任务。</li>
<li>因为光栅化线程池和 GPU 进程中的任务执行也会影响到页面的性能，所以性能面板也添加了这两个指标，分别是 Raster 指标和 GPU 指标。因为 Raster 是线程池，所以如果你点开 Raster 项，可以看到它维护了多个线程。</li>
<li>渲染进程中除了有主线程、合成线程、光栅化线程池之外，还维护了一个 IO 线程，IO 线程主要用来接收用户输入事件、网络事件、设备相关等事件，如果事件需要渲染主线程来处理，那么 IO 线程还会将这些事件转发给渲染主线程。在性能面板上，Chrome_ChildIOThread 指标对应的就是 IO 线程的任务记录。</li>
<li>Network 指标，网络记录展示了页面中的每个网络请求所消耗的时长，并以瀑布流的形式展现。这块内容和网络面板的瀑布流类似，之所以放在性能面板中是为了方便我们和其他指标对照着分析。</li>
<li>第二个是 Timings 指标，用来记录一些关键的时间节点在何时产生的数据信息，诸如 FP、FCP、LCP 等。</li>
<li>第三个是 Frames 指标，也就是浏览器生成每帧的记录，我们知道页面所展现出来的画面都是由渲染进程一帧一帧渲染出来的，帧记录就是用来记录渲染进程生成所有帧信息，包括了渲染出每帧的时长、每帧的图层构造等信息，你可以点击对应的帧，然后在详细信息面板里面查看具体信息。</li>
<li>第四个是 Interactions 指标，用来记录用户交互操作，比如点击鼠标、输入文字等交互信息。</li>
</ol>
<ul>
<li>详情面板<br>1.你可以通过在性能面板中选中性能指标中的任何历史数据，然后选中记录的细节信息就会展现在详情面板中了。</li>
</ul>
<h2 id="性能分析工具：如何分析Performance中的Main指标？"><a href="#性能分析工具：如何分析Performance中的Main指标？" class="headerlink" title="性能分析工具：如何分析Performance中的Main指标？"></a>性能分析工具：如何分析Performance中的Main指标？</h2><h3 id="任务-vs-过程"><a href="#任务-vs-过程" class="headerlink" title="任务 vs 过程"></a>任务 vs 过程</h3><ul>
<li>渲染进程中维护了消息队列，如果通过 SetTimeout 设置的回调函数，通过鼠标点击的消息事件，都会以任务的形式添加消息队列中，然后任务调度器会按照一定规则从消息队列中取出合适的任务，并让其在渲染主线程上执行。</li>
<li>Main 指标就记录渲染主线上所执行的全部任务，以及每个任务的详细执行过程。</li>
<li>每个灰色横条就对应了一个任务，灰色长条的长度对应了任务的执行时长。通常，渲染主线程上的任务都是比较复杂的，如果只单纯记录任务执行的时长，那么依然很难定位问题，因此，还需要将任务执行过程中的一些关键的细节记录下来，这些细节就是任务的过程，灰线下面的横条就是一个个过程，同样这些横条的长度就代表这些过程执行的时长。<h3 id="分析页面加载过程"><a href="#分析页面加载过程" class="headerlink" title="分析页面加载过程"></a>分析页面加载过程</h3></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Main&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        area &#123;</span><br><span class="line">            border: 2px ridge;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        box &#123;</span><br><span class="line">            background-color: rgba(106, 24, 238, 0.26);</span><br><span class="line">            height: 5em;</span><br><span class="line">            margin: 1em;</span><br><span class="line">            width: 5em;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;area&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;box rAF&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        function setNewArea() &#123;</span><br><span class="line">            let el = document.createElement(&apos;div&apos;)</span><br><span class="line">            el.setAttribute(&apos;class&apos;, &apos;area&apos;)</span><br><span class="line">            el.innerHTML = &apos;&lt;div class=&quot;box rAF&quot;&gt;&lt;/div&gt;&apos;</span><br><span class="line">            document.body.append(el)</span><br><span class="line">        &#125;</span><br><span class="line">        setNewArea()   </span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">加载过程主要分为三个阶段，它们分别是：</span><br><span class="line"></span><br><span class="line">1. 导航阶段，该阶段主要是从网络进程接收 HTML 响应头和 HTML 响应体。</span><br><span class="line">2. 解析 HTML 数据阶段，该阶段主要是将接收到的 HTML 数据转换为 DOM 和 CSSOM。</span><br><span class="line">3. 生成可显示的位图阶段，该阶段主要是利用 DOM 和 CSSOM，经过计算布局、生成层树 (LayerTree)、生成绘制列表 (Paint)、完成合成等操作，生成最终的图片。</span><br></pre></td></tr></table></figure>
<ul>
<li>导航阶段</li>
</ul>
<ol>
<li>当你点击了 Performance 上的重新录制按钮之后，浏览器进程会通知网络进程去请求对应的 URL 资源；一旦网络进程从服务器接收到 URL 的响应头，便立即判断该响应头中的 content-type 字段是否属于 text/html 类型；如果是，那么浏览器进程会让当前的页面执行退出前的清理操作，比如执行 JavaScript 中的 beforeunload 事件，清理操作执行结束之后就准备显示新页面了，这包括了解析、布局、合成、显示等一系列操作。</li>
<li>因此，在导航阶段，这些任务实际上是在老页面的渲染主线程上执行的。</li>
<li>当你点击重新加载按钮后:<br>第一个子过程就是 Send request，该过程表示网络请求已被发送。然后该任务进入了等待状态。<br>接着由网络进程负责下载资源，当接收到响应头的时候，该任务便执行 Receive Respone 过程，该过程表示接收到 HTTP 的响应头了。<br>接着执行 DOM 事件：pagehide、visibilitychange 和 unload 等事件，如果你注册了这些事件的回调函数，那么这些回调函数会依次在该任务中被调用。<br>这些事件被处理完成之后，那么接下来就接收 HTML 数据了，这体现在了 Recive Data 过程，Recive Data 过程表示请求的数据已被接收，如果 HTML 数据过多，会存在多个 Receive Data 过程。<br>等到所有的数据都接收完成之后，渲染进程会触发另外一个任务，该任务主要执行 Finish load 过程，该过程表示网络请求已经完成。</li>
</ol>
<ul>
<li>解析 HTML 数据阶段</li>
</ul>
<ol>
<li>这个阶段的主要任务就是通过解析 HTML 数据、解析 CSS 数据、执行 JavaScript 来生成 DOM 和 CSSOM。</li>
<li>其中一个主要的过程是 HTMLParser，顾名思义，这个过程是用来解析 HTML 文件，解析的就是上个阶段接收到的 HTML 数据。<br>在 ParserHTML 的过程中，如果解析到了 script 标签，那么便进入了脚本执行过程<br>我们知道，要执行一段脚本我们需要首先编译该脚本，于是在 Evalute Script 过程中，先进入了脚本编译过程，脚本编译好之后，就进入程序执行过程，执行全局代码时，V8 会先构造一个 anonymous 过程，在执行 anonymous 过程中，会调用 setNewArea 过程，setNewArea 过程中又调用了 createElement，由于之后调用了 document.append 方法，该方法会触发 DOM 内容的修改，所以又强制执行了 ParserHTML 过程生成的新的 DOM。<br>DOM 生成完成之后，会触发相关的 DOM 事件，比如典型的 DOMContentLoaded，还有 readyStateChanged。<br>DOM 生成之后，ParserHTML 过程继续计算样式表，也就是 Reculate Style，这就是生成 CSSOM 的过程</li>
</ol>
<ul>
<li>生成可显示位图阶段</li>
</ul>
<ol>
<li>生成页面上的位图。通常这需要经历布局 (Layout)、分层、绘制、合成等一系列操作</li>
<li>在生成完了 DOM 和 CSSOM 之后，渲染主线程首先执行了一些 DOM 事件，诸如 readyStateChange、load、pageshow。具体地讲，如果你使用 JavaScript 监听了这些事件，那么这些监听的函数会被渲染主线程依次调用。</li>
<li>接下来就正式进入显示流程了，大致过程如下所示。<br>首先执行布局，这个过程对应 Layout。<br>然后更新层树 (LayerTree)，这个过程对应Update LayerTree。<br>有了层树之后，就需要为层树中的每一层准备绘制列表了，这个过程就称为 Paint。<br>准备每层的绘制列表之后，就需要利用绘制列表来生成相应图层的位图了，这个过程对应 Composite Layers。<br>走到了 Composite Layers 这步，主线程的任务就完成了，接下来主线程会将合成的任务完全教给合成线程来执行</li>
<li>我们再来梳理下最终图像是怎么显示出来的。<br>首先主线程执行到 Composite Layers 过程之后，便会将绘制列表等信息提交给合成线程，合成线程的执行记录你可以通过 Compositor 指标来查看。<br>合成线程维护了一个 Raster 线程池，线程池中的每个线程称为 Rasterize，用来执行光栅化操作，对应的任务就是 Rasterize Paint。<br>当然光栅化操作并不是在 Rasterize 线程中直接执行的，而是在 GPU 进程中执行的，因此 Rasterize 线程需要和 GPU 线程保持通信。<br>然后 GPU 生成图像，最终这些图层会被提交给浏览器进程，浏览器进程将其合成并最终显示在页面上。</li>
</ol>
<h2 id="HTTPS：浏览器如何验证数字证书？"><a href="#HTTPS：浏览器如何验证数字证书？" class="headerlink" title="HTTPS：浏览器如何验证数字证书？"></a>HTTPS：浏览器如何验证数字证书？</h2><ul>
<li>HTTPS 使用了对称和非对称的混合加密方式，这解决了数据传输安全的问题；</li>
<li>HTTPS 引入了中间机构 CA，CA 通过给服务器颁发数字证书，解决了浏览器对服务器的信任问题；<h3 id="浏览器验证证书的流程"><a href="#浏览器验证证书的流程" class="headerlink" title="浏览器验证证书的流程"></a>浏览器验证证书的流程</h3></li>
<li>在浏览器和服务器建立 HTTPS 链接的过程中，浏览器首先会向服务器请求数字证书，之后浏览器要做的第一件事就是验证数字证书。</li>
<li>具体地讲，浏览器需要验证证书的有效期、证书是否被 CA 吊销、证书是否是合法的 CA 机构颁发的。</li>
<li>数字证书和身份证一样也是有时间期限的，所以第一部分就是验证证书的有效期，这部分比较简单，因为证书里面就含有证书的有效期，所以浏览器只需要判断当前时间是否在证书的有效期范围内即可。</li>
<li>有时候有些数字证书被 CA 吊销了，吊销之后的证书是无法使用的，所以第二部分就是验证数字证书是否被吊销了。通常有两种方式，一种是下载吊销证书列表 -CRL (Certificate Revocation Lists)，第二种是在线验证方式 -OCSP (Online Certificate Status Protocol) </li>
<li>验证数字证书是否是 CA 机构颁发的，验证的流程非常简单：</li>
</ul>
<ol>
<li>首先，浏览器利用证书的原始信息计算出信息摘要；</li>
<li>然后，利用 CA 的公钥来解密数字证书中的数字签名，解密出来的数据也是信息摘要；</li>
<li>最后，判断这两个信息摘要是否相等就可以了。</li>
</ol>
<h3 id="浏览器是怎么获取到-CA-公钥的？"><a href="#浏览器是怎么获取到-CA-公钥的？" class="headerlink" title="浏览器是怎么获取到 CA 公钥的？"></a>浏览器是怎么获取到 CA 公钥的？</h3><ul>
<li>通常，当你部署 HTTP 服务器的时候，除了部署当前的数字证书之外，还需要部署 CA 机构的数字证书，CA 机构的数字证书包括了 CA 的公钥，以及 CA 机构的一些基础信息。</li>
<li>服务器就有了两个数字证书:域名的数字证书；签名的 CA 机构的数字证书。</li>
<li>然后在建立 HTTPS 链接时，服务器会将这两个证书一同发送给浏览器，于是浏览器就可以获取到 CA 的公钥了。</li>
<li>如果有些服务器没有部署 CA 的数字证书，那么浏览器还可以通过网络去下载 CA 证书，不过这种方式多了一次证书下载操作，会拖慢首次打开页面的请求速度，一般不推荐使用。<h3 id="证明-CA-机构的合法性"><a href="#证明-CA-机构的合法性" class="headerlink" title="证明 CA 机构的合法性"></a>证明 CA 机构的合法性</h3></li>
<li>这里并没有一个非常好的方法来证明 CA 的合法性，妥协的方案是，直接在操作系统中内置这些 CA 机构的数字证书</li>
<li>我们将所有 CA 机构的数字证书都内置在操作系统中，这样当需要使用某 CA 机构的公钥时，我们只需要依据 CA 机构名称，就能查询到对应的数字证书了，然后再从数字证书中取出公钥。</li>
<li>不过这种方式依然存在问题，因为在实际情况下，CA 机构众多，因此操作系统不可能将每家 CA 的数字证书都内置进操作系统。</li>
</ul>
<h3 id="数字证书链"><a href="#数字证书链" class="headerlink" title="数字证书链"></a>数字证书链</h3><ul>
<li>将颁发证书的机构划分为两种类型，根 CA(Root CAs)和中间 CA(Intermediates CAs)，通常申请者都是向中间 CA 去申请证书的，而根 CA 作用就是给中间 CA 做认证，一个根 CA 会认证很多中间的 CA，而这些中间 CA 又可以去认证其他的中间 CA。<h3 id="如何验证根证书的合法性"><a href="#如何验证根证书的合法性" class="headerlink" title="如何验证根证书的合法性"></a>如何验证根证书的合法性</h3></li>
<li>其实浏览器的判断策略很简单，它只是简单地判断这个根证书在不在操作系统里面，如果在，那么浏览器就认为这个根证书是合法的，如果不在，那么就是非法的。</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/学习/">学习</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/学习/">学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网站/">网站</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/资源/">资源</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-module_webpack" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2021/03/08/module_webpack/" class="article-date">
      <time datetime="2021-03-07T16:00:00.000Z" itemprop="datePublished">2021-03-08</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/08/module_webpack/">模块化/webpack</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="ES-Modules"><a href="#ES-Modules" class="headerlink" title="ES Modules"></a>ES Modules</h2><p>1.自动采用严格模式（use strict）<br>2.每个ESM模块都是单独的私有作用域<br>3.ESM模块通过CORS（跨域资源共享）去请求外部js模块<br>4.ESM的script标签会延迟脚本的执行</p>
<h2 id="url-loader、file-loader"><a href="#url-loader、file-loader" class="headerlink" title="url-loader、file-loader"></a>url-loader、file-loader</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">url-loader  小文件使用Data URLs,减少请求次数</span><br><span class="line">file-loader 大文件单独提取存放，提高加载速度</span><br><span class="line">&#123;</span><br><span class="line">  test:/.png$/,</span><br><span class="line">  use:&#123;</span><br><span class="line">    loader:&quot;url-loader&quot;,</span><br><span class="line">	options:&#123;</span><br><span class="line">	   limit:10*1024,//10kb以下使用url-loader,10kb以上使用file-loader</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="css-loader、style-loader"><a href="#css-loader、style-loader" class="headerlink" title="css-loader、style-loader"></a>css-loader、style-loader</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">css-loader 将css代码转换成js模块</span><br><span class="line">style-loader 将css代码通过style标签插入html当中</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"> test:/.css$/,</span><br><span class="line"> use:[&apos;style-loader&apos;,&apos;css-loader&apos;]  //由后往前加载loader</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="html-loader"><a href="#html-loader" class="headerlink" title="html-loader"></a>html-loader</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> test:/.html$/,</span><br><span class="line"> use:&#123;</span><br><span class="line">  loader:&apos;html-loader&apos;,</span><br><span class="line">  options:&#123;</span><br><span class="line">     attrs:[&apos;img:src&apos;,&apos;a:href&apos;]  //默认只处理img标签src属性</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><ul>
<li>专注实现资源模块加载，实现项目打包</li>
<li>加载过程类似于管道，可以依次使用多个loader，最终结果必须是js代码。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">module:&#123;</span><br><span class="line">rules:[</span><br><span class="line">   &#123;</span><br><span class="line">   test:/.md$/,</span><br><span class="line">   use:&apos;./markdown-loader&apos;  //可以是模块路径或模块名称</span><br><span class="line">   &#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//自定义loader  处理md文件</span><br><span class="line">const marked=reuqire(&apos;marked&apos;)</span><br><span class="line">module.exports=source=&gt;&#123;</span><br><span class="line"> const html = marked(source)</span><br><span class="line"> return  `export default $&#123;JSON.stringify(html)&#125;`   //最终输出结果必须是js代码 。   可以返回html，交给html-loader继续处理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li>编译转换类：将资源模块转换为js代码。   //<code>css-loader</code>:将css代码转换成js模块</li>
<li>文件操作类：将资源模块拷贝到输出目录，向外到处文件的访问路径   //<code>file-loader</code></li>
<li>代码检查类：对资源模块进行校验   //<code>eslint-loader</code></li>
</ul>
<h2 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h2><ul>
<li>增强webpack自动化能力，实现大多前端工程化 //清除dist目录插件、拷贝不需要参与打包的静态资源文件到输出目录、压缩输出代码等</li>
<li>拥有更宽的能力范围，通过钩子机制实现</li>
<li>必须是一个函数或者包含<code>apply</code>方法的对象,通过在生命周期的钩子中挂载函数实现扩展</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//自定义插件</span><br><span class="line">class MyPlugin&#123;</span><br><span class="line"></span><br><span class="line"> //webpack启动时自动调用</span><br><span class="line"> apply(compiler)&#123;</span><br><span class="line">  compiler.hooks.emit.tap(&apos;MyPlugin&apos;,compilation=&gt;&#123;</span><br><span class="line">    //compilation  //打包上下文</span><br><span class="line">	//compilation.assets   //打包的资源文件 (对象)</span><br><span class="line">	//compilation.assets[&apos;文件名&apos;].source()  //资源文件内容</span><br><span class="line">	</span><br><span class="line">	compilation.assets[&apos;文件名&apos;]=&#123;</span><br><span class="line">	 source:()=&gt; 返回更改的文件内容，</span><br><span class="line">	 size:()=&gt;返回文件的大小</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;)</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">const &#123;CleanWebpackPlugin&#125;  from &apos;clean-webpack-plugin&apos; //自动清除输出目录 </span><br><span class="line">const HtmlWebpackPlugin  from &apos;html-webpack-plugin&apos; //自动生成html </span><br><span class="line">const CopyWebpackPlugin  from &apos;copy-webpack-plugin&apos; //拷贝不需要打包静态资源到输出目录</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plugins:[ </span><br><span class="line">new CleanWebpackPlugin(),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//index.html</span><br><span class="line">new HtmlWebpackPlugin(</span><br><span class="line">&#123;</span><br><span class="line">  title:&apos;diamonds&apos;,   //设置生成html的title属性</span><br><span class="line">  meta:&#123;</span><br><span class="line">   viewport:&apos;width=device-width&apos;</span><br><span class="line">  &#125;，</span><br><span class="line">  template:&apos;./src/index.html&apos;   //html使用的模板</span><br><span class="line">&#125;),</span><br><span class="line"></span><br><span class="line">//about.html</span><br><span class="line">new HtmlWebpackPlugin(</span><br><span class="line">&#123;</span><br><span class="line">  filename:&apos;about.html&apos;  //输出的文件名  默认是index.html</span><br><span class="line">&#125;),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//生产阶段使用</span><br><span class="line">new CopyWebpackPlugin([&apos;public&apos;]),  //将public目录下资源拷贝到输出目录</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h2><p>//工作模式  默认production</p>
<ul>
<li>production  //优化打包结果      代码压缩等</li>
<li>development  //优化打包速度，增加辅助函数便于调试</li>
<li>none   //不做处理</li>
</ul>
<h2 id="–watch"><a href="#–watch" class="headerlink" title="–watch"></a>–watch</h2><p> //监听  自动编译</p>
<h2 id="browser-sync"><a href="#browser-sync" class="headerlink" title="browser-sync"></a>browser-sync</h2><p>//实现浏览器自动刷新</p>
<p><code>browser-sync 文件目录  --files  &#39;**/*&#39;</code>   //启动并监听文件改变</p>
<h2 id="webapck-dev-server"><a href="#webapck-dev-server" class="headerlink" title="webapck-dev-server"></a>webapck-dev-server</h2><p>//集成自动编译、自动刷新功能</p>
<h2 id="devServer"><a href="#devServer" class="headerlink" title="devServer"></a>devServer</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//webpack-dev-server 配置选项</span><br><span class="line">devServer:&#123;</span><br><span class="line">  contentBase:&apos;&apos; , //额外为开发服务器指定查找资源目录</span><br><span class="line">  //代理服务配置</span><br><span class="line">  proxy:&#123;</span><br><span class="line">    //前缀</span><br><span class="line">    &apos;/api&apos;:&#123;</span><br><span class="line">	   //代理请求目标  http://localhost:8080/api/users -&gt; https://api.github.com/api/users</span><br><span class="line">	  target:&apos;https://api.github.com&apos;,</span><br><span class="line">	  //路径重写</span><br><span class="line">	  pathRewrite:&#123;</span><br><span class="line">	  &apos;^/api&apos;:&apos;&apos;   // https://api.github.com/users</span><br><span class="line">	  &#125;,</span><br><span class="line">	  //改变请求源</span><br><span class="line">	  changeOrigin:true</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="devtool"><a href="#devtool" class="headerlink" title="devtool"></a>devtool</h2><p>(build初次构建速度、rebuild监视模式重新打包速度、production是否适合在生产环境中使用、quality质量)     </p>
<ul>
<li><code>source-map</code></li>
<li><code>eval</code>  //通过<code>sourceURL</code>描述对应模块文件的资源路径   不生成对应的<code>sourceMap</code>,只能定位到错误出现的具体文件  构建速度快</li>
<li><code>cheap-eveal-source-map</code>   阉割版  生成的<code>sourceMap</code>只能定位到错误具体行，没有列的信息</li>
<li><code>cheap-module-eveal-source-map</code>   解析出来的源代码没有经过对应的loader加工，与手写时候的代码一样  一般开发环境使用多</li>
<li><code>inline-source-map</code> 通过<code>DataURL</code>方式将<code>sourceMap</code>嵌入到代码当中，<code>eval-source-map</code>也是</li>
<li><code>hidden-source-map</code> 代码当中没有通过注释方式引入<code>sourceMap</code></li>
<li><code>nosources-source-map</code> 能看到错误出现行列信息，但看不到源代码   生产环境不会暴露源代码</li>
<li><code>none</code>  推荐生产环境使用</li>
</ul>
<h2 id="HMR-热更新"><a href="#HMR-热更新" class="headerlink" title="HMR  热更新"></a><code>HMR</code>  热更新</h2><ul>
<li>应用运行过程中实时替换某个模块，应用运行状态不受影响</li>
<li>不刷新页面情况下，及时更新模块</li>
<li>提高开发效率</li>
<li>集成在<code>webpack-dev-server</code> 中  </li>
<li>使用方式：<code>webpack-dev-server --hot</code>  或 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">style-loader自动处理样式文件的热更新  js模块热更新需要手动处理</span><br><span class="line">const webpack=require(&apos;webpack&apos;)</span><br><span class="line">devServer:&#123;</span><br><span class="line">  hot:true  //热替换失败，自动刷新浏览器      hotOnly取消浏览器自动刷新</span><br><span class="line">&#125;,</span><br><span class="line">plugins:[</span><br><span class="line">  //module.hot</span><br><span class="line">  new webpack.HotModuleReplacementPlugin()</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">------------------</span><br><span class="line"></span><br><span class="line">注册模块更新后的处理函数</span><br><span class="line">//打包后代码会被自动移除，不会影响生产环境</span><br><span class="line">if(module.hot)&#123;</span><br><span class="line">module.hot.accept(&apos;模块路径&apos;,()=&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="webpack-config-js"><a href="#webpack-config-js" class="headerlink" title="webpack.config.js"></a>webpack.config.js</h2><p><code>webpack --env production</code>  //生产模式打包<br><code>webpack --config webpack.prod.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module.exports=(env,argv)=&gt;&#123;&#125;</span><br><span class="line">if(env===&apos;production&apos;)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">------------------</span><br><span class="line"></span><br><span class="line">const merge=require(&apos;webpack-merge&apos;)//合并webpack配置文件</span><br></pre></td></tr></table></figure>
<h2 id="definePlugin"><a href="#definePlugin" class="headerlink" title="definePlugin"></a>definePlugin</h2><ul>
<li>为代码注入全局成员</li>
<li><code>production</code>模式下默认启动，并注入<code>process.env.NODE_ENV</code>变量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const webpack =reuqire(&apos;webpack&apos;)</span><br><span class="line"></span><br><span class="line">plugins:[</span><br><span class="line"></span><br><span class="line">//注入全局变量</span><br><span class="line"> new webpack.DefinePlugin(&#123;</span><br><span class="line">    API_BASE_URL:&apos;&quot;&quot;&apos; //代码片段  可以通过JSON.stringify()传递变量</span><br><span class="line"> &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="tree-shaking-基于ES-Modules"><a href="#tree-shaking-基于ES-Modules" class="headerlink" title="tree-shaking  (基于ES Modules)"></a>tree-shaking  (基于ES Modules)</h2><ul>
<li>移除为引用代码</li>
<li>生产模式下自动开启</li>
<li>由Webpack打包的代码必须使用ESM</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//优化选项</span><br><span class="line">optimization:&#123;</span><br><span class="line">  usedExports:true,   //只导出外部使用过的成员</span><br><span class="line">  minimize:true, //代码压缩</span><br><span class="line">  concatenateModules:true  // `ScopeHoisting`作用域提升）   尽可能将所有模块合并在一起，提高运行效率，减少代码体积 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="babel-loader-与-tree-shaking"><a href="#babel-loader-与-tree-shaking" class="headerlink" title="babel-loader 与 tree-shaking"></a>babel-loader 与 tree-shaking</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">module:[</span><br><span class="line">  &#123;</span><br><span class="line">  test:/\.js$/,</span><br><span class="line">  use:&#123;</span><br><span class="line">    loader:&apos;babel-loader&apos;,</span><br><span class="line">	options:&#123;</span><br><span class="line">	 presets:[[&apos;@babel/preset-env&apos;],&#123;</span><br><span class="line">	  modules:&apos;commonjs&apos;   //默认是auto 根据环境判断是否开启ES Module插件</span><br><span class="line">	 &#125;]  //</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="sideEffects"><a href="#sideEffects" class="headerlink" title="sideEffects"></a>sideEffects</h2><p>//副作用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">optimization:&#123;</span><br><span class="line">   //production模式下会自动开启  为tree-shaking提供更大的压缩空间   （使用前应确保代码真的没有副作用。 副作用：模块执行时除了导出成员外所做的其它的事情	）</span><br><span class="line">  sideEffects:true//   webpack会先检查当前项目的package.json当中是否有sideEffects字段 ,  sideEffects:false表示没有副作用，也可是数组 sideEffects:[&apos;*.css&apos;]  表示有副作用的模块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="code-splitting"><a href="#code-splitting" class="headerlink" title="code splitting"></a>code splitting</h2><p>//代码分割 按需加载</p>
<ul>
<li>多入口打包</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">entry:&#123;</span><br><span class="line">   index:&apos;&apos;,</span><br><span class="line">   main:&apos;&apos;</span><br><span class="line">&#125;,</span><br><span class="line">output:&#123;</span><br><span class="line">  //动态生成</span><br><span class="line">   filename:&apos;[name].bundle.js&apos;</span><br><span class="line">&#125;,</span><br><span class="line">plugins:[</span><br><span class="line"></span><br><span class="line">    //默认生成自动注入所有打包结果的html，可以通过chunks属性为生成的html指定所需要的bundle</span><br><span class="line">   new HtmlWebpackPlugin(&#123;</span><br><span class="line">     title:&apos;&apos;,</span><br><span class="line">	 template:&apos;./src/index.html&apos;,</span><br><span class="line">	 filename:&apos;index.html&apos;,</span><br><span class="line">	 chunks:[&apos;index&apos;] </span><br><span class="line">   &#125;),</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">     title:&apos;&apos;,</span><br><span class="line">	 template:&apos;./src/main.html&apos;,</span><br><span class="line">	 filename:&apos;main.html&apos;,</span><br><span class="line">	 chunks:[&apos;main&apos;] </span><br><span class="line">   &#125;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<ul>
<li>ES Module 动态导入   </li>
</ul>
<p>//模块会被自动分包  可以通过魔法注释为生成的bundle文件设置名字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import (/* webpackChunkName:&apos;&apos; */ &apos;&apos;).then((&#123;default:module&#125;)=&gt;&#123;&#125;)   //相同的chunkName会被打包到一起</span><br></pre></td></tr></table></figure>
<ul>
<li>提取公共模块<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">optimization:&#123;</span><br><span class="line">  splitChunks:&#123;</span><br><span class="line">    chunks:&apos;all&apos;  // 会将所有的公共模块提取到单独的bundle当中</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="mini-css-extract-plugin"><a href="#mini-css-extract-plugin" class="headerlink" title="mini-css-extract-plugin"></a>mini-css-extract-plugin</h2><p>//（css文件超过150kb时可以考虑单独提取）  样式会单独存放在文件当中，不在需要style标签引入（style-loader）,通过link标签方式注入样式文件  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">module:&#123;</span><br><span class="line">   rules:[</span><br><span class="line">   &#123;</span><br><span class="line">   test:/\.css$/,</span><br><span class="line">   use:[</span><br><span class="line">   MiniCssExtractPlugin.loader,  //通过link标签引入样式文件</span><br><span class="line">   &apos;css-loader&apos;</span><br><span class="line">   ] </span><br><span class="line">   &#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="optimize-css-assets-webpack-plugin"><a href="#optimize-css-assets-webpack-plugin" class="headerlink" title="optimize-css-assets-webpack-plugin"></a>optimize-css-assets-webpack-plugin</h2><p> //压缩css文件   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">optimization:&#123;         </span><br><span class="line">  //webpack默认压缩js代码</span><br><span class="line">  //production模式自动开启</span><br><span class="line">  //自动压缩插件</span><br><span class="line">  minimizer:[</span><br><span class="line">   new OptimizeCssAssetsWebpackPlugin()</span><br><span class="line">   new TerserWebpackPlugin()   //压缩js代码</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="输出文件名-Hash"><a href="#输出文件名-Hash" class="headerlink" title="输出文件名 Hash"></a>输出文件名 Hash</h2><ul>
<li>filename:’[name]-[hash].bundle.css’  //项目任一文件发生改变，hash值都会改变</li>
<li>filename:’[name]-[chunkhash].bundle.css’  //chunk级别</li>
<li>filename:’[name]-[contenthash:8].bundle.css’  //单个文件级别</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/学习/">学习</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/学习/">学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网站/">网站</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/资源/">资源</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-yeoman" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2021/03/08/yeoman/" class="article-date">
      <time datetime="2021-03-07T16:00:00.000Z" itemprop="datePublished">2021-03-08</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/08/yeoman/">脚手架/yeoman/gulp</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="脚手架"><a href="#脚手架" class="headerlink" title="脚手架"></a>脚手架</h2><ul>
<li>创建项目基本结构、提供项目规范和约定(组织结构、开发范式、模块依赖、工具配置、基础代码)</li>
<li>搭建脚手架</li>
</ul>
<ol>
<li>创建cli.js文件,</li>
<li>在package.json添加字段 “bin”:”cli.js” 指明入口文件  </li>
<li><code>yarn add inquirer</code>来发起命令行交互</li>
<li>创建templates目录</li>
<li><code>yarn add ejs</code></li>
<li>yarn link 使之成为一个全局的模块<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env node</span><br><span class="line">//Node CLI应用入口文件必须要有这样的文件头</span><br><span class="line">//如果是Linux或者macOS还需要修改此文件的读写权限为755</span><br><span class="line"></span><br><span class="line"> const path=require(&apos;path&apos;)</span><br><span class="line"> const fa=require(&apos;fs&apos;)</span><br><span class="line"> const inquirer=require(&apos;inquirer&apos;)</span><br><span class="line"> const ejs=require(&apos;ejs&apos;)</span><br><span class="line"> inquirer.prompt([</span><br><span class="line"> &#123;</span><br><span class="line">  type:&apos;input&apos;,</span><br><span class="line">  name:&apos;name&apos;,</span><br><span class="line">  message:&apos;project name&apos;</span><br><span class="line"> &#125;</span><br><span class="line"> ]).then(answers=&gt;&#123;</span><br><span class="line"> </span><br><span class="line"> //模板目录</span><br><span class="line">    const tmpDir=path.join(__dirname,&apos;templates&apos;)</span><br><span class="line"> //目标目录   </span><br><span class="line">    const destDir=process.cwd() </span><br><span class="line"> </span><br><span class="line">    fs.readdir(tmpDir,(err,files)=&gt;&#123;</span><br><span class="line">	 if(err) return</span><br><span class="line">	 files.forEach(()=&gt;&#123;</span><br><span class="line">	  //通过模板引擎渲染文件</span><br><span class="line">	  </span><br><span class="line">	  ejs.renderFile(path.join(tmpDir,file,answers,(err,result)=&gt;&#123;</span><br><span class="line">	   if(err) return</span><br><span class="line">	  </span><br><span class="line">	  //将结果写入文件</span><br><span class="line">	   fs.writeFileSync(path.join(destDir,file),result)</span><br><span class="line">	  &#125;))</span><br><span class="line">	 </span><br><span class="line">	 &#125;)</span><br><span class="line">	 </span><br><span class="line">	&#125;)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="Yeoman"><a href="#Yeoman" class="headerlink" title="Yeoman"></a>Yeoman</h3><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><ol>
<li>全局安装：<code>yarn global add yo</code> 或 <code>npm install yo --global</code></li>
<li>安装相关generator:例如  <code>yarn global add generator-node</code> 或 <code>npm install generator-node --global</code></li>
<li>运行generator: 例如  <code>yo node</code></li>
</ol>
<h4 id="自定义generator"><a href="#自定义generator" class="headerlink" title="自定义generator"></a>自定义generator</h4><ol>
<li>创建文件目录：</li>
</ol>
<ul>
<li>generator模块名称必须是generator-name格式。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* generators 生成器目录</span><br><span class="line">  * app      默认生成器目录</span><br><span class="line">    * templates 模板目录   内部文件可以使用EJS模板标记输出数据 例如&lt;%= title %&gt; 或&lt;% if (success) &#123; %&gt; &lt;% &#125; %&gt;</span><br><span class="line">    * index.js  默认生成器实现</span><br><span class="line">* package.json   配置文件</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="2">
<li>创建generator</li>
</ol>
<ul>
<li>安装yeoman-generator </li>
<li>在index.js文件编写逻辑<br>index.js文件是generator的入口文件，该文件需要导出一个继承自Yeoman Generator的类型。<br>Yeoman Generator在工作时会自动调用我们在此类型文件中定义的一些生命周期方法。<br>我们可以在这些方法中调用父类提供的一些工具方法实现一些功能，例如文件写入<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">const Generator=require(&apos;yeoman-genertaor&apos;)</span><br><span class="line">module.exports=class extends Generator&#123;</span><br><span class="line"></span><br><span class="line">//yeoman在询问用户时会自动调用此方法</span><br><span class="line">prompting()&#123;</span><br><span class="line">//返回的时promise类型  参数时数组  对应每个问题</span><br><span class="line">return this.prompt([</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  type:&apos;input&quot;,</span><br><span class="line">  name:&apos;name&apos;,</span><br><span class="line">  message:&apos;项目名字&apos;，</span><br><span class="line">  default:this.appname //appname为项目生成目录名称</span><br><span class="line">&#125;</span><br><span class="line">]).then(answers=&gt;&#123;</span><br><span class="line">//answers=&gt;  &#123;name:&apos;用户输入的值&apos;&#125;</span><br><span class="line">  this.answers=answers   //作为模板的上下文数据</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//yeoman在生成文件时自动调用此方法</span><br><span class="line"> writing()&#123;</span><br><span class="line">   </span><br><span class="line"> </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="3">
<li>通过<code>yarn link</code>或<code>npm link</code>使之成为一个全局的模块</li>
<li>通过yo命令运行generator</li>
<li>发布generator <code>npm publish</code>或<code>yarn publish --registry=https://registry.yarnpkg.com</code><h3 id="Plop"><a href="#Plop" class="headerlink" title="Plop"></a>Plop</h3></li>
<li>作为开发依赖安装 <code>yarn add plop --dev</code> </li>
<li><p>创建plopfile.js文件,plop-templates目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">module.exports=plop=&gt;&#123;</span><br><span class="line"></span><br><span class="line"> plop.setGenerator(&apos;component&apos;,&#123;</span><br><span class="line">  description:&apos;create a component&apos;,</span><br><span class="line">  prompts:[&#123;</span><br><span class="line">  </span><br><span class="line">   type:&apos;input&apos;,</span><br><span class="line">   name:&apos;name&apos;,</span><br><span class="line">   message:&apos;component name&apos;,</span><br><span class="line">   default:&apos;MyComponent&apos;</span><br><span class="line">  &#125;],</span><br><span class="line">  actions:[</span><br><span class="line">  &#123;</span><br><span class="line">  //添加文件</span><br><span class="line">  type:&apos;add&apos;,</span><br><span class="line">   path:&apos;src/components/&#123;&#123;name&#125;&#125;/&#123;&#123;name&#125;&#125;.js&apos;</span><br><span class="line">   templateFile:&apos;plop-templates/component.hbs&apos;</span><br><span class="line">  &#125;，</span><br><span class="line">   &#123;</span><br><span class="line">  //添加文件</span><br><span class="line">  type:&apos;add&apos;,</span><br><span class="line">   path:&apos;src/components/&#123;&#123;name&#125;&#125;/&#123;&#123;name&#125;&#125;.css&apos;</span><br><span class="line">   templateFile:&apos;plop-templates/component.css.hbs&apos;</span><br><span class="line">  &#125;，</span><br><span class="line">  ]</span><br><span class="line"> &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>yarn plop component</code> 对应上面设置的generator名字</p>
</li>
</ol>
<h2 id="gulp"><a href="#gulp" class="headerlink" title="gulp"></a>gulp</h2>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/学习/">学习</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/学习/">学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网站/">网站</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/资源/">资源</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-question_four" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2021/01/10/question_four/" class="article-date">
      <time datetime="2021-01-09T16:00:00.000Z" itemprop="datePublished">2021-01-10</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/01/10/question_four/">知识点四</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="请说出下列最终的执行结果，并解释为什么。"><a href="#请说出下列最终的执行结果，并解释为什么。" class="headerlink" title="请说出下列最终的执行结果，并解释为什么。"></a>请说出下列最终的执行结果，并解释为什么。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = [];</span><br><span class="line">for (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    a[i] = function() &#123;</span><br><span class="line">        console.log(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">a[6]()</span><br></pre></td></tr></table></figure>
<p>答：结果是10。因为for循环里的i是全局变量，for循环执行完之后，i已经变成了10，所以之后无论调用a几，输出的都是10。</p>
<hr>
<h2 id="请说出下列最终的执行结果，并解释为什么。-1"><a href="#请说出下列最终的执行结果，并解释为什么。-1" class="headerlink" title="请说出下列最终的执行结果，并解释为什么。"></a>请说出下列最终的执行结果，并解释为什么。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var tmp = 123;</span><br><span class="line">if (true) &#123;</span><br><span class="line">    console.log(tmp)</span><br><span class="line">    let tmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答：结果报错，cannot access ‘tmp’ before initialization<br>     原因：let 会形成块级作用域和封闭作用域，所以 tmp 无法拿到外层 var 声明的值，只能在块级作用域中查找。let 不会导致变量提升，因此<code>console.log(tmp)</code>无法找到声明，出现暂时性死区。</p>
<hr>
<h2 id="结合ES6新语法，用最简单的方法找出数组中的最小值。"><a href="#结合ES6新语法，用最简单的方法找出数组中的最小值。" class="headerlink" title="结合ES6新语法，用最简单的方法找出数组中的最小值。"></a>结合ES6新语法，用最简单的方法找出数组中的最小值。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var arr = [12, 34, 32, 89, 4]</span><br></pre></td></tr></table></figure>
<p>答：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.sort((a, b) =&gt; a-b)[0]</span><br><span class="line">arr.reduce((min,num)=&gt;min&lt;num?min:num)</span><br><span class="line">Math.min(...arr)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="请详细说明-var，let，const-三种声明变量方式之间的具体差别。"><a href="#请详细说明-var，let，const-三种声明变量方式之间的具体差别。" class="headerlink" title="请详细说明 var，let，const 三种声明变量方式之间的具体差别。"></a>请详细说明 var，let，const 三种声明变量方式之间的具体差别。</h2><table>
<thead>
<tr>
<th></th>
<th>var</th>
<th>let</th>
<th>const</th>
</tr>
</thead>
<tbody>
<tr>
<td>提升</td>
<td>声明提升，使用undefined初始化</td>
<td>不存在变量提升</td>
<td>不存在变量提升</td>
</tr>
<tr>
<td>作用域</td>
<td>全局</td>
<td>块级</td>
<td>块级</td>
</tr>
<tr>
<td>初始化</td>
<td>可以仅声明不初始化</td>
<td>可以仅声明不初始化</td>
<td>必须在声明时初始化</td>
</tr>
<tr>
<td>重复定义</td>
<td>可以</td>
<td>不可以</td>
<td>不可以</td>
</tr>
<tr>
<td>多次赋值</td>
<td>可以</td>
<td>可以</td>
<td>基本数据类型不可以，引用数据类型仅可改变值</td>
</tr>
<tr>
<td>声明前访问</td>
<td>可以</td>
<td>不可以</td>
<td>不可以</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="请说出下列代码最终输出的结果，并解释为什么。"><a href="#请说出下列代码最终输出的结果，并解释为什么。" class="headerlink" title="请说出下列代码最终输出的结果，并解释为什么。"></a>请说出下列代码最终输出的结果，并解释为什么。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a = 10;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    a: 20,</span><br><span class="line">    fn () &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(this.a)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.fn()</span><br></pre></td></tr></table></figure>
<p>答：打印20。因为setTimeout是箭头函数，里面的this指向没有改变和fn函数里的this是一致的都指向obj，所以会输出20</p>
<hr>
<h2 id="简述Symbol类型的用途。"><a href="#简述Symbol类型的用途。" class="headerlink" title="简述Symbol类型的用途。"></a>简述Symbol类型的用途。</h2><p>答：</p>
<ul>
<li>作为对象的属性，可以作为对象的私有属性，</li>
<li>阻止对象上属性名的冲突，每个 Symbol 都独一无二的，可以保证不与其他属性名产生冲突，</li>
<li>使用Symbol来替代常量</li>
</ul>
<hr>
<h2 id="说说什么是浅拷贝，什么是深拷贝。"><a href="#说说什么是浅拷贝，什么是深拷贝。" class="headerlink" title="说说什么是浅拷贝，什么是深拷贝。"></a>说说什么是浅拷贝，什么是深拷贝。</h2><p>答：</p>
<ul>
<li>浅拷贝：针对 Object,Array 这种复杂数据类型，浅拷贝复制一层对象的属性，属性中的值是基本数据类型直接复制值，如果是引用类型复制内存地址的指针，所以在修改复制后的变量里引用类型的里面的值时，会导致原始数据也被修改</li>
<li>深拷贝：针对 Object,Array 这种复杂数据类型，深复制递归复制了所有的层级，新数据和原始数据不存在联系，因此在修改复制后的变量里引用类型的里面的值时，不会导致原始数据也被修改</li>
</ul>
<hr>
<h2 id="简述TypeScript和JavaScript之间的关系。"><a href="#简述TypeScript和JavaScript之间的关系。" class="headerlink" title="简述TypeScript和JavaScript之间的关系。"></a>简述TypeScript和JavaScript之间的关系。</h2><p>答：TypeScript 并不是一个完全新的语言, 它是 JavaScript 的超集，为 JavaScript 的生态增加了类型机制，并最终将代码编译为纯粹的 JavaScript 代码。</p>
<table>
<thead>
<tr>
<th>TypeScript</th>
<th>JavaScript</th>
</tr>
</thead>
<tbody>
<tr>
<td>JavaScript 的超集用于解决大型项目的代码复杂性</td>
<td>一种脚本语言，用于创建动态网页。</td>
</tr>
<tr>
<td>可以在编译期间发现并纠正错误</td>
<td>作为一种解释型语言，只能在运行时发现错误</td>
</tr>
<tr>
<td>强类型，支持静态和动态类型</td>
<td>弱类型，没有静态类型选项</td>
</tr>
<tr>
<td>最终被编译成 JavaScript 代码，使浏览器可以理解</td>
<td>可以直接在浏览器中使用</td>
</tr>
<tr>
<td>支持模块、泛型和接口</td>
<td>不支持模块，泛型或接口</td>
</tr>
<tr>
<td>支持 ES3，ES4，ES5 和 ES6 等</td>
<td>不支持编译其他 ES3，ES4，ES5 或 ES6 功能</td>
</tr>
<tr>
<td>社区的支持仍在增长，而且还不是很大</td>
<td>大量的社区支持以及大量文档和解决问题的支持</td>
</tr>
</tbody>
</table>
<h2 id="请谈谈你所认为的TypeScript优缺点。"><a href="#请谈谈你所认为的TypeScript优缺点。" class="headerlink" title="请谈谈你所认为的TypeScript优缺点。"></a>请谈谈你所认为的TypeScript优缺点。</h2><p>优点：</p>
<ul>
<li>任何一种 javascript 运行环境都支持</li>
<li>功能更为强大，生态更健全、更完善</li>
<li>TypeScript 属于渐进式的</li>
<li>增强代码的可读性和可维护性，增强了编译器和 IDE 的功能，定义可以作为文文档</li>
<li>在编译阶段就可以发现大部分大错误，不需要在运行时才发现</li>
</ul>
<p>缺点：</p>
<ul>
<li>语言本身多了很多概率，提高学习成本</li>
<li>项目初期，TypeScript 增加开发成本</li>
<li>集成到构建流程需要一些工足量</li>
<li>可能和一些库结合不完美，需要单独添加一些声明，不过大部分的库都支持了 TypeScript</li>
</ul>
<h2 id="描述引用计数的工作原理和优缺点。"><a href="#描述引用计数的工作原理和优缺点。" class="headerlink" title="描述引用计数的工作原理和优缺点。"></a>描述引用计数的工作原理和优缺点。</h2><p>工作原理：设置引用数,判断当前引用数是否为 0，引用关系改变时修改引用数字</p>
<p>优点：</p>
<ol>
<li>发现垃圾时立即回收</li>
<li>最大限度减少程序暂停（保证空间不会被占满）</li>
</ol>
<p>缺点：</p>
<ol>
<li>无法回收循环引用的对象</li>
<li>时间开销大（监控对象，维护引用数）</li>
</ol>
<h2 id="描述标记整理算法的工作流程。"><a href="#描述标记整理算法的工作流程。" class="headerlink" title="描述标记整理算法的工作流程。"></a>描述标记整理算法的工作流程。</h2><ol>
<li><p>遍历所有对象找标记活动对象</p>
</li>
<li><p>清除阶段会先执行整理，移动对象位置，将活动对象放在一起</p>
</li>
<li><p>清除没有标记的对象，同时把第一次遍历所做的标记抹掉</p>
</li>
<li><p>把回收的空间放到空闲列表上面，方便后续程序申请空间使用</p>
<p>优点： 减少了内存空间的碎片化，缺点： 不能立即回收对象</p>
</li>
</ol>
<h2 id="描述V8中新生代存储区垃圾回收的流程。"><a href="#描述V8中新生代存储区垃圾回收的流程。" class="headerlink" title="描述V8中新生代存储区垃圾回收的流程。"></a>描述V8中新生代存储区垃圾回收的流程。</h2><ol>
<li>回收过程采用复制算法+标记整理算法</li>
<li>新生代分为 from-to 两个等大空间 32M(32 位为 16M)</li>
<li>使用空间为 from 内存区，空闲空间为 to 内存区，当 from 空间应用一定大小会触发标记整理</li>
<li>当发生标记整理后，复制活动对象到 to 内存区，然后 From 空间进行内存释放。</li>
<li>如果拷贝时出现晋升，将新生代活动对象移入老生代</li>
<li>当 To 空间的使用率达到 25%时，将新生代活动对象移入老生代</li>
<li>当一轮 GC 执行完毕后还存活的新生代测需要晋级</li>
<li>当一次 GC 操作后，From 和 to 需要进行置换</li>
</ol>
<h2 id="描述增量标记算法在何时使用及工作原理。"><a href="#描述增量标记算法在何时使用及工作原理。" class="headerlink" title="描述增量标记算法在何时使用及工作原理。"></a>描述增量标记算法在何时使用及工作原理。</h2><p>答： 使用时机：会穿插在程序的运行中执行。</p>
<p>​工作原理： 对象存在直接可达和间接可达，将遍历对象标记，拆分成多个小步骤，先标记直接可达对象。间接可达的标记与程序执行交替执行，最终完成清除。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/前端/">前端</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/">js</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-question_one" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2021/01/10/question_one/" class="article-date">
      <time datetime="2021-01-09T16:00:00.000Z" itemprop="datePublished">2021-01-10</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/01/10/question_one/">知识点一</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h5 id="谈谈你对工程化的初步认识，结合你之前遇到过的问题说出三个以上工程化能够解决问题或者带来的价值。"><a href="#谈谈你对工程化的初步认识，结合你之前遇到过的问题说出三个以上工程化能够解决问题或者带来的价值。" class="headerlink" title="谈谈你对工程化的初步认识，结合你之前遇到过的问题说出三个以上工程化能够解决问题或者带来的价值。"></a>谈谈你对工程化的初步认识，结合你之前遇到过的问题说出三个以上工程化能够解决问题或者带来的价值。</h5><p>答案：工程化是根据业务特点，将前端开发流程规范化，标准化，它包括了开发流程，技术选型，代码规范，构建发布等，用于提升前端工程师的开发效率和代码质量。</p>
<ol>
<li>制定各项规范，编码规范，开发流程规范，前后端接口规范等等</li>
<li>使用版本控制工具 git，commit描述规范</li>
<li>使用合适前端技术和框架，提高生产效率，降低维护难度，采用模块化，组件化，数据分离等</li>
<li>代码可测试，单元测试，端到端测试等</li>
<li>开发部署自动化</li>
</ol>
<h5 id="你认为脚手架除了为我们创建项目结构，还有什么更深的意义？"><a href="#你认为脚手架除了为我们创建项目结构，还有什么更深的意义？" class="headerlink" title="你认为脚手架除了为我们创建项目结构，还有什么更深的意义？"></a>你认为脚手架除了为我们创建项目结构，还有什么更深的意义？</h5><ul>
<li>减少重复性的工作，不需要复制其他项目再删除无关代码，或者从零创建一个项目和文件。</li>
<li>可以根据交互动态生成项目结构和配置文件。</li>
<li>多人协作更为方便，不需要把文件传来传去。</li>
</ul>
<h5 id="概述脚手架实现的过程，并使用-NodeJS-完成一个自定义的小型脚手架工具。"><a href="#概述脚手架实现的过程，并使用-NodeJS-完成一个自定义的小型脚手架工具。" class="headerlink" title="概述脚手架实现的过程，并使用 NodeJS 完成一个自定义的小型脚手架工具。"></a>概述脚手架实现的过程，并使用 NodeJS 完成一个自定义的小型脚手架工具。</h5><p>说明：实现了创建不同主题的，选择不同内容的静态应用</p>
<ul>
<li><p>首先创建目录 初始化 yarn init 创建出 package.json</p>
</li>
<li><p>在package.json中 输入 bin入口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  //...</span><br><span class="line">  &quot;bin&quot;: &quot;lib.js&quot;,</span><br><span class="line">  //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在根目录创建 lib.js文件 添加bin 入口标识</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env node</span><br><span class="line"></span><br><span class="line">//...</span><br></pre></td></tr></table></figure>
</li>
<li><p>引入inquirer 模块 创建用户与命令行交互的工具 编写所需问题及字段</p>
</li>
<li><p>创建模板目录templates 将项目文件导入到目录中</p>
</li>
<li><p>引入ejs模块 结合所需功能问题变量 改写 templates 下项目文件 达到所需功能</p>
</li>
<li><p>在inquirer回调中 结合nodejs 读写功能 和ejs 模块将问题变量 重写到项目中</p>
</li>
<li><p>然后发布到npm上</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//cli.js 参考</span></span><br><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> inquirer = <span class="built_in">require</span>(<span class="string">'inquirer'</span>)</span><br><span class="line"><span class="keyword">const</span> ejs = <span class="built_in">require</span>(<span class="string">'ejs'</span>)</span><br><span class="line"></span><br><span class="line">inquirer.prompt([</span><br><span class="line">  &#123;</span><br><span class="line">    type: <span class="string">'input'</span>,</span><br><span class="line">    name: <span class="string">'name'</span>,</span><br><span class="line">    message: <span class="string">'Project name?'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    type: <span class="string">'list'</span>,</span><br><span class="line">    name: <span class="string">'theme'</span>,</span><br><span class="line">    message: <span class="string">'Select the theme color'</span>,</span><br><span class="line">    choices: [<span class="string">'Dark'</span>, <span class="string">'Light'</span>],</span><br><span class="line">    filter: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> val.toLowerCase();</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    type: <span class="string">'checkbox'</span>,</span><br><span class="line">    message: <span class="string">'Select what to include'</span>,</span><br><span class="line">    name: <span class="string">'content'</span>,</span><br><span class="line">    choices: [</span><br><span class="line">      &#123;</span><br><span class="line">        name: <span class="string">'Header'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        name: <span class="string">'Body'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        name: <span class="string">'Footer'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">    validate: <span class="function"><span class="keyword">function</span> (<span class="params">answer</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (answer.length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'You must choose at least one content.'</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">])</span><br><span class="line">.then(<span class="function"><span class="params">anwsers</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> tmplDir = path.join(__dirname, <span class="string">'templates'</span>)</span><br><span class="line">  <span class="keyword">const</span> destDir = process.cwd()</span><br><span class="line"></span><br><span class="line">  fs.readdir(tmplDir, (err, files) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err</span><br><span class="line">    files.forEach(<span class="function"><span class="params">file</span> =&gt;</span> &#123;</span><br><span class="line">      ejs.renderFile(path.join(tmplDir, file), anwsers, (err, result) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err</span><br><span class="line"></span><br><span class="line">        fs.writeFileSync(path.join(destDir, file), result)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h5 id="尝试使用-Gulp-完成项目的自动化构建"><a href="#尝试使用-Gulp-完成项目的自动化构建" class="headerlink" title="尝试使用 Gulp 完成项目的自动化构建"></a>尝试使用 Gulp 完成项目的自动化构建</h5><p>​查找 gulp 插件：<a href="https://gulpjs.com/plugins/" target="_blank" rel="noopener">https://gulpjs.com/plugins/</a></p>
<ul>
<li><p>根据项目结构分析得出前端静态应用</p>
</li>
<li><p>亮点： <strong>stylelint</strong> <strong>eslint</strong> <strong>postcss</strong> <strong>autoprefixer</strong> 实现 <strong>–fix</strong></p>
</li>
<li><p>根据README 结合 package.json 得知gulp 需要实现的命令 如下：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">yarn lint</span><br><span class="line">yarn compile</span><br><span class="line">yarn serve</span><br><span class="line">yarn build</span><br><span class="line">yarn start</span><br><span class="line">yarn deploy</span><br><span class="line">yarn clean</span><br><span class="line">//并能实现一下 扩展参数命令</span><br><span class="line">yarn serve --port 5210 --open</span><br></pre></td></tr></table></figure>
<ul>
<li><p>根据具体实现功能分布拆解 主要原理建立通道 分步处理</p>
<p>clean： <strong>del</strong></p>
<p>compile：拆分为 <strong>style</strong> <strong>script</strong> <strong>page</strong> 同时执行</p>
<p>style：在处理sass的基础上 引入gulp-postcss 处理 autoprefixer, 后期可扩展更多postcss功能</p>
<p>script: 处理js 引入 gulp-babel 并 @babel/preset-env 来处理 es6+ 功能</p>
<p>page: 查看html文件为swig 文件，并且layouts,partials 文件夹下的为非入口文件 所以在src 添加ignore 排除这两个目录下的文件 在进行处理</p>
<p>serve：拆分为 <strong>compile</strong> <strong>devServe</strong> 首先生成 temp内容 然后开启开发服务器 监听变化 显示变化</p>
<p>devServe：将生成在 temp 目录下的文件 首先用<strong>watch</strong> 监听文件变化css js html 进行实时监听，实时编译。 <strong>browserSync</strong> 开启静态服务 未查询到的文件 可通过 路由处理 及 文件来源查找进行处理</p>
<p>build：拆分为<strong>clean</strong> 及重新打包 （先 <strong>compile</strong> 后 <strong>useref</strong> ）在打包静态资源类 <strong>image</strong>，<strong>font</strong>，<strong>extra</strong></p>
<p>useref： 在temp下 根据 html 注释 解析文件 将资源文件css 和 js 打包 根据引用资源 在 压缩js css html 生成在 dist 目录下</p>
<p>image，font：经过 imagemin 压缩处理 生成在dist目录下</p>
<p>extra：直接拷贝到dist目录下</p>
<p>start：拆分为<strong>build </strong>及 <strong>prodServe</strong> 处理</p>
<p>prodServe： 将生成的 dist 目录下的文件 通过 <strong>browserSync</strong> 开启静态服务器</p>
<p>deploy：拆分为 <strong>build</strong> 及 <strong>publish</strong> 处理</p>
<p>publish：将 生成的 dist 目录下的文件 通过gulp-gh-pages 插件 进行处理 发布到 gh-pages分支下</p>
<p>lint： 拆分为 <strong>stylesLint</strong> 及 <strong>scriptLint</strong> 处理 又添加了 gulp lint –fix 添加修复功能</p>
<p>styleLint： 通过gulp-postcss 结合相应 <strong>stylelint</strong> 插件 在根目录下.stylelintrc.json 文件引入 stylelint-config-sass-guidelines 对sass 文件进行文件 lint</p>
<p>scriptLint： 通过<strong>gulp-eslint</strong> 在根目录下.eslintrc.js 引入 eslint-config-airbnb-base 进行 强校验 保证代码质量</p>
</li>
<li><p>–production –port 5020 –open –fix 等 可通过 process.argv 获取 查询到 minimist 可进行相应处理 处理结果 可以直接拿到</p>
</li>
<li><p>–production 判断是否存在 存在可生成 js，css sourcemaps 文件</p>
</li>
<li><p>项目配置化，变量统一化， 可读取pages.config.js文件 可填写相应配置项 及 data数据</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gulpfile.js 仅做参考</span></span><br><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">  src, dest, parallel, series, watch,</span><br><span class="line">&#125; = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> del = <span class="built_in">require</span>(<span class="string">'del'</span>);</span><br><span class="line"><span class="keyword">const</span> browserSync = <span class="built_in">require</span>(<span class="string">'browser-sync'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> loadPlugins = <span class="built_in">require</span>(<span class="string">'gulp-load-plugins'</span>);</span><br><span class="line"><span class="keyword">const</span> autoprefixer = <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>);</span><br><span class="line"><span class="keyword">const</span> stylelint = <span class="built_in">require</span>(<span class="string">'stylelint'</span>);</span><br><span class="line"><span class="keyword">const</span> scss = <span class="built_in">require</span>(<span class="string">'postcss-scss'</span>);</span><br><span class="line"><span class="keyword">const</span> reporter = <span class="built_in">require</span>(<span class="string">'postcss-reporter'</span>);</span><br><span class="line"><span class="keyword">const</span> minimist = <span class="built_in">require</span>(<span class="string">'minimist'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> plugins = loadPlugins();</span><br><span class="line"><span class="keyword">const</span> bs = browserSync.create();</span><br><span class="line"><span class="keyword">const</span> cwd = process.cwd();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> args = minimist(process.argv.slice(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isProd = process.env.NODE_ENV ? process.env.NODE_ENV === <span class="string">'production'</span> : args.production || args.prod || <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bsInit = &#123;</span><br><span class="line">  notify: <span class="literal">false</span>,</span><br><span class="line">  port: args.port || <span class="number">2080</span>,</span><br><span class="line">  open: args.open || <span class="literal">false</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> config = &#123;</span><br><span class="line">  build: &#123;</span><br><span class="line">    src: <span class="string">'src'</span>,</span><br><span class="line">    dist: <span class="string">'dist'</span>,</span><br><span class="line">    temp: <span class="string">'temp'</span>,</span><br><span class="line">    public: <span class="string">'public'</span>,</span><br><span class="line">    paths: &#123;</span><br><span class="line">      styles: <span class="string">'assets/styles/**/*.scss'</span>,</span><br><span class="line">      scripts: <span class="string">'assets/scripts/**/*.js'</span>,</span><br><span class="line">      pages: <span class="string">'**/*.html'</span>,</span><br><span class="line">      images: <span class="string">'assets/images/**/*.&#123;jpg,jpeg,png,gif,svg&#125;'</span>,</span><br><span class="line">      fonts: <span class="string">'assets/fonts/**/*.&#123;eot,svg,ttf,woff,woff2&#125;'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> loadConfig = <span class="built_in">require</span>(<span class="string">`<span class="subst">$&#123;cwd&#125;</span>/pages.config.js`</span>);</span><br><span class="line">  config = &#123; ...config, ...loadConfig &#125;;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> clean = <span class="function"><span class="params">()</span> =&gt;</span> del([config.build.dist, config.build.temp]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> style = <span class="function"><span class="params">()</span> =&gt;</span> src(config.build.paths.styles, &#123; <span class="attr">base</span>: config.build.src, <span class="attr">cwd</span>: config.build.src, <span class="attr">sourcemaps</span>: !isProd &#125;)</span><br><span class="line">  .pipe(plugins.sass(&#123; <span class="attr">outputStyle</span>: <span class="string">'expanded'</span> &#125;))</span><br><span class="line">  .pipe(plugins.postcss([</span><br><span class="line">    autoprefixer(),</span><br><span class="line">  ]))</span><br><span class="line">  .pipe(dest(config.build.temp, &#123; <span class="attr">sourcemaps</span>: <span class="string">'.'</span> &#125;))</span><br><span class="line">  .pipe(bs.reload(&#123; <span class="attr">stream</span>: <span class="literal">true</span> &#125;));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stylesLint = <span class="function"><span class="params">()</span> =&gt;</span> src(config.build.paths.styles, &#123; <span class="attr">base</span>: config.build.src, <span class="attr">cwd</span>: config.build.src &#125;)</span><br><span class="line">  .pipe(plugins.postcss([</span><br><span class="line">    stylelint(&#123; <span class="attr">fix</span>: args.fix &#125;),</span><br><span class="line">    reporter(),</span><br><span class="line">  ], &#123; <span class="attr">syntax</span>: scss &#125;));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> script = <span class="function"><span class="params">()</span> =&gt;</span> src(config.build.paths.scripts, &#123;</span><br><span class="line">  base: config.build.src, <span class="attr">cwd</span>: config.build.src, <span class="attr">sourcemaps</span>: !isProd,</span><br><span class="line">&#125;)</span><br><span class="line">  .pipe(plugins.babel(&#123; <span class="attr">presets</span>: [<span class="built_in">require</span>(<span class="string">'@babel/preset-env'</span>)] &#125;))</span><br><span class="line">  .pipe(dest(config.build.temp, &#123; <span class="attr">sourcemaps</span>: <span class="string">'.'</span> &#125;))</span><br><span class="line">  .pipe(bs.reload(&#123; <span class="attr">stream</span>: <span class="literal">true</span> &#125;));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> scriptsLint = <span class="function"><span class="params">()</span> =&gt;</span> src(config.build.paths.scripts, &#123;</span><br><span class="line">  base: config.build.src, <span class="attr">cwd</span>: config.build.src,</span><br><span class="line">&#125;)</span><br><span class="line">  .pipe(plugins.eslint(&#123; <span class="attr">fix</span>: args.fix &#125;))</span><br><span class="line">  .pipe(plugins.eslint.format())</span><br><span class="line">  .pipe(plugins.eslint.failAfterError());</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> page = <span class="function"><span class="params">()</span> =&gt;</span> src(config.build.paths.pages, &#123;</span><br><span class="line">  base: config.build.src, <span class="attr">cwd</span>: config.build.src, <span class="attr">ignore</span>: [<span class="string">'&#123;layouts,partials&#125;/**'</span>],</span><br><span class="line">&#125;)</span><br><span class="line">  .pipe(plugins.swig(&#123; <span class="attr">data</span>: config.data, <span class="attr">defaults</span>: &#123; <span class="attr">cache</span>: <span class="literal">false</span> &#125; &#125;))</span><br><span class="line">  .pipe(dest(config.build.temp))</span><br><span class="line">  .pipe(bs.reload(&#123; <span class="attr">stream</span>: <span class="literal">true</span> &#125;));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> image = <span class="function"><span class="params">()</span> =&gt;</span> src(config.build.paths.images, &#123;</span><br><span class="line">  base: config.build.src, <span class="attr">cwd</span>: config.build.src,</span><br><span class="line">&#125;)</span><br><span class="line">  .pipe(plugins.imagemin())</span><br><span class="line">  .pipe(dest(config.build.dist));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> font = <span class="function"><span class="params">()</span> =&gt;</span> src(config.build.paths.fonts, &#123; <span class="attr">base</span>: config.build.src, <span class="attr">cwd</span>: config.build.src &#125;)</span><br><span class="line">  .pipe(plugins.imagemin())</span><br><span class="line">  .pipe(dest(config.build.dist));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> extra = <span class="function"><span class="params">()</span> =&gt;</span> src(<span class="string">'**'</span>, &#123; <span class="attr">base</span>: config.build.public, <span class="attr">cwd</span>: config.build.public &#125;)</span><br><span class="line">  .pipe(dest(config.build.dist));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> devServe = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  watch(config.build.paths.styles, &#123; <span class="attr">cwd</span>: config.build.src &#125;, style);</span><br><span class="line">  watch(config.build.paths.scripts, &#123; <span class="attr">cwd</span>: config.build.src &#125;, script);</span><br><span class="line">  watch(config.build.paths.pages, &#123; <span class="attr">cwd</span>: config.build.src &#125;, page);</span><br><span class="line"></span><br><span class="line">  watch([</span><br><span class="line">    config.build.paths.images,</span><br><span class="line">    config.build.paths.fonts,</span><br><span class="line">  ], &#123; <span class="attr">cwd</span>: config.build.src &#125;, bs.reload);</span><br><span class="line"></span><br><span class="line">  watch(<span class="string">'**'</span>, &#123; <span class="attr">cwd</span>: config.build.public &#125;, bs.reload);</span><br><span class="line"></span><br><span class="line">  bs.init(&#123;</span><br><span class="line">    ...bsInit,</span><br><span class="line">    server: &#123;</span><br><span class="line">      baseDir: [config.build.temp, config.build.dist, config.build.public, config.build.src],</span><br><span class="line">      routes: &#123;</span><br><span class="line">        <span class="string">'/node_modules'</span>: <span class="string">'node_modules'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> prodServe = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  bs.init(&#123;</span><br><span class="line">    ...bsInit,</span><br><span class="line">    server: &#123;</span><br><span class="line">      baseDir: config.build.dist,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useref = <span class="function"><span class="params">()</span> =&gt;</span> src(</span><br><span class="line">  config.build.paths.pages,</span><br><span class="line">  &#123; <span class="attr">base</span>: config.build.temp, <span class="attr">cwd</span>: config.build.temp &#125;,</span><br><span class="line">)</span><br><span class="line">  .pipe(plugins.useref(&#123; <span class="attr">searchPath</span>: [config.build.temp, <span class="string">'.'</span>, <span class="string">'..'</span>] &#125;))</span><br><span class="line">  <span class="comment">// html js css</span></span><br><span class="line">  .pipe(plugins.if(<span class="regexp">/\.js$/</span>, plugins.uglify()))</span><br><span class="line">  .pipe(plugins.if(<span class="regexp">/\.css$/</span>, plugins.cleanCss()))</span><br><span class="line">  .pipe(plugins.if(<span class="regexp">/\.html$/</span>, plugins.htmlmin(&#123;</span><br><span class="line">    collapseWhitespace: <span class="literal">true</span>,</span><br><span class="line">    minifyCSS: <span class="literal">true</span>,</span><br><span class="line">    minifyJS: <span class="literal">true</span>,</span><br><span class="line">  &#125;)))</span><br><span class="line">  .pipe(dest(config.build.dist));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> publish = <span class="function"><span class="params">()</span> =&gt;</span> src(<span class="string">'**'</span>, &#123; <span class="attr">base</span>: config.build.dist, <span class="attr">cwd</span>: config.build.dist &#125;)</span><br><span class="line">  <span class="comment">// .pipe(plugins.gzip())</span></span><br><span class="line">  .pipe(plugins.ghPages());</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> lint = parallel(stylesLint, scriptsLint);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> compile = parallel(style, script, page);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上线之前执行的任务</span></span><br><span class="line"><span class="keyword">const</span> build = series(</span><br><span class="line">  clean,</span><br><span class="line">  parallel(</span><br><span class="line">    series(compile, useref),</span><br><span class="line">    image,</span><br><span class="line">    font,</span><br><span class="line">    extra,</span><br><span class="line">  ),</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> serve = series(compile, devServe);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> start = series(build, prodServe);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> deploy = series(build, publish);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  clean,</span><br><span class="line">  lint,</span><br><span class="line">  compile,</span><br><span class="line">  serve,</span><br><span class="line">  build,</span><br><span class="line">  start,</span><br><span class="line">  deploy,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="使用-Grunt-完成项目的自动化构建"><a href="#使用-Grunt-完成项目的自动化构建" class="headerlink" title="使用 Grunt 完成项目的自动化构建"></a>使用 Grunt 完成项目的自动化构建</h5><p>说明：</p>
<p>​    查找 grunt 插件：<a href="https://www.gruntjs.net/plugins" target="_blank" rel="noopener">https://www.gruntjs.net/plugins</a></p>
<ul>
<li><p>思路大体跟gulp一致 首先查找对应功能的插件 根据插件文档 编写插件信息</p>
</li>
<li><p>根据grunt文件管理 可以拆分 cwd src dest ext 等 精确控制</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  expand: true,</span><br><span class="line">  cwd: config.build.src,</span><br><span class="line">  src: [config.build.paths.styles],</span><br><span class="line">  dest: config.build.temp,</span><br><span class="line">  ext: &apos;.css&apos;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>grunt-usemin 代替 gulp-useref</p>
</li>
<li><p>grunt-browser-sync grunt-contrib-copy</p>
</li>
<li><p>watch 用到插件为 grunt-contrib-watch gulp则是本身功能</p>
</li>
<li><p>copy 用到插件为grunt-contrib-copy gulp则是本身功能</p>
</li>
<li><p>del 可使用 del.sync 同步执行</p>
</li>
<li><p>处理 swig 用到 grunt-html-template 插件</p>
</li>
</ul>
<p>​<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gruntfile.js 参考配置</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> sass = <span class="built_in">require</span>(<span class="string">'sass'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> del = <span class="built_in">require</span>(<span class="string">'del'</span>);</span><br><span class="line"><span class="keyword">const</span> browserSync = <span class="built_in">require</span>(<span class="string">'browser-sync'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> loadGruntTasks = <span class="built_in">require</span>(<span class="string">'load-grunt-tasks'</span>);</span><br><span class="line"><span class="keyword">const</span> autoprefixer = <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>);</span><br><span class="line"><span class="keyword">const</span> stylelint = <span class="built_in">require</span>(<span class="string">'stylelint'</span>);</span><br><span class="line"><span class="keyword">const</span> scss = <span class="built_in">require</span>(<span class="string">'postcss-scss'</span>);</span><br><span class="line"><span class="keyword">const</span> reporter = <span class="built_in">require</span>(<span class="string">'postcss-reporter'</span>);</span><br><span class="line"><span class="keyword">const</span> minimist = <span class="built_in">require</span>(<span class="string">'minimist'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bs = browserSync.create();</span><br><span class="line"><span class="keyword">const</span> cwd = process.cwd();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> args = minimist(process.argv.slice(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isProd = process.env.NODE_ENV ? process.env.NODE_ENV === <span class="string">'production'</span> : args.production || args.prod || <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bsInit = &#123;</span><br><span class="line">  notify: <span class="literal">false</span>,</span><br><span class="line">  port: args.port || <span class="number">2080</span>,</span><br><span class="line">  open: args.open || <span class="literal">false</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> config = &#123;</span><br><span class="line">  build: &#123;</span><br><span class="line">    src: <span class="string">'src'</span>,</span><br><span class="line">    dist: <span class="string">'dist'</span>,</span><br><span class="line">    temp: <span class="string">'temp'</span>,</span><br><span class="line">    public: <span class="string">'public'</span>,</span><br><span class="line">    paths: &#123;</span><br><span class="line">      styles: <span class="string">'assets/styles/**/*.scss'</span>,</span><br><span class="line">      scripts: <span class="string">'assets/scripts/**/*.js'</span>,</span><br><span class="line">      pages: <span class="string">'**/*.html'</span>,</span><br><span class="line">      images: <span class="string">'assets/images/**/*.&#123;jpg,jpeg,png,gif,svg&#125;'</span>,</span><br><span class="line">      fonts: <span class="string">'assets/fonts/**/*.&#123;eot,svg,ttf,woff,woff2&#125;'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> loadConfig = <span class="built_in">require</span>(<span class="string">`<span class="subst">$&#123;cwd&#125;</span>/pages.config.js`</span>);</span><br><span class="line">  config = &#123; ...config, ...loadConfig &#125;;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">grunt</span>) =&gt;</span> &#123;</span><br><span class="line">  grunt.initConfig(&#123;</span><br><span class="line">    sass: &#123;</span><br><span class="line">      options: &#123;</span><br><span class="line">        sourceMap: !isProd,</span><br><span class="line">        implementation: sass,</span><br><span class="line">        outputStyle: <span class="string">'expanded'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      main: &#123;</span><br><span class="line">        expand: <span class="literal">true</span>,</span><br><span class="line">        cwd: config.build.src,</span><br><span class="line">        src: [config.build.paths.styles],</span><br><span class="line">        dest: config.build.temp,</span><br><span class="line">        ext: <span class="string">'.css'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    postcss: &#123;</span><br><span class="line">      main: &#123;</span><br><span class="line">        options: &#123;</span><br><span class="line">          processors: [</span><br><span class="line">            autoprefixer(),</span><br><span class="line">          ],</span><br><span class="line">        &#125;,</span><br><span class="line">        expand: <span class="literal">true</span>,</span><br><span class="line">        cwd: config.build.temp,</span><br><span class="line">        src: [<span class="string">'assets/styles/**/*.css'</span>],</span><br><span class="line">        dest: config.build.temp,</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      lint: &#123;</span><br><span class="line">        options: &#123;</span><br><span class="line">          processors: [</span><br><span class="line">            stylelint(&#123; <span class="attr">fix</span>: args.fix &#125;),</span><br><span class="line">            reporter(),</span><br><span class="line">          ],</span><br><span class="line">        &#125;,</span><br><span class="line">        src: <span class="string">`<span class="subst">$&#123;path.join(config.build.src, config.build.paths.styles)&#125;</span>`</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    eslint: &#123;</span><br><span class="line">      options: &#123;</span><br><span class="line">        fix: args.fix,</span><br><span class="line">      &#125;,</span><br><span class="line">      main: <span class="string">`<span class="subst">$&#123;path.join(config.build.src, config.build.paths.scripts)&#125;</span>`</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    babel: &#123;</span><br><span class="line">      options: &#123;</span><br><span class="line">        sourceMap: !isProd,</span><br><span class="line">        presets: [<span class="string">'@babel/preset-env'</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      main: &#123;</span><br><span class="line">        expand: <span class="literal">true</span>,</span><br><span class="line">        cwd: config.build.src,</span><br><span class="line">        src: [config.build.paths.scripts],</span><br><span class="line">        dest: config.build.temp,</span><br><span class="line">        ext: <span class="string">'.js'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    html_template: &#123;</span><br><span class="line">      options: &#123;</span><br><span class="line">        cache: <span class="literal">false</span>,</span><br><span class="line">        locals: config.data,</span><br><span class="line">      &#125;,</span><br><span class="line">      main: &#123;</span><br><span class="line">        expand: <span class="literal">true</span>,</span><br><span class="line">        cwd: config.build.src,</span><br><span class="line">        src: [config.build.paths.pages, <span class="string">'!layouts/**'</span>, <span class="string">'!partials/**'</span>],</span><br><span class="line">        dest: config.build.temp,</span><br><span class="line">        ext: <span class="string">'.html'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    imagemin: &#123;</span><br><span class="line">      image: &#123;</span><br><span class="line">        expand: <span class="literal">true</span>,</span><br><span class="line">        cwd: config.build.src,</span><br><span class="line">        src: [config.build.paths.images],</span><br><span class="line">        dest: config.build.dist,</span><br><span class="line">      &#125;,</span><br><span class="line">      font: &#123;</span><br><span class="line">        expand: <span class="literal">true</span>,</span><br><span class="line">        cwd: config.build.src,</span><br><span class="line">        src: [config.build.paths.fonts],</span><br><span class="line">        dest: config.build.dist,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    copy: &#123;</span><br><span class="line">      main: &#123;</span><br><span class="line">        expand: <span class="literal">true</span>,</span><br><span class="line">        cwd: config.build.public,</span><br><span class="line">        src: [<span class="string">'**'</span>],</span><br><span class="line">        dest: config.build.dist,</span><br><span class="line">      &#125;,</span><br><span class="line">      html: &#123;</span><br><span class="line">        expand: <span class="literal">true</span>,</span><br><span class="line">        cwd: config.build.temp,</span><br><span class="line">        src: [config.build.paths.pages],</span><br><span class="line">        dest: config.build.dist,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    useminPrepare: &#123;</span><br><span class="line">      main: &#123;</span><br><span class="line">        expand: <span class="literal">true</span>,</span><br><span class="line">        cwd: config.build.temp,</span><br><span class="line">        src: [config.build.paths.pages],</span><br><span class="line">      &#125;,</span><br><span class="line">      options: &#123;</span><br><span class="line">        dest: config.build.dist,</span><br><span class="line">        root: [config.build.temp, <span class="string">'.'</span>, <span class="string">'..'</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    usemin: &#123;</span><br><span class="line">      main: &#123;</span><br><span class="line">        expand: <span class="literal">true</span>,</span><br><span class="line">        cwd: config.build.dist,</span><br><span class="line">        src: [config.build.paths.pages],</span><br><span class="line">      &#125;,</span><br><span class="line">      options: &#123;</span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'gh-pages'</span>: &#123;</span><br><span class="line">      options: &#123;</span><br><span class="line">        base: config.build.dist,</span><br><span class="line">        branch: <span class="string">'gh-pages-grunt'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      main: [<span class="string">'**'</span>],</span><br><span class="line">    &#125;,</span><br><span class="line">    watch: &#123;</span><br><span class="line">      script: &#123;</span><br><span class="line">        files: [<span class="string">`<span class="subst">$&#123;path.join(config.build.src, config.build.paths.scripts)&#125;</span>`</span>],</span><br><span class="line">        tasks: [<span class="string">'babel'</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      style: &#123;</span><br><span class="line">        files: [<span class="string">`<span class="subst">$&#123;path.join(config.build.src, config.build.paths.styles)&#125;</span>`</span>],</span><br><span class="line">        tasks: [<span class="string">'style'</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      page: &#123;</span><br><span class="line">        files: [<span class="string">`<span class="subst">$&#123;path.join(config.build.src, config.build.paths.pages)&#125;</span>`</span>],</span><br><span class="line">        tasks: [<span class="string">'html_template'</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    browserSync: &#123;</span><br><span class="line">      dev: &#123;</span><br><span class="line">        bsFiles: &#123;</span><br><span class="line">          src: [</span><br><span class="line">            config.build.temp,</span><br><span class="line">            config.build.dist,</span><br><span class="line">          ],</span><br><span class="line">        &#125;,</span><br><span class="line">        options: &#123;</span><br><span class="line">          ...bsInit,</span><br><span class="line">          watchTask: <span class="literal">true</span>,</span><br><span class="line">          server: &#123;</span><br><span class="line">            baseDir: [config.build.temp, config.build.dist, config.build.public, config.build.src],</span><br><span class="line">            routes: &#123;</span><br><span class="line">              <span class="string">'/node_modules'</span>: <span class="string">'node_modules'</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      prod: &#123;</span><br><span class="line">        bsFiles: &#123;</span><br><span class="line">          src: config.build.dist,</span><br><span class="line">        &#125;,</span><br><span class="line">        options: &#123;</span><br><span class="line">          ...bsInit,</span><br><span class="line">          server: &#123;</span><br><span class="line">            baseDir: config.build.dist,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  loadGruntTasks(grunt);</span><br><span class="line"></span><br><span class="line">  grunt.registerTask(<span class="string">'reload'</span>, () =&gt; &#123;</span><br><span class="line">    bs.reload();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  grunt.registerTask(<span class="string">'stylesLint'</span>, []);</span><br><span class="line"></span><br><span class="line">  grunt.registerTask(<span class="string">'scriptsLint'</span>, []);</span><br><span class="line"></span><br><span class="line">  grunt.registerTask(<span class="string">'clean'</span>, () =&gt; &#123;</span><br><span class="line">    del.sync([config.build.dist, config.build.temp, <span class="string">'.tmp'</span>]);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  grunt.registerTask(<span class="string">'style'</span>, [<span class="string">'sass'</span>, <span class="string">'postcss:main'</span>]);</span><br><span class="line"></span><br><span class="line">  grunt.registerTask(<span class="string">'compile'</span>, [<span class="string">'style'</span>, <span class="string">'babel'</span>, <span class="string">'html_template'</span>]);</span><br><span class="line"></span><br><span class="line">  grunt.registerTask(<span class="string">'build'</span>, [</span><br><span class="line">    <span class="string">'clean'</span>,</span><br><span class="line">    <span class="string">'compile'</span>,</span><br><span class="line">    <span class="string">'copy'</span>,</span><br><span class="line">    <span class="string">'useminPrepare'</span>,</span><br><span class="line">    <span class="string">'concat:generated'</span>,</span><br><span class="line">    <span class="string">'cssmin:generated'</span>,</span><br><span class="line">    <span class="string">'uglify:generated'</span>,</span><br><span class="line">    <span class="string">'usemin'</span>,</span><br><span class="line">    <span class="string">'imagemin'</span>,</span><br><span class="line">  ]);</span><br><span class="line"></span><br><span class="line">  grunt.registerTask(<span class="string">'serve'</span>, [<span class="string">'compile'</span>, <span class="string">'browserSync:dev'</span>, <span class="string">'watch'</span>]);</span><br><span class="line"></span><br><span class="line">  grunt.registerTask(<span class="string">'start'</span>, [<span class="string">'build'</span>, <span class="string">'browserSync:prod'</span>]);</span><br><span class="line"></span><br><span class="line">  grunt.registerTask(<span class="string">'deploy'</span>, [<span class="string">'build'</span>, <span class="string">'gh-pages'</span>]);</span><br><span class="line"></span><br><span class="line">  grunt.registerTask(<span class="string">'lint'</span>, [<span class="string">'postcss:lint'</span>, <span class="string">'eslint'</span>]);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/前端/">前端</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/">js</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-question_five" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2021/01/10/question_five/" class="article-date">
      <time datetime="2021-01-09T16:00:00.000Z" itemprop="datePublished">2021-01-10</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/01/10/question_five/">知识点五</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <blockquote>
<p>2021-1-10</p>
</blockquote>
<h3 id="如何理解-JS-异步编程，EventLoop、消息队列都是做什么的，什么是宏任务，什么是微任务？"><a href="#如何理解-JS-异步编程，EventLoop、消息队列都是做什么的，什么是宏任务，什么是微任务？" class="headerlink" title="如何理解 JS 异步编程，EventLoop、消息队列都是做什么的，什么是宏任务，什么是微任务？"></a>如何理解 JS 异步编程，EventLoop、消息队列都是做什么的，什么是宏任务，什么是微任务？</h3><ul>
<li><p>JS 异步编程</p>
<p>JavaScript 语言的执行环境是单线程的，一次只能执行一个任务，多任务需要排队等候，这种模式可能会阻塞代码，导致代码执行效率低下。为了避免这个问题，出现了异步编程。一般是通过 callback 回调函数、事件发布/订阅、Promise 等来组织代码，本质都是通过回调函数来实现异步代码的存放与执行。</p>
</li>
<li><p>EventLoop 事件环和消息队列</p>
<p><strong>EventLoop</strong> 是一种循环机制 ，不断去轮询一些队列 ，从中找到 需要执行的任务并按顺序执行的一个执行模型。</p>
<p><strong>消息队列</strong> 是用来存放宏任务的队列， 比如定时器时间到了， 定时间内传入的方法引用会存到该队列， ajax回调之后的执行方法也会存到该队列。</p>
</li>
</ul>
<p>  一开始整个脚本作为一个宏任务执行。执行过程中同步代码直接执行，宏任务等待时间到达或者成功后，将方法的回调放入宏任务队列中，微任务进入微任务队列。</p>
<p>  当前主线程的宏任务执行完出队，检查并清空微任务队列。接着执行浏览器 UI 线程的渲染工作，检查web worker 任务，有则执行。</p>
<p>  然后再取出一个宏任务执行。以此循环…</p>
<ul>
<li><p>宏任务与微任务</p>
<p><strong>宏任务</strong>可以理解为每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）。</p>
<p>浏览器为了让 JS 内部宏任务 与 DOM 操作能够有序的执行，会在一个宏任务执行结束后，在下一个宏任务执行开始前，对页面进行重新渲染。</p>
<p>宏任务包含：script(整体代码)、setTimeout、setInterval、I/O、UI交互事件、MessageChannel 等</p>
</li>
</ul>
<p>  <strong>微任务</strong>可以理解是在当前任务执行结束后需要立即执行的任务。也就是说，在当前任务后，在渲染之前，执行清空微任务。</p>
<p>  所以它的响应速度相比宏任务会更快，因为无需等待 UI 渲染。</p>
<p>  微任务包含：Promise.then、MutaionObserver、process.nextTick(Node.js 环境)等</p>
<h3 id="基于以下代码完成下面的四个练习"><a href="#基于以下代码完成下面的四个练习" class="headerlink" title="基于以下代码完成下面的四个练习"></a>基于以下代码完成下面的四个练习</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const fp = require(&apos;lodash/fp&apos;)</span><br><span class="line">// 数据：horsepower 马力，dollar_value 价格，in_stock 库存</span><br><span class="line">const cars = [</span><br><span class="line">    &#123; name: &apos;Ferrari FF&apos;, horsepower: 660, dollar_value: 700000, in_stock: true &#125;,</span><br><span class="line">    &#123; name: &apos;Spyker C12 Zagato&apos;, horsepower: 650, dollar_value: 648000, in_stock: false &#125;,</span><br><span class="line">    &#123; name: &apos;Jaguar XKR-S&apos;, horsepower: 550, dollar_value: 132000, in_stock: false &#125;,</span><br><span class="line">    &#123; name: &apos;Audi R8&apos;, horsepower: 525, dollar_value: 114200, in_stock: false &#125;,</span><br><span class="line">    &#123; name: &apos;Aston Martin One-77&apos;, horsepower: 750, dollar_value: 1850000, in_stock: true &#125;,</span><br><span class="line">    &#123; name: &apos;Pagani Huayra&apos;, horsepower: 700, dollar_value: 1300000, in_stock: false &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h4 id="使用组合函数-fp-flowRight-重新实现下面这个函数"><a href="#使用组合函数-fp-flowRight-重新实现下面这个函数" class="headerlink" title="使用组合函数 fp.flowRight() 重新实现下面这个函数"></a>使用组合函数 fp.flowRight() 重新实现下面这个函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let isLastInStock = function(cars)&#123;</span><br><span class="line">    // 获取最后一条数据</span><br><span class="line">    let last_car = fp.last(cars)</span><br><span class="line">    // 获取最后一条数据的 in_stock 属性值</span><br><span class="line">    return fp.prop(&apos;in_stock&apos;, last_car)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>先定义获取最后一条数据的函数，再定义获取某个对象中的 in_stock 属性的函数，再用 fp.flowRight 组合函数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let isLastInStock = fp.flowRight(fp.prop(&apos;in_stock&apos;), fp.last);</span><br><span class="line">console.log(isLastInStock(cars)); // false</span><br></pre></td></tr></table></figure>
<h4 id="使用-fp-flowRight-、fp-prop-和-fp-first-获取第一个-car-的-name"><a href="#使用-fp-flowRight-、fp-prop-和-fp-first-获取第一个-car-的-name" class="headerlink" title="使用 fp.flowRight()、fp.prop() 和 fp.first() 获取第一个 car 的 name"></a>使用 fp.flowRight()、fp.prop() 和 fp.first() 获取第一个 car 的 name</h4><blockquote>
<p>先定义获取第一条数据的函数，再定义获取某个对象中的 name 属性的函数，再用 fp.flowRight 组合函数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const getFirstName = fp.flowRight(fp.prop(&quot;name&quot;), fp.first)</span><br><span class="line">console.log(getFirstName(cars)) // Ferrari FF</span><br></pre></td></tr></table></figure>
<h4 id="使用帮助函数-average-重构-averageDollarValue，使用函数组合的方式实现"><a href="#使用帮助函数-average-重构-averageDollarValue，使用函数组合的方式实现" class="headerlink" title="使用帮助函数 _average 重构 averageDollarValue，使用函数组合的方式实现"></a>使用帮助函数 _average 重构 averageDollarValue，使用函数组合的方式实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let _average = function(xs)&#123;</span><br><span class="line">    return fp.reduce(fp.add, 0, xs) / xs.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>先定义获取某个对象中的 dollar_value 属性的函数，将该函数作为 fp.map 的数组元素处理函数，再用 fp.flowRight 组合函数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let averageDollarValue = fp.flowRight(_average, fp.map(&apos;dollar_value&apos;));</span><br><span class="line">console.log(averageDollarValue(cars));  //790700</span><br></pre></td></tr></table></figure>
<h4 id="使用-flowRight-写一个-sanitizeNames-函数，返回一个下划线连续的小写字符串，把数组中的-name-转换为这种形式，例如：sanitizeNames-“Hello-World”-gt-“hello-world”"><a href="#使用-flowRight-写一个-sanitizeNames-函数，返回一个下划线连续的小写字符串，把数组中的-name-转换为这种形式，例如：sanitizeNames-“Hello-World”-gt-“hello-world”" class="headerlink" title="使用 flowRight 写一个 sanitizeNames() 函数，返回一个下划线连续的小写字符串，把数组中的 name 转换为这种形式，例如：sanitizeNames([“Hello World”]) =&gt; [“hello_world”]"></a>使用 flowRight 写一个 sanitizeNames() 函数，返回一个下划线连续的小写字符串，把数组中的 name 转换为这种形式，例如：sanitizeNames([“Hello World”]) =&gt; [“hello_world”]</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let _underscore = fp.replace(/\W+/g, &apos;_&apos;) // 无须改动，并在 sanitizeNames 中使用它</span><br></pre></td></tr></table></figure>
<blockquote>
<p>先定义获取某个对象中的 name 属性的函数，再定义转化为小写的函数，再将空格和下划线替换，,再用 fp.flowRight 组合函数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let sanitizeNames = fp.flowRight(</span><br><span class="line">  fp.map(_underscore),</span><br><span class="line">  fp.map(fp.toLower),</span><br><span class="line">  fp.map((car) =&gt; car.name)</span><br><span class="line">);</span><br><span class="line">console.log(sanitizeNames(CARS)) </span><br><span class="line">// [</span><br><span class="line">//  &apos;ferrari_ff&apos;,       </span><br><span class="line">//  &apos;spyker_c12_zagato&apos;,</span><br><span class="line">//  &apos;jaguar_xkr_s&apos;,</span><br><span class="line">//  &apos;audi_r8&apos;,</span><br><span class="line">//  &apos;aston_martin_one_77&apos;,</span><br><span class="line">//  &apos;pagani_huayra&apos;</span><br><span class="line">// ]</span><br></pre></td></tr></table></figure>
<h3 id="基于下面提供的代码，完成后续的四个练习"><a href="#基于下面提供的代码，完成后续的四个练习" class="headerlink" title="基于下面提供的代码，完成后续的四个练习"></a>基于下面提供的代码，完成后续的四个练习</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// support.js</span><br><span class="line">class Container &#123;</span><br><span class="line">    static of(value)&#123;</span><br><span class="line">        return new Container(value)</span><br><span class="line">    &#125;</span><br><span class="line">    constructor(value)&#123;</span><br><span class="line">        this._value = value</span><br><span class="line">    &#125;</span><br><span class="line">    map(fn)&#123;</span><br><span class="line">        return Container.of(fn(this._value))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Maybe &#123;</span><br><span class="line">    static of(x)&#123;</span><br><span class="line">        return new Maybe(x)</span><br><span class="line">    &#125;</span><br><span class="line">    isNothing()&#123;</span><br><span class="line">        return this._value === null || this._value === undefined</span><br><span class="line">    &#125;</span><br><span class="line">    constructor(x)&#123;</span><br><span class="line">        this._value = x</span><br><span class="line">    &#125;</span><br><span class="line">    map(fn)&#123;</span><br><span class="line">        return this.isNothing() ? this : Maybe.of(fn(this._value))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = &#123; Maybe, Container &#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用-fp-add-x-y-和-fp-map-f-x-创建一个能让-functor-里的值增加的函数-ex1"><a href="#使用-fp-add-x-y-和-fp-map-f-x-创建一个能让-functor-里的值增加的函数-ex1" class="headerlink" title="使用 fp.add(x, y) 和 fp.map(f,x) 创建一个能让 functor 里的值增加的函数 ex1"></a>使用 fp.add(x, y) 和 fp.map(f,x) 创建一个能让 functor 里的值增加的函数 ex1</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const fp = require(&apos;lodash/fp&apos;)</span><br><span class="line">const &#123;Maybe, Container&#125; = require(&apos;./support&apos;)</span><br><span class="line">let maybe = Maybe.of([5,6,1])</span><br><span class="line">let ex1 = () =&gt; &#123;</span><br><span class="line">    // 你需要实现的函数。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>函子对象的 map 方法可以运行一个函数对值进行处理，函数的参数为传入 of 方法的参数；接着对传入的整个数组进行遍历，并对每一项执行 fp.add 方法</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let ex1 = maybe.map(i =&gt; fp.map(fp.add(1), i))</span><br><span class="line">console.log(ex1) // [6, 7, 2]</span><br></pre></td></tr></table></figure>
<h4 id="实现一个函数-ex2，能够使用-fp-first-获取列表的第一个元素"><a href="#实现一个函数-ex2，能够使用-fp-first-获取列表的第一个元素" class="headerlink" title="实现一个函数 ex2，能够使用 fp.first 获取列表的第一个元素"></a>实现一个函数 ex2，能够使用 fp.first 获取列表的第一个元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const fp = require(&apos;lodash/fp&apos;)</span><br><span class="line">const &#123;Maybe, Container&#125; = require(&apos;./support&apos;)</span><br><span class="line">let xs = Container.of([&apos;do&apos;, &apos;ray&apos;, &apos;me&apos;, &apos;fa&apos;, &apos;so&apos;, &apos;la&apos;, &apos;ti&apos;, &apos;do&apos;])</span><br><span class="line">let ex2 = () =&gt; &#123;</span><br><span class="line">    // 你需要实现的函数。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>解答如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let ex2 = xs.map(i =&gt; fp.first(i))</span><br><span class="line">console.log(ex2)// do</span><br></pre></td></tr></table></figure>
<h4 id="实现一个函数-ex3，使用-safeProp-和-fp-first-找到-user-的名字的首字母"><a href="#实现一个函数-ex3，使用-safeProp-和-fp-first-找到-user-的名字的首字母" class="headerlink" title="实现一个函数 ex3，使用 safeProp 和 fp.first 找到 user 的名字的首字母"></a>实现一个函数 ex3，使用 safeProp 和 fp.first 找到 user 的名字的首字母</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const fp = require(&apos;lodash/fp&apos;)</span><br><span class="line">const &#123;Maybe, Container&#125; = require(&apos;./support&apos;)</span><br><span class="line">let safeProp = fp.curry(function(x, o)&#123;</span><br><span class="line">    return Maybe.of(o[x])</span><br><span class="line">&#125;)</span><br><span class="line">let user = &#123; id: 2, name: &apos;Albert&apos; &#125;</span><br><span class="line">let ex3 = () =&gt; &#123;</span><br><span class="line">    // 你需要实现的函数。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>调用 ex3 函数传入 user 对象，safeProp 是经过柯里化处理的，可以先传“属性”参数，后传“对象”参数。safeProp 函数处理后返回 user 的值，再调用fp.first 获取首字母</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let ex3 = fp.flowRight(fp.map(i =&gt; fp.first(i)), safeProp(&apos;name&apos;))</span><br><span class="line">console.log(ex3(user)) // A</span><br><span class="line">// 或者 return safeProp(&quot;name&quot;, user).map(x =&gt; fp.first(x));</span><br></pre></td></tr></table></figure>
<h4 id="使用-Maybe-重写-ex4，不要有-if-语句"><a href="#使用-Maybe-重写-ex4，不要有-if-语句" class="headerlink" title="使用 Maybe 重写 ex4，不要有 if 语句"></a>使用 Maybe 重写 ex4，不要有 if 语句</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const fp = require(&apos;lodash/fp&apos;)</span><br><span class="line">const &#123;Maybe, Container&#125; = require(&apos;./support&apos;)</span><br><span class="line">let ex4 = function(n)&#123;</span><br><span class="line">    if(n)&#123;</span><br><span class="line">        return parseInt(n)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>MayBe 函子用来处理外部的空值情况，防止空值的异常，拿到函子的值之后进行 parseInt 转化</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let ex4 = n =&gt; Maybe.of(n).map(parseInt)</span><br><span class="line">console.log(ex4(&apos;1&apos;)) // 1</span><br></pre></td></tr></table></figure>
<h3 id="手写实现-MyPromise-源码"><a href="#手写实现-MyPromise-源码" class="headerlink" title="手写实现 MyPromise 源码"></a>手写实现 MyPromise 源码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始状态</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">"pending"</span>;</span><br><span class="line"><span class="comment">// 完成状态</span></span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">"fulfilled"</span>;</span><br><span class="line"><span class="comment">// 失败状态</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">"rejected"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步执行方法封装</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncExecFun</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> fn(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行promise resolve功能</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise, res, resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回同一个promise</span></span><br><span class="line">  <span class="keyword">if</span> (promise === res) &#123;</span><br><span class="line">    reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Chaining cycle detected for promise #&lt;MyPromise&gt;"</span>));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// promise结果</span></span><br><span class="line">  <span class="keyword">if</span> (res <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">    res.then(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 非promise结果</span></span><br><span class="line">    resolve(res);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 是个构造函数</span></span><br><span class="line"><span class="comment"> * 2. 传入一个可执行函数 函数的入参第一个为 fullFill函数 第二个为 reject函数；  函数立即执行，  参数函数异步执行</span></span><br><span class="line"><span class="comment"> * 3. 状态一旦更改就不可以变更  只能 pending =&gt; fulfilled 或者  pending =&gt; rejected</span></span><br><span class="line"><span class="comment"> * 4. then 的时候要处理入参的情况 successCallback 和failCallback 均可能为非函数</span></span><br><span class="line"><span class="comment"> *      默认的 failCallback 一定要将异常抛出， 这样下一个promise便可将其捕获 异常冒泡的目的</span></span><br><span class="line"><span class="comment"> * 5. then 中执行回调的时候要捕获异常 将其传给下一个promise</span></span><br><span class="line"><span class="comment"> *    如果promise状态未变更 则将回调方法添加到对应队列中</span></span><br><span class="line"><span class="comment"> *    如果promise状态已经变更 需要异步处理成功或者失败回调</span></span><br><span class="line"><span class="comment"> *    因为可能出现 回调结果和当前then返回的Promise一致 从而导致死循环问题</span></span><br><span class="line"><span class="comment"> * 6. catch只是then的一种特殊的写法 方便理解和使用</span></span><br><span class="line"><span class="comment"> * 7. finally 特点 1. 不过resolve或者reject都会执行</span></span><br><span class="line"><span class="comment"> *                2. 回调没有参数</span></span><br><span class="line"><span class="comment"> *                3. 返回一个Promise 且值可以穿透到下一个then或者catch</span></span><br><span class="line"><span class="comment"> * 8. Promise.resolve, Promise.reject 根据其参数返回对应的值 或者状态的Promise即可</span></span><br><span class="line"><span class="comment"> * 9. Proise.all 特点  1. 返回一个Promise</span></span><br><span class="line"><span class="comment"> *                    2. 入参是数组 resolve的情况下出参也是数组 且结果顺序和调用顺序一致</span></span><br><span class="line"><span class="comment"> *                    3. 所有的值或者promise都完成才能resolve 所有要计数</span></span><br><span class="line"><span class="comment"> *                    4. 只要有一个为reject 返回的Promise便reject</span></span><br><span class="line"><span class="comment"> * 10. Proise.race 特点 1. 返回一个Promise</span></span><br><span class="line"><span class="comment"> *                    2. 入参是数组 那么出参根据第一个成功或者失败的参数来确定</span></span><br><span class="line"><span class="comment"> *                    3. 只要有一个resolve 或者reject 便更改返回Promise的状态</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  status = PENDING;</span><br><span class="line">  value = <span class="literal">undefined</span>;</span><br><span class="line">  reason = <span class="literal">undefined</span>;</span><br><span class="line">  successCallbacks = [];</span><br><span class="line">  failCallbacks = [];</span><br><span class="line">  <span class="keyword">constructor</span>(exector) &#123;</span><br><span class="line">    <span class="comment">// 立即执行传入参数</span></span><br><span class="line">    <span class="comment">// 参数直接写为 this.resolve  会导致函数内 this指向会发生改变</span></span><br><span class="line">    <span class="comment">// 异步执行状态变更</span></span><br><span class="line">    <span class="comment">// 捕获执行器的异常</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        exector(</span><br><span class="line">          (value) =&gt; asyncExecFun(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.resolve(value)),</span><br><span class="line">          (reason) =&gt; asyncExecFun(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.reject(reason))</span><br><span class="line">        );</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">this</span>.reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  resolve(value) &#123;</span><br><span class="line">    <span class="comment">// 如果状态已经变更则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.status !== PENDING) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">    <span class="keyword">this</span>.status = FULFILLED;</span><br><span class="line">    <span class="comment">// 执行所有成功回调</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>.successCallbacks.length) <span class="keyword">this</span>.successCallbacks.shift()();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  reject(reason) &#123;</span><br><span class="line">    <span class="comment">// 如果状态已经变更则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.status !== PENDING) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">this</span>.reason = reason;</span><br><span class="line">    <span class="keyword">this</span>.status = REJECTED;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>.failCallbacks.length)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">'(in MyPromise)'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行所有失败回调</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>.failCallbacks.length) <span class="keyword">this</span>.failCallbacks.shift()();</span><br><span class="line">  &#125;</span><br><span class="line">  then(successCallback, failCallback) &#123;</span><br><span class="line">    <span class="comment">// 成功函数处理 忽略函数之外的其他值</span></span><br><span class="line">    successCallback =</span><br><span class="line">      <span class="keyword">typeof</span> successCallback == <span class="string">"function"</span> ? successCallback : <span class="function">(<span class="params">v</span>) =&gt;</span> v;</span><br><span class="line">    <span class="comment">// 失败函数处理 忽略函数之外的其他值 抛出异常  实现catch冒泡的关键</span></span><br><span class="line">    failCallback =</span><br><span class="line">      <span class="keyword">typeof</span> failCallback == <span class="string">"function"</span></span><br><span class="line">        ? failCallback</span><br><span class="line">        : <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> reason;</span><br><span class="line">          &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> promise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 统一异常处理逻辑</span></span><br><span class="line">      <span class="keyword">const</span> execFun = <span class="function">(<span class="params">fn, val</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> res = fn(val);</span><br><span class="line">          resolvePromise(promise, res, resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="comment">// 执行成功回调</span></span><br><span class="line">      <span class="keyword">const</span> execSuccessCallback = <span class="function"><span class="params">()</span> =&gt;</span> execFun(successCallback, <span class="keyword">this</span>.value);</span><br><span class="line">      <span class="comment">// 执行失败回调</span></span><br><span class="line">      <span class="keyword">const</span> execFailCallback = <span class="function"><span class="params">()</span> =&gt;</span> execFun(failCallback, <span class="keyword">this</span>.reason);</span><br><span class="line">      <span class="comment">// 同步将对应成功或者失败回调事件加入对应回调队列</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === PENDING) &#123;</span><br><span class="line">        <span class="comment">// 将成功回调加入队列</span></span><br><span class="line">        <span class="keyword">this</span>.successCallbacks.push(execSuccessCallback);</span><br><span class="line">        <span class="comment">// 讲失败回调加入队列</span></span><br><span class="line">        <span class="keyword">this</span>.failCallbacks.push(execFailCallback);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 延迟执行 可以将函数执行结果和当前then 返回的promise 进行比较</span></span><br><span class="line">      asyncExecFun(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 如果已经 fulfilled 可直接调用成功回调方法</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.status === FULFILLED) &#123;</span><br><span class="line">          execSuccessCallback();</span><br><span class="line">          <span class="comment">// 如果已经 rejected 可直接调用失败回调方法</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.status === REJECTED) &#123;</span><br><span class="line">          execFailCallback();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">catch</span>(failCallback) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">undefined</span>, failCallback);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">finally</span>(callback) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.then(</span><br><span class="line">      <span class="comment">// 穿透正常值</span></span><br><span class="line">      (value) =&gt; MyPromise.resolve(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> value),</span><br><span class="line">      (reason) =&gt;</span><br><span class="line">        MyPromise.resolve(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 穿透异常信息</span></span><br><span class="line">          <span class="keyword">throw</span> reason;</span><br><span class="line">        &#125;)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> resolve(value) &#123;</span><br><span class="line">    <span class="comment">// 如果是MyPromise 实例 则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> MyPromise) <span class="keyword">return</span> value;</span><br><span class="line">    <span class="comment">// 如果是MyPromise 实例 否则返回一个 MyPromise实例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve</span>) =&gt;</span> resolve(value));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> reject(reason) &#123;</span><br><span class="line">    <span class="comment">// 如果是MyPromise 实例 则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (reason <span class="keyword">instanceof</span> MyPromise) <span class="keyword">return</span> reason;</span><br><span class="line">    <span class="comment">// 如果是MyPromise 实例 否则返回一个 MyPromise实例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(reason));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// all方法</span></span><br><span class="line">  <span class="keyword">static</span> all(array) &#123;</span><br><span class="line">    <span class="comment">// 存储结果</span></span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="comment">// 存储数组长度</span></span><br><span class="line">    <span class="keyword">let</span> len = array.length;</span><br><span class="line">    <span class="comment">// 创建返回MyPromise</span></span><br><span class="line">    <span class="keyword">let</span> promise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 定义当前MyPromise的索引</span></span><br><span class="line">      <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// 添加数据的公用方法</span></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">addData</span>(<span class="params">key, data</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 赋值</span></span><br><span class="line">        result[key] = data;</span><br><span class="line">        <span class="comment">// 索引递增</span></span><br><span class="line">        index++;</span><br><span class="line">        <span class="comment">// 全部执行完则resolve</span></span><br><span class="line">        <span class="keyword">if</span> (index == len) &#123;</span><br><span class="line">          resolve(result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 按顺序变量数组</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> curr = array[i];</span><br><span class="line">        <span class="comment">// 如果是MyPromise则 按其规则处理</span></span><br><span class="line">        <span class="keyword">if</span> (curr <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">          curr.then(<span class="function">(<span class="params">value</span>) =&gt;</span> addData(i, value), reject);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 非MyPromise直接赋值</span></span><br><span class="line">          addData(i, curr);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 返回新的MyPromise实例</span></span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 只要有一个成功或者失败就返回</span></span><br><span class="line">  <span class="keyword">static</span> race(array) &#123;</span><br><span class="line">    <span class="keyword">let</span> promise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> curr = array[i];</span><br><span class="line">        <span class="comment">// MyPromise实例 结果处理</span></span><br><span class="line">        <span class="keyword">if</span> (curr <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">          curr.then(resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 非MyPromise实例处理</span></span><br><span class="line">          resolve(curr);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = MyPromise;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/前端/">前端</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/css/">css</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/">js</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-question_two" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2021/01/10/question_two/" class="article-date">
      <time datetime="2021-01-09T16:00:00.000Z" itemprop="datePublished">2021-01-10</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/01/10/question_two/">知识点二</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>1、Webpack 的构建流程主要有哪些环节？如果可以请尽可能详尽的描述 Webpack 打包的整个过程。<br>答: webpack是运行在nodejs环境下，配置文件遵循commonjs规范。其配置文件webpack.config.js导出一个object/function/promise/array。 Webpack在启动后，会从entry开始，递归解析entry依赖的所有Module，每找到一个Module，就会根据Module.rules里配置的Loader规则进行相应的转换处理，对Module进行转换后，再解析出当前Module依赖的Module，这些Module会以entry为单位进行分组，即为一个Chunk。因此一个Chunk，就是一个entry及其所有依赖的Module合并的结果。最后Webpack会将所有的Chunk转换成文件输出Output。在整个构建流程中，Webpack会在恰当的时机执行Plugin里定义的逻辑，从而完成Plugin插件的优化任务。其流程如下：</p>
<p>1、配置初始化<br>webpack会首先读取配置文件，执行默认配置</p>
<p>2、编译前准备<br>webpack 会实例化compiler，注册plugins、resolverFactory、hooks。</p>
<p>3、reslove前准备<br>webpack 实例化compilation、NormalModuleFactory和ContextModuleFactory</p>
<p>4、reslove流程<br>解析文件的路径信息以及inline loader和配置的loader合并、排序</p>
<p>5、构建module<br>runLoaders处理源码，得到一个编译后的字符串或buffer。将文件解析为ast，分析module间的依赖关系，递归解析依赖文件</p>
<p>6、生成chunk<br>实例化chunk并生成chunk graph，设置module id，chunk id，hash等</p>
<p>7、资源构建<br>使用不同的template渲染chunk资源</p>
<p>8、文件生成<br>创建目标文件夹及文件并将资源写入，打印构建信息</p>
<p>2、Loader 和 Plugin 有哪些不同？请描述一下开发 Loader 和 Plugin 的思路。<br>答： loader：用于对模块源码的转换，因为webpack本身只支持js处理，loader描述了webpack如何处理非javascript模块，并且在build中引入这些依赖。loader可以将文件从不同css预处理转换为css,将ts转换为JavaScript，或者将内联图像转换为data URL。比如说：sass-loader、css-Loader，style-Loader、file-loader等。</p>
<p>loader开发:就像开发中间件管道，可以首先新建一个导出模块,入参为source，对source进行一系列处理，然后返回js代码（或跟上别的loader）</p>
<p>module.exports = (source)=&gt;{</p>
<pre><code>return result(source)
</code></pre><p>}<br>plugin：plugin通过webpack钩子机制实现，相比于loader,plugin拥有更宽的能力。其目的在于解决loader无法实现的其他事，从打包优化和压缩，到重新定义环境变量，功能强大到可以用来处理各种各样的任务。 plugin开发：plugin被要求必须是一个函数或者是包含apply方法的对象。入参是一个compiler对象，其包含构建所需信息，开发时可以通过compiler中hooks属性访问到emit钩子，并通过其tap方法注册一个钩子函数，定制钩子名称和挂载函数。该函数入参为compilation打包上下文，通过遍历compilation下assets的所有键得到所有文件名称。然后根据 键 的source（）方法拿到对应的content内容，然后对content进行一些处理，并返回给souce函数，以达到我们的插件目的。</p>
<p>webpack.common.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; VueLoaderPlugin &#125; = <span class="built_in">require</span>(<span class="string">'vue-loader'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> utils = <span class="built_in">require</span>(<span class="string">'./utils.js'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">entry:utils.resolve(<span class="string">'./src/main.js'</span>),</span><br><span class="line">output:&#123;</span><br><span class="line">  path:utils.resolve(<span class="string">'./dist'</span>),</span><br><span class="line">  filename:<span class="string">'[name].[hash:6].js'</span></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">  resolve: &#123;</span><br><span class="line">    extensions: [<span class="string">'.js'</span>, <span class="string">'.vue'</span>, <span class="string">'.json'</span>],</span><br><span class="line">    alias: &#123;</span><br><span class="line">      <span class="string">'assets'</span>: utils.resolve(<span class="string">'assets'</span>),</span><br><span class="line">      <span class="string">'pages'</span>: utils.resolve(<span class="string">'src/pages'</span>),</span><br><span class="line">      <span class="string">'public'</span>: utils.resolve(<span class="string">'public'</span>),</span><br><span class="line">      <span class="string">'components'</span>: utils.resolve(<span class="string">'src/components'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(js|vue)$/</span>,</span><br><span class="line">        use: <span class="string">'eslint-loader'</span>,</span><br><span class="line">        enforce: <span class="string">'pre'</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        title:<span class="string">"my vue"</span>,</span><br><span class="line">      filename: <span class="string">'index.html'</span>,</span><br><span class="line">      template: <span class="string">'src/index.html'</span>,</span><br><span class="line">      inject: <span class="literal">true</span>,</span><br><span class="line">      url:<span class="string">'public/'</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> VueLoaderPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>webpack.dev.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>)</span><br><span class="line"><span class="keyword">const</span> baseConfig = <span class="built_in">require</span>(<span class="string">'./webpack.common.js'</span>)</span><br><span class="line"><span class="keyword">const</span> utils = <span class="built_in">require</span>(<span class="string">'./utils.js'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> PORT = <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(baseConfig, &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  devtool: <span class="string">'cheap-module-eval-source-map'</span>,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    clientLogLevel: <span class="string">'warning'</span>,</span><br><span class="line">    hot: <span class="literal">true</span>,</span><br><span class="line">    port: PORT,</span><br><span class="line">    open: <span class="literal">true</span>,</span><br><span class="line">    contentBase:utils.resolve(<span class="string">'./dist'</span>),</span><br><span class="line">    publicPath:<span class="string">'/'</span>,</span><br><span class="line">    overlay: &#123; <span class="attr">warnings</span>: <span class="literal">false</span>, <span class="attr">errors</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css?$/</span>,</span><br><span class="line">        use: [<span class="string">'vue-style-loader'</span>,<span class="string">'css-loader'</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.styl(us)?$/</span>,</span><br><span class="line">        use: [<span class="string">'vue-style-loader'</span>,<span class="string">'css-loader'</span>, <span class="string">'stylus-loader'</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(js|vue)$/</span>,</span><br><span class="line">        use: <span class="string">'eslint-loader'</span>,</span><br><span class="line">        enforce: <span class="string">'pre'</span></span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        test: <span class="regexp">/\.less?$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">'vue-style-loader'</span>,</span><br><span class="line">          <span class="string">'css-loader'</span>,</span><br><span class="line">          <span class="string">'less-loader'</span></span><br><span class="line">        ]</span><br><span class="line">      &#125; ,&#123;</span><br><span class="line">        test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">        use: <span class="string">'vue-loader'</span></span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">'babel-loader'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpe?g|gif|svg)(\?.*)?$/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">'url-loader'</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            limit: <span class="number">10</span>*<span class="number">1024</span>,</span><br><span class="line">            esModule: <span class="literal">false</span>,</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        test: <span class="regexp">/\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">'url-loader'</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            limit: <span class="number">10000</span>,</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        test: <span class="regexp">/\.(woff2?|eot|ttf|otf)(\?.*)?$/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">'url-loader'</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            limit: <span class="number">10000</span>,</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>webpack.prod.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>)</span><br><span class="line"><span class="keyword">const</span> baseConfig = <span class="built_in">require</span>(<span class="string">'./webpack.common'</span>)</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> CopyWebpackPlugin = <span class="built_in">require</span>(<span class="string">'copy-webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> &#123;CleanWebpackPlugin&#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> utils = <span class="built_in">require</span>(<span class="string">'./utils.js'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(baseConfig, &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  devtool: <span class="string">'none'</span>,</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    usedExports:<span class="literal">true</span>,</span><br><span class="line">    minimize:<span class="literal">true</span>,</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        commons: &#123;</span><br><span class="line">          test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">          name: <span class="string">'vendor'</span>,</span><br><span class="line">          chunks: <span class="string">'all'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css?$/</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader, <span class="string">'css-loader'</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.styl(us)?$/</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader, <span class="string">'css-loader'</span>, <span class="string">'stylus-loader'</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(js|vue)$/</span>,</span><br><span class="line">        use: <span class="string">'eslint-loader'</span>,</span><br><span class="line">        enforce: <span class="string">'pre'</span></span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        test: <span class="regexp">/\.less?$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">'vue-style-loader'</span>,</span><br><span class="line">          <span class="string">'css-loader'</span>,</span><br><span class="line">          <span class="string">'less-loader'</span></span><br><span class="line">        ]</span><br><span class="line">      &#125; ,&#123;</span><br><span class="line">        test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">        use: <span class="string">'vue-loader'</span></span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">          </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpe?g|gif|svg)(\?.*)?$/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">'url-loader'</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            limit: <span class="number">10</span>*<span class="number">1024</span>,</span><br><span class="line">            esModule: <span class="literal">false</span>,</span><br><span class="line">            name: utils.assetsPath(<span class="string">'img/[name].[hash:7].[ext]'</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        test: <span class="regexp">/\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">'url-loader'</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            limit: <span class="number">10000</span>,</span><br><span class="line">            name: utils.assetsPath(<span class="string">'media/[name].[hash:7].[ext]'</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        test: <span class="regexp">/\.(woff2?|eot|ttf|otf)(\?.*)?$/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">'url-loader'</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            limit: <span class="number">10000</span>,</span><br><span class="line">            name: utils.assetsPath(<span class="string">'fonts/[name].[hash:7].[ext]'</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'main.css'</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> CopyWebpackPlugin(&#123;</span><br><span class="line">      patterns: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">from</span>: utils.resolve(<span class="string">'public/'</span>),</span><br><span class="line">          to: utils.resolve(<span class="string">'dist/public'</span>),</span><br><span class="line">          toType: <span class="string">'dir'</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>util.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  resolve: <span class="function"><span class="keyword">function</span> (<span class="params">dir</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> path.join(__dirname, dir)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  assetsPath: <span class="function"><span class="keyword">function</span> (<span class="params">_path</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> assetsSubDirectory = <span class="string">'public'</span></span><br><span class="line">    <span class="keyword">return</span> path.posix.join(assetsSubDirectory, _path)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/前端/">前端</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/">js</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-question" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/08/16/question/" class="article-date">
      <time datetime="2020-08-15T16:00:00.000Z" itemprop="datePublished">2020-08-16</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/16/question/">知识点</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p> 记录一下，给自己看。</p>
<blockquote>
<p>2020-8-16</p>
</blockquote>
<h2 id="H5当中contenteditable-属性"><a href="#H5当中contenteditable-属性" class="headerlink" title="H5当中contenteditable 属性"></a>H5当中contenteditable 属性</h2><ul>
<li>contenteditable 属性规定元素内容是否可编辑  </li>
<li>通过<code>&amp;:focus{outline: none;}</code>去除聚焦边框</li>
<li><code>oninput</code> 监听文本变化</li>
</ul>
<h2 id="微信表情包使用"><a href="#微信表情包使用" class="headerlink" title="微信表情包使用"></a>微信表情包使用</h2><ul>
<li><code>https://res.wx.qq.com/mpres/htmledition/images/icon/emotion/${Math.floor(Math.random() * 104 + 1)}.gif&quot;</code></li>
</ul>
<h2 id="点击复制"><a href="#点击复制" class="headerlink" title="点击复制"></a>点击复制</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">      copy(dom) &#123;</span><br><span class="line">	//创建input元素</span><br><span class="line">	let input = document.createElement(&apos;input&apos;)</span><br><span class="line">	document.body.appendChild(input)</span><br><span class="line">	input.value = this.$refs[dom].innerText</span><br><span class="line">	//input元素选中状态</span><br><span class="line">	input.select()</span><br><span class="line">	//复制内容到剪切板</span><br><span class="line">	document.execCommand(&apos;copy&apos;)</span><br><span class="line">	//移除input元素</span><br><span class="line">	document.body.removeChild(input)</span><br><span class="line">	this.$notify(&#123; type: &apos;success&apos;, message: &apos;复制成功！&apos;, duration: 500 &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>2020-8-18</p>
</blockquote>
<h2 id="vue-cli-publicPath-来自官方文档"><a href="#vue-cli-publicPath-来自官方文档" class="headerlink" title="vue-cli publicPath(来自官方文档)"></a>vue-cli publicPath(来自官方文档)</h2><ul>
<li>默认情况下，Vue CLI 会假设你的应用是被部署在一个域名的根路径上，例如 <a href="https://www.my-app.com/。" target="_blank" rel="noopener">https://www.my-app.com/。</a><br>如果应用被部署在一个子路径上，你就需要用这个选项指定这个子路径。例如，如果你的应用被部署在 <a href="https://www.my-app.com/my-app/，则设置" target="_blank" rel="noopener">https://www.my-app.com/my-app/，则设置</a> publicPath 为 /my-app/。<br>这个值也可以被设置为空字符串 (‘’) 或是相对路径 (‘./‘)，这样所有的资源都会被链接为相对路径，这样打出来的包可以被部署在任意路径，也可以用在类似 Cordova hybrid 应用的文件系统中。</li>
<li>相对路径的 publicPath 有一些使用上的限制。在以下情况下，应当避免使用相对 :<br>当使用基于 HTML5 history.pushState 的路由时；<br>当使用 pages 选项构建多页面应用时.</li>
<li>这个值在开发环境下同样生效。如果你想把开发服务器架设在根路径，你可以使用一个条件式的值：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  publicPath: process.env.NODE_ENV === &apos;production&apos;</span><br><span class="line">    ? &apos;/production-sub-path/&apos;</span><br><span class="line">    : &apos;/&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>2020-8-24</p>
</blockquote>
<h2 id="Ant-Design-输入框、下拉框取消聚焦时的边框颜色"><a href="#Ant-Design-输入框、下拉框取消聚焦时的边框颜色" class="headerlink" title="Ant-Design 输入框、下拉框取消聚焦时的边框颜色"></a>Ant-Design 输入框、下拉框取消聚焦时的边框颜色</h2><ul>
<li>输入框</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/deep/ .ant-input &#123;</span><br><span class="line">                     //ant-design输入框聚焦样式通过box-shadow设置</span><br><span class="line">                   &amp;:focus &#123;</span><br><span class="line">                                box-shadow: none;</span><br><span class="line">                            &#125;</span><br><span class="line">                  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>下拉框</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//ant-design下拉框聚焦样式通过box-shadow设置</span><br><span class="line">                        /deep/ .ant-select-focused &#123;</span><br><span class="line">                            .ant-select-selection &#123;</span><br><span class="line">                                box-shadow: none;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Ant-Design-Table组件设置四角圆角属性-border-radius"><a href="#Ant-Design-Table组件设置四角圆角属性-border-radius" class="headerlink" title="Ant-Design Table组件设置四角圆角属性 border-radius"></a>Ant-Design Table组件设置四角圆角属性 border-radius</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/deep/ .ant-table-thead tr &#123;</span><br><span class="line">            th &#123;</span><br><span class="line">                &amp;:nth-child(1) &#123;</span><br><span class="line">                    border-top-left-radius: 15px;</span><br><span class="line">                &#125;</span><br><span class="line">                &amp;:nth-last-child(1) &#123;</span><br><span class="line">                    border-top-right-radius: 15px;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        /deep/ .ant-table-tbody &#123;</span><br><span class="line">            background-color: #fff;</span><br><span class="line">            tr &#123;</span><br><span class="line">                &amp;:nth-last-child(1) &#123;</span><br><span class="line">                    td &#123;</span><br><span class="line">                        &amp;:nth-child(1) &#123;</span><br><span class="line">                            border-bottom-left-radius: 15px;</span><br><span class="line">                        &#125;</span><br><span class="line">                        &amp;:nth-last-child(1) &#123;</span><br><span class="line">                            border-bottom-right-radius: 15px;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>2020-8-27</p>
</blockquote>
<h2 id="必选星号-字体"><a href="#必选星号-字体" class="headerlink" title="必选星号 字体"></a>必选星号 字体</h2><ul>
<li><code>font-family: SimSun, sans-serif</code></li>
</ul>
<blockquote>
<p>2020-8-28</p>
</blockquote>
<h2 id="实现-placeholder-效果"><a href="#实现-placeholder-效果" class="headerlink" title="实现  placeholder 效果"></a>实现  placeholder 效果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&amp;:before &#123;</span><br><span class="line">      content: &apos;请输入...&apos;;</span><br><span class="line">      color: gray;</span><br><span class="line">&#125;</span><br><span class="line">&amp;:focus:before &#123;</span><br><span class="line"> content: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>2020-8-29</p>
</blockquote>
<h2 id="oninput-事件"><a href="#oninput-事件" class="headerlink" title="oninput 事件"></a><code>oninput</code> 事件</h2><p><em>该事件在<code>&lt;input&gt;</code>或 <code>&lt;textarea&gt;</code>元素的值发生改变时触发。
</em>提示： 该事件类似于<code>onchange</code>事件。不同之处在于 <code>oninput</code> 事件在元素值发生变化是立即触发，<code>onchange</code> 在元素失去焦点时触发。<br>*另外一点不同是 <code>onchange</code>事件也可以作用于<code>&lt;keygen&gt;</code>和 <code>&lt;select&gt;</code>元素。</p>
<blockquote>
<p>2020-8-30</p>
</blockquote>
<h2 id="vant-Dialog弹出框、Popup弹出层样式修改"><a href="#vant-Dialog弹出框、Popup弹出层样式修改" class="headerlink" title="vant Dialog弹出框、Popup弹出层样式修改"></a>vant Dialog弹出框、Popup弹出层样式修改</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">position: absolute;</span><br><span class="line">left: 0;</span><br><span class="line">right: 0;</span><br><span class="line">top: 0;</span><br><span class="line">bottom: 0;</span><br><span class="line">margin: auto;</span><br><span class="line">transform: translate3d(0, 0, 0); 解决字体模糊</span><br></pre></td></tr></table></figure>
<blockquote>
<p>2020-9-1</p>
</blockquote>
<h2 id="滚动条"><a href="#滚动条" class="headerlink" title="滚动条"></a>滚动条</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">                    &amp;::-webkit-scrollbar &#123;</span><br><span class="line">                        width: 10px; /*滚动条宽度*/</span><br><span class="line">                    &#125;</span><br><span class="line">                    &amp;::-webkit-scrollbar-thumb &#123;</span><br><span class="line">                        /*滚动条滑块*/</span><br><span class="line">                        border-radius: 10px;</span><br><span class="line">                        box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.2);</span><br><span class="line">                        background: #535353;</span><br><span class="line">                    &#125;</span><br><span class="line">                    &amp;::-webkit-scrollbar-track &#123;</span><br><span class="line">                        /*滚动条轨道*/</span><br><span class="line">                        box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.2);</span><br><span class="line">                        border-radius: 10px;</span><br><span class="line">                        background: #ededed;</span><br><span class="line">                    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>2020-9-9</p>
</blockquote>
<h2 id="location-search"><a href="#location-search" class="headerlink" title="location.search"></a><code>location.search</code></h2><ul>
<li><code>location.search</code> 属性是一个可读可写的字符串，可设置或返回当前 URL 的查询部分（问号 ? 之后的部分）。</li>
<li>hash路由时也可</li>
</ul>
<blockquote>
<p>2020-9-10</p>
</blockquote>
<h2 id="attname"><a href="#attname" class="headerlink" title="attname"></a><code>attname</code></h2><ul>
<li><code>url?attname=&#39;&#39;</code>  可以自定义资源文件下载的文件后缀和名字（比如七牛云转链的APK文件）</li>
</ul>
<h2 id="deep"><a href="#deep" class="headerlink" title="/deep/"></a><code>/deep/</code></h2><ul>
<li>less  修改富文本图片样式时需要用到   （这样描述估计只有本尊自己能看懂，没错，就是给我自己看的）</li>
</ul>
<blockquote>
<p>2020-9-15</p>
</blockquote>
<h2 id="env-prod配置文件"><a href="#env-prod配置文件" class="headerlink" title=".env.prod配置文件"></a><code>.env.prod配置文件</code></h2><ul>
<li>配置文件注释使用<code>#</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">NODE_ENV=production   (打包部署时，NODE_ENV需为production)</span><br><span class="line">测试环境</span><br><span class="line">VUE_APP_API_BASE_URL=xxx </span><br><span class="line">VUE_APP_API_REDIRECT_URL=xxx</span><br><span class="line">预发环境</span><br><span class="line">VUE_APP_API_BASE_URL=xxx</span><br><span class="line">VUE_APP_API_REDIRECT_URL=xxx</span><br><span class="line">线上测试环境</span><br><span class="line">VUE_APP_API_BASE_URL=xxx</span><br><span class="line">VUE_APP_API_REDIRECT_URL=xxx</span><br><span class="line">正式线上环境</span><br><span class="line">VUE_APP_API_BASE_URL=xxx</span><br><span class="line">VUE_APP_API_REDIRECT_URL=xxx</span><br></pre></td></tr></table></figure>
<h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a><code>package.json</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">        &quot;serve&quot;: &quot;vue-cli-service serve --mode dev&quot;,</span><br><span class="line">        &quot;build&quot;: &quot;vue-cli-service build --mode prod&quot;,</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>
<h2 id="npm-cache-clear-–force-清除缓存"><a href="#npm-cache-clear-–force-清除缓存" class="headerlink" title="npm cache clear –force 清除缓存"></a>npm cache clear –force 清除缓存</h2><blockquote>
<p>2020-9-18</p>
</blockquote>
<h2 id="env-prod配置文件-1"><a href="#env-prod配置文件-1" class="headerlink" title=".env.prod配置文件"></a><code>.env.prod配置文件</code></h2><ul>
<li>配置文件注释使用<code>#</code></li>
</ul>
<blockquote>
<p>2020-9-22</p>
</blockquote>
<h2 id="promise"><a href="#promise" class="headerlink" title="promise"></a><code>promise</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line">const PENDING = &quot;pending&quot;; // 等待</span><br><span class="line">const FULFILLED = &quot;fulfilled&quot;; // 成功</span><br><span class="line">const REJECTED = &quot;rejected&quot;; // 失败</span><br><span class="line"></span><br><span class="line">class _Promise &#123;</span><br><span class="line">  constructor(executor) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      executor(this.resolve, this.reject);</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">      this.reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // promsie 状态</span><br><span class="line">  status = PENDING;</span><br><span class="line">  // 成功之后的值</span><br><span class="line">  value = undefined;</span><br><span class="line">  // 失败后的原因</span><br><span class="line">  reason = undefined;</span><br><span class="line">  // 成功回调</span><br><span class="line">  successCallback = [];</span><br><span class="line">  // 失败回调</span><br><span class="line">  failCallback = [];</span><br><span class="line"></span><br><span class="line">  resolve = (value) =&gt; &#123;</span><br><span class="line">    // 如果状态不是等待 阻止程序向下执行</span><br><span class="line">    if (this.status !== PENDING) return;</span><br><span class="line">    // 将状态更改为成功</span><br><span class="line">    this.status = FULFILLED;</span><br><span class="line">    // 保存成功之后的值</span><br><span class="line">    this.value = value;</span><br><span class="line">    // 判断成功回调是否存在 如果存在 调用</span><br><span class="line">    // this.successCallback &amp;&amp; this.successCallback(this.value);</span><br><span class="line">    while (this.successCallback.length) this.successCallback.shift()();</span><br><span class="line">  &#125;;</span><br><span class="line">  reject = (reason) =&gt; &#123;</span><br><span class="line">    // 如果状态不是等待 阻止程序向下执行</span><br><span class="line">    if (this.status !== PENDING) return;</span><br><span class="line">    // 将状态更改为失败</span><br><span class="line">    this.status = REJECTED;</span><br><span class="line">    // 保存失败后的原因</span><br><span class="line">    this.reason = reason;</span><br><span class="line">    // 判断失败回调是否存在 如果存在 调用</span><br><span class="line">    // this.failCallback &amp;&amp; this.failCallback(this.reason);</span><br><span class="line">    while (this.failCallback.length) this.failCallback.shift()();</span><br><span class="line">  &#125;;</span><br><span class="line">  then(successCallback, failCallback) &#123;</span><br><span class="line">    // 参数可选</span><br><span class="line">    successCallback = successCallback ? successCallback : (value) =&gt; value;</span><br><span class="line">    // 参数可选</span><br><span class="line">    failCallback = failCallback</span><br><span class="line">      ? failCallback</span><br><span class="line">      : (reason) =&gt; &#123;</span><br><span class="line">          throw reason;</span><br><span class="line">        &#125;;</span><br><span class="line">    let promsie2 = new _Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      // 判断状态</span><br><span class="line">      if (this.status === FULFILLED) &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">            let x = successCallback(this.value);</span><br><span class="line">            // 判断 x 的值是普通值还是Promise对象</span><br><span class="line">            // 如果是普通值 直接调用resolve</span><br><span class="line">            // 如果是promise对象 查看promsie对象返回的结果</span><br><span class="line">            // 再根据promise对象返回的结果 决定调用resolve 还是调用reject</span><br><span class="line">            resolvePromise(promsie2, x, resolve, reject);</span><br><span class="line">          &#125; catch (e) &#123;</span><br><span class="line">            reject(e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, 0);</span><br><span class="line">      &#125; else if (this.status === REJECTED) &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">            let x = failCallback(this.reason);</span><br><span class="line">            // 判断 x 的值是普通值还是promise对象</span><br><span class="line">            // 如果是普通值 直接调用resolve</span><br><span class="line">            // 如果是promise对象 查看promsie对象返回的结果</span><br><span class="line">            // 再根据promise对象返回的结果 决定调用resolve 还是调用reject</span><br><span class="line">            resolvePromise(promsie2, x, resolve, reject);</span><br><span class="line">          &#125; catch (e) &#123;</span><br><span class="line">            reject(e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, 0);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        // 等待</span><br><span class="line">        // 将成功回调和失败回调存储起来</span><br><span class="line">        this.successCallback.push(() =&gt; &#123;</span><br><span class="line">          setTimeout(() =&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">              let x = successCallback(this.value);</span><br><span class="line">              // 判断 x 的值是普通值还是promise对象</span><br><span class="line">              // 如果是普通值 直接调用resolve</span><br><span class="line">              // 如果是promise对象 查看promsie对象返回的结果</span><br><span class="line">              // 再根据promise对象返回的结果 决定调用resolve 还是调用reject</span><br><span class="line">              resolvePromise(promsie2, x, resolve, reject);</span><br><span class="line">            &#125; catch (e) &#123;</span><br><span class="line">              reject(e);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, 0);</span><br><span class="line">        &#125;);</span><br><span class="line">        this.failCallback.push(() =&gt; &#123;</span><br><span class="line">          setTimeout(() =&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">              let x = failCallback(this.reason);</span><br><span class="line">              // 判断 x 的值是普通值还是promise对象</span><br><span class="line">              // 如果是普通值 直接调用resolve</span><br><span class="line">              // 如果是promise对象 查看promsie对象返回的结果</span><br><span class="line">              // 再根据promise对象返回的结果 决定调用resolve 还是调用reject</span><br><span class="line">              resolvePromise(promsie2, x, resolve, reject);</span><br><span class="line">            &#125; catch (e) &#123;</span><br><span class="line">              reject(e);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, 0);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return promsie2;</span><br><span class="line">  &#125;</span><br><span class="line">  finally(callback) &#123;</span><br><span class="line">    return this.then(</span><br><span class="line">      (value) =&gt; &#123;</span><br><span class="line">        return _Promise.resolve(callback()).then(() =&gt; value);</span><br><span class="line">      &#125;,</span><br><span class="line">      (reason) =&gt; &#123;</span><br><span class="line">        return _Promise.resolve(callback()).then(() =&gt; &#123;</span><br><span class="line">          throw reason;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  catch(failCallback) &#123;</span><br><span class="line">    return this.then(undefined, failCallback);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //all静态方法</span><br><span class="line">  static all(array) &#123;</span><br><span class="line">    let result = [];</span><br><span class="line">    let index = 0;</span><br><span class="line">    return new _Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      function addData(key, value) &#123;</span><br><span class="line">        result[key] = value;</span><br><span class="line">        index++;</span><br><span class="line">        if (index === array.length) &#123;</span><br><span class="line">          resolve(result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      for (let i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">        let current = array[i];</span><br><span class="line">        if (current instanceof _Promise) &#123;</span><br><span class="line">          // promise 对象</span><br><span class="line">          current.then(</span><br><span class="line">            (value) =&gt; addData(i, value),</span><br><span class="line">            (reason) =&gt; reject(reason)</span><br><span class="line">          );</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          // 普通值</span><br><span class="line">          addData(i, array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  //resolve静态方法</span><br><span class="line">  static resolve(value) &#123;</span><br><span class="line">    if (value instanceof _Promise) return value;</span><br><span class="line">    return new _Promise((resolve) =&gt; resolve(value));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function resolvePromise(promsie2, x, resolve, reject) &#123;</span><br><span class="line">  if (promsie2 === x) &#123;</span><br><span class="line">    return reject(</span><br><span class="line">      new TypeError(&quot;Chaining cycle detected for promise #&lt;Promise&gt;&quot;)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  //promise对象</span><br><span class="line">  if (x instanceof _Promise) &#123;</span><br><span class="line">    x.then(resolve, reject);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // 普通值</span><br><span class="line">    resolve(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">module.exports = __Promise;</span><br></pre></td></tr></table></figure>
<h2 id="AntDesign-Notification"><a href="#AntDesign-Notification" class="headerlink" title="AntDesign  Notification"></a><code>AntDesign  Notification</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">this.$notification.open(&#123;</span><br><span class="line">  getContainer: function () &#123;</span><br><span class="line">    return document.querySelector(&quot;#team_set&quot;);</span><br><span class="line">  &#125;,</span><br><span class="line">  message: &quot;生成链接&quot;,</span><br><span class="line">  description: (h) =&gt; &#123;</span><br><span class="line">    return h(&quot;div&quot;, [</span><br><span class="line">      h(&quot;h3&quot;, &quot;长链接&quot;),</span><br><span class="line">      h(&quot;div&quot;, &#123;</span><br><span class="line">        //html attribute</span><br><span class="line">        attrs: &#123;</span><br><span class="line">          id: &quot;longUrl&quot;,</span><br><span class="line">          class: &quot;notification-text&quot;,</span><br><span class="line">        &#125;, //dom  property</span><br><span class="line">        domProps: &#123;</span><br><span class="line">          innerHTML: `$&#123;this.link.redirectUrl&#125;`,</span><br><span class="line">        &#125;,</span><br><span class="line">        on: &#123;</span><br><span class="line">          click: this.copy,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;),</span><br><span class="line">      h(&quot;h3&quot;, &quot;短链接&quot;),</span><br><span class="line">      h(&quot;div&quot;, &#123;</span><br><span class="line">        //html attribute</span><br><span class="line">        attrs: &#123;</span><br><span class="line">          id: &quot;shortUrl&quot;,</span><br><span class="line">          class: &quot;notification-text&quot;,</span><br><span class="line">        &#125;, //dom  property</span><br><span class="line">        domProps: &#123;</span><br><span class="line">          innerHTML: `$&#123;this.link.shorUrl&#125;`,</span><br><span class="line">        &#125;,</span><br><span class="line">        on: &#123;</span><br><span class="line">          click: this.copy,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;),</span><br><span class="line">    ]);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="图片宽度高度相等"><a href="#图片宽度高度相等" class="headerlink" title="图片宽度高度相等"></a><code>图片宽度高度相等</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> .face-list &#123;</span><br><span class="line">        display: flex;</span><br><span class="line">        justify-content: space-between;</span><br><span class="line">        flex-wrap: wrap;</span><br><span class="line">        padding: 10px;</span><br><span class="line">        &amp;::after &#123;</span><br><span class="line">            content: &apos;&apos;;</span><br><span class="line">            flex-grow: 9999;</span><br><span class="line">        &#125;</span><br><span class="line">        .face-list-item &#123;</span><br><span class="line">            width: 8%;</span><br><span class="line">            margin: 2% 1%;</span><br><span class="line">            padding: 8px;</span><br><span class="line">            border: 1px solid #d9d9d9;</span><br><span class="line">            border-radius: 6px;</span><br><span class="line">            .face-list-item-img &#123;</span><br><span class="line">                padding: 50% 0;</span><br><span class="line">                cursor: pointer;</span><br><span class="line">                position: relative;</span><br><span class="line">                .face-list-item-cover &#123;</span><br><span class="line">                    position: absolute;</span><br><span class="line">                    top: 0px;</span><br><span class="line">                    background-color: rgba(0, 0, 0, 0.5);</span><br><span class="line">                    width: 100%;</span><br><span class="line">                    height: 100%;</span><br><span class="line">                    display: flex;</span><br><span class="line">                    justify-content: center;</span><br><span class="line">                    align-items: center;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="AntDesign-select组件-popupScroll事件"><a href="#AntDesign-select组件-popupScroll事件" class="headerlink" title="AntDesign select组件 popupScroll事件"></a><code>AntDesign select组件 popupScroll事件</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//下拉框滚动事件</span><br><span class="line">        selectScroll(e) &#123;</span><br><span class="line">            //滚动距离顶部的高度</span><br><span class="line">            let scrollTop = e.target.scrollTop</span><br><span class="line">            //滚动区域高度</span><br><span class="line">            let scrollHeight = e.target.scrollHeight</span><br><span class="line">            //滚动可视区域高度</span><br><span class="line">            let height = parseInt(e.target.style.height.replace(&apos;px&apos;, &apos;&apos;))</span><br><span class="line">            //是否滚动到底部</span><br><span class="line">            if (scrollTop + height === scrollHeight) &#123;</span><br><span class="line">               </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br></pre></td></tr></table></figure>
<h2 id="响应头-responseType-Blob"><a href="#响应头-responseType-Blob" class="headerlink" title="响应头 responseType:Blob"></a>响应头 responseType:Blob</h2><p>处理文件下载时返回的二进制数据</p>
<h2 id="get请求url含特殊参数时"><a href="#get请求url含特殊参数时" class="headerlink" title="get请求url含特殊参数时"></a>get请求url含特殊参数时</h2><p>需要对特殊参数进行编码(encodeURIComponent)</p>
<p>encodeURIComponent:该方法不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码： - _ . ! ~ * ‘ ( ) 。<br>其他字符（比如 ：;/?:@&amp;=+$,# 这些用于分隔 URI 组件的标点符号），都是由一个或多个十六进制的转义序列替换的。</p>
<h2 id="lottie-json动画"><a href="#lottie-json动画" class="headerlink" title="lottie  (json动画)"></a>lottie  (json动画)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const el = document.querySelector(&quot;#lottie_avtivity&quot;);</span><br><span class="line">lottie.loadAnimation(&#123;</span><br><span class="line">  container: el,</span><br><span class="line">  renderer: &quot;svg&quot;,</span><br><span class="line">  loop: true,</span><br><span class="line">  autoplay: true,</span><br><span class="line">  path: &quot;lottie.json&quot;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="DatePicker、MonthPicker、RangePicker、WeekPicker-部分-locale-是从-value-中读取，需要先正确设置-moment-的-locale。"><a href="#DatePicker、MonthPicker、RangePicker、WeekPicker-部分-locale-是从-value-中读取，需要先正确设置-moment-的-locale。" class="headerlink" title="DatePicker、MonthPicker、RangePicker、WeekPicker 部分 locale 是从 value 中读取，需要先正确设置 moment 的 locale。"></a>DatePicker、MonthPicker、RangePicker、WeekPicker 部分 locale 是从 value 中读取，需要先正确设置 moment 的 locale。</h2><h2 id="replace-s-g-’’-清除所有空白字符"><a href="#replace-s-g-’’-清除所有空白字符" class="headerlink" title="replace(/\s/g,’’)   清除所有空白字符"></a>replace(/\s/g,’’)   清除所有空白字符</h2><h2 id="375px以下适配"><a href="#375px以下适配" class="headerlink" title="375px以下适配"></a>375px以下适配</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@screen: 3.75;</span><br><span class="line">@media screen and(max-width:375px) &#123;</span><br><span class="line">  #app &#123;</span><br><span class="line">    padding: 20vw / @screen 0;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="获取url查询参数"><a href="#获取url查询参数" class="headerlink" title="获取url查询参数"></a>获取url查询参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function getUrlParams(field) &#123;</span><br><span class="line">  //查询字符串  去掉?</span><br><span class="line">  const queryStr = window.location.search.slice(1);</span><br><span class="line">  //查询参数数组</span><br><span class="line">  const queryArr = queryStr.split(&quot;&amp;&quot;);</span><br><span class="line">  for (const query of queryArr) &#123;</span><br><span class="line">    const key = query.split(&quot;=&quot;)[0];</span><br><span class="line">    const value = query.split(&quot;=&quot;)[1];</span><br><span class="line">    //匹配到字段</span><br><span class="line">    if (field === key) return value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="提示框"><a href="#提示框" class="headerlink" title="提示框"></a>提示框</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;tip&quot; id=&quot;tip&quot;&gt;复制成功&lt;/div&gt;</span><br><span class="line">.tip&#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 30px;</span><br><span class="line">    line-height: 30px;</span><br><span class="line">    text-align: center;</span><br><span class="line">    border-radius: 6px;</span><br><span class="line">    background-color: rgba(0, 0, 0, .4);</span><br><span class="line">    color:  rgba(256, 256, 256, .8);</span><br><span class="line">    font-size: 14px;</span><br><span class="line">    opacity: 0;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 50%;</span><br><span class="line">    left: 50%;</span><br><span class="line">    transform: translate(-50%);</span><br><span class="line">    transition: opacity .8s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">渠道专属推广位   /^([a-zA-Z])\1_[0-9]&#123;1,&#125;_[0-9]&#123;1,&#125;_[0-9]&#123;1,&#125;$/g, message: &apos;格式:mm_123456_123456_123456&apos; </span><br><span class="line"></span><br><span class="line">手机号  /^[1][3|4|5|6|7|8|9][0-9]&#123;9&#125;$/g</span><br></pre></td></tr></table></figure>
<h2 id="textarea-禁止拖拽"><a href="#textarea-禁止拖拽" class="headerlink" title="textarea  禁止拖拽"></a>textarea  禁止拖拽</h2><p>resize:none</p>
<h2 id="腾讯图形验证码"><a href="#腾讯图形验证码" class="headerlink" title="腾讯图形验证码"></a>腾讯图形验证码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://ssl.captcha.qq.com/TCaptcha.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> //验证码生成</span><br><span class="line">    tencentCode() &#123;</span><br><span class="line">      let tencentCodeDom = document.querySelector(&quot;#TencentCaptchaCode&quot;);</span><br><span class="line">      let self = this;</span><br><span class="line">      this.tencentCodeObject = new TencentCaptcha(</span><br><span class="line">        tencentCodeDom,</span><br><span class="line">        &quot;2062726362&quot;,</span><br><span class="line">        function (res) &#123;</span><br><span class="line">          //判断验证成功</span><br><span class="line">          if (res.ret === 2) &#123;</span><br><span class="line">            self.loading = false;</span><br><span class="line">          &#125; else if (res.ret === 0) &#123;</span><br><span class="line">            self</span><br><span class="line">              .Login(&#123;</span><br><span class="line">                loginTilKey: self.loginTilKey,</span><br><span class="line">                values: self.loginParams,</span><br><span class="line">              &#125;)</span><br><span class="line">              .then((res) =&gt; &#123;</span><br><span class="line">                self.loginSuccess();</span><br><span class="line">              &#125;)</span><br><span class="line">              .catch((res) =&gt; self.requestFailed(res))</span><br><span class="line">              .finally(() =&gt; &#123;</span><br><span class="line">                self.loading = false;</span><br><span class="line">                self.resetValidateCode();</span><br><span class="line">              &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      );</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>
<h2 id="h函数"><a href="#h函数" class="headerlink" title="h函数"></a>h函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">render (h) &#123;</span><br><span class="line">  return h(&apos;div&apos;, &#123;</span><br><span class="line">    // Component props</span><br><span class="line">    props: &#123;</span><br><span class="line">      msg: &apos;hi&apos;,</span><br><span class="line">      onCustomEvent: this.customEventHandler</span><br><span class="line">    &#125;,</span><br><span class="line">    // normal HTML attributes</span><br><span class="line">    attrs: &#123;</span><br><span class="line">      id: &apos;foo&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    // DOM props</span><br><span class="line">    domProps: &#123;</span><br><span class="line">      innerHTML: &apos;bar&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    // Event handlers are nested under &quot;on&quot;, though</span><br><span class="line">    // modifiers such as in v-on:keyup.enter are not</span><br><span class="line">    // supported. You&apos;ll have to manually check the</span><br><span class="line">    // keyCode in the handler instead.</span><br><span class="line">    on: &#123;</span><br><span class="line">      click: this.clickHandler</span><br><span class="line">    &#125;,</span><br><span class="line">    // For components only. Allows you to listen to</span><br><span class="line">    // native events, rather than events emitted from</span><br><span class="line">    // the component using vm.$emit.</span><br><span class="line">    nativeOn: &#123;</span><br><span class="line">      click: this.nativeClickHandler</span><br><span class="line">    &#125;,</span><br><span class="line">    // class is a special module, same API as `v-bind:class`</span><br><span class="line">    class: &#123;</span><br><span class="line">      foo: true,</span><br><span class="line">      bar: false</span><br><span class="line">    &#125;,</span><br><span class="line">    // style is also same as `v-bind:style`</span><br><span class="line">    style: &#123;</span><br><span class="line">      color: &apos;red&apos;,</span><br><span class="line">      fontSize: &apos;14px&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    // other special top-level properties</span><br><span class="line">    key: &apos;key&apos;,</span><br><span class="line">    ref: &apos;ref&apos;,</span><br><span class="line">    // assign the `ref` is used on elements/components with v-for</span><br><span class="line">    refInFor: true,</span><br><span class="line">    slot: &apos;slot&apos;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Ant-Design-upload-文件封面设置"><a href="#Ant-Design-upload-文件封面设置" class="headerlink" title="Ant Design  upload   文件封面设置"></a>Ant Design  upload   文件封面设置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">:preview-file=&quot;handlePreviewImg&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  //图片base64预览</span><br><span class="line">    getBase64More(file) &#123;</span><br><span class="line">      return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        const reader = new FileReader();</span><br><span class="line">        reader.readAsDataURL(file);</span><br><span class="line">        reader.onload = () =&gt; resolve(reader.result);</span><br><span class="line">        reader.onerror = (error) =&gt; reject(error);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//文件封面设置</span><br><span class="line">    async handlePreviewImg(file) &#123;</span><br><span class="line">      //视频</span><br><span class="line">      if (file.type === &quot;video/mp4&quot;) &#123;</span><br><span class="line">        return Promise.resolve(&quot;https://kuaizhan.ecostudio.cn/video.png&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      //图片</span><br><span class="line">      else &#123;</span><br><span class="line">        //图片封面</span><br><span class="line">        const imgCover = await this.getBase64More(file);</span><br><span class="line">        return Promise.resolve(imgCover);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>
<h2 id="linus"><a href="#linus" class="headerlink" title="linus"></a>linus</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">rm-rf 删除目录</span><br></pre></td></tr></table></figure>
<h2 id="a标签-下载跨域文件"><a href="#a标签-下载跨域文件" class="headerlink" title="a标签  下载跨域文件"></a>a标签  下载跨域文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"> download(url, name) &#123;</span><br><span class="line">      const xhr = new XMLHttpRequest();</span><br><span class="line">      xhr.open(&quot;GET&quot;, url, true);</span><br><span class="line">      xhr.responseType = &quot;blob&quot;;</span><br><span class="line">      xhr.onload = function (e) &#123;</span><br><span class="line">        const url = window.URL.createObjectURL(xhr.response);</span><br><span class="line">        const a = document.createElement(&quot;a&quot;);</span><br><span class="line">        a.href = url;</span><br><span class="line">        a.download = name;</span><br><span class="line">        a.click();</span><br><span class="line">      &#125;;</span><br><span class="line">      xhr.send();</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>
<h2 id="pm2"><a href="#pm2" class="headerlink" title="pm2"></a>pm2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">pm2 list 查看</span><br><span class="line">pm2 start npm --name strapi-demo -- run start 启动、别名</span><br><span class="line">pm2 delete 删除(id)</span><br><span class="line">pm2 stop 停止(name)</span><br></pre></td></tr></table></figure>
<h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1. 删除本地tag</span><br><span class="line">　　　　git tag -d tag-name</span><br><span class="line">2. 删除远程tag</span><br><span class="line">　　　　git push origin :refs/tags/tag-name</span><br></pre></td></tr></table></figure>
<h2 id="port设置"><a href="#port设置" class="headerlink" title="port设置"></a>port设置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1. windows:    eg: &quot;start&quot;: &quot;set PORT=9000 &amp;&amp; react-scripts start&quot; </span><br><span class="line">　　　</span><br><span class="line">2. Linux:    eg: &quot;start&quot;: &quot;PORT=9000  react-scripts start&quot;</span><br></pre></td></tr></table></figure>
<h2 id="WeakSet、WeakMap"><a href="#WeakSet、WeakMap" class="headerlink" title="WeakSet、WeakMap"></a>WeakSet、WeakMap</h2><ul>
<li>WeakSet</li>
</ul>
<ol>
<li>WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。首先，WeakSet 的成员只能是对象，而不能是其他类型的值。</li>
<li>其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。<br>这是因为垃圾回收机制依赖引用计数，如果一个值的引用次数不为0，垃圾回收机制就不会释放这块内存。结束使用该值之后，有时会忘记取消引用，导致内存无法释放，进而可能会引发内存泄漏。WeakSet 里面的引用，都不计入垃圾回收机制，所以就不存在这个问题。<br>因此，WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。<br>由于上面这个特点，WeakSet 的成员是不适合引用的，因为它会随时消失。<br>另外，由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 WeakSet 不可遍历。</li>
<li>WeakSet 没有size属性，没有办法遍历它的成员。</li>
<li>WeakSet 不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。<br>WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。</li>
</ol>
<ul>
<li>WeakMap</li>
</ul>
<ol>
<li>首先，WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。</li>
<li>其次，WeakMap的键名所指向的对象，不计入垃圾回收机制。</li>
<li>WeakMap的设计目的在于，有时我们想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。请看下面的例子。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const e1 = document.getElementById(&apos;foo&apos;);</span><br><span class="line">const e2 = document.getElementById(&apos;bar&apos;);</span><br><span class="line">const arr = [</span><br><span class="line">  [e1, &apos;foo 元素&apos;],</span><br><span class="line">  [e2, &apos;bar 元素&apos;],</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>上面代码中，e1和e2是两个对象，我们通过arr数组对这两个对象添加一些文字说明。这就形成了arr对e1和e2的引用。<br>一旦不再需要这两个对象，我们就必须手动删除这个引用，否则垃圾回收机制就不会释放e1和e2占用的内存。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 不需要 e1 和 e2 的时候</span><br><span class="line">// 必须手动删除引用</span><br><span class="line">arr [0] = null;</span><br><span class="line">arr [1] = null;</span><br></pre></td></tr></table></figure></p>
<p>上面这样的写法显然很不方便。一旦忘了写，就会造成内存泄露。<br>WeakMap 就是为了解决这个问题而诞生的，它的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。<br>因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。<br>也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。</p>
<h2 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h2><ul>
<li>Reflect对象的设计目的有这样几个。</li>
</ul>
<ol>
<li>将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。<br>现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。<br>也就是说，从Reflect对象上可以拿到语言内部的方法。</li>
<li>修改某些Object方法的返回结果，让其变得更合理。<br>比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。</li>
<li>让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。</li>
<li>Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。<br>也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。</li>
<li>Reflect.ownKeys方法用于返回对象的所有属性，基本等同于Object.getOwnPropertyNames与Object.getOwnPropertySymbols之和。</li>
<li>Reflect.construct方法等同于new target(…args)，这提供了一种不使用new，来调用构造函数的方法。<h2 id="encodeURI-encodeURIComponent"><a href="#encodeURI-encodeURIComponent" class="headerlink" title="encodeURI encodeURIComponent"></a>encodeURI encodeURIComponent</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var set1 = &quot;;,/?:@&amp;=+$&quot;;  // 保留字符</span><br><span class="line">var set2 = &quot;-_.!~*&apos;()&quot;;   // 不转义字符</span><br><span class="line">var set3 = &quot;#&quot;;           // 数字标志</span><br><span class="line">var set4 = &quot;ABC abc 123&quot;; // 字母数字字符和空格</span><br><span class="line"></span><br><span class="line">console.log(encodeURI(set1)); // ;,/?:@&amp;=+$</span><br><span class="line">console.log(encodeURI(set2)); // -_.!~*&apos;()</span><br><span class="line">console.log(encodeURI(set3)); // #</span><br><span class="line">console.log(encodeURI(set4)); // ABC%20abc%20123 (the space gets encoded as %20)</span><br><span class="line"></span><br><span class="line">console.log(encodeURIComponent(set1)); // %3B%2C%2F%3F%3A%40%26%3D%2B%24</span><br><span class="line">console.log(encodeURIComponent(set2)); // -_.!~*&apos;()</span><br><span class="line">console.log(encodeURIComponent(set3)); // %23</span><br><span class="line">console.log(encodeURIComponent(set4)); // ABC%20abc%20123 (the space gets encoded as %20)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="encodeURI"><a href="#encodeURI" class="headerlink" title="encodeURI"></a>encodeURI</h3><ul>
<li>encodeURI 会替换所有的字符，但不包括以下字符:<br>; , / ? : @ &amp; = + $ 字母 数字 - _ . ! ~ * ‘ ( ) #</li>
<li>encodeURI 自身无法产生能适用于HTTP GET 或 POST 请求的URI，例如对于 XMLHTTPRequests, 因为 “&amp;”, “+”, 和 “=” 不会被编码，然而在 GET 和 POST 请求中它们是特殊字符。然而encodeURIComponent这个方法会对这些字符编码。<h3 id="encodeURIComponent"><a href="#encodeURIComponent" class="headerlink" title="encodeURIComponent"></a>encodeURIComponent</h3></li>
<li>encodeURIComponent 转义除了如下所示外的所有字符：<br>A-Z a-z 0-9 - _ . ! ~ * ‘ ( )<h2 id="img标签"><a href="#img标签" class="headerlink" title="img标签"></a>img标签</h2></li>
<li>loading属性：eager 立即加载   lazy延迟加载</li>
<li>onload事件在图片加载完成后立即执行</li>
<li>可以通过getBoundingClientRect().top&lt;window.innerHeight来判断是否加载图片<h2 id="dataset"><a href="#dataset" class="headerlink" title="dataset"></a>dataset</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;user&quot; data-id=&quot;1234567890&quot; data-user=&quot;johndoe&quot; data-date-of-birth&gt;John Doe</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">var el = document.querySelector(&apos;#user&apos;);</span><br><span class="line"></span><br><span class="line">// el.id == &apos;user&apos;</span><br><span class="line">// el.dataset.id === &apos;1234567890&apos;</span><br><span class="line">// el.dataset.user === &apos;johndoe&apos;</span><br><span class="line">// el.dataset.dateOfBirth === &apos;&apos;</span><br><span class="line"></span><br><span class="line">el.dataset.dateOfBirth = &apos;1960-10-03&apos;; // set the DOB.</span><br><span class="line"></span><br><span class="line">// &apos;someDataAttr&apos; in el.dataset === false</span><br><span class="line"></span><br><span class="line">el.dataset.someDataAttr = &apos;mydata&apos;;</span><br><span class="line">// &apos;someDataAttr&apos; in el.dataset === true</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="load-DOMContentLoaded"><a href="#load-DOMContentLoaded" class="headerlink" title="load DOMContentLoaded"></a>load DOMContentLoaded</h2><ul>
<li>当整个页面及所有依赖资源如样式表和图片都已完成加载时，将触发load事件。它与DOMContentLoaded不同，后者只要页面DOM加载完成就触发，无需等待依赖资源的加载。<h2 id="script"><a href="#script" class="headerlink" title="script"></a>script</h2></li>
<li>async 该属性能够消除解析阻塞的 Javascript。解析阻塞的 Javascript 会导致浏览器必须加载并且执行脚本，之后才能继续解析。defer 在这一点上也有类似的作用。</li>
<li><p>defer 这个布尔属性被设定用来通知浏览器该脚本将在文档完成解析后，触发 DOMContentLoaded (en-US) 事件前执行。有 defer 属性的脚本会阻止 DOMContentLoaded 事件，直到脚本被加载并且解析完成。defer 属性对模块脚本没有作用 —— 他们默认 defer。</p>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">操作	结果	等同于	结果</span><br><span class="line">5 &amp; 1	1	0101 &amp; 0001	0001</span><br><span class="line">5 | 1	5	0101 | 0001	0101</span><br><span class="line">5 ^ 1	4	0101 ^ 0001	0100    如果两位只有一位为 1 则设置为 1</span><br><span class="line">~ 5	    10	~0101	    1010    反转所有位</span><br><span class="line">5 &lt;&lt; 1	10	0101 &lt;&lt; 1	1010    通过从右推入零向左位移，并使最左边的位脱落。</span><br><span class="line">5 &gt;&gt; 1	2	0101 &gt;&gt; 1	0010    通过从左推入最左位的拷贝来向右位移，并使最右边的位脱落。</span><br><span class="line">5 &gt;&gt;&gt; 1	2	0101 &gt;&gt;&gt; 1	0010    通过从左推入零来向右位移，并使最右边的位脱落。</span><br></pre></td></tr></table></figure>
</li>
<li><p>x &gt;&gt;&gt; 0有什么意义</p>
</li>
</ul>
<ol>
<li>移位操作符在移位前做了两种转换，第一将不是number类型的数据转换为number，第二将number转换为无符号的32bit数据，也就是Uint32类型。这些与移位的位数无关，移位0位主要就是用了js的内部特性做了前两种转换。</li>
<li>x &gt;&gt;&gt; 0本质上就是保证x有意义（为数字类型），且为正整数，在有效的数组范围内（0 ～ 0xFFFFFFFF），且在无意义的情况下缺省值为0。<h2 id="浏览器环境判断"><a href="#浏览器环境判断" class="headerlink" title="浏览器环境判断"></a>浏览器环境判断</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vue源码抄一波，哈哈哈</span><br><span class="line">export const inBrowser = typeof window !== &apos;undefined&apos;</span><br><span class="line">export const inWeex = typeof WXEnvironment !== &apos;undefined&apos; &amp;&amp; !!WXEnvironment.platform</span><br><span class="line">export const weexPlatform = inWeex &amp;&amp; WXEnvironment.platform.toLowerCase()</span><br><span class="line">export const UA = inBrowser &amp;&amp; window.navigator.userAgent.toLowerCase()</span><br><span class="line">export const isIE = UA &amp;&amp; /msie|trident/.test(UA)</span><br><span class="line">export const isIE9 = UA &amp;&amp; UA.indexOf(&apos;msie 9.0&apos;) &gt; 0</span><br><span class="line">export const isEdge = UA &amp;&amp; UA.indexOf(&apos;edge/&apos;) &gt; 0</span><br><span class="line">export const isAndroid = (UA &amp;&amp; UA.indexOf(&apos;android&apos;) &gt; 0) || (weexPlatform === &apos;android&apos;)</span><br><span class="line">export const isIOS = (UA &amp;&amp; /iphone|ipad|ipod|ios/.test(UA)) || (weexPlatform === &apos;ios&apos;)</span><br><span class="line">export const isChrome = UA &amp;&amp; /chrome\/\d+/.test(UA) &amp;&amp; !isEdge</span><br><span class="line">export const isPhantomJS = UA &amp;&amp; /phantomjs/.test(UA)</span><br><span class="line">export const isFF = UA &amp;&amp; UA.match(/firefox\/(\d+)/)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="尾调用-http-www-ruanyifeng-com"><a href="#尾调用-http-www-ruanyifeng-com" class="headerlink" title="尾调用(http://www.ruanyifeng.com/)"></a>尾调用(<a href="http://www.ruanyifeng.com/" target="_blank" rel="noopener">http://www.ruanyifeng.com/</a>)</h2><h3 id="什么是尾调用？"><a href="#什么是尾调用？" class="headerlink" title="什么是尾调用？"></a>什么是尾调用？</h3><ul>
<li>尾调用的概念非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function f(x)&#123;</span><br><span class="line">  return g(x);</span><br><span class="line">&#125;</span><br><span class="line">上面代码中，函数f的最后一步是调用函数g，这就叫尾调用。</span><br><span class="line"></span><br><span class="line">以下两种情况，都不属于尾调用。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 情况一</span><br><span class="line">function f(x)&#123;</span><br><span class="line">  let y = g(x);</span><br><span class="line">  return y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 情况二</span><br><span class="line">function f(x)&#123;</span><br><span class="line">  return g(x) + 1;</span><br><span class="line">&#125;</span><br><span class="line">上面代码中，情况一是调用函数g之后，还有别的操作，所以不属于尾调用，即使语义完全一样。情况二也属于调用后还有操作，即使写在一行内。</span><br><span class="line"></span><br><span class="line">尾调用不一定出现在函数尾部，只要是最后一步操作即可。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function f(x) &#123;</span><br><span class="line">  if (x &gt; 0) &#123;</span><br><span class="line">    return m(x)</span><br><span class="line">  &#125;</span><br><span class="line">  return n(x);</span><br><span class="line">&#125;</span><br><span class="line">上面代码中，函数m和n都属于尾调用，因为它们都是函数f的最后一步操作。</span><br></pre></td></tr></table></figure>
<h3 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h3><ul>
<li>我们知道，函数调用会在内存形成一个”调用记录”，又称”调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用记录上方，还会形成一个B的调用记录。等到B运行结束，将结果返回到A，B的调用记录才会消失。如果函数B内部还调用函数C，那就还有一个C的调用记录栈，以此类推。所有的调用记录，就形成一个”调用栈”（call stack）。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;</span><br><span class="line">  let m = 1;</span><br><span class="line">  let n = 2;</span><br><span class="line">  return g(m + n);</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">function f() &#123;</span><br><span class="line">  return g(3);</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">g(3);</span><br><span class="line"></span><br><span class="line">尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了。</span><br><span class="line"></span><br><span class="line">上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除 f() 的调用记录，只保留 g(3) 的调用记录。</span><br><span class="line"></span><br><span class="line">这就叫做&quot;尾调用优化&quot;（Tail call optimization），即只保留内层函数的调用记录。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用记录只有一项，这将大大节省内存。这就是&quot;尾调用优化&quot;的意义。</span><br></pre></td></tr></table></figure>
<h3 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h3><ul>
<li>递归非常耗费内存，因为需要同时保存成千上百个调用记录，很容易发生”栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用记录，所以永远不会发生”栈溢出”错误。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function factorial(n) &#123;</span><br><span class="line">  if (n === 1) return 1;</span><br><span class="line">  return n * factorial(n - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(5) // 120</span><br><span class="line">上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。</span><br><span class="line"></span><br><span class="line">如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。</span><br><span class="line"></span><br><span class="line">function factorial(n, total) &#123;</span><br><span class="line">  if (n === 1) return total;</span><br><span class="line">  return factorial(n - 1, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(5, 1) // 120</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><ul>
<li>ES6的尾调用优化只在严格模式下开启，正常模式是无效的。这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。arguments：返回调用时函数的参数。func.caller：返回调用当前函数的那个函数。</li>
<li>尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。</li>
</ul>
<h2 id="window-postMessage"><a href="#window-postMessage" class="headerlink" title="window.postMessage"></a>window.postMessage</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">从广义上讲，一个窗口可以获得对另一个窗口的引用（比如 targetWindow = window.opener），然后在窗口上调用 targetWindow.postMessage() 方法分发一个  MessageEvent 消息。接收消息的窗口可以根据需要自由处理此事件。</span><br><span class="line">传递给 window.postMessage() 的参数（比如 message ）将通过消息事件对象暴露给接收消息的窗口。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">otherWindow.postMessage(message, targetOrigin, [transfer])</span><br><span class="line"></span><br><span class="line">targetOrigin:通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串&quot;*&quot;（表示无限制）或者一个URI。</span><br><span class="line">在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；</span><br><span class="line">只有三者完全匹配，消息才会被发送。这个机制用来控制消息可以发送到哪些窗口；</span><br><span class="line">例如，当用postMessage传送密码时，这个参数就显得尤为重要，必须保证它的值与这条包含密码的信息的预期接受者的origin属性完全一致，来防止密码被恶意的第三方截获。</span><br><span class="line">如果你明确的知道消息应该发送到哪个窗口，那么请始终提供一个有确切值的targetOrigin，而不是*。</span><br><span class="line">不提供确切的目标将导致数据泄露到任何对数据感兴趣的恶意站点。</span><br><span class="line"></span><br><span class="line">window.addEventListener(&quot;message&quot;, receiveMessage, false);</span><br><span class="line"></span><br><span class="line">function receiveMessage(event)</span><br><span class="line">&#123;</span><br><span class="line">  var origin = event.origin</span><br><span class="line">  if (origin !== &quot;http://example.org:8080&quot;)</span><br><span class="line">    return;</span><br><span class="line"></span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Window-localStorage-同源"><a href="#Window-localStorage-同源" class="headerlink" title="Window.localStorage(同源)"></a>Window.localStorage(同源)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// storage事件监听器</span><br><span class="line">storageListener(e) &#123;</span><br><span class="line">	if (e.newValue) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;,</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">window.addEventListener(&apos;storage&apos;, storageListener)</span><br></pre></td></tr></table></figure>
<h2 id="MessageChannel"><a href="#MessageChannel" class="headerlink" title="MessageChannel()"></a>MessageChannel()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">new MessageChannel() 返回的对象中包含两个 MessagePort 对象。</span><br><span class="line">&#123;</span><br><span class="line">port1: MessagePort &#123;onmessage: null, onmessageerror: null&#125;,</span><br><span class="line">port2: MessagePort &#123;onmessage: null, onmessageerror: null&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// main thread</span><br><span class="line">if (serviceWorker) &#123;</span><br><span class="line">  // 创建信道</span><br><span class="line">  const channel = new MessageChannel();</span><br><span class="line">  // port1留给自己</span><br><span class="line">  channel.port1.onmessage = (e) =&gt; &#123;</span><br><span class="line">    console.log(&quot;main thread receive message...&quot;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  // port2给对方</span><br><span class="line">  serviceWorker.postMessage(&quot;hello world!&quot;, [channel.port2]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// sw</span><br><span class="line">self.addEventListener(&quot;message&quot;, (ev) =&gt; &#123;</span><br><span class="line">  console.log(&quot;sw receive message..&quot;);</span><br><span class="line">  // 取main thread传来的port2</span><br><span class="line">  ev.ports[0].postMessage(&quot;Hi, hello too&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="Beacon"><a href="#Beacon" class="headerlink" title="Beacon"></a>Beacon</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">用于将异步和非阻塞请求发送到服务器。信标（Beacon ）请求使用HTTP协议中的POST方法，请求通常不需要响应。这个请求被保证在，页面的unload状态从发起到完成之前，被发送。而并不需要一个阻塞请求，例如 XMLHttpRequest 。</span><br><span class="line"></span><br><span class="line">Beacon API 的示例用例是记录活动并向服务器发送分析数据。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Beacon 接口满足了分析和诊断代码的需要，这些代码通常会尝试在卸载文档之前将数据发送到 web服务器。发送数据的任何过早时机都可能导致错失收集数据的机会。但是，确保在卸载文档期间发送数据是开发人员难以做到的。</span><br><span class="line">用户代理通常会忽略卸载文档处理程序中的异步 XMLHttpRequests 请求。若要解决此问题，为了分析和诊断代码，通常会在 unload 事件或 beforeunload 事件中创建同步 XMLHttpRequest 请求以提交数据。同步 XMLHttpRequest 请求强制浏览器延迟卸载文档，并使下一个页面跳转看起来较慢。下一页面没有任何办法来避免这种页面加载性能不佳的感觉。</span><br><span class="line">其他技术也可以用来确保提交数据。其中一种技术是通过创建 Image 元素并在卸载文档处理程序中设置其 src 属性来延迟卸载以提交数据。由于大多数用户代理会延迟文档卸载，以完成挂起的图片加载，因此可以在卸载过程中提交数据。另一种方法是在卸载处理程序中创建一个无操作循环，花费数秒以延迟卸载并将数据提交到服务器。</span><br><span class="line">但是上述技术不仅代表了较差的编码模式，其中一些还是不可靠的，会导致下一个导航的页面加载性能较差的感觉。信标 API 提供了解决这些问题的标准方法。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Navigator.sendBeacon() 方法用于在全局浏览上下文中向服务器发送数据信标。该方法有两个参数，URL和要在请求中发送的数据data。data参数是可选的，其类型可以是 ArrayBufferView、Blob、DOMString 或FormData。如果浏览器成功的以队列形式排列了用于传递的请求，则该方法返回“true”，否则返回“false”。</span><br></pre></td></tr></table></figure>
<h2 id="unhandledrejection"><a href="#unhandledrejection" class="headerlink" title="unhandledrejection"></a>unhandledrejection</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">当Promise 被 reject 且没有 reject 处理器的时候，会触发 unhandledrejection 事件；</span><br><span class="line"></span><br><span class="line">window.addEventListener(&quot;unhandledrejection&quot;, event =&gt; &#123;</span><br><span class="line">  console.warn(`UNHANDLED PROMISE REJECTION: $&#123;event.reason&#125;`);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">window.onunhandledrejection = event =&gt; &#123;</span><br><span class="line">  console.warn(`UNHANDLED PROMISE REJECTION: $&#123;event.reason&#125;`);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="requestIdleCallback"><a href="#requestIdleCallback" class="headerlink" title="requestIdleCallback"></a>requestIdleCallback</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var handle = window.requestIdleCallback(callback[, options])</span><br><span class="line">callback:一个在事件循环空闲时即将被调用的函数的引用。函数会接收到一个名为 IdleDeadline 的参数，这个参数可以获取当前空闲时间以及回调是否在超时时间前已经执行的状态。</span><br><span class="line">options:包括可选的配置参数。具有如下属性：timeout：如果指定了timeout并具有一个正值，并且尚未通过超时毫秒数调用回调，那么回调会在下一次空闲时期被强制执行，尽管这样很可能会对性能造成负面影响。</span><br><span class="line"></span><br><span class="line">window.requestIdleCallback()方法将在浏览器的空闲时段内调用的函数排队。这使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，如动画和输入响应。函数一般会按先进先调用的顺序执行，然而，如果回调函数指定了执行超时时间timeout，则有可能为了在超时前执行函数而打乱执行顺序。</span><br><span class="line">你可以在空闲回调函数中调用requestIdleCallback()，以便在下一次通过事件循环之前调度另一个回调。</span><br><span class="line">返回值是一个ID，可以把它传入 Window.cancelIdleCallback() 方法来结束回调。</span><br></pre></td></tr></table></figure>
<h2 id="浏览器渲染"><a href="#浏览器渲染" class="headerlink" title="浏览器渲染"></a>浏览器渲染</h2><h3 id="渲染页面"><a href="#渲染页面" class="headerlink" title="渲染页面"></a>渲染页面</h3><ul>
<li>五大关键渲染路径</li>
</ul>
<ol>
<li>JavaScript</li>
<li>样式计算：该过程根据选择器计算元素的css规则，通过这些规则计算出每个元素的最终样式。</li>
<li>布局：在知道一个元素css规则后，浏览器便开始计算每个元素的空间大小和具体位置。</li>
<li>绘制：绘制是填充像素的过程。包括绘制文本、颜色、图像、边框、阴影等</li>
<li>合成：页面的各部分可能被绘制到多层，因此需要按正确顺序绘制到屏幕上。</li>
</ol>
<ul>
<li>三种输出方式</li>
</ul>
<ol>
<li>js/css-样式-布局-绘制-合成  如果改变了元素的几何属性（例如宽高等），那么浏览器将检查所有元素，重排页面。</li>
<li>js/css-样式-绘制-合成    如果改变了背景图片、颜色、阴影等不会影响页面布局的属性，浏览器将跳过布局阶段。</li>
<li>js/css-样式-合成   如果改变的属性不影响布局和绘制，将直接进行合成阶段。<h3 id="帧"><a href="#帧" class="headerlink" title="帧"></a>帧</h3></li>
</ol>
<ul>
<li>在视频领域，电影、电视、数字视频等可视为随时间连续变换的许多张画面，其中帧是指每一张画面。</li>
</ul>
<h2 id="visibilitychange"><a href="#visibilitychange" class="headerlink" title="visibilitychange"></a>visibilitychange</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">当其选项卡的内容变得可见或被隐藏时，会在文档上触发 visibilitychange (能见度更改)事件。</span><br><span class="line"></span><br><span class="line">document.addEventListener(&quot;visibilitychange&quot;, function() &#123;</span><br><span class="line">  console.log( document.visibilityState );</span><br><span class="line">&#125;);</span><br><span class="line">document.addEventListener(&quot;visibilitychange&quot;, function() &#123;</span><br><span class="line">  if (document.visibilityState === &apos;visible&apos;) &#123;</span><br><span class="line">    backgroundMusic.play();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    backgroundMusic.pause();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">当 visibleStateState 属性的值转换为 hidden 时，Safari不会按预期触发visibilitychange； 因此，在这种情况下，您还需要包含代码以侦听 pagehide 事件。</span><br><span class="line"></span><br><span class="line">出于兼容性原因，请确保使用  document.addEventListener 而不是window.addEventListener来注册回调。 Safari &lt;14.0仅支持前者。</span><br></pre></td></tr></table></figure>
<h2 id="剪切板-http-www-ruanyifeng-com"><a href="#剪切板-http-www-ruanyifeng-com" class="headerlink" title="剪切板(http://www.ruanyifeng.com/)"></a>剪切板(<a href="http://www.ruanyifeng.com/" target="_blank" rel="noopener">http://www.ruanyifeng.com/</a>)</h2><h3 id="Document-execCommand-方法"><a href="#Document-execCommand-方法" class="headerlink" title="Document.execCommand() 方法"></a>Document.execCommand() 方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">document.execCommand(&apos;copy&apos;)（复制）</span><br><span class="line">document.execCommand(&apos;cut&apos;)（剪切）</span><br><span class="line">document.execCommand(&apos;paste&apos;)（粘贴）</span><br><span class="line"></span><br><span class="line">Document.execCommand()方法虽然方便，但是有一些缺点。</span><br><span class="line"></span><br><span class="line">首先，它只能将选中的内容复制到剪贴板，无法向剪贴板任意写入内容。</span><br><span class="line"></span><br><span class="line">其次，它是同步操作，如果复制/粘贴大量数据，页面会出现卡顿。有些浏览器还会跳出提示框，要求用户许可，这时在用户做出选择前，页面会失去响应。</span><br></pre></td></tr></table></figure>
<h3 id="异步-Clipboard-API"><a href="#异步-Clipboard-API" class="headerlink" title="异步 Clipboard API"></a>异步 Clipboard API</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Clipboard API 是下一代的剪贴板操作方法，比传统的document.execCommand()方法更强大、更合理。</span><br><span class="line"></span><br><span class="line">它的所有操作都是异步的，返回 Promise 对象，不会造成页面卡顿。而且，它可以将任意内容（比如图片）放入剪贴板。</span><br><span class="line"></span><br><span class="line">navigator.clipboard属性返回 Clipboard 对象，所有操作都通过这个对象进行。</span><br><span class="line"></span><br><span class="line">const clipboardObj = navigator.clipboard</span><br><span class="line"></span><br><span class="line">如果navigator.clipboard属性返回undefined，就说明当前浏览器不支持这个 API。</span><br><span class="line"></span><br><span class="line">由于用户可能把敏感数据（比如密码）放在剪贴板，允许脚本任意读取会产生安全风险，所以这个 API 的安全限制比较多。</span><br><span class="line"></span><br><span class="line">首先，Chrome 浏览器规定，只有 HTTPS 协议的页面才能使用这个 API。不过，开发环境（localhost）允许使用非加密协议。</span><br><span class="line"></span><br><span class="line">其次，调用时需要明确获得用户的许可。权限的具体实现使用了 Permissions API，跟剪贴板相关的有两个权限：clipboard-write（写权限）和clipboard-read（读权限）。&quot;写权限&quot;自动授予脚本，而&quot;读权限&quot;必须用户明确同意给予。也就是说，写入剪贴板，脚本可以自动完成，但是读取剪贴板时，浏览器会弹出一个对话框，询问用户是否同意读取。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Clipboard.readText()方法用于复制剪贴板里面的文本数据。</span><br><span class="line">Clipboard.writeText()方法用于将文本内容写入剪贴板。</span><br></pre></td></tr></table></figure>
<h2 id="grid布局-http-www-ruanyifeng-com"><a href="#grid布局-http-www-ruanyifeng-com" class="headerlink" title="grid布局(http://www.ruanyifeng.com/)"></a>grid布局(<a href="http://www.ruanyifeng.com/" target="_blank" rel="noopener">http://www.ruanyifeng.com/</a>)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line">指定一个容器采用网格布局。注意，设为网格布局以后，容器子元素（项目）的float、display: inline-block、display: table-cell、vertical-align和column-*等设置都将失效。</span><br><span class="line">div &#123;</span><br><span class="line">  display: grid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">默认情况下，容器元素都是块级元素，但也可以设成行内元素。</span><br><span class="line">div &#123;</span><br><span class="line">  display: inline-grid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">容器属性:</span><br><span class="line">容器指定了网格布局以后，接着就要划分行和列。grid-template-columns属性定义每一列的列宽，grid-template-rows属性定义每一行的行高。</span><br><span class="line">.container &#123;</span><br><span class="line">  display: grid;</span><br><span class="line">  grid-template-columns: 100px 100px 100px;</span><br><span class="line">  grid-template-rows: 100px 100px 100px;</span><br><span class="line">&#125;</span><br><span class="line">除了使用绝对单位，也可以使用百分比。</span><br><span class="line">.container &#123;</span><br><span class="line">  display: grid;</span><br><span class="line">  grid-template-columns: 33.33% 33.33% 33.33%;</span><br><span class="line">  grid-template-rows: 33.33% 33.33% 33.33%;</span><br><span class="line">&#125;</span><br><span class="line">有时候，重复写同样的值非常麻烦，尤其网格很多时。这时，可以使用repeat()函数，简化重复的值。上面的代码用repeat()改写如下。</span><br><span class="line">.container &#123;</span><br><span class="line">  display: grid;</span><br><span class="line">  grid-template-columns: repeat(3, 33.33%); //grid-template-columns: repeat(2, 100px 20px 80px);</span><br><span class="line">  grid-template-rows: repeat(3, 33.33%);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">有时，单元格的大小是固定的，但是容器的大小不确定。如果希望每一行（或每一列）容纳尽可能多的单元格，这时可以使用auto-fill关键字表示自动填充。</span><br><span class="line">.container &#123;</span><br><span class="line">  display: grid;</span><br><span class="line">  grid-template-columns: repeat(auto-fill, 100px);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">为了方便表示比例关系，网格布局提供了fr关键字（fraction 的缩写，意为&quot;片段&quot;）。如果两列的宽度分别为1fr和2fr，就表示后者是前者的两倍。</span><br><span class="line">.container &#123;</span><br><span class="line">  display: grid;</span><br><span class="line">  grid-template-columns: 1fr 1fr;</span><br><span class="line">&#125;</span><br><span class="line">fr可以与绝对长度的单位结合使用，这时会非常方便。</span><br><span class="line">.container &#123;</span><br><span class="line">  display: grid;</span><br><span class="line">  grid-template-columns: 150px 1fr 2fr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">minmax()函数产生一个长度范围，表示长度就在这个范围之中。它接受两个参数，分别为最小值和最大值。</span><br><span class="line">grid-template-columns: 1fr 1fr minmax(100px, 1fr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">auto关键字表示由浏览器自己决定长度。</span><br><span class="line">grid-template-columns: 100px auto 100px;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">grid-template-columns属性和grid-template-rows属性里面，还可以使用方括号，指定每一根网格线的名字，方便以后的引用。</span><br><span class="line">.container &#123;</span><br><span class="line">  display: grid;</span><br><span class="line">  grid-template-columns: [c1] 100px [c2] 100px [c3] auto [c4];</span><br><span class="line">  grid-template-rows: [r1] 100px [r2] 100px [r3] auto [r4];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">传统的十二网格布局</span><br><span class="line">grid-template-columns: repeat(12, 1fr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">grid-row-gap属性设置行与行的间隔（行间距），grid-column-gap属性设置列与列的间隔（列间距）。</span><br><span class="line">.container &#123;</span><br><span class="line">  grid-row-gap: 20px;</span><br><span class="line">  grid-column-gap: 20px;</span><br><span class="line">&#125;</span><br><span class="line">grid-gap属性是grid-column-gap和grid-row-gap的合并简写形式，语法如下。</span><br><span class="line">.container &#123;</span><br><span class="line">  grid-gap: 20px 20px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">网格布局允许指定&quot;区域&quot;（area），一个区域由单个或多个单元格组成。grid-template-areas属性用于定义区域。</span><br><span class="line">.container &#123;</span><br><span class="line">  display: grid;</span><br><span class="line">  grid-template-columns: 100px 100px 100px;</span><br><span class="line">  grid-template-rows: 100px 100px 100px;</span><br><span class="line">  grid-template-areas: &apos;a b c&apos;</span><br><span class="line">                       &apos;d e f&apos;</span><br><span class="line">                       &apos;g h i&apos;;</span><br><span class="line">&#125;</span><br><span class="line">上面代码先划分出9个单元格，然后将其定名为a到i的九个区域，分别对应这九个单元格。</span><br><span class="line">多个单元格合并成一个区域的写法如下。</span><br><span class="line">grid-template-areas: &apos;a a a&apos;</span><br><span class="line">                     &apos;b b b&apos;</span><br><span class="line">                     &apos;c c c&apos;;</span><br><span class="line">					 </span><br><span class="line">					 </span><br><span class="line">grid-template-areas: &quot;header header header&quot;</span><br><span class="line">                     &quot;main main sidebar&quot;</span><br><span class="line">                     &quot;footer footer footer&quot;;					 </span><br><span class="line">上面代码中，顶部是页眉区域header，底部是页脚区域footer，中间部分则为main和sidebar。</span><br><span class="line">如果某些区域不需要利用，则使用&quot;点&quot;（.）表示。</span><br><span class="line">grid-template-areas: &apos;a . c&apos;</span><br><span class="line">                     &apos;d . f&apos;</span><br><span class="line">                     &apos;g . i&apos;;</span><br><span class="line">注意，区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为区域名-start，终止网格线自动命名为区域名-end。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">					 </span><br><span class="line">划分网格以后，容器的子元素会按照顺序，自动放置在每一个网格。默认的放置顺序是&quot;先行后列&quot;，即先填满第一行，再开始放入第二行				 </span><br><span class="line">这个顺序由grid-auto-flow属性决定，默认值是row，即&quot;先行后列&quot;。也可以将它设成column，变成&quot;先列后行&quot;。					 </span><br><span class="line">设为row dense，表示&quot;先行后列&quot;，并且尽可能紧密填满，尽量不出现空格。					 </span><br><span class="line">					 </span><br><span class="line">					 </span><br><span class="line">justify-items属性设置单元格内容的水平位置（左中右），align-items属性设置单元格内容的垂直位置（上中下）。					 </span><br><span class="line">place-items属性是align-items属性和justify-items属性的合并简写形式。					 </span><br><span class="line">place-items: start end;					 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">justify-content属性是整个内容区域在容器里面的水平位置（左中右），align-content属性是整个内容区域的垂直位置（上中下）。</span><br><span class="line">place-content属性是align-content属性和justify-content属性的合并简写形式。</span><br><span class="line">place-content: space-around space-evenly;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">项目属性:</span><br><span class="line">grid-column-start属性：左边框所在的垂直网格线</span><br><span class="line">grid-column-end属性：右边框所在的垂直网格线</span><br><span class="line">grid-row-start属性：上边框所在的水平网格线</span><br><span class="line">grid-row-end属性：下边框所在的水平网格线</span><br><span class="line"></span><br><span class="line">这四个属性的值，除了指定为第几个网格线，还可以指定为网格线的名字。</span><br><span class="line">这四个属性的值还可以使用span关键字，表示&quot;跨越&quot;，即左右边框（上下边框）之间跨越多少个网格。</span><br><span class="line">使用这四个属性，如果产生了项目的重叠，则使用z-index属性指定项目的重叠顺序。</span><br><span class="line">grid-column属性是grid-column-start和grid-column-end的合并简写形式，grid-row属性是grid-row-start属性和grid-row-end的合并简写形式。</span><br><span class="line">.item-1 &#123;</span><br><span class="line">  grid-column: 1 / 3;</span><br><span class="line">  grid-row: 1 / 2;</span><br><span class="line">&#125;</span><br><span class="line">/* 等同于 */</span><br><span class="line">.item-1 &#123;</span><br><span class="line">  grid-column-start: 1;</span><br><span class="line">  grid-column-end: 3;</span><br><span class="line">  grid-row-start: 1;</span><br><span class="line">  grid-row-end: 2;</span><br><span class="line">&#125;</span><br><span class="line">.item-1 &#123;</span><br><span class="line">  grid-column: 1 / 3;</span><br><span class="line">  grid-row: 1 / 2;</span><br><span class="line">&#125;</span><br><span class="line">/* 等同于 */</span><br><span class="line">.item-1 &#123;</span><br><span class="line">  grid-column-start: 1;</span><br><span class="line">  grid-column-end: 3;</span><br><span class="line">  grid-row-start: 1;</span><br><span class="line">  grid-row-end: 2;</span><br><span class="line">&#125;</span><br><span class="line">斜杠以及后面的部分可以省略，默认跨越一个网格。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">grid-area属性指定项目放在哪一个区域。</span><br><span class="line">.item-1 &#123;</span><br><span class="line">  grid-area: e;</span><br><span class="line">&#125;</span><br><span class="line">grid-area属性还可用作grid-row-start、grid-column-start、grid-row-end、grid-column-end的合并简写形式，直接指定项目的位置。</span><br><span class="line">.item-1 &#123;</span><br><span class="line">  grid-area: 1 / 1 / 3 / 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">justify-self属性设置单元格内容的水平位置（左中右），跟justify-items属性的用法完全一致，但只作用于单个项目。</span><br><span class="line">align-self属性设置单元格内容的垂直位置（上中下），跟align-items属性的用法完全一致，也是只作用于单个项目。</span><br><span class="line">place-self属性是align-self属性和justify-self属性的合并简写形式。</span><br></pre></td></tr></table></figure>
<h2 id="vue路由"><a href="#vue路由" class="headerlink" title="vue路由"></a>vue路由</h2><ul>
<li>Hash模式是基于锚点，以及onhashchange事件</li>
<li>History模式基于HTML5中的History API，history.pushState()/history.replaceState()/popstate事件</li>
</ul>
<h2 id="Monorepo"><a href="#Monorepo" class="headerlink" title="Monorepo"></a>Monorepo</h2><ul>
<li>Multirepo  每个包对应一个项目</li>
<li>Monorepo 一个项目仓库中管理多个模块/包，每个包有自己的依赖，都可以单独测试、单独发布</li>
</ul>
<h2 id="StoryBook开发组件"><a href="#StoryBook开发组件" class="headerlink" title="StoryBook开发组件"></a>StoryBook开发组件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npx -p @storybook/cli sb init --type vue</span><br><span class="line">yarn add vue </span><br><span class="line">yarn add vue-loader vue-template-compiler --dev</span><br><span class="line"></span><br><span class="line">yarn storybook 启动</span><br></pre></td></tr></table></figure>
<h2 id="yarn-workspaces"><a href="#yarn-workspaces" class="headerlink" title="yarn workspaces"></a>yarn workspaces</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1. 开启yarn工作区</span><br><span class="line"></span><br><span class="line">项目根目录的package.json文件</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;private&quot;:true,  提交到github或者发布到npm时禁止将当前根目录进行提交</span><br><span class="line">  //管理的包的路径,支持通配符</span><br><span class="line">  &quot;workspaces&quot;:[</span><br><span class="line">     &quot;packages/*&quot;</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. yarn workspaces使用        如果多个包引用相同依赖，会自动提升到根目录的依赖当中,避免重复下载，节省内存空间</span><br><span class="line"></span><br><span class="line">给工作区根目录安装开发依赖</span><br><span class="line">yarn add jest -D -W          -D开发依赖  -W工作区</span><br><span class="line"></span><br><span class="line">给指定工作区安装依赖</span><br><span class="line">yarn workspace 包名 add loadsh@next   包名指package.json中的包名</span><br><span class="line"></span><br><span class="line">给所有工作区安装依赖</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">yarn install</span><br></pre></td></tr></table></figure>
<h2 id="lerna"><a href="#lerna" class="headerlink" title="lerna"></a>lerna</h2><ul>
<li>优化使用git和npm管理多包仓库的工作流工具</li>
<li>用于管理具有多个包的javascript项目</li>
<li>可以一键把代码提交到git和npm仓库上面</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">全局安装</span><br><span class="line">yarn global add lerna </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">初始化</span><br><span class="line">lerna init </span><br><span class="line"></span><br><span class="line">发布</span><br><span class="line">lerna publish </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lerna.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">//需要管理的包的路径</span><br><span class="line">  &quot;packages&quot;:[</span><br><span class="line">     &quot;packages/*&quot;</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lerna clean 清除node_modules文件夹</span><br></pre></td></tr></table></figure>
<h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm whoami 查看当前用户名</span><br><span class="line"></span><br><span class="line">npm config get registry 获取当前的镜像源</span><br></pre></td></tr></table></figure>
<h2 id="vue组件单元测试"><a href="#vue组件单元测试" class="headerlink" title="vue组件单元测试"></a>vue组件单元测试</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">yarn add jest @vue/test/utils vue-jest babel-jest -D -W</span><br><span class="line"></span><br><span class="line">jest.config.js</span><br><span class="line"></span><br><span class="line">babel.config.js</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Babel桥接  yarn add babel-core@bridge -D -W</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Rollup打包 yarn add rollup rollup-plugin-terser rollup-plugin-vue@5.1.9  vue-template-compiler -D -W</span><br><span class="line"></span><br><span class="line">rollup.config.js</span><br></pre></td></tr></table></figure>
<h2 id="cross-env-跨平台设置环境变量"><a href="#cross-env-跨平台设置环境变量" class="headerlink" title="cross-env  跨平台设置环境变量"></a>cross-env  跨平台设置环境变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add cross-env -D -W</span><br></pre></td></tr></table></figure>
<h2 id="rimraf"><a href="#rimraf" class="headerlink" title="rimraf"></a>rimraf</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yarn add rimraf -D -W </span><br><span class="line"></span><br><span class="line">删除文件夹   eg: rimraf dist</span><br><span class="line"></span><br><span class="line">yarn workspace rimraf diat 删除所有包中的dist</span><br></pre></td></tr></table></figure>
<h2 id="vite"><a href="#vite" class="headerlink" title="vite"></a>vite</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">* 面向现在浏览器，基于ES Modules实现</span><br><span class="line">* 热更新只针对当前修改的文件，webapck则会把所有涉及到的依赖都加载一遍</span><br><span class="line">* 核心功能：静态服务器、编译单文件组件（拦截浏览器不识别的模块并处理）、热更新（基于websocket）</span><br><span class="line"></span><br><span class="line">1. package.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;bin&quot;:&quot;index.js&quot;,</span><br><span class="line">  &quot;dependencies&quot;:&#123;</span><br><span class="line">   &quot;koa&quot;:&quot;^2.13.0&quot;,</span><br><span class="line">   &quot;koa-send&quot;:&quot;^5.0.1&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2. index.js</span><br><span class="line">#!/usr/bin/env node</span><br><span class="line"></span><br><span class="line">const Koa=require(&apos;koa&apos;)</span><br><span class="line">const send=require(&apos;koa-send&apos;)</span><br><span class="line"></span><br><span class="line">const app=new Koa()</span><br><span class="line"></span><br><span class="line">//流转换成字符串</span><br><span class="line">const streamToString= stream=&gt;new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">  const chunks=[]</span><br><span class="line">  stream.on(&apos;data&apos;,chunk=&gt;chunks.push(chunk))</span><br><span class="line">  stream.on(&apos;end&apos;,()=&gt;resolve(Buffer.concat(chunks).toString(&apos;utf-8&apos;)))</span><br><span class="line">  stream.on(&apos;error&apos;,reject)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//静态文件服务器</span><br><span class="line">app.use(async (ctx,next)=&gt;&#123;</span><br><span class="line">  await send(ctx,ctx.path,&#123;root:process.pwd(),index:&apos;index.html&apos;&#125;)</span><br><span class="line">  await next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//修改第三方模块路径</span><br><span class="line">app.use(async (ctx,next)=&gt;&#123;</span><br><span class="line"> if(ctx.type===&apos;application/javascript&apos;)</span><br><span class="line"> &#123;</span><br><span class="line">  const contents=await streamToString(ctx.body)</span><br><span class="line">  ctx.body=contents.replace(/(from\s+[&apos;&quot;])(?!\.\/)/g,&apos;$1/@modules/&apos;)</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> await next()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//加载第三方模块</span><br><span class="line"></span><br><span class="line">app.use(async (ctx,next)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">if(ctx.path.startsWith(&apos;/@modules/&apos;))&#123;</span><br><span class="line"> const moduleName=ctx.path.substr(10)</span><br><span class="line"> const pkgPath=path.join(process.pwd(),&apos;node_modules&apos;,moduleName,&apos;package.json&apos;)</span><br><span class="line"> const pkg=require(pkgPath)</span><br><span class="line"> </span><br><span class="line"> ctx.path=path.join(&apos;/node_modules&apos;,moduleName,pkg.module)</span><br><span class="line"> </span><br><span class="line"> await next()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.listen(3000)</span><br></pre></td></tr></table></figure>
<h2 id="env-constant"><a href="#env-constant" class="headerlink" title="env()/ constant()"></a>env()/ constant()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">padding-top: constant(safe-area-inset-top);</span><br><span class="line">padding-top: env(safe-area-inset-top);</span><br><span class="line"></span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;viewport-fit=cover&quot; /&gt;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/前端/">前端</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/css/">css</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/">js</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-question_three" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/03/24/question_three/" class="article-date">
      <time datetime="2019-03-23T16:00:00.000Z" itemprop="datePublished">2019-03-24</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/24/question_three/">知识点三</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <blockquote>
<p>2019-3-24</p>
</blockquote>
<h2 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">var Book = &#123;&#125;</span><br><span class="line">var name = &apos;&apos;;</span><br><span class="line">Object.defineProperty(Book, &apos;name&apos;, &#123;</span><br><span class="line">  set: function (value) &#123;</span><br><span class="line">    name = value;</span><br><span class="line">    console.log(&apos;你取了一个书名叫做&apos; + value);</span><br><span class="line">  &#125;,</span><br><span class="line">  get: function () &#123;</span><br><span class="line">    return &apos;《&apos; + name + &apos;》&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line">Book.name = &apos;vue权威指南&apos;;  // 你取了一个书名叫做vue权威指南</span><br><span class="line">console.log(Book.name);  // 《vue权威指南》</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">源自:http://www.cnblogs.com/canfoo/p/6891868.html</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 当我们点击按钮的时候动态给 data 增加的成员是否是响应式数据，如果不是的话，如何把新增成员设置成响应式数据，它的内部原理是什么。</span><br><span class="line"></span><br><span class="line">答：不是响应式数据。响应式对象和响应式数组是指在vue初始化时期，利用Object.defineProperty()方法对其进行监听，这样在修改数据时会及时体现在页面上。</span><br><span class="line"></span><br><span class="line">- 设置为响应式数据有两种方法：</span><br><span class="line"></span><br><span class="line">  - 1、给 dog 的属性 name 设置一个初始值，可以为空字符串或者 undefined 之类的，代码和原因如下：</span><br><span class="line"></span><br><span class="line">    ```js</span><br><span class="line">    let vm = new Vue(&#123;</span><br><span class="line">        el: &apos;#app&apos;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            msg: &apos;object&apos;,</span><br><span class="line">            dog: &#123;</span><br><span class="line">                name: &apos;&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        method: &#123;</span><br><span class="line">            clickHandler() &#123;</span><br><span class="line">                // 该 name 属性是否是响应式的</span><br><span class="line">                this.dog.name = &apos;Trump&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<pre><code>- 原因：vm[key] setter 操作的时候会触发 data[key] 的 setter 操作，data[key] 的 setter 操作会 walk 这个新的值（walk方法是给data里的对象类型的值设置响应式），而题目中的 data 的 dog 是个空对象，没有任何属性，所以初始化 Vue 实例的时候，在给 dog 设置 proxy 的时候没有任何属性有 getter 和 setter 方法，所以在点击按钮动态的给 dog 添加 name 属性，并设置值的时候是不会触发 dog 对象下的属性 name 的 setter 方法，故不是响应式数据。而给 dog 对象添加了 name 的初始值后，dog 对象的 name 属性就有了 getter 和 setter 方法，故可以实现响应式。代码如下：

  - vue.js(监听 vm[key]的 getter 和 setter 操作 )

  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">        <span class="comment">// 1、通过属性保存选项的数据</span></span><br><span class="line">        <span class="keyword">this</span>.$options = options || &#123;&#125;</span><br><span class="line">        <span class="keyword">this</span>.$data = options.data || &#123;&#125;</span><br><span class="line">        <span class="keyword">this</span>.$el = <span class="keyword">typeof</span> options.el === <span class="string">'string'</span> ? <span class="built_in">document</span>.querySelector(options.el) : options.el</span><br><span class="line">            <span class="comment">// 2、把 data 中的成员转换成 getter 和 setter,并注入到 vue 实例中</span></span><br><span class="line">        <span class="keyword">this</span>._proxyData(<span class="keyword">this</span>.$data)</span><br><span class="line">            <span class="comment">// 3、调用 observer 对象，监听数据的变化</span></span><br><span class="line">        <span class="keyword">new</span> Observer(<span class="keyword">this</span>.$data)</span><br><span class="line">            <span class="comment">// 4、调用 compiler 对象，解析指令和插值表达式</span></span><br><span class="line">        <span class="keyword">new</span> Compiler(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    _proxyData(data) &#123;</span><br><span class="line">        <span class="comment">// 遍历 data 中的所有属性</span></span><br><span class="line">        <span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 把 data 的属性注入到 vue 实例中</span></span><br><span class="line">            <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>, key, &#123;</span><br><span class="line">                enumerable: <span class="literal">true</span>,</span><br><span class="line">                configurable: <span class="literal">true</span>,</span><br><span class="line">                get() &#123;</span><br><span class="line">                    <span class="keyword">return</span> data[key]</span><br><span class="line">                &#125;,</span><br><span class="line">                set(newValue) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (newValue !== data[key]) &#123;</span><br><span class="line">                        data[key] = newValue</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  - observe.js (data[key] 的 setter 操作会 walk 这个新的值,walk方法是给data里的对象类型的值设置响应式)

    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(data) &#123;</span><br><span class="line">        <span class="keyword">this</span>.walk(data)</span><br><span class="line">    &#125;</span><br><span class="line">    walk(data) &#123;</span><br><span class="line">        <span class="comment">// 1、判断 data 是否是对象</span></span><br><span class="line">        <span class="keyword">if</span> (!data || <span class="keyword">typeof</span> data !== <span class="string">'object'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2、遍历 data 对象的所有属性</span></span><br><span class="line">        <span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.defineReactive(data, key, data[key])</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    defineReactive(obj, key, val) &#123;</span><br><span class="line">        <span class="keyword">let</span> that = <span class="keyword">this</span></span><br><span class="line">            <span class="comment">// 负责收集依赖，并发送通知</span></span><br><span class="line">        <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line">            <span class="comment">// 如果 val 是对象，把 val 内部的属性转换成响应式数据</span></span><br><span class="line">        that.walk(val)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">            enumerable: <span class="literal">true</span>,</span><br><span class="line">            configurable: <span class="literal">true</span>,</span><br><span class="line">            get() &#123;</span><br><span class="line">                <span class="comment">// 收集依赖</span></span><br><span class="line">                Dep.target &amp;&amp; dep.addSub(Dep.target)</span><br><span class="line">                <span class="keyword">return</span> val</span><br><span class="line">            &#125;,</span><br><span class="line">            set(newValue) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(newValue, <span class="string">'&gt;&gt;&gt;&gt;&gt;'</span>, val)</span><br><span class="line">                <span class="keyword">if</span> (newValue === val) &#123;</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                val = newValue</span><br><span class="line">                that.walk(newValue)</span><br><span class="line">                    <span class="comment">// 发送通知</span></span><br><span class="line">                dep.notify()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><ul>
<li><p>2、使用 Vue.set(target, key, value) 时，target 为需要添加属性的对象，key 是要添加的属性名，value 为属性 key 对应的值, vue 中 set 的源码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">set</span> (<span class="params">target: Array&lt;any&gt; | Object, key: any, val: any</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line">    (isUndef(target) || isPrimitive(target))</span><br><span class="line">  ) &#123;</span><br><span class="line">    warn(<span class="string">`Cannot set reactive property on undefined, null, or primitive value: <span class="subst">$&#123;(target: any)&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123;</span><br><span class="line">    target.length = <span class="built_in">Math</span>.max(target.length, key)</span><br><span class="line">    target.splice(key, <span class="number">1</span>, val)</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (key <span class="keyword">in</span> target &amp;&amp; !(key <span class="keyword">in</span> <span class="built_in">Object</span>.prototype)) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> ob = (target: any).__ob__</span><br><span class="line">  <span class="keyword">if</span> (target._isVue || (ob &amp;&amp; ob.vmCount)) &#123;</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">      <span class="string">'Avoid adding reactive properties to a Vue instance or its root $data '</span> +</span><br><span class="line">      <span class="string">'at runtime - declare it upfront in the data option.'</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!ob) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  defineReactive(ob.value, key, val)</span><br><span class="line">  ob.dep.notify()</span><br><span class="line">  <span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>上面源码的执行逻辑如下(参考链接：<a href="https://www.cnblogs.com/heavenYJJ/p/9559439.html)：" target="_blank" rel="noopener">https://www.cnblogs.com/heavenYJJ/p/9559439.html)：</a></li>
<li>1、如果是在开发环境，且 target 未定义（为 null、undefined ）或 target 为基础数据类型（string、boolean、number、symbol）时，抛出告警；</li>
<li>2、如果 target 为数组且 key 为有效的数组 key 时，将数组的长度设置为 target.length 和 key 中的最大的那一个，然后调用数组的 splice 方法（ vue 中重写的 splice 方法）添加元素；</li>
<li>3、如果属性 key 存在于 target 对象中且 key 不是 Object.prototype 上的属性时，表明这是在修改 target 对象属性 key 的值（不管 target 对象是否是响应式的，只要 key 存在于 target 对象中，就执行这一步逻辑），此时就直接将 value 直接赋值给 target[key]；</li>
<li>4、判断 target，当 target 为 vue 实例或根数据 data 对象时，在开发环境下抛错；</li>
<li>5、当一个数据为响应式时，vue 会给该数据添加一个 <strong>ob</strong> 属性，因此可以通过判断target对象是否存在 <strong>ob</strong> 属性来判断 target 是否是响应式数据，当 target 是非响应式数据时，我们就按照普通对象添加属性的方式来处理；当 target 对象是响应式数据时，我们将 target 的属性 key 也设置为响应式并手动触发通知其属性值的更新；</li>
</ul>
</li>
<li><p>defineReactive(ob.value, key, val) ,将新增属性设置为响应式; ob.dep.notify() 手动触发通知该属性值的更新, 所以我们可以修改代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        el: <span class="string">'#app'</span>,</span><br><span class="line">        data: &#123;</span><br><span class="line">            msg: <span class="string">'object'</span>,</span><br><span class="line">            dog: &#123;</span><br><span class="line">                name: <span class="literal">undefined</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        method: &#123;</span><br><span class="line">            clickHandler() &#123;</span><br><span class="line">                <span class="comment">// 该 name 属性是否是响应式的</span></span><br><span class="line">                <span class="keyword">this</span>.$set(<span class="keyword">this</span>.data.dog, name, <span class="string">'Trump'</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="请简述-Diff-算法的执行过程"><a href="#请简述-Diff-算法的执行过程" class="headerlink" title="请简述 Diff 算法的执行过程"></a>请简述 Diff 算法的执行过程</h2><p>diff算法是一种通过同层的树节点进行比较的高效算法，避免了对树进行逐层搜索遍历，所以时间复杂度只有 O(n)。 </p>
<p>diff算法有两个比较显著的特点： </p>
<p>1、比较只会在同层级进行, 不会跨层级比较。 </p>
<p>2、在diff比较的过程中，循环从两边向中间收拢。 </p>
<p>diff流程： </p>
<p>1 、首先定义 oldStartIdx、newStartIdx、oldEndIdx 以及 newEndIdx 分别是新老两个 VNode 的两边的索引。 </p>
<p>2、接下来是一个 while 循环，在这过程中，oldStartIdx、newStartIdx、oldEndIdx 以及 newEndIdx 会逐渐向中间靠拢。while 循环的退出条件是直到老节点或者新节点的开始位置大于结束位置。</p>
<p>while 循环中会遇到四种情况： </p>
<p>情形一：当新老 VNode 节点的 start 是同一节点时，直接 patchVnode 即可，同时新老 VNode 节点的开始索引都加 1。 </p>
<p>情形二：当新老 VNode 节点的 end  是同一节点时，直接 patchVnode 即可，同时新老 VNode 节点的结束索引都减 1。 </p>
<p>情形三：当老 VNode 节点的 start 和新 VNode 节点的 end  是同一节点时，这说明这次数据更新后 oldStartVnode 已经跑到了 oldEndVnode 后面去了。这时候在 patchVnode 后，还需要将当前真实 dom 节点移动到 oldEndVnode 的后面，同时老 VNode 节点开始索引加 1，新 VNode 节点的结束索引减 1。 </p>
<p>情形四：当老 VNode 节点的 end 和新 VNode 节点的 start 是同一节点时，这说明这次数据更新后 oldEndVnode 跑到了 oldStartVnode 的前面去了。这时候在 patchVnode 后，还需要将当前真实 dom 节点移动到 oldStartVnode 的前面，同时老 VNode 节点结束索引减 1，新 VNode 节点的开始索引加 1。  </p>
<p>3、while 循环的退出条件是直到老节点或者新节点的开始位置大于结束位置。 </p>
<p>情形一：如果在循环中，oldStartIdx大于oldEndIdx了，那就表示oldChildren比newChildren先循环完毕，那么newChildren里面剩余的节点都是需要新增的节点，把[newStartIdx, newEndIdx]之间的所有节点都插入到DOM中 </p>
<p>情形二：如果在循环中，newStartIdx大于newEndIdx了，那就表示newChildren比oldChildren先循环完毕，那么oldChildren里面剩余的节点都是需要删除的节点，把[oldStartIdx, oldEndIdx]之间的所有节点都删除</p>
<h2 id="模拟-VueRouter-的-hash-模式的实现，实现思路和-History-模式类似，把-URL-中的-后面的内容作为路由的地址，可以通过-hashchange-事件监听路由地址的变化。"><a href="#模拟-VueRouter-的-hash-模式的实现，实现思路和-History-模式类似，把-URL-中的-后面的内容作为路由的地址，可以通过-hashchange-事件监听路由地址的变化。" class="headerlink" title="模拟 VueRouter 的 hash 模式的实现，实现思路和 History 模式类似，把 URL 中的 # 后面的内容作为路由的地址，可以通过 hashchange 事件监听路由地址的变化。"></a>模拟 VueRouter 的 hash 模式的实现，实现思路和 History 模式类似，把 URL 中的 # 后面的内容作为路由的地址，可以通过 hashchange 事件监听路由地址的变化。</h2> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="built_in">console</span>.dir(Vue)</span><br><span class="line"><span class="keyword">let</span> _Vue = <span class="literal">null</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">VueRouter</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 实现 vue 的插件机制</span></span><br><span class="line">  <span class="keyword">static</span> install(Vue) &#123;</span><br><span class="line">    <span class="comment">//1 判断当前插件是否被安装</span></span><br><span class="line">    <span class="keyword">if</span> (VueRouter.install.installed) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    VueRouter.install.installed = <span class="literal">true</span></span><br><span class="line">    <span class="comment">//2 把Vue的构造函数记录在全局</span></span><br><span class="line">    _Vue = Vue</span><br><span class="line">    <span class="comment">//3 把创建Vue的实例传入的router对象注入到Vue实例</span></span><br><span class="line">    <span class="comment">// _Vue.prototype.$router = this.$options.router</span></span><br><span class="line">    <span class="comment">// 混入</span></span><br><span class="line">    _Vue.mixin(&#123;</span><br><span class="line">      beforeCreate() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.$options.router) &#123;</span><br><span class="line">          _Vue.prototype.$router = <span class="keyword">this</span>.$options.router</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化属性</span></span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="keyword">this</span>.options = options <span class="comment">// options 记录构造函数传入的对象</span></span><br><span class="line">    <span class="keyword">this</span>.routeMap = &#123;&#125; <span class="comment">// routeMap 路由地址和组件的对应关系</span></span><br><span class="line">    <span class="comment">// observable     data 是一个响应式对象</span></span><br><span class="line">    <span class="keyword">this</span>.data = _Vue.observable(&#123;</span><br><span class="line">      current: <span class="string">"/"</span> <span class="comment">// 当前路由地址</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">this</span>.init()</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用 createRouteMap, initComponent, initEvent 三个方法</span></span><br><span class="line">  init() &#123;</span><br><span class="line">    <span class="keyword">this</span>.createRouteMap()</span><br><span class="line">    <span class="keyword">this</span>.initComponent(_Vue)</span><br><span class="line">    <span class="keyword">this</span>.initEvent()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用来初始化 routeMap 属性，路由规则转换为键值对</span></span><br><span class="line">  createRouteMap() &#123;</span><br><span class="line">    <span class="comment">//遍历所有的路由规则 把路由规则解析成键值对的形式存储到routeMap中</span></span><br><span class="line">    <span class="keyword">this</span>.options.routes.forEach(<span class="function"><span class="params">route</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.routeMap[route.path] = route.component</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用来创建 router-link 和 router-view 组件</span></span><br><span class="line">  initComponent(Vue) &#123;</span><br><span class="line">    <span class="comment">// router-link 组件</span></span><br><span class="line">    Vue.component(<span class="string">'router-link'</span>, &#123;</span><br><span class="line">      props: &#123;</span><br><span class="line">        to: <span class="built_in">String</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// render --- 可在 vue 运行时版直接使用</span></span><br><span class="line">      render(h) &#123;</span><br><span class="line">        <span class="comment">// h(选择器（标签的名字）， 属性，生成的某个标签的内容)</span></span><br><span class="line">        <span class="keyword">return</span> h(<span class="string">'a'</span>, &#123;</span><br><span class="line">          attrs: &#123;</span><br><span class="line">            href: <span class="string">'#'</span> + <span class="keyword">this</span>.to,</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="comment">// 注册事件</span></span><br><span class="line">        <span class="comment">//   on: &#123;</span></span><br><span class="line">        <span class="comment">//     click: this.clickHandler // 点击事件</span></span><br><span class="line">        <span class="comment">//   &#125;,</span></span><br><span class="line">        &#125;, [<span class="keyword">this</span>.$slots.default]) <span class="comment">// this.$slot.default 默认插槽</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// router-view 组件</span></span><br><span class="line">    <span class="keyword">const</span> self = <span class="keyword">this</span>; <span class="comment">//这里的 this 指向 vueRouter 实例</span></span><br><span class="line">    Vue.component(<span class="string">'router-view'</span>, &#123;</span><br><span class="line">      render(h) &#123;</span><br><span class="line">        <span class="comment">// 根据 routerMap 中的对应关系，拿到当前路由地址所对应的组件</span></span><br><span class="line">        <span class="keyword">const</span> component = self.routeMap[self.data.current]</span><br><span class="line">        <span class="keyword">return</span> h(component)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用来注册 hashchange 事件</span></span><br><span class="line">  initEvent () &#123;</span><br><span class="line">     <span class="built_in">window</span>.addEventListener(<span class="string">'hashchange'</span>, () =&gt; &#123;</span><br><span class="line">      <span class="keyword">this</span>.data.current = <span class="keyword">this</span>.getHash();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, () =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">window</span>.location.hash) &#123;</span><br><span class="line">        <span class="built_in">window</span>.location.hash = <span class="string">'#/'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getHash() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">window</span>.location.hash.slice(<span class="number">1</span>) || <span class="string">'/'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="在模拟-Vue-js-响应式源码的基础上实现-v-html-指令，以及-v-on-指令。"><a href="#在模拟-Vue-js-响应式源码的基础上实现-v-html-指令，以及-v-on-指令。" class="headerlink" title="在模拟 Vue.js 响应式源码的基础上实现 v-html 指令，以及 v-on 指令。"></a>在模拟 Vue.js 响应式源码的基础上实现 v-html 指令，以及 v-on 指令。</h2> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不同指令所调用的函数</span></span><br><span class="line">update (node, key, attrName) &#123;</span><br><span class="line">    <span class="keyword">let</span> updateFn = <span class="keyword">this</span>[attrName + <span class="string">'Updater'</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 v-on 指令</span></span><br><span class="line">    <span class="keyword">if</span> (attrName.startsWith(<span class="string">'on:'</span>)) &#123;</span><br><span class="line">        updateFn = <span class="keyword">this</span>[<span class="string">'on'</span> + <span class="string">'Updater'</span>]</span><br><span class="line">        <span class="keyword">const</span> eventType = attrName.split(<span class="string">':'</span>)[<span class="number">1</span>]</span><br><span class="line">        updateFn.call(<span class="keyword">this</span>, node, <span class="keyword">this</span>.vm[key], key, eventType)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    updateFn &amp;&amp; updateFn.call(<span class="keyword">this</span>, node, <span class="keyword">this</span>.vm[key], key) <span class="comment">// 此处的 this 就是 compiler 对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 v-html 指令</span></span><br><span class="line">htmlUpdater (node, value, key) &#123;</span><br><span class="line">    node.innerHTML = value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Watcher(<span class="keyword">this</span>.vm, key, (newValue) =&gt; &#123;</span><br><span class="line">        node.innerHTML = newValue</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 v-on 指令</span></span><br><span class="line">onUpdater (node, value, key, eventType) &#123;</span><br><span class="line">    <span class="comment">// console.log(value, key, eventType, this.vm.$options.methods[key])</span></span><br><span class="line">    node.addEventListener(eventType, <span class="keyword">this</span>.vm.$options.methods[key])</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="请简述-Vue-首次渲染过程。"><a href="#请简述-Vue-首次渲染过程。" class="headerlink" title="请简述 Vue 首次渲染过程。"></a>请简述 Vue 首次渲染过程。</h2><p>解析：</p>
<ol>
<li><p>Vue 初始化，添加实例成员、静态成员，并在原型上挂载<strong>patch</strong>方法和$mount方法。</p>
</li>
<li><p>初始化结束，调用new Vue()。在new Vue()的过程中，调用this.init()方法, 给vue的实例挂载各种功能。</p>
</li>
<li><p>在 this.init() 内部最终会调用 entry-runtime-with-compiler.js中的 vm.$mount(),用于获取render函数。</p>
</li>
<li><p>$mount 获取 render 过程: 如果用户没有传入render,会将template编译为render，如果template也没有，则将el中的内容作为模版，通过 compileToFunctions() 生成render。</p>
</li>
<li><p>接下来调用 runtime/index.js 中的 $mount, 重新获取 el 并调用 mountComponent() 方法。<br> mountComponent 用于触发 beforeMount，定义 updateComponent,创建watcher实例，触发mounted,并最终返回vm实例。</p>
</li>
<li><p>创建完watcher的实例后会调用一次 watcher.get() 方法，该方法会调用updateComponent(), updateComponent()又会调用 vm.render() 以及vm.update(),vm._update()会调用vm.<strong>patch</strong>()挂载真实dom,并将真实dom记录于vm.$el中。</p>
</li>
</ol>
<h2 id="请简述-Vue-响应式原理。"><a href="#请简述-Vue-响应式原理。" class="headerlink" title="请简述 Vue 响应式原理。"></a>请简述 Vue 响应式原理。</h2><p>解析：</p>
<ul>
<li>响应式处理整体过程为initState() =&gt; initData() =&gt; observe()</li>
<li>其中observe是响应式处理的入口，通过该方法为data对象转化为响应式对象。</li>
<li>observe方法接收的是对象且该对象不是响应式时，会为该对象创建一个observe对象，会调用Observer类</li>
<li>Observer类中判断该value是数组还是对象，进行不同的处理</li>
<li>数组的响应化处理，是重写push,pop,sort等会修改原数组的方法，调用对应的notify.然后遍历数组中的成员，判断其类型决定是否调用observe方法</li>
<li>对象的响应化处理，会调用walk方法，遍历对象中的每个属性，调用defineReactive</li>
<li>defineReactive的核心是为每一个属性定义getter和setter,getter中收集依赖，setter中派发更新,即调用dep.notify。</li>
<li>dep.notify()会调用watcher的update()方法。如果该watcher未被处理，会被添加到queue队列中，并调用flushSchedulerQueue()方法，该方法会触发对应的钩子函数以及调用watcher.run()更新视图。</li>
</ul>
<h2 id="请简述虚拟-DOM-中-Key-的作用和好处。"><a href="#请简述虚拟-DOM-中-Key-的作用和好处。" class="headerlink" title="请简述虚拟 DOM 中 Key 的作用和好处。"></a>请简述虚拟 DOM 中 Key 的作用和好处。</h2><p>解析：</p>
<p>​    作用： 标识节点在当前层级的唯一性。<br>​    好处： 在执行 updateChildren 对比新旧 Vnode 的子节点差异时，通过设置 key 可以进行更高效的比较，便于复用节点。 降低创建销毁节点成本，从而减少 dom 操作，提升更新 dom 的性能。</p>
<p>​      </p>
<h2 id="请简述-Vue-中模版编译过程。"><a href="#请简述-Vue-中模版编译过程。" class="headerlink" title="请简述 Vue 中模版编译过程。"></a>请简述 Vue 中模版编译过程。</h2><p>解析：</p>
<ul>
<li>模版编译入口函数是compileToFunctions,首先判断是否有缓存好的render函数，如果没有，则调用compile。compile用作于合并options, 它将用户传入的options和初始化的options合并起来。然后将template和合并好的options传递给baseCompile。</li>
<li>在 baseCompile 中完成了模版编译的核心部分：</li>
<li>调用parse()将template转换成AST对象；</li>
<li>调用optimize()优化 AST tree；</li>
<li>调用 generate() 将优化后的AST tree转换成字符串形式的代码。</li>
<li>最后回到compileToFunctions，通过createFunction()将字符串形式的代码转换为函数,并将其挂载到Vue实例的options对应的属性中。</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/前端/">前端</a><a class="article-category-link" href="/categories/前端/框架/">框架</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/">js</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue/">vue</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-life" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/01/02/life/" class="article-date">
      <time datetime="2019-01-01T16:00:00.000Z" itemprop="datePublished">2019-01-02</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/02/life/">记录生活</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>没什么文采，想说什么就说什么。</p>
<blockquote>
<p>2019-1-2<br>最近特别怀旧，喜欢看老剧、听老歌，可能。。。。自己真的老了吧。<br>以前看不懂的红楼梦（87版，现在的电视剧真不敢恭维，不排除有好的（有个小戏骨翻拍的红楼梦，听说还可以），但以前的老演员演技是真的好，也敬业。），现在看起来发现剧中各种小细节，很讽刺，也很现实，演员演得也好，眉眼之间但是演技，每个眼神特写都不多余。<br>对了，才发现剧中的王熙凤是邓婕（张国立的老婆）演的。</p>
</blockquote>
<blockquote>
<p>2019-3-10<br>好久没有更新博客了，利用寒假时间把js又深入的学习了一遍，发现时间过的很快，一个月转眼就过去了。<br>大三下学期要面临找实习，我开始焦虑了。<br>算下来学习前端的时间有一年多了吧。<br>尤其是大三上学期，我接触了es6、webpack打包工具、vue、vue-cli自动化构建工具、vuex状态管理、以及服务端的js——node、babel编译工具、模块化编程等等，发现前端的知识好杂乱，要学的好多，为了搞懂这些东西，花费了我大量时间，感觉时间都浪费掉了。在追求知识的广度和深度这个问题上，我迷茫了。<br>随着时间的推进，我慢慢察觉基础的重要性，开始对css、js进行更深一步的进阶学习，收获挺多，基础还是很重要的。<br>今天写了一个三级联动，碰到了一些问题，就此谈一下我的感受：</p>
<ol>
<li>对于jquery动态添加的Dom元素无法绑定事件，可以借助事件代理。但就因为这个问题我折腾了一、两个小时，为啥呢？因为我为动态添加的option标签绑定了click事件！！！（Chrome对option的click事件不支持，卧槽！在我心中堪称完美的Chrome居然也有缺陷），这个问题曾一度让我怀疑自己。</li>
<li>上面都不是关键，之所以要说这个问题，我想强调的是“百度使用方式的重要性”，之前我一直搜索的是“jquery动态添加的Dom元素绑定事件失效”，然后出来一大堆，基本上都是说使用事件代理，于是就照着这个方法修改了代码，最后发现没用啊，难道是我别的地方出错了？调试了好几遍还是没问题啊，打开控制台，发现事件添加上去了，当时的我一脸懵逼。。。来回折腾进一个小时，几乎快要崩溃。。休息了10分钟，整理了一下思绪，一步步的排除错误，最后锁定在了select标签这个东西上。再次打开百度，输入“select标签绑定click事件无效”，终于真相大白，原来是Chrome浏览器不支持 。</li>
<li>由此我发现，我还是没有找到解决问题的关键。但同样一个问题，搜索的方式至关重要，学会使用关键字搜索也是一门学问。</li>
<li>以上只是我的一些个人看法，因人而异吧。<br>最后想勉励一下自己，还得继续加油啊。</li>
</ol>
</blockquote>
<blockquote>
<p>2019-3-25<br>今天用js敲了几个排序算法（为了面试），让我再次发现了调试的重要性！下面是希尔排序，话不多说，上代码</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line">//希尔排序</span><br><span class="line">    let increase = Math.floor(arr.length / 2);</span><br><span class="line">    while (increase!==0) &#123;</span><br><span class="line">		</span><br><span class="line">		//第一层for循环 ：分成几组</span><br><span class="line">        for (let j = 0; j &lt; increase; j++) &#123;</span><br><span class="line">			</span><br><span class="line">             //第二层for循环 ：每组多少成员</span><br><span class="line">            for (let i = j + increase, t = 1; t &lt; arr.length / increase; i += increase, t++) &#123;</span><br><span class="line">				</span><br><span class="line">                let flag=i; //记录i值</span><br><span class="line">				</span><br><span class="line">				//下面while循环是直接插入排序    注意！while循环会引起i值改变</span><br><span class="line">                while (arr[i] &lt; arr[i - increase]) &#123;  </span><br><span class="line"></span><br><span class="line">                    arr[i - increase] = arr[i] + arr[i - increase];</span><br><span class="line">                    arr[i] = arr[i - increase] - arr[i];</span><br><span class="line">                    arr[i - increase] = arr[i - increase] - arr[i];</span><br><span class="line"></span><br><span class="line">                    i = i - increase;</span><br><span class="line">                    if (i === j) break;</span><br><span class="line">                &#125; </span><br><span class="line">				</span><br><span class="line">                i=flag; //恢复i值</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //debugger</span><br><span class="line">        //console.log(arr);</span><br><span class="line">        increase = Math.floor(increase/2); //记录每次增量改变</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">折腾最久的就是上面那个i值得恢复，通过debugger发现，只要进行直接插入排序，i值就会发生变化，因此需要排序后进行i值恢复。</span><br><span class="line">上面这个希尔排序只是简单的练手，算法的性能以及健壮性上面可能不是很好，但希尔排序算法的思想还是能体现出来的。</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">//快速排序  (百度百科)  （基准值、左右索引、递归）</span><br><span class="line">    const quickSort = (array) =&gt; &#123;</span><br><span class="line">         const sort = (arr, left = 0, right = arr.length - 1) =&gt; &#123;</span><br><span class="line">             if (left &gt;= right) &#123;//如果左边的索引大于等于右边的索引说明整理完毕</span><br><span class="line">                 return</span><br><span class="line">             &#125;</span><br><span class="line">             let i = left;</span><br><span class="line">             let j = right;</span><br><span class="line">             const baseVal = arr[j]; // 取无序数组最后一个数为基准值</span><br><span class="line">             //debugger;</span><br><span class="line">             while (i &lt; j) &#123;//把所有比基准值小的数放在左边大的数放在右边</span><br><span class="line">                 while (i &lt; j &amp;&amp; arr[i] &lt;= baseVal) &#123; //找到一个比基准值大的数交换</span><br><span class="line">                     i++</span><br><span class="line">                 &#125;</span><br><span class="line">                 arr[j] = arr[i];// 将较大的值放在右边如果没有比基准值大的数就是将自己赋值给自己（i 等于 j）</span><br><span class="line">                 while (j &gt; i &amp;&amp; arr[j] &gt;= baseVal) &#123; //找到一个比基准值小的数交换</span><br><span class="line">                     j--</span><br><span class="line">                 &#125;</span><br><span class="line">                 arr[i] = arr[j] // 将较小的值放在左边如果没有找到比基准值小的数就是将自己赋值给自己（i 等于 j）</span><br><span class="line">             &#125;</span><br><span class="line">             arr[j] = baseVal; // 将基准值放至中央位置完成一次循环（这时候 j 等于 i ）</span><br><span class="line">             sort(arr, left, j-1); // 将左边的无序数组重复上面的操作</span><br><span class="line">             sort(arr, j+1, right) // 将右边的无序数组重复上面的操作</span><br><span class="line">         &#125;;</span><br><span class="line">         const newArr = array.concat(); // 为了保证这个函数是纯函数拷贝一次数组</span><br><span class="line">         sort(newArr);</span><br><span class="line">         return newArr</span><br><span class="line">     &#125;;</span><br><span class="line"></span><br><span class="line">    //二分查找</span><br><span class="line">    function binary(find, arr, low, high) &#123;</span><br><span class="line">        if (low &lt;= high) &#123;</span><br><span class="line">            if (arr[low] == find) &#123;</span><br><span class="line">                return low;</span><br><span class="line">            &#125;</span><br><span class="line">            if (arr[high] == find) &#123;</span><br><span class="line">                return high;</span><br><span class="line">            &#125;</span><br><span class="line">            var mid = Math.ceil((high + low) / 2);</span><br><span class="line">            if (arr[mid] == find) &#123;</span><br><span class="line">                return mid;</span><br><span class="line">            &#125; else if (arr[mid] &gt; find) &#123;</span><br><span class="line">                return binary(find, arr, low, mid - 1);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return binary(find, arr, mid + 1, high);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">		//深度搜索</span><br><span class="line">		function deepTraversal(node) &#123;</span><br><span class="line">        var nodeList = [];</span><br><span class="line">        if (node) &#123;</span><br><span class="line">            var stack = [];//先进后出</span><br><span class="line">            stack.push(node);</span><br><span class="line">            while (stack.length != 0) &#123;</span><br><span class="line">                var childrenItem = stack.pop();</span><br><span class="line">                nodeList.push(childrenItem);</span><br><span class="line">                var childrenList = childrenItem.children;</span><br><span class="line">                for (var i = childrenList.length - 1; i &gt;= 0; i--)</span><br><span class="line">                    stack.push(childrenList[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nodeList;</span><br><span class="line">    &#125;</span><br><span class="line">    //广度搜索</span><br><span class="line">    function wideTraversal(node) &#123;</span><br><span class="line">        var nodes = [];</span><br><span class="line">        if (node ) &#123;</span><br><span class="line">            var queue = [];//先进先出</span><br><span class="line">            queue.unshift(node);</span><br><span class="line">            while (queue.length != 0) &#123;</span><br><span class="line">                var item = queue.shift();</span><br><span class="line">                nodes.push(item);</span><br><span class="line">                var children = item.children;</span><br><span class="line">                for (var i = 0; i &lt; children.length; i++)</span><br><span class="line">                    queue.push(children[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">下面是几个简单的排序算法：</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">     //简单选择排序</span><br><span class="line">     for(let i=0;i&lt;arr.length;i++)</span><br><span class="line">     &#123;</span><br><span class="line">         for(let j=i+1;j&lt;arr.length;j++)</span><br><span class="line">         &#123;</span><br><span class="line">             if(arr[j]&lt;arr[i])</span><br><span class="line">             &#123;</span><br><span class="line">                 arr[i]=arr[i]+arr[j];</span><br><span class="line">                 arr[j]=arr[i]-arr[j];</span><br><span class="line">                 arr[i]=arr[i]-arr[j];</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         //console.log(arr);</span><br><span class="line">     &#125;</span><br><span class="line">	 </span><br><span class="line">	 //冒泡排序</span><br><span class="line">     for(let i=0;i&lt;arr.length;i++)</span><br><span class="line">     &#123;</span><br><span class="line">         for(let i=0;i&lt;arr.length;i++)</span><br><span class="line">         &#123;</span><br><span class="line">             if(arr[i+1]&lt;arr[i])</span><br><span class="line">             &#123;</span><br><span class="line">                 arr[i]=arr[i]+arr[i+1];</span><br><span class="line">                 arr[i+1]=arr[i]-arr[i+1];</span><br><span class="line">                 arr[i]=arr[i]-arr[i+1];</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         //console.log(arr);</span><br><span class="line">     &#125;</span><br><span class="line">	 </span><br><span class="line">	 //直接插入排序</span><br><span class="line">    for(let i=1;i&lt;arr.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">			  let flag=i;</span><br><span class="line">        while(arr[i]&lt;arr[i-1])</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i-1]=arr[i]+arr[i-1];</span><br><span class="line">            arr[i]=arr[i-1]-arr[i];</span><br><span class="line">            arr[i-1]=arr[i-1]-arr[i];</span><br><span class="line"></span><br><span class="line">            i=i-1;</span><br><span class="line">            if(i===0) break;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">				 i=flag;</span><br><span class="line">       // console.log(arr);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过敲这几个排序算法，发现动手实践是很重要的。但我认为，动手之前基本的东西最好搞明白，不然你会发现出的错都是跟它们有关，有些错误还很低级，但足够你折腾半天。<br>还要再说一遍，只是练手，只是练手，只是练手。</p>
<blockquote>
<p>2019-5-22<br>刚开始学习React,官方文档都还没看一遍就开始被狂轰滥炸的问各种React高级和底层基础，？？？？？好慌啊，稳如狗？ 好像翻车了哦。。</p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/生活/">生活</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/生活，心情/">生活，心情</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
    </nav>
  

</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2021 DiamondsZz
            </div>        
        </div>
    </div>
</footer>

    </div>
    
<script src="https://www.unpkg.com/jquery@3.6.0/dist/jquery.js"></script>

<script src="/js/main.js"></script>

    <script>
        $(document).ready(function() {
            var backgroundnum = 1;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>






<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" "="">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(
            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


  </div>
</body>
</html>